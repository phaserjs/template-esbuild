(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __exportStar = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module) => {
    return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
  };

  // node_modules/phaser/dist/phaser.js
  var require_phaser = __commonJS((exports, module) => {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("Phaser", [], factory);
      else if (typeof exports === "object")
        exports["Phaser"] = factory();
      else
        root["Phaser"] = factory();
    })(exports, () => {
      return (() => {
        var __webpack_modules__ = {
          6659: (module2) => {
            "use strict";
            var has = Object.prototype.hasOwnProperty, prefix = "~";
            function Events() {
            }
            if (Object.create) {
              Events.prototype = Object.create(null);
              if (!new Events().__proto__)
                prefix = false;
            }
            function EE(fn, context, once) {
              this.fn = fn;
              this.context = context;
              this.once = once || false;
            }
            function addListener(emitter, event, fn, context, once) {
              if (typeof fn !== "function") {
                throw new TypeError("The listener must be a function");
              }
              var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
              if (!emitter._events[evt])
                emitter._events[evt] = listener, emitter._eventsCount++;
              else if (!emitter._events[evt].fn)
                emitter._events[evt].push(listener);
              else
                emitter._events[evt] = [emitter._events[evt], listener];
              return emitter;
            }
            function clearEvent(emitter, evt) {
              if (--emitter._eventsCount === 0)
                emitter._events = new Events();
              else
                delete emitter._events[evt];
            }
            function EventEmitter() {
              this._events = new Events();
              this._eventsCount = 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
              var names = [], events, name;
              if (this._eventsCount === 0)
                return names;
              for (name in events = this._events) {
                if (has.call(events, name))
                  names.push(prefix ? name.slice(1) : name);
              }
              if (Object.getOwnPropertySymbols) {
                return names.concat(Object.getOwnPropertySymbols(events));
              }
              return names;
            };
            EventEmitter.prototype.listeners = function listeners(event) {
              var evt = prefix ? prefix + event : event, handlers = this._events[evt];
              if (!handlers)
                return [];
              if (handlers.fn)
                return [handlers.fn];
              for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
                ee[i] = handlers[i].fn;
              }
              return ee;
            };
            EventEmitter.prototype.listenerCount = function listenerCount(event) {
              var evt = prefix ? prefix + event : event, listeners = this._events[evt];
              if (!listeners)
                return 0;
              if (listeners.fn)
                return 1;
              return listeners.length;
            };
            EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
              var evt = prefix ? prefix + event : event;
              if (!this._events[evt])
                return false;
              var listeners = this._events[evt], len = arguments.length, args, i;
              if (listeners.fn) {
                if (listeners.once)
                  this.removeListener(event, listeners.fn, void 0, true);
                switch (len) {
                  case 1:
                    return listeners.fn.call(listeners.context), true;
                  case 2:
                    return listeners.fn.call(listeners.context, a1), true;
                  case 3:
                    return listeners.fn.call(listeners.context, a1, a2), true;
                  case 4:
                    return listeners.fn.call(listeners.context, a1, a2, a3), true;
                  case 5:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                  case 6:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                }
                for (i = 1, args = new Array(len - 1); i < len; i++) {
                  args[i - 1] = arguments[i];
                }
                listeners.fn.apply(listeners.context, args);
              } else {
                var length = listeners.length, j;
                for (i = 0; i < length; i++) {
                  if (listeners[i].once)
                    this.removeListener(event, listeners[i].fn, void 0, true);
                  switch (len) {
                    case 1:
                      listeners[i].fn.call(listeners[i].context);
                      break;
                    case 2:
                      listeners[i].fn.call(listeners[i].context, a1);
                      break;
                    case 3:
                      listeners[i].fn.call(listeners[i].context, a1, a2);
                      break;
                    case 4:
                      listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                      break;
                    default:
                      if (!args)
                        for (j = 1, args = new Array(len - 1); j < len; j++) {
                          args[j - 1] = arguments[j];
                        }
                      listeners[i].fn.apply(listeners[i].context, args);
                  }
                }
              }
              return true;
            };
            EventEmitter.prototype.on = function on(event, fn, context) {
              return addListener(this, event, fn, context, false);
            };
            EventEmitter.prototype.once = function once(event, fn, context) {
              return addListener(this, event, fn, context, true);
            };
            EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
              var evt = prefix ? prefix + event : event;
              if (!this._events[evt])
                return this;
              if (!fn) {
                clearEvent(this, evt);
                return this;
              }
              var listeners = this._events[evt];
              if (listeners.fn) {
                if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                  clearEvent(this, evt);
                }
              } else {
                for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                  if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                    events.push(listeners[i]);
                  }
                }
                if (events.length)
                  this._events[evt] = events.length === 1 ? events[0] : events;
                else
                  clearEvent(this, evt);
              }
              return this;
            };
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
              var evt;
              if (event) {
                evt = prefix ? prefix + event : event;
                if (this._events[evt])
                  clearEvent(this, evt);
              } else {
                this._events = new Events();
                this._eventsCount = 0;
              }
              return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.addListener = EventEmitter.prototype.on;
            EventEmitter.prefixed = prefix;
            EventEmitter.EventEmitter = EventEmitter;
            if (true) {
              module2.exports = EventEmitter;
            }
          },
          62270: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var QuickSet = __webpack_require__2(82590);
            var AlignTo = function(items, position, offsetX, offsetY) {
              var target = items[0];
              for (var i = 1; i < items.length; i++) {
                var item = items[i];
                QuickSet(item, target, position, offsetX, offsetY);
                target = item;
              }
              return items;
            };
            module2.exports = AlignTo;
          },
          61148: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var Angle = function(items, value, step, index, direction) {
              return PropertyValueInc(items, "angle", value, step, index, direction);
            };
            module2.exports = Angle;
          },
          22015: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Call = function(items, callback, context) {
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                callback.call(context, item);
              }
              return items;
            };
            module2.exports = Call;
          },
          31060: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFirst = function(items, compare, index) {
              if (index === void 0) {
                index = 0;
              }
              for (var i = index; i < items.length; i++) {
                var item = items[i];
                var match = true;
                for (var property in compare) {
                  if (item[property] !== compare[property]) {
                    match = false;
                  }
                }
                if (match) {
                  return item;
                }
              }
              return null;
            };
            module2.exports = GetFirst;
          },
          52367: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLast = function(items, compare, index) {
              if (index === void 0) {
                index = 0;
              }
              for (var i = items.length - 1; i >= index; i--) {
                var item = items[i];
                var match = true;
                for (var property in compare) {
                  if (item[property] !== compare[property]) {
                    match = false;
                  }
                }
                if (match) {
                  return item;
                }
              }
              return null;
            };
            module2.exports = GetLast;
          },
          12673: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AlignIn = __webpack_require__2(40327);
            var CONST = __webpack_require__2(84093);
            var GetFastValue = __webpack_require__2(72632);
            var NOOP = __webpack_require__2(72283);
            var Zone = __webpack_require__2(71030);
            var tempZone = new Zone({sys: {queueDepthSort: NOOP, events: {once: NOOP}}}, 0, 0, 1, 1).setOrigin(0, 0);
            var GridAlign = function(items, options) {
              if (options === void 0) {
                options = {};
              }
              var widthSet = options.hasOwnProperty("width");
              var heightSet = options.hasOwnProperty("height");
              var width = GetFastValue(options, "width", -1);
              var height = GetFastValue(options, "height", -1);
              var cellWidth = GetFastValue(options, "cellWidth", 1);
              var cellHeight = GetFastValue(options, "cellHeight", cellWidth);
              var position = GetFastValue(options, "position", CONST.TOP_LEFT);
              var x = GetFastValue(options, "x", 0);
              var y = GetFastValue(options, "y", 0);
              var cx = 0;
              var cy = 0;
              var w = width * cellWidth;
              var h = height * cellHeight;
              tempZone.setPosition(x, y);
              tempZone.setSize(cellWidth, cellHeight);
              for (var i = 0; i < items.length; i++) {
                AlignIn(items[i], tempZone, position);
                if (widthSet && width === -1) {
                  tempZone.x += cellWidth;
                } else if (heightSet && height === -1) {
                  tempZone.y += cellHeight;
                } else if (heightSet && !widthSet) {
                  cy += cellHeight;
                  tempZone.y += cellHeight;
                  if (cy === h) {
                    cy = 0;
                    cx += cellWidth;
                    tempZone.y = y;
                    tempZone.x += cellWidth;
                    if (cx === w) {
                      break;
                    }
                  }
                } else {
                  cx += cellWidth;
                  tempZone.x += cellWidth;
                  if (cx === w) {
                    cx = 0;
                    cy += cellHeight;
                    tempZone.x = x;
                    tempZone.y += cellHeight;
                    if (cy === h) {
                      break;
                    }
                  }
                }
              }
              return items;
            };
            module2.exports = GridAlign;
          },
          691: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var IncAlpha = function(items, value, step, index, direction) {
              return PropertyValueInc(items, "alpha", value, step, index, direction);
            };
            module2.exports = IncAlpha;
          },
          3877: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var IncX = function(items, value, step, index, direction) {
              return PropertyValueInc(items, "x", value, step, index, direction);
            };
            module2.exports = IncX;
          },
          71020: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var IncXY = function(items, x, y, stepX, stepY, index, direction) {
              if (y === void 0 || y === null) {
                y = x;
              }
              PropertyValueInc(items, "x", x, stepX, index, direction);
              return PropertyValueInc(items, "y", y, stepY, index, direction);
            };
            module2.exports = IncXY;
          },
          28970: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var IncY = function(items, value, step, index, direction) {
              return PropertyValueInc(items, "y", value, step, index, direction);
            };
            module2.exports = IncY;
          },
          82249: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PlaceOnCircle = function(items, circle, startAngle, endAngle) {
              if (startAngle === void 0) {
                startAngle = 0;
              }
              if (endAngle === void 0) {
                endAngle = 6.28;
              }
              var angle = startAngle;
              var angleStep = (endAngle - startAngle) / items.length;
              var cx = circle.x;
              var cy = circle.y;
              var radius = circle.radius;
              for (var i = 0; i < items.length; i++) {
                items[i].x = cx + radius * Math.cos(angle);
                items[i].y = cy + radius * Math.sin(angle);
                angle += angleStep;
              }
              return items;
            };
            module2.exports = PlaceOnCircle;
          },
          30285: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PlaceOnEllipse = function(items, ellipse, startAngle, endAngle) {
              if (startAngle === void 0) {
                startAngle = 0;
              }
              if (endAngle === void 0) {
                endAngle = 6.28;
              }
              var angle = startAngle;
              var angleStep = (endAngle - startAngle) / items.length;
              var a = ellipse.width / 2;
              var b = ellipse.height / 2;
              for (var i = 0; i < items.length; i++) {
                items[i].x = ellipse.x + a * Math.cos(angle);
                items[i].y = ellipse.y + b * Math.sin(angle);
                angle += angleStep;
              }
              return items;
            };
            module2.exports = PlaceOnEllipse;
          },
          61557: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetPoints = __webpack_require__2(8570);
            var PlaceOnLine = function(items, line) {
              var points = GetPoints(line, items.length);
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var point = points[i];
                item.x = point.x;
                item.y = point.y;
              }
              return items;
            };
            module2.exports = PlaceOnLine;
          },
          63549: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MarchingAnts = __webpack_require__2(40053);
            var RotateLeft = __webpack_require__2(77640);
            var RotateRight = __webpack_require__2(38487);
            var PlaceOnRectangle = function(items, rect, shift) {
              if (shift === void 0) {
                shift = 0;
              }
              var points = MarchingAnts(rect, false, items.length);
              if (shift > 0) {
                RotateLeft(points, shift);
              } else if (shift < 0) {
                RotateRight(points, Math.abs(shift));
              }
              for (var i = 0; i < items.length; i++) {
                items[i].x = points[i].x;
                items[i].y = points[i].y;
              }
              return items;
            };
            module2.exports = PlaceOnRectangle;
          },
          51629: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BresenhamPoints = __webpack_require__2(58813);
            var PlaceOnTriangle = function(items, triangle, stepRate) {
              var p1 = BresenhamPoints({x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2}, stepRate);
              var p2 = BresenhamPoints({x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3}, stepRate);
              var p3 = BresenhamPoints({x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1}, stepRate);
              p1.pop();
              p2.pop();
              p3.pop();
              p1 = p1.concat(p2, p3);
              var step = p1.length / items.length;
              var p = 0;
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var point = p1[Math.floor(p)];
                item.x = point.x;
                item.y = point.y;
                p += step;
              }
              return items;
            };
            module2.exports = PlaceOnTriangle;
          },
          1045: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PlayAnimation = function(items, key, ignoreIfPlaying) {
              for (var i = 0; i < items.length; i++) {
                var gameObject = items[i];
                if (gameObject.anims) {
                  gameObject.anims.play(key, ignoreIfPlaying);
                }
              }
              return items;
            };
            module2.exports = PlayAnimation;
          },
          6124: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = function(items, key, value, step, index, direction) {
              if (step === void 0) {
                step = 0;
              }
              if (index === void 0) {
                index = 0;
              }
              if (direction === void 0) {
                direction = 1;
              }
              var i;
              var t = 0;
              var end = items.length;
              if (direction === 1) {
                for (i = index; i < end; i++) {
                  items[i][key] += value + t * step;
                  t++;
                }
              } else {
                for (i = index; i >= 0; i--) {
                  items[i][key] += value + t * step;
                  t++;
                }
              }
              return items;
            };
            module2.exports = PropertyValueInc;
          },
          23646: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = function(items, key, value, step, index, direction) {
              if (step === void 0) {
                step = 0;
              }
              if (index === void 0) {
                index = 0;
              }
              if (direction === void 0) {
                direction = 1;
              }
              var i;
              var t = 0;
              var end = items.length;
              if (direction === 1) {
                for (i = index; i < end; i++) {
                  items[i][key] = value + t * step;
                  t++;
                }
              } else {
                for (i = index; i >= 0; i--) {
                  items[i][key] = value + t * step;
                  t++;
                }
              }
              return items;
            };
            module2.exports = PropertyValueSet;
          },
          4392: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Random = __webpack_require__2(30977);
            var RandomCircle = function(items, circle) {
              for (var i = 0; i < items.length; i++) {
                Random(circle, items[i]);
              }
              return items;
            };
            module2.exports = RandomCircle;
          },
          94985: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Random = __webpack_require__2(72006);
            var RandomEllipse = function(items, ellipse) {
              for (var i = 0; i < items.length; i++) {
                Random(ellipse, items[i]);
              }
              return items;
            };
            module2.exports = RandomEllipse;
          },
          63305: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Random = __webpack_require__2(74077);
            var RandomLine = function(items, line) {
              for (var i = 0; i < items.length; i++) {
                Random(line, items[i]);
              }
              return items;
            };
            module2.exports = RandomLine;
          },
          90739: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Random = __webpack_require__2(30001);
            var RandomRectangle = function(items, rect) {
              for (var i = 0; i < items.length; i++) {
                Random(rect, items[i]);
              }
              return items;
            };
            module2.exports = RandomRectangle;
          },
          91417: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Random = __webpack_require__2(99761);
            var RandomTriangle = function(items, triangle) {
              for (var i = 0; i < items.length; i++) {
                Random(triangle, items[i]);
              }
              return items;
            };
            module2.exports = RandomTriangle;
          },
          26182: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var Rotate = function(items, value, step, index, direction) {
              return PropertyValueInc(items, "rotation", value, step, index, direction);
            };
            module2.exports = Rotate;
          },
          87299: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAroundDistance = __webpack_require__2(72395);
            var DistanceBetween = __webpack_require__2(53996);
            var RotateAround = function(items, point, angle) {
              var x = point.x;
              var y = point.y;
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
              }
              return items;
            };
            module2.exports = RotateAround;
          },
          92194: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MathRotateAroundDistance = __webpack_require__2(72395);
            var RotateAroundDistance = function(items, point, angle, distance) {
              var x = point.x;
              var y = point.y;
              if (distance === 0) {
                return items;
              }
              for (var i = 0; i < items.length; i++) {
                MathRotateAroundDistance(items[i], x, y, angle, distance);
              }
              return items;
            };
            module2.exports = RotateAroundDistance;
          },
          30363: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var ScaleX = function(items, value, step, index, direction) {
              return PropertyValueInc(items, "scaleX", value, step, index, direction);
            };
            module2.exports = ScaleX;
          },
          51449: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var ScaleXY = function(items, scaleX, scaleY, stepX, stepY, index, direction) {
              if (scaleY === void 0 || scaleY === null) {
                scaleY = scaleX;
              }
              PropertyValueInc(items, "scaleX", scaleX, stepX, index, direction);
              return PropertyValueInc(items, "scaleY", scaleY, stepY, index, direction);
            };
            module2.exports = ScaleXY;
          },
          64895: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueInc = __webpack_require__2(6124);
            var ScaleY = function(items, value, step, index, direction) {
              return PropertyValueInc(items, "scaleY", value, step, index, direction);
            };
            module2.exports = ScaleY;
          },
          30329: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetAlpha = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "alpha", value, step, index, direction);
            };
            module2.exports = SetAlpha;
          },
          43954: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetBlendMode = function(items, value, index, direction) {
              return PropertyValueSet(items, "blendMode", value, 0, index, direction);
            };
            module2.exports = SetBlendMode;
          },
          70688: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetDepth = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "depth", value, step, index, direction);
            };
            module2.exports = SetDepth;
          },
          8314: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetHitArea = function(items, hitArea, hitAreaCallback) {
              for (var i = 0; i < items.length; i++) {
                items[i].setInteractive(hitArea, hitAreaCallback);
              }
              return items;
            };
            module2.exports = SetHitArea;
          },
          12894: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetOrigin = function(items, originX, originY, stepX, stepY, index, direction) {
              if (originY === void 0 || originY === null) {
                originY = originX;
              }
              PropertyValueSet(items, "originX", originX, stepX, index, direction);
              PropertyValueSet(items, "originY", originY, stepY, index, direction);
              items.forEach(function(item) {
                item.updateDisplayOrigin();
              });
              return items;
            };
            module2.exports = SetOrigin;
          },
          38767: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetRotation = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "rotation", value, step, index, direction);
            };
            module2.exports = SetRotation;
          },
          18584: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetScale = function(items, scaleX, scaleY, stepX, stepY, index, direction) {
              if (scaleY === void 0 || scaleY === null) {
                scaleY = scaleX;
              }
              PropertyValueSet(items, "scaleX", scaleX, stepX, index, direction);
              return PropertyValueSet(items, "scaleY", scaleY, stepY, index, direction);
            };
            module2.exports = SetScale;
          },
          17381: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetScaleX = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "scaleX", value, step, index, direction);
            };
            module2.exports = SetScaleX;
          },
          74370: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetScaleY = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "scaleY", value, step, index, direction);
            };
            module2.exports = SetScaleY;
          },
          27773: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetScrollFactor = function(items, scrollFactorX, scrollFactorY, stepX, stepY, index, direction) {
              if (scrollFactorY === void 0 || scrollFactorY === null) {
                scrollFactorY = scrollFactorX;
              }
              PropertyValueSet(items, "scrollFactorX", scrollFactorX, stepX, index, direction);
              return PropertyValueSet(items, "scrollFactorY", scrollFactorY, stepY, index, direction);
            };
            module2.exports = SetScrollFactor;
          },
          75257: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetScrollFactorX = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "scrollFactorX", value, step, index, direction);
            };
            module2.exports = SetScrollFactorX;
          },
          54512: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetScrollFactorY = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "scrollFactorY", value, step, index, direction);
            };
            module2.exports = SetScrollFactorY;
          },
          69423: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTint = function(items, topLeft, topRight, bottomLeft, bottomRight) {
              for (var i = 0; i < items.length; i++) {
                items[i].setTint(topLeft, topRight, bottomLeft, bottomRight);
              }
              return items;
            };
            module2.exports = SetTint;
          },
          58291: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetVisible = function(items, value, index, direction) {
              return PropertyValueSet(items, "visible", value, 0, index, direction);
            };
            module2.exports = SetVisible;
          },
          94833: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetX = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "x", value, step, index, direction);
            };
            module2.exports = SetX;
          },
          14284: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetXY = function(items, x, y, stepX, stepY, index, direction) {
              if (y === void 0 || y === null) {
                y = x;
              }
              PropertyValueSet(items, "x", x, stepX, index, direction);
              return PropertyValueSet(items, "y", y, stepY, index, direction);
            };
            module2.exports = SetXY;
          },
          96574: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PropertyValueSet = __webpack_require__2(23646);
            var SetY = function(items, value, step, index, direction) {
              return PropertyValueSet(items, "y", value, step, index, direction);
            };
            module2.exports = SetY;
          },
          74086: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var ShiftPosition = function(items, x, y, direction, output) {
              if (direction === void 0) {
                direction = 0;
              }
              if (output === void 0) {
                output = new Vector2();
              }
              var px;
              var py;
              var len = items.length;
              if (len === 1) {
                px = items[0].x;
                py = items[0].y;
                items[0].x = x;
                items[0].y = y;
              } else {
                var i = 1;
                var pos = 0;
                if (direction === 0) {
                  pos = len - 1;
                  i = len - 2;
                }
                px = items[pos].x;
                py = items[pos].y;
                items[pos].x = x;
                items[pos].y = y;
                for (var c = 0; c < len; c++) {
                  if (i >= len || i === -1) {
                    continue;
                  }
                  var cur = items[i];
                  var cx = cur.x;
                  var cy = cur.y;
                  cur.x = px;
                  cur.y = py;
                  px = cx;
                  py = cy;
                  if (direction === 0) {
                    i--;
                  } else {
                    i++;
                  }
                }
              }
              output.x = px;
              output.y = py;
              return output;
            };
            module2.exports = ShiftPosition;
          },
          86347: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArrayShuffle = __webpack_require__2(18592);
            var Shuffle = function(items) {
              return ArrayShuffle(items);
            };
            module2.exports = Shuffle;
          },
          1558: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MathSmoothStep = __webpack_require__2(5514);
            var SmoothStep = function(items, property, min, max, inc) {
              if (inc === void 0) {
                inc = false;
              }
              var step = Math.abs(max - min) / items.length;
              var i;
              if (inc) {
                for (i = 0; i < items.length; i++) {
                  items[i][property] += MathSmoothStep(i * step, min, max);
                }
              } else {
                for (i = 0; i < items.length; i++) {
                  items[i][property] = MathSmoothStep(i * step, min, max);
                }
              }
              return items;
            };
            module2.exports = SmoothStep;
          },
          9938: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MathSmootherStep = __webpack_require__2(87736);
            var SmootherStep = function(items, property, min, max, inc) {
              if (inc === void 0) {
                inc = false;
              }
              var step = Math.abs(max - min) / items.length;
              var i;
              if (inc) {
                for (i = 0; i < items.length; i++) {
                  items[i][property] += MathSmootherStep(i * step, min, max);
                }
              } else {
                for (i = 0; i < items.length; i++) {
                  items[i][property] = MathSmootherStep(i * step, min, max);
                }
              }
              return items;
            };
            module2.exports = SmootherStep;
          },
          71060: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Spread = function(items, property, min, max, inc) {
              if (inc === void 0) {
                inc = false;
              }
              if (items.length === 0) {
                return items;
              }
              if (items.length === 1) {
                if (inc) {
                  items[0][property] += (max + min) / 2;
                } else {
                  items[0][property] = (max + min) / 2;
                }
                return items;
              }
              var step = Math.abs(max - min) / (items.length - 1);
              var i;
              if (inc) {
                for (i = 0; i < items.length; i++) {
                  items[i][property] += i * step + min;
                }
              } else {
                for (i = 0; i < items.length; i++) {
                  items[i][property] = i * step + min;
                }
              }
              return items;
            };
            module2.exports = Spread;
          },
          11207: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ToggleVisible = function(items) {
              for (var i = 0; i < items.length; i++) {
                items[i].visible = !items[i].visible;
              }
              return items;
            };
            module2.exports = ToggleVisible;
          },
          24404: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       samme <samme.npm@gmail.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Wrap = __webpack_require__2(1071);
            var WrapInRectangle = function(items, rect, padding) {
              if (padding === void 0) {
                padding = 0;
              }
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                item.x = Wrap(item.x, rect.left - padding, rect.right + padding);
                item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);
              }
              return items;
            };
            module2.exports = WrapInRectangle;
          },
          83979: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              AlignTo: __webpack_require__2(62270),
              Angle: __webpack_require__2(61148),
              Call: __webpack_require__2(22015),
              GetFirst: __webpack_require__2(31060),
              GetLast: __webpack_require__2(52367),
              GridAlign: __webpack_require__2(12673),
              IncAlpha: __webpack_require__2(691),
              IncX: __webpack_require__2(3877),
              IncXY: __webpack_require__2(71020),
              IncY: __webpack_require__2(28970),
              PlaceOnCircle: __webpack_require__2(82249),
              PlaceOnEllipse: __webpack_require__2(30285),
              PlaceOnLine: __webpack_require__2(61557),
              PlaceOnRectangle: __webpack_require__2(63549),
              PlaceOnTriangle: __webpack_require__2(51629),
              PlayAnimation: __webpack_require__2(1045),
              PropertyValueInc: __webpack_require__2(6124),
              PropertyValueSet: __webpack_require__2(23646),
              RandomCircle: __webpack_require__2(4392),
              RandomEllipse: __webpack_require__2(94985),
              RandomLine: __webpack_require__2(63305),
              RandomRectangle: __webpack_require__2(90739),
              RandomTriangle: __webpack_require__2(91417),
              Rotate: __webpack_require__2(26182),
              RotateAround: __webpack_require__2(87299),
              RotateAroundDistance: __webpack_require__2(92194),
              ScaleX: __webpack_require__2(30363),
              ScaleXY: __webpack_require__2(51449),
              ScaleY: __webpack_require__2(64895),
              SetAlpha: __webpack_require__2(30329),
              SetBlendMode: __webpack_require__2(43954),
              SetDepth: __webpack_require__2(70688),
              SetHitArea: __webpack_require__2(8314),
              SetOrigin: __webpack_require__2(12894),
              SetRotation: __webpack_require__2(38767),
              SetScale: __webpack_require__2(18584),
              SetScaleX: __webpack_require__2(17381),
              SetScaleY: __webpack_require__2(74370),
              SetScrollFactor: __webpack_require__2(27773),
              SetScrollFactorX: __webpack_require__2(75257),
              SetScrollFactorY: __webpack_require__2(54512),
              SetTint: __webpack_require__2(69423),
              SetVisible: __webpack_require__2(58291),
              SetX: __webpack_require__2(94833),
              SetXY: __webpack_require__2(14284),
              SetY: __webpack_require__2(96574),
              ShiftPosition: __webpack_require__2(74086),
              Shuffle: __webpack_require__2(86347),
              SmootherStep: __webpack_require__2(9938),
              SmoothStep: __webpack_require__2(1558),
              Spread: __webpack_require__2(71060),
              ToggleVisible: __webpack_require__2(11207),
              WrapInRectangle: __webpack_require__2(24404)
            };
          },
          85463: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(16938);
            var FindClosestInSorted = __webpack_require__2(2406);
            var Frame = __webpack_require__2(71519);
            var GetValue = __webpack_require__2(10850);
            var SortByDigits = __webpack_require__2(28834);
            var Animation = new Class({
              initialize: function Animation2(manager, key, config2) {
                this.manager = manager;
                this.key = key;
                this.type = "frame";
                this.frames = this.getFrames(manager.textureManager, GetValue(config2, "frames", []), GetValue(config2, "defaultTextureKey", null), GetValue(config2, "sortFrames", true));
                this.frameRate = GetValue(config2, "frameRate", null);
                this.duration = GetValue(config2, "duration", null);
                this.msPerFrame;
                this.skipMissedFrames = GetValue(config2, "skipMissedFrames", true);
                this.delay = GetValue(config2, "delay", 0);
                this.repeat = GetValue(config2, "repeat", 0);
                this.repeatDelay = GetValue(config2, "repeatDelay", 0);
                this.yoyo = GetValue(config2, "yoyo", false);
                this.showBeforeDelay = GetValue(config2, "showBeforeDelay", false);
                this.showOnStart = GetValue(config2, "showOnStart", false);
                this.hideOnComplete = GetValue(config2, "hideOnComplete", false);
                this.randomFrame = GetValue(config2, "randomFrame", false);
                this.paused = false;
                this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate);
                if (this.manager.on) {
                  this.manager.on(Events.PAUSE_ALL, this.pause, this);
                  this.manager.on(Events.RESUME_ALL, this.resume, this);
                }
              },
              getTotalFrames: function() {
                return this.frames.length;
              },
              calculateDuration: function(target, totalFrames, duration, frameRate) {
                if (duration === null && frameRate === null) {
                  target.frameRate = 24;
                  target.duration = 24 / totalFrames * 1e3;
                } else if (duration && frameRate === null) {
                  target.duration = duration;
                  target.frameRate = totalFrames / (duration / 1e3);
                } else {
                  target.frameRate = frameRate;
                  target.duration = totalFrames / frameRate * 1e3;
                }
                target.msPerFrame = 1e3 / target.frameRate;
              },
              addFrame: function(config2) {
                return this.addFrameAt(this.frames.length, config2);
              },
              addFrameAt: function(index, config2) {
                var newFrames = this.getFrames(this.manager.textureManager, config2);
                if (newFrames.length > 0) {
                  if (index === 0) {
                    this.frames = newFrames.concat(this.frames);
                  } else if (index === this.frames.length) {
                    this.frames = this.frames.concat(newFrames);
                  } else {
                    var pre = this.frames.slice(0, index);
                    var post = this.frames.slice(index);
                    this.frames = pre.concat(newFrames, post);
                  }
                  this.updateFrameSequence();
                }
                return this;
              },
              checkFrame: function(index) {
                return index >= 0 && index < this.frames.length;
              },
              getFirstTick: function(state) {
                state.accumulator = 0;
                state.nextTick = state.msPerFrame + state.currentFrame.duration;
              },
              getFrameAt: function(index) {
                return this.frames[index];
              },
              getFrames: function(textureManager, frames, defaultTextureKey, sortFrames) {
                if (sortFrames === void 0) {
                  sortFrames = true;
                }
                var out = [];
                var prev;
                var animationFrame;
                var index = 1;
                var i;
                var textureKey;
                if (typeof frames === "string") {
                  textureKey = frames;
                  if (!textureManager.exists(textureKey)) {
                    console.warn('Texture "%s" not found', textureKey);
                    return out;
                  }
                  var texture = textureManager.get(textureKey);
                  var frameKeys = texture.getFrameNames();
                  if (sortFrames) {
                    SortByDigits(frameKeys);
                  }
                  frames = [];
                  frameKeys.forEach(function(value) {
                    frames.push({key: textureKey, frame: value});
                  });
                }
                if (!Array.isArray(frames) || frames.length === 0) {
                  return out;
                }
                for (i = 0; i < frames.length; i++) {
                  var item = frames[i];
                  var key = GetValue(item, "key", defaultTextureKey);
                  if (!key) {
                    continue;
                  }
                  var frame = GetValue(item, "frame", 0);
                  var textureFrame = textureManager.getFrame(key, frame);
                  if (!textureFrame) {
                    console.warn('Texture "%s" not found', key);
                    continue;
                  }
                  animationFrame = new Frame(key, frame, index, textureFrame);
                  animationFrame.duration = GetValue(item, "duration", 0);
                  animationFrame.isFirst = !prev;
                  if (prev) {
                    prev.nextFrame = animationFrame;
                    animationFrame.prevFrame = prev;
                  }
                  out.push(animationFrame);
                  prev = animationFrame;
                  index++;
                }
                if (out.length > 0) {
                  animationFrame.isLast = true;
                  animationFrame.nextFrame = out[0];
                  out[0].prevFrame = animationFrame;
                  var slice = 1 / (out.length - 1);
                  for (i = 0; i < out.length; i++) {
                    out[i].progress = i * slice;
                  }
                }
                return out;
              },
              getNextTick: function(state) {
                state.accumulator -= state.nextTick;
                state.nextTick = state.msPerFrame + state.currentFrame.duration;
              },
              getFrameByProgress: function(value) {
                value = Clamp(value, 0, 1);
                return FindClosestInSorted(value, this.frames, "progress");
              },
              nextFrame: function(state) {
                var frame = state.currentFrame;
                if (frame.isLast) {
                  if (state.yoyo) {
                    this.handleYoyoFrame(state, false);
                  } else if (state.repeatCounter > 0) {
                    if (state.inReverse && state.forward) {
                      state.forward = false;
                    } else {
                      this.repeatAnimation(state);
                    }
                  } else {
                    state.complete();
                  }
                } else {
                  this.updateAndGetNextTick(state, frame.nextFrame);
                }
              },
              handleYoyoFrame: function(state, isReverse) {
                if (!isReverse) {
                  isReverse = false;
                }
                if (state.inReverse === !isReverse && state.repeatCounter > 0) {
                  if (state.repeatDelay === 0 || state.pendingRepeat) {
                    state.forward = isReverse;
                  }
                  this.repeatAnimation(state);
                  return;
                }
                if (state.inReverse !== isReverse && state.repeatCounter === 0) {
                  state.complete();
                  return;
                }
                state.forward = isReverse;
                var frame = isReverse ? state.currentFrame.nextFrame : state.currentFrame.prevFrame;
                this.updateAndGetNextTick(state, frame);
              },
              getLastFrame: function() {
                return this.frames[this.frames.length - 1];
              },
              previousFrame: function(state) {
                var frame = state.currentFrame;
                if (frame.isFirst) {
                  if (state.yoyo) {
                    this.handleYoyoFrame(state, true);
                  } else if (state.repeatCounter > 0) {
                    if (state.inReverse && !state.forward) {
                      this.repeatAnimation(state);
                    } else {
                      state.forward = true;
                      this.repeatAnimation(state);
                    }
                  } else {
                    state.complete();
                  }
                } else {
                  this.updateAndGetNextTick(state, frame.prevFrame);
                }
              },
              updateAndGetNextTick: function(state, frame) {
                state.setCurrentFrame(frame);
                this.getNextTick(state);
              },
              removeFrame: function(frame) {
                var index = this.frames.indexOf(frame);
                if (index !== -1) {
                  this.removeFrameAt(index);
                }
                return this;
              },
              removeFrameAt: function(index) {
                this.frames.splice(index, 1);
                this.updateFrameSequence();
                return this;
              },
              repeatAnimation: function(state) {
                if (state._pendingStop === 2) {
                  if (state._pendingStopValue === 0) {
                    return state.stop();
                  } else {
                    state._pendingStopValue--;
                  }
                }
                if (state.repeatDelay > 0 && !state.pendingRepeat) {
                  state.pendingRepeat = true;
                  state.accumulator -= state.nextTick;
                  state.nextTick += state.repeatDelay;
                } else {
                  state.repeatCounter--;
                  if (state.forward) {
                    state.setCurrentFrame(state.currentFrame.nextFrame);
                  } else {
                    state.setCurrentFrame(state.currentFrame.prevFrame);
                  }
                  if (state.isPlaying) {
                    this.getNextTick(state);
                    state.handleRepeat();
                  }
                }
              },
              toJSON: function() {
                var output = {
                  key: this.key,
                  type: this.type,
                  frames: [],
                  frameRate: this.frameRate,
                  duration: this.duration,
                  skipMissedFrames: this.skipMissedFrames,
                  delay: this.delay,
                  repeat: this.repeat,
                  repeatDelay: this.repeatDelay,
                  yoyo: this.yoyo,
                  showBeforeDelay: this.showBeforeDelay,
                  showOnStart: this.showOnStart,
                  randomFrame: this.randomFrame,
                  hideOnComplete: this.hideOnComplete
                };
                this.frames.forEach(function(frame) {
                  output.frames.push(frame.toJSON());
                });
                return output;
              },
              updateFrameSequence: function() {
                var len = this.frames.length;
                var slice = 1 / (len - 1);
                var frame;
                for (var i = 0; i < len; i++) {
                  frame = this.frames[i];
                  frame.index = i + 1;
                  frame.isFirst = false;
                  frame.isLast = false;
                  frame.progress = i * slice;
                  if (i === 0) {
                    frame.isFirst = true;
                    if (len === 1) {
                      frame.isLast = true;
                      frame.nextFrame = frame;
                      frame.prevFrame = frame;
                    } else {
                      frame.isLast = false;
                      frame.prevFrame = this.frames[len - 1];
                      frame.nextFrame = this.frames[i + 1];
                    }
                  } else if (i === len - 1 && len > 1) {
                    frame.isLast = true;
                    frame.prevFrame = this.frames[len - 2];
                    frame.nextFrame = this.frames[0];
                  } else if (len > 1) {
                    frame.prevFrame = this.frames[i - 1];
                    frame.nextFrame = this.frames[i + 1];
                  }
                }
                return this;
              },
              pause: function() {
                this.paused = true;
                return this;
              },
              resume: function() {
                this.paused = false;
                return this;
              },
              destroy: function() {
                if (this.manager.off) {
                  this.manager.off(Events.PAUSE_ALL, this.pause, this);
                  this.manager.off(Events.RESUME_ALL, this.resume, this);
                }
                this.manager.remove(this.key);
                for (var i = 0; i < this.frames.length; i++) {
                  this.frames[i].destroy();
                }
                this.frames = [];
                this.manager = null;
              }
            });
            module2.exports = Animation;
          },
          71519: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var AnimationFrame = new Class({
              initialize: function AnimationFrame2(textureKey, textureFrame, index, frame, isKeyFrame) {
                if (isKeyFrame === void 0) {
                  isKeyFrame = false;
                }
                this.textureKey = textureKey;
                this.textureFrame = textureFrame;
                this.index = index;
                this.frame = frame;
                this.isFirst = false;
                this.isLast = false;
                this.prevFrame = null;
                this.nextFrame = null;
                this.duration = 0;
                this.progress = 0;
                this.isKeyFrame = isKeyFrame;
              },
              toJSON: function() {
                return {
                  key: this.textureKey,
                  frame: this.textureFrame,
                  duration: this.duration,
                  keyframe: this.isKeyFrame
                };
              },
              destroy: function() {
                this.frame = void 0;
              }
            });
            module2.exports = AnimationFrame;
          },
          90249: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Animation = __webpack_require__2(85463);
            var Class = __webpack_require__2(56694);
            var CustomMap = __webpack_require__2(33885);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(16938);
            var GameEvents = __webpack_require__2(97081);
            var GetFastValue = __webpack_require__2(72632);
            var GetValue = __webpack_require__2(10850);
            var MATH_CONST = __webpack_require__2(83392);
            var NumberArray = __webpack_require__2(13401);
            var Pad = __webpack_require__2(76400);
            var AnimationManager = new Class({
              Extends: EventEmitter,
              initialize: function AnimationManager2(game) {
                EventEmitter.call(this);
                this.game = game;
                this.textureManager = null;
                this.globalTimeScale = 1;
                this.anims = new CustomMap();
                this.mixes = new CustomMap();
                this.paused = false;
                this.name = "AnimationManager";
                game.events.once(GameEvents.BOOT, this.boot, this);
              },
              boot: function() {
                this.textureManager = this.game.textures;
                this.game.events.once(GameEvents.DESTROY, this.destroy, this);
              },
              addMix: function(animA, animB, delay) {
                var anims = this.anims;
                var mixes = this.mixes;
                var keyA = typeof animA === "string" ? animA : animA.key;
                var keyB = typeof animB === "string" ? animB : animB.key;
                if (anims.has(keyA) && anims.has(keyB)) {
                  var mixObj = mixes.get(keyA);
                  if (!mixObj) {
                    mixObj = {};
                  }
                  mixObj[keyB] = delay;
                  mixes.set(keyA, mixObj);
                }
                return this;
              },
              removeMix: function(animA, animB) {
                var mixes = this.mixes;
                var keyA = typeof animA === "string" ? animA : animA.key;
                var mixObj = mixes.get(keyA);
                if (mixObj) {
                  if (animB) {
                    var keyB = typeof animB === "string" ? animB : animB.key;
                    if (mixObj.hasOwnProperty(keyB)) {
                      delete mixObj[keyB];
                    }
                  } else if (!animB) {
                    mixes.delete(keyA);
                  }
                }
                return this;
              },
              getMix: function(animA, animB) {
                var mixes = this.mixes;
                var keyA = typeof animA === "string" ? animA : animA.key;
                var keyB = typeof animB === "string" ? animB : animB.key;
                var mixObj = mixes.get(keyA);
                if (mixObj && mixObj.hasOwnProperty(keyB)) {
                  return mixObj[keyB];
                } else {
                  return 0;
                }
              },
              add: function(key, animation) {
                if (this.anims.has(key)) {
                  console.warn("Animation key exists: " + key);
                  return this;
                }
                animation.key = key;
                this.anims.set(key, animation);
                this.emit(Events.ADD_ANIMATION, key, animation);
                return this;
              },
              exists: function(key) {
                return this.anims.has(key);
              },
              createFromAseprite: function(key, tags, target) {
                var output = [];
                var data = this.game.cache.json.get(key);
                if (!data) {
                  console.warn("No Aseprite data found for: " + key);
                  return output;
                }
                var _this = this;
                var meta = GetValue(data, "meta", null);
                var frames = GetValue(data, "frames", null);
                if (meta && frames) {
                  var frameTags = GetValue(meta, "frameTags", []);
                  frameTags.forEach(function(tag) {
                    var animFrames = [];
                    var name = GetFastValue(tag, "name", null);
                    var from = GetFastValue(tag, "from", 0);
                    var to = GetFastValue(tag, "to", 0);
                    var direction = GetFastValue(tag, "direction", "forward");
                    if (!name) {
                      return;
                    }
                    if (!tags || tags && tags.indexOf(name) > -1) {
                      var totalDuration = 0;
                      for (var i = from; i <= to; i++) {
                        var frameKey = i.toString();
                        var frame = frames[frameKey];
                        if (frame) {
                          var frameDuration = GetFastValue(frame, "duration", MATH_CONST.MAX_SAFE_INTEGER);
                          animFrames.push({key, frame: frameKey, duration: frameDuration});
                          totalDuration += frameDuration;
                        }
                      }
                      var msPerFrame = totalDuration / animFrames.length;
                      animFrames.forEach(function(entry) {
                        entry.duration -= msPerFrame;
                      });
                      if (direction === "reverse") {
                        animFrames = animFrames.reverse();
                      }
                      var createConfig = {
                        key: name,
                        frames: animFrames,
                        duration: totalDuration,
                        yoyo: direction === "pingpong"
                      };
                      var result;
                      if (target) {
                        if (target.anims) {
                          result = target.anims.create(createConfig);
                        }
                      } else {
                        result = _this.create(createConfig);
                      }
                      if (result) {
                        output.push(result);
                      }
                    }
                  });
                }
                return output;
              },
              create: function(config2) {
                var key = config2.key;
                var anim = false;
                if (key) {
                  anim = this.get(key);
                  if (!anim) {
                    anim = new Animation(this, key, config2);
                    this.anims.set(key, anim);
                    this.emit(Events.ADD_ANIMATION, key, anim);
                  } else {
                    console.warn("AnimationManager key already exists: " + key);
                  }
                }
                return anim;
              },
              fromJSON: function(data, clearCurrentAnimations) {
                if (clearCurrentAnimations === void 0) {
                  clearCurrentAnimations = false;
                }
                if (clearCurrentAnimations) {
                  this.anims.clear();
                }
                if (typeof data === "string") {
                  data = JSON.parse(data);
                }
                var output = [];
                if (data.hasOwnProperty("anims") && Array.isArray(data.anims)) {
                  for (var i = 0; i < data.anims.length; i++) {
                    output.push(this.create(data.anims[i]));
                  }
                  if (data.hasOwnProperty("globalTimeScale")) {
                    this.globalTimeScale = data.globalTimeScale;
                  }
                } else if (data.hasOwnProperty("key") && data.type === "frame") {
                  output.push(this.create(data));
                }
                return output;
              },
              generateFrameNames: function(key, config2) {
                var prefix = GetValue(config2, "prefix", "");
                var start = GetValue(config2, "start", 0);
                var end = GetValue(config2, "end", 0);
                var suffix = GetValue(config2, "suffix", "");
                var zeroPad = GetValue(config2, "zeroPad", 0);
                var out = GetValue(config2, "outputArray", []);
                var frames = GetValue(config2, "frames", false);
                if (!this.textureManager.exists(key)) {
                  console.warn('Texture "%s" not found', key);
                  return out;
                }
                var texture = this.textureManager.get(key);
                if (!texture) {
                  return out;
                }
                var i;
                if (!config2) {
                  frames = texture.getFrameNames();
                  for (i = 0; i < frames.length; i++) {
                    out.push({key, frame: frames[i]});
                  }
                } else {
                  if (!frames) {
                    frames = NumberArray(start, end);
                  }
                  for (i = 0; i < frames.length; i++) {
                    var frame = prefix + Pad(frames[i], zeroPad, "0", 1) + suffix;
                    if (texture.has(frame)) {
                      out.push({key, frame});
                    } else {
                      console.warn('Frame "%s" not found in texture "%s"', frame, key);
                    }
                  }
                }
                return out;
              },
              generateFrameNumbers: function(key, config2) {
                var start = GetValue(config2, "start", 0);
                var end = GetValue(config2, "end", -1);
                var first = GetValue(config2, "first", false);
                var out = GetValue(config2, "outputArray", []);
                var frames = GetValue(config2, "frames", false);
                if (!this.textureManager.exists(key)) {
                  console.warn('Texture "%s" not found', key);
                  return out;
                }
                var texture = this.textureManager.get(key);
                if (!texture) {
                  return out;
                }
                if (first && texture.has(first)) {
                  out.push({key, frame: first});
                }
                if (!frames) {
                  if (end === -1) {
                    end = texture.frameTotal - 2;
                  }
                  frames = NumberArray(start, end);
                }
                for (var i = 0; i < frames.length; i++) {
                  var frameName = frames[i];
                  if (texture.has(frameName)) {
                    out.push({key, frame: frameName});
                  } else {
                    console.warn('Frame "%s" not found in texture "%s"', frameName, key);
                  }
                }
                return out;
              },
              get: function(key) {
                return this.anims.get(key);
              },
              getAnimsFromTexture: function(key) {
                var texture = this.textureManager.get(key);
                var match = texture.key;
                var anims = this.anims.getArray();
                var out = [];
                for (var i = 0; i < anims.length; i++) {
                  var anim = anims[i];
                  var frames = anim.frames;
                  for (var c = 0; c < frames.length; c++) {
                    if (frames[c].textureKey === match) {
                      out.push(anim.key);
                      break;
                    }
                  }
                }
                return out;
              },
              pauseAll: function() {
                if (!this.paused) {
                  this.paused = true;
                  this.emit(Events.PAUSE_ALL);
                }
                return this;
              },
              play: function(key, children) {
                if (!Array.isArray(children)) {
                  children = [children];
                }
                for (var i = 0; i < children.length; i++) {
                  children[i].anims.play(key);
                }
                return this;
              },
              staggerPlay: function(key, children, stagger, staggerFirst) {
                if (stagger === void 0) {
                  stagger = 0;
                }
                if (staggerFirst === void 0) {
                  staggerFirst = true;
                }
                if (!Array.isArray(children)) {
                  children = [children];
                }
                var len = children.length;
                if (!staggerFirst) {
                  len--;
                }
                for (var i = 0; i < children.length; i++) {
                  var time = stagger < 0 ? Math.abs(stagger) * (len - i) : stagger * i;
                  children[i].anims.playAfterDelay(key, time);
                }
                return this;
              },
              remove: function(key) {
                var anim = this.get(key);
                if (anim) {
                  this.emit(Events.REMOVE_ANIMATION, key, anim);
                  this.anims.delete(key);
                  this.removeMix(key);
                }
                return anim;
              },
              resumeAll: function() {
                if (this.paused) {
                  this.paused = false;
                  this.emit(Events.RESUME_ALL);
                }
                return this;
              },
              toJSON: function(key) {
                var output = {
                  anims: [],
                  globalTimeScale: this.globalTimeScale
                };
                if (key !== void 0 && key !== "") {
                  output.anims.push(this.anims.get(key).toJSON());
                } else {
                  this.anims.each(function(animationKey, animation) {
                    output.anims.push(animation.toJSON());
                  });
                }
                return output;
              },
              destroy: function() {
                this.anims.clear();
                this.mixes.clear();
                this.textureManager = null;
                this.game = null;
              }
            });
            module2.exports = AnimationManager;
          },
          16569: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Animation = __webpack_require__2(85463);
            var Between = __webpack_require__2(17489);
            var Class = __webpack_require__2(56694);
            var CustomMap = __webpack_require__2(33885);
            var Events = __webpack_require__2(16938);
            var GetFastValue = __webpack_require__2(72632);
            var AnimationState = new Class({
              initialize: function AnimationState2(parent) {
                this.parent = parent;
                this.animationManager = parent.scene.sys.anims;
                this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this);
                this.textureManager = this.animationManager.textureManager;
                this.anims = null;
                this.isPlaying = false;
                this.hasStarted = false;
                this.currentAnim = null;
                this.currentFrame = null;
                this.nextAnim = null;
                this.nextAnimsQueue = [];
                this.timeScale = 1;
                this.frameRate = 0;
                this.duration = 0;
                this.msPerFrame = 0;
                this.skipMissedFrames = true;
                this.randomFrame = false;
                this.delay = 0;
                this.repeat = 0;
                this.repeatDelay = 0;
                this.yoyo = false;
                this.showBeforeDelay = false;
                this.showOnStart = false;
                this.hideOnComplete = false;
                this.forward = true;
                this.inReverse = false;
                this.accumulator = 0;
                this.nextTick = 0;
                this.delayCounter = 0;
                this.repeatCounter = 0;
                this.pendingRepeat = false;
                this._paused = false;
                this._wasPlaying = false;
                this._pendingStop = 0;
                this._pendingStopValue;
              },
              chain: function(key) {
                var parent = this.parent;
                if (key === void 0) {
                  this.nextAnimsQueue.length = 0;
                  this.nextAnim = null;
                  return parent;
                }
                if (!Array.isArray(key)) {
                  key = [key];
                }
                for (var i = 0; i < key.length; i++) {
                  var anim = key[i];
                  if (!this.nextAnim) {
                    this.nextAnim = anim;
                  } else {
                    this.nextAnimsQueue.push(anim);
                  }
                }
                return this.parent;
              },
              getName: function() {
                return this.currentAnim ? this.currentAnim.key : "";
              },
              getFrameName: function() {
                return this.currentFrame ? this.currentFrame.textureFrame : "";
              },
              load: function(key) {
                if (this.isPlaying) {
                  this.stop();
                }
                var manager = this.animationManager;
                var animKey = typeof key === "string" ? key : GetFastValue(key, "key", null);
                var anim = this.exists(animKey) ? this.get(animKey) : manager.get(animKey);
                if (!anim) {
                  console.warn("Missing animation: " + animKey);
                } else {
                  this.currentAnim = anim;
                  var totalFrames = anim.getTotalFrames();
                  var frameRate = GetFastValue(key, "frameRate", anim.frameRate);
                  var duration = GetFastValue(key, "duration", anim.duration);
                  anim.calculateDuration(this, totalFrames, duration, frameRate);
                  this.delay = GetFastValue(key, "delay", anim.delay);
                  this.repeat = GetFastValue(key, "repeat", anim.repeat);
                  this.repeatDelay = GetFastValue(key, "repeatDelay", anim.repeatDelay);
                  this.yoyo = GetFastValue(key, "yoyo", anim.yoyo);
                  this.showBeforeDelay = GetFastValue(key, "showBeforeDelay", anim.showBeforeDelay);
                  this.showOnStart = GetFastValue(key, "showOnStart", anim.showOnStart);
                  this.hideOnComplete = GetFastValue(key, "hideOnComplete", anim.hideOnComplete);
                  this.skipMissedFrames = GetFastValue(key, "skipMissedFrames", anim.skipMissedFrames);
                  this.randomFrame = GetFastValue(key, "randomFrame", anim.randomFrame);
                  this.timeScale = GetFastValue(key, "timeScale", this.timeScale);
                  var startFrame = GetFastValue(key, "startFrame", 0);
                  if (startFrame > totalFrames) {
                    startFrame = 0;
                  }
                  if (this.randomFrame) {
                    startFrame = Between(0, totalFrames - 1);
                  }
                  var frame = anim.frames[startFrame];
                  if (startFrame === 0 && !this.forward) {
                    frame = anim.getLastFrame();
                  }
                  this.currentFrame = frame;
                }
                return this.parent;
              },
              pause: function(atFrame) {
                if (!this._paused) {
                  this._paused = true;
                  this._wasPlaying = this.isPlaying;
                  this.isPlaying = false;
                }
                if (atFrame !== void 0) {
                  this.setCurrentFrame(atFrame);
                }
                return this.parent;
              },
              resume: function(fromFrame) {
                if (this._paused) {
                  this._paused = false;
                  this.isPlaying = this._wasPlaying;
                }
                if (fromFrame !== void 0) {
                  this.setCurrentFrame(fromFrame);
                }
                return this.parent;
              },
              playAfterDelay: function(key, delay) {
                if (!this.isPlaying) {
                  this.delayCounter = delay;
                  this.play(key, true);
                } else {
                  var nextAnim = this.nextAnim;
                  var queue = this.nextAnimsQueue;
                  if (nextAnim) {
                    queue.unshift(nextAnim);
                  }
                  this.nextAnim = key;
                  this._pendingStop = 1;
                  this._pendingStopValue = delay;
                }
                return this.parent;
              },
              playAfterRepeat: function(key, repeatCount) {
                if (repeatCount === void 0) {
                  repeatCount = 1;
                }
                if (!this.isPlaying) {
                  this.play(key);
                } else {
                  var nextAnim = this.nextAnim;
                  var queue = this.nextAnimsQueue;
                  if (nextAnim) {
                    queue.unshift(nextAnim);
                  }
                  if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
                    repeatCount = this.repeatCounter;
                  }
                  this.nextAnim = key;
                  this._pendingStop = 2;
                  this._pendingStopValue = repeatCount;
                }
                return this.parent;
              },
              play: function(key, ignoreIfPlaying) {
                if (ignoreIfPlaying === void 0) {
                  ignoreIfPlaying = false;
                }
                var currentAnim = this.currentAnim;
                var parent = this.parent;
                var animKey = typeof key === "string" ? key : key.key;
                if (ignoreIfPlaying && this.isPlaying && currentAnim.key === animKey) {
                  return parent;
                }
                if (currentAnim && this.isPlaying) {
                  var mix = this.animationManager.getMix(currentAnim.key, key);
                  if (mix > 0) {
                    return this.playAfterDelay(key, mix);
                  }
                }
                this.forward = true;
                this.inReverse = false;
                this._paused = false;
                this._wasPlaying = true;
                return this.startAnimation(key);
              },
              playReverse: function(key, ignoreIfPlaying) {
                if (ignoreIfPlaying === void 0) {
                  ignoreIfPlaying = false;
                }
                var animKey = typeof key === "string" ? key : key.key;
                if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === animKey) {
                  return this.parent;
                }
                this.forward = false;
                this.inReverse = true;
                this._paused = false;
                this._wasPlaying = true;
                return this.startAnimation(key);
              },
              startAnimation: function(key) {
                this.load(key);
                var anim = this.currentAnim;
                var gameObject = this.parent;
                if (!anim) {
                  return gameObject;
                }
                this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
                anim.getFirstTick(this);
                this.isPlaying = true;
                this.pendingRepeat = false;
                this.hasStarted = false;
                this._pendingStop = 0;
                this._pendingStopValue = 0;
                this._paused = false;
                this.delayCounter += this.delay;
                if (this.delayCounter === 0) {
                  this.handleStart();
                } else if (this.showBeforeDelay) {
                  this.setCurrentFrame(this.currentFrame);
                }
                return gameObject;
              },
              handleStart: function() {
                if (this.showOnStart) {
                  this.parent.setVisible(true);
                }
                this.setCurrentFrame(this.currentFrame);
                this.hasStarted = true;
                this.emitEvents(Events.ANIMATION_START);
              },
              handleRepeat: function() {
                this.pendingRepeat = false;
                this.emitEvents(Events.ANIMATION_REPEAT);
              },
              handleStop: function() {
                this._pendingStop = 0;
                this.isPlaying = false;
                this.emitEvents(Events.ANIMATION_STOP);
              },
              handleComplete: function() {
                this._pendingStop = 0;
                this.isPlaying = false;
                if (this.hideOnComplete) {
                  this.parent.setVisible(false);
                }
                this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);
              },
              emitEvents: function(event, keyEvent) {
                var anim = this.currentAnim;
                if (anim) {
                  var frame = this.currentFrame;
                  var gameObject = this.parent;
                  var frameKey = frame.textureFrame;
                  gameObject.emit(event, anim, frame, gameObject, frameKey);
                  if (keyEvent) {
                    gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);
                  }
                }
              },
              reverse: function() {
                if (this.isPlaying) {
                  this.inReverse = !this.inReverse;
                  this.forward = !this.forward;
                }
                return this.parent;
              },
              getProgress: function() {
                var frame = this.currentFrame;
                if (!frame) {
                  return 0;
                }
                var p = frame.progress;
                if (this.inReverse) {
                  p *= -1;
                }
                return p;
              },
              setProgress: function(value) {
                if (!this.forward) {
                  value = 1 - value;
                }
                this.setCurrentFrame(this.currentAnim.getFrameByProgress(value));
                return this.parent;
              },
              setRepeat: function(value) {
                this.repeatCounter = value === -1 ? Number.MAX_VALUE : value;
                return this.parent;
              },
              globalRemove: function(key, animation) {
                if (animation === void 0) {
                  animation = this.currentAnim;
                }
                if (this.isPlaying && animation.key === this.currentAnim.key) {
                  this.stop();
                  this.setCurrentFrame(this.currentAnim.frames[0]);
                }
              },
              restart: function(includeDelay, resetRepeats) {
                if (includeDelay === void 0) {
                  includeDelay = false;
                }
                if (resetRepeats === void 0) {
                  resetRepeats = false;
                }
                var anim = this.currentAnim;
                var gameObject = this.parent;
                if (!anim) {
                  return gameObject;
                }
                if (resetRepeats) {
                  this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
                }
                anim.getFirstTick(this);
                this.emitEvents(Events.ANIMATION_RESTART);
                this.isPlaying = true;
                this.pendingRepeat = false;
                this.hasStarted = !includeDelay;
                this._pendingStop = 0;
                this._pendingStopValue = 0;
                this._paused = false;
                this.setCurrentFrame(anim.frames[0]);
                return this.parent;
              },
              complete: function() {
                this._pendingStop = 0;
                this.isPlaying = false;
                if (this.currentAnim) {
                  this.handleComplete();
                }
                if (this.nextAnim) {
                  var key = this.nextAnim;
                  this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null;
                  this.play(key);
                }
                return this.parent;
              },
              stop: function() {
                this._pendingStop = 0;
                this.isPlaying = false;
                this.delayCounter = 0;
                if (this.currentAnim) {
                  this.handleStop();
                }
                if (this.nextAnim) {
                  var key = this.nextAnim;
                  this.nextAnim = this.nextAnimsQueue.shift();
                  this.play(key);
                }
                return this.parent;
              },
              stopAfterDelay: function(delay) {
                this._pendingStop = 1;
                this._pendingStopValue = delay;
                return this.parent;
              },
              stopAfterRepeat: function(repeatCount) {
                if (repeatCount === void 0) {
                  repeatCount = 1;
                }
                if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
                  repeatCount = this.repeatCounter;
                }
                this._pendingStop = 2;
                this._pendingStopValue = repeatCount;
                return this.parent;
              },
              stopOnFrame: function(frame) {
                this._pendingStop = 3;
                this._pendingStopValue = frame;
                return this.parent;
              },
              getTotalFrames: function() {
                return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
              },
              update: function(time, delta) {
                var anim = this.currentAnim;
                if (!this.isPlaying || !anim || anim.paused) {
                  return;
                }
                this.accumulator += delta * this.timeScale * this.animationManager.globalTimeScale;
                if (this._pendingStop === 1) {
                  this._pendingStopValue -= delta;
                  if (this._pendingStopValue <= 0) {
                    return this.stop();
                  }
                }
                if (!this.hasStarted) {
                  if (this.accumulator >= this.delayCounter) {
                    this.accumulator -= this.delayCounter;
                    this.handleStart();
                  }
                } else if (this.accumulator >= this.nextTick) {
                  if (this.forward) {
                    anim.nextFrame(this);
                  } else {
                    anim.previousFrame(this);
                  }
                  if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick) {
                    var safetyNet = 0;
                    do {
                      if (this.forward) {
                        anim.nextFrame(this);
                      } else {
                        anim.previousFrame(this);
                      }
                      safetyNet++;
                    } while (this.isPlaying && this.accumulator > this.nextTick && safetyNet < 60);
                  }
                }
              },
              setCurrentFrame: function(animationFrame) {
                var gameObject = this.parent;
                this.currentFrame = animationFrame;
                gameObject.texture = animationFrame.frame.texture;
                gameObject.frame = animationFrame.frame;
                if (gameObject.isCropped) {
                  gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY);
                }
                if (animationFrame.setAlpha) {
                  gameObject.alpha = animationFrame.alpha;
                }
                gameObject.setSizeToFrame();
                if (gameObject._originComponent) {
                  if (animationFrame.frame.customPivot) {
                    gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY);
                  } else {
                    gameObject.updateDisplayOrigin();
                  }
                }
                if (this.isPlaying && this.hasStarted) {
                  this.emitEvents(Events.ANIMATION_UPDATE);
                  if (this._pendingStop === 3 && this._pendingStopValue === animationFrame) {
                    this.stop();
                  }
                }
                return gameObject;
              },
              nextFrame: function() {
                if (this.currentAnim) {
                  this.currentAnim.nextFrame(this);
                }
                return this.parent;
              },
              previousFrame: function() {
                if (this.currentAnim) {
                  this.currentAnim.previousFrame(this);
                }
                return this.parent;
              },
              get: function(key) {
                return this.anims ? this.anims.get(key) : null;
              },
              exists: function(key) {
                return this.anims ? this.anims.has(key) : false;
              },
              create: function(config2) {
                var key = config2.key;
                var anim = false;
                if (key) {
                  anim = this.get(key);
                  if (!anim) {
                    anim = new Animation(this, key, config2);
                    if (!this.anims) {
                      this.anims = new CustomMap();
                    }
                    this.anims.set(key, anim);
                  } else {
                    console.warn("Animation key already exists: " + key);
                  }
                }
                return anim;
              },
              createFromAseprite: function(key, tags) {
                return this.animationManager.createFromAseprite(key, tags, this.parent);
              },
              generateFrameNames: function(key, config2) {
                return this.animationManager.generateFrameNames(key, config2);
              },
              generateFrameNumbers: function(key, config2) {
                return this.animationManager.generateFrameNumbers(key, config2);
              },
              remove: function(key) {
                var anim = this.get(key);
                if (anim) {
                  if (this.currentAnim === anim) {
                    this.stop();
                  }
                  this.anims.delete(key);
                }
                return anim;
              },
              destroy: function() {
                this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this);
                if (this.anims) {
                  this.anims.clear();
                }
                this.animationManager = null;
                this.parent = null;
                this.nextAnim = null;
                this.nextAnimsQueue.length = 0;
                this.currentAnim = null;
                this.currentFrame = null;
              },
              isPaused: {
                get: function() {
                  return this._paused;
                }
              }
            });
            module2.exports = AnimationState;
          },
          44509: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "add";
          },
          84563: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "animationcomplete";
          },
          61586: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "animationcomplete-";
          },
          72175: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "animationrepeat";
          },
          568: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "animationrestart";
          },
          37690: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "animationstart";
          },
          58525: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "animationstop";
          },
          5243: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "animationupdate";
          },
          10598: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pauseall";
          },
          4860: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "remove";
          },
          31865: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resumeall";
          },
          16938: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ADD_ANIMATION: __webpack_require__2(44509),
              ANIMATION_COMPLETE: __webpack_require__2(84563),
              ANIMATION_COMPLETE_KEY: __webpack_require__2(61586),
              ANIMATION_REPEAT: __webpack_require__2(72175),
              ANIMATION_RESTART: __webpack_require__2(568),
              ANIMATION_START: __webpack_require__2(37690),
              ANIMATION_STOP: __webpack_require__2(58525),
              ANIMATION_UPDATE: __webpack_require__2(5243),
              PAUSE_ALL: __webpack_require__2(10598),
              REMOVE_ANIMATION: __webpack_require__2(4860),
              RESUME_ALL: __webpack_require__2(31865)
            };
          },
          13517: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Animation: __webpack_require__2(85463),
              AnimationFrame: __webpack_require__2(71519),
              AnimationManager: __webpack_require__2(90249),
              AnimationState: __webpack_require__2(16569),
              Events: __webpack_require__2(16938)
            };
          },
          23740: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CustomMap = __webpack_require__2(33885);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(69773);
            var BaseCache = new Class({
              initialize: function BaseCache2() {
                this.entries = new CustomMap();
                this.events = new EventEmitter();
              },
              add: function(key, data) {
                this.entries.set(key, data);
                this.events.emit(Events.ADD, this, key, data);
                return this;
              },
              has: function(key) {
                return this.entries.has(key);
              },
              exists: function(key) {
                return this.entries.has(key);
              },
              get: function(key) {
                return this.entries.get(key);
              },
              remove: function(key) {
                var entry = this.get(key);
                if (entry) {
                  this.entries.delete(key);
                  this.events.emit(Events.REMOVE, this, key, entry.data);
                }
                return this;
              },
              getKeys: function() {
                return this.entries.keys();
              },
              destroy: function() {
                this.entries.clear();
                this.events.removeAllListeners();
                this.entries = null;
                this.events = null;
              }
            });
            module2.exports = BaseCache;
          },
          43474: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseCache = __webpack_require__2(23740);
            var Class = __webpack_require__2(56694);
            var GameEvents = __webpack_require__2(97081);
            var CacheManager = new Class({
              initialize: function CacheManager2(game) {
                this.game = game;
                this.binary = new BaseCache();
                this.bitmapFont = new BaseCache();
                this.json = new BaseCache();
                this.physics = new BaseCache();
                this.shader = new BaseCache();
                this.audio = new BaseCache();
                this.video = new BaseCache();
                this.text = new BaseCache();
                this.html = new BaseCache();
                this.obj = new BaseCache();
                this.tilemap = new BaseCache();
                this.xml = new BaseCache();
                this.custom = {};
                this.game.events.once(GameEvents.DESTROY, this.destroy, this);
              },
              addCustom: function(key) {
                if (!this.custom.hasOwnProperty(key)) {
                  this.custom[key] = new BaseCache();
                }
                return this.custom[key];
              },
              destroy: function() {
                var keys = [
                  "binary",
                  "bitmapFont",
                  "json",
                  "physics",
                  "shader",
                  "audio",
                  "video",
                  "text",
                  "html",
                  "obj",
                  "tilemap",
                  "xml"
                ];
                for (var i = 0; i < keys.length; i++) {
                  this[keys[i]].destroy();
                  this[keys[i]] = null;
                }
                for (var key in this.custom) {
                  this.custom[key].destroy();
                }
                this.custom = null;
                this.game = null;
              }
            });
            module2.exports = CacheManager;
          },
          94762: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "add";
          },
          75968: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "remove";
          },
          69773: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ADD: __webpack_require__2(94762),
              REMOVE: __webpack_require__2(75968)
            };
          },
          45820: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BaseCache: __webpack_require__2(23740),
              CacheManager: __webpack_require__2(43474),
              Events: __webpack_require__2(69773)
            };
          },
          51052: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var DegToRad = __webpack_require__2(75606);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(89787);
            var Rectangle = __webpack_require__2(74118);
            var TransformMatrix = __webpack_require__2(69360);
            var ValueToColor = __webpack_require__2(93222);
            var Vector2 = __webpack_require__2(93736);
            var BaseCamera = new Class({
              Extends: EventEmitter,
              Mixins: [
                Components.AlphaSingle,
                Components.Visible
              ],
              initialize: function BaseCamera2(x, y, width, height) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = 0;
                }
                if (height === void 0) {
                  height = 0;
                }
                EventEmitter.call(this);
                this.scene;
                this.sceneManager;
                this.scaleManager;
                this.cameraManager;
                this.id = 0;
                this.name = "";
                this.roundPixels = false;
                this.useBounds = false;
                this.worldView = new Rectangle();
                this.dirty = true;
                this._x = x;
                this._y = y;
                this._width = width;
                this._height = height;
                this._bounds = new Rectangle();
                this._scrollX = 0;
                this._scrollY = 0;
                this._zoomX = 1;
                this._zoomY = 1;
                this._rotation = 0;
                this.matrix = new TransformMatrix();
                this.transparent = true;
                this.backgroundColor = ValueToColor("rgba(0,0,0,0)");
                this.disableCull = false;
                this.culledObjects = [];
                this.midPoint = new Vector2(width / 2, height / 2);
                this.originX = 0.5;
                this.originY = 0.5;
                this._customViewport = false;
                this.mask = null;
                this._maskCamera = null;
                this.renderList = [];
                this.isSceneCamera = true;
              },
              addToRenderList: function(child) {
                this.renderList.push(child);
              },
              setOrigin: function(x, y) {
                if (x === void 0) {
                  x = 0.5;
                }
                if (y === void 0) {
                  y = x;
                }
                this.originX = x;
                this.originY = y;
                return this;
              },
              getScroll: function(x, y, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                var originX = this.width * 0.5;
                var originY = this.height * 0.5;
                out.x = x - originX;
                out.y = y - originY;
                if (this.useBounds) {
                  out.x = this.clampX(out.x);
                  out.y = this.clampY(out.y);
                }
                return out;
              },
              centerOnX: function(x) {
                var originX = this.width * 0.5;
                this.midPoint.x = x;
                this.scrollX = x - originX;
                if (this.useBounds) {
                  this.scrollX = this.clampX(this.scrollX);
                }
                return this;
              },
              centerOnY: function(y) {
                var originY = this.height * 0.5;
                this.midPoint.y = y;
                this.scrollY = y - originY;
                if (this.useBounds) {
                  this.scrollY = this.clampY(this.scrollY);
                }
                return this;
              },
              centerOn: function(x, y) {
                this.centerOnX(x);
                this.centerOnY(y);
                return this;
              },
              centerToBounds: function() {
                if (this.useBounds) {
                  var bounds = this._bounds;
                  var originX = this.width * 0.5;
                  var originY = this.height * 0.5;
                  this.midPoint.set(bounds.centerX, bounds.centerY);
                  this.scrollX = bounds.centerX - originX;
                  this.scrollY = bounds.centerY - originY;
                }
                return this;
              },
              centerToSize: function() {
                this.scrollX = this.width * 0.5;
                this.scrollY = this.height * 0.5;
                return this;
              },
              cull: function(renderableObjects) {
                if (this.disableCull) {
                  return renderableObjects;
                }
                var cameraMatrix = this.matrix.matrix;
                var mva = cameraMatrix[0];
                var mvb = cameraMatrix[1];
                var mvc = cameraMatrix[2];
                var mvd = cameraMatrix[3];
                var determinant = mva * mvd - mvb * mvc;
                if (!determinant) {
                  return renderableObjects;
                }
                var mve = cameraMatrix[4];
                var mvf = cameraMatrix[5];
                var scrollX = this.scrollX;
                var scrollY = this.scrollY;
                var cameraW = this.width;
                var cameraH = this.height;
                var cullTop = this.y;
                var cullBottom = cullTop + cameraH;
                var cullLeft = this.x;
                var cullRight = cullLeft + cameraW;
                var culledObjects = this.culledObjects;
                var length = renderableObjects.length;
                determinant = 1 / determinant;
                culledObjects.length = 0;
                for (var index = 0; index < length; ++index) {
                  var object = renderableObjects[index];
                  if (!object.hasOwnProperty("width") || object.parentContainer) {
                    culledObjects.push(object);
                    continue;
                  }
                  var objectW = object.width;
                  var objectH = object.height;
                  var objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX;
                  var objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY;
                  var tx = objectX * mva + objectY * mvc + mve;
                  var ty = objectX * mvb + objectY * mvd + mvf;
                  var tw = (objectX + objectW) * mva + (objectY + objectH) * mvc + mve;
                  var th = (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf;
                  if (tw > cullLeft && tx < cullRight && (th > cullTop && ty < cullBottom)) {
                    culledObjects.push(object);
                  }
                }
                return culledObjects;
              },
              getWorldPoint: function(x, y, output) {
                if (output === void 0) {
                  output = new Vector2();
                }
                var cameraMatrix = this.matrix.matrix;
                var mva = cameraMatrix[0];
                var mvb = cameraMatrix[1];
                var mvc = cameraMatrix[2];
                var mvd = cameraMatrix[3];
                var mve = cameraMatrix[4];
                var mvf = cameraMatrix[5];
                var determinant = mva * mvd - mvb * mvc;
                if (!determinant) {
                  output.x = x;
                  output.y = y;
                  return output;
                }
                determinant = 1 / determinant;
                var ima = mvd * determinant;
                var imb = -mvb * determinant;
                var imc = -mvc * determinant;
                var imd = mva * determinant;
                var ime = (mvc * mvf - mvd * mve) * determinant;
                var imf = (mvb * mve - mva * mvf) * determinant;
                var c = Math.cos(this.rotation);
                var s = Math.sin(this.rotation);
                var zoomX = this.zoomX;
                var zoomY = this.zoomY;
                var scrollX = this.scrollX;
                var scrollY = this.scrollY;
                var sx = x + (scrollX * c - scrollY * s) * zoomX;
                var sy = y + (scrollX * s + scrollY * c) * zoomY;
                output.x = sx * ima + sy * imc + ime;
                output.y = sx * imb + sy * imd + imf;
                return output;
              },
              ignore: function(entries) {
                var id = this.id;
                if (!Array.isArray(entries)) {
                  entries = [entries];
                }
                for (var i = 0; i < entries.length; i++) {
                  var entry = entries[i];
                  if (Array.isArray(entry)) {
                    this.ignore(entry);
                  } else if (entry.isParent) {
                    this.ignore(entry.getChildren());
                  } else {
                    entry.cameraFilter |= id;
                  }
                }
                return this;
              },
              preRender: function() {
                this.renderList.length = 0;
                var width = this.width;
                var height = this.height;
                var halfWidth = width * 0.5;
                var halfHeight = height * 0.5;
                var zoomX = this.zoomX;
                var zoomY = this.zoomY;
                var matrix = this.matrix;
                var originX = width * this.originX;
                var originY = height * this.originY;
                var sx = this.scrollX;
                var sy = this.scrollY;
                if (this.useBounds) {
                  sx = this.clampX(sx);
                  sy = this.clampY(sy);
                }
                this.scrollX = sx;
                this.scrollY = sy;
                var midX = sx + halfWidth;
                var midY = sy + halfHeight;
                this.midPoint.set(midX, midY);
                var displayWidth = width / zoomX;
                var displayHeight = height / zoomY;
                this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight);
                matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoomX, zoomY);
                matrix.translate(-originX, -originY);
              },
              clampX: function(x) {
                var bounds = this._bounds;
                var dw = this.displayWidth;
                var bx = bounds.x + (dw - this.width) / 2;
                var bw = Math.max(bx, bx + bounds.width - dw);
                if (x < bx) {
                  x = bx;
                } else if (x > bw) {
                  x = bw;
                }
                return x;
              },
              clampY: function(y) {
                var bounds = this._bounds;
                var dh = this.displayHeight;
                var by = bounds.y + (dh - this.height) / 2;
                var bh = Math.max(by, by + bounds.height - dh);
                if (y < by) {
                  y = by;
                } else if (y > bh) {
                  y = bh;
                }
                return y;
              },
              removeBounds: function() {
                this.useBounds = false;
                this.dirty = true;
                this._bounds.setEmpty();
                return this;
              },
              setAngle: function(value) {
                if (value === void 0) {
                  value = 0;
                }
                this.rotation = DegToRad(value);
                return this;
              },
              setBackgroundColor: function(color) {
                if (color === void 0) {
                  color = "rgba(0,0,0,0)";
                }
                this.backgroundColor = ValueToColor(color);
                this.transparent = this.backgroundColor.alpha === 0;
                return this;
              },
              setBounds: function(x, y, width, height, centerOn) {
                if (centerOn === void 0) {
                  centerOn = false;
                }
                this._bounds.setTo(x, y, width, height);
                this.dirty = true;
                this.useBounds = true;
                if (centerOn) {
                  this.centerToBounds();
                } else {
                  this.scrollX = this.clampX(this.scrollX);
                  this.scrollY = this.clampY(this.scrollY);
                }
                return this;
              },
              getBounds: function(out) {
                if (out === void 0) {
                  out = new Rectangle();
                }
                var source = this._bounds;
                out.setTo(source.x, source.y, source.width, source.height);
                return out;
              },
              setName: function(value) {
                if (value === void 0) {
                  value = "";
                }
                this.name = value;
                return this;
              },
              setPosition: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.x = x;
                this.y = y;
                return this;
              },
              setRotation: function(value) {
                if (value === void 0) {
                  value = 0;
                }
                this.rotation = value;
                return this;
              },
              setRoundPixels: function(value) {
                this.roundPixels = value;
                return this;
              },
              setScene: function(scene, isSceneCamera) {
                if (isSceneCamera === void 0) {
                  isSceneCamera = true;
                }
                if (this.scene && this._customViewport) {
                  this.sceneManager.customViewports--;
                }
                this.scene = scene;
                this.isSceneCamera = isSceneCamera;
                var sys = scene.sys;
                this.sceneManager = sys.game.scene;
                this.scaleManager = sys.scale;
                this.cameraManager = sys.cameras;
                this.updateSystem();
                return this;
              },
              setScroll: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.scrollX = x;
                this.scrollY = y;
                return this;
              },
              setSize: function(width, height) {
                if (height === void 0) {
                  height = width;
                }
                this.width = width;
                this.height = height;
                return this;
              },
              setViewport: function(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                return this;
              },
              setZoom: function(x, y) {
                if (x === void 0) {
                  x = 1;
                }
                if (y === void 0) {
                  y = x;
                }
                if (x === 0) {
                  x = 1e-3;
                }
                if (y === 0) {
                  y = 1e-3;
                }
                this.zoomX = x;
                this.zoomY = y;
                return this;
              },
              setMask: function(mask, fixedPosition) {
                if (fixedPosition === void 0) {
                  fixedPosition = true;
                }
                this.mask = mask;
                this._maskCamera = fixedPosition ? this.cameraManager.default : this;
                return this;
              },
              clearMask: function(destroyMask) {
                if (destroyMask === void 0) {
                  destroyMask = false;
                }
                if (destroyMask && this.mask) {
                  this.mask.destroy();
                }
                this.mask = null;
                return this;
              },
              toJSON: function() {
                var output = {
                  name: this.name,
                  x: this.x,
                  y: this.y,
                  width: this.width,
                  height: this.height,
                  zoom: this.zoom,
                  rotation: this.rotation,
                  roundPixels: this.roundPixels,
                  scrollX: this.scrollX,
                  scrollY: this.scrollY,
                  backgroundColor: this.backgroundColor.rgba
                };
                if (this.useBounds) {
                  output["bounds"] = {
                    x: this._bounds.x,
                    y: this._bounds.y,
                    width: this._bounds.width,
                    height: this._bounds.height
                  };
                }
                return output;
              },
              update: function() {
              },
              setIsSceneCamera: function(value) {
                this.isSceneCamera = value;
                return this;
              },
              updateSystem: function() {
                if (!this.scaleManager || !this.isSceneCamera) {
                  return;
                }
                var custom = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height;
                var sceneManager = this.sceneManager;
                if (custom && !this._customViewport) {
                  sceneManager.customViewports++;
                } else if (!custom && this._customViewport) {
                  sceneManager.customViewports--;
                }
                this.dirty = true;
                this._customViewport = custom;
              },
              destroy: function() {
                this.emit(Events.DESTROY, this);
                this.removeAllListeners();
                this.matrix.destroy();
                this.culledObjects = [];
                if (this._customViewport) {
                  this.sceneManager.customViewports--;
                }
                this.renderList = [];
                this._bounds = null;
                this.scene = null;
                this.scaleManager = null;
                this.sceneManager = null;
                this.cameraManager = null;
              },
              x: {
                get: function() {
                  return this._x;
                },
                set: function(value) {
                  this._x = value;
                  this.updateSystem();
                }
              },
              y: {
                get: function() {
                  return this._y;
                },
                set: function(value) {
                  this._y = value;
                  this.updateSystem();
                }
              },
              width: {
                get: function() {
                  return this._width;
                },
                set: function(value) {
                  this._width = value;
                  this.updateSystem();
                }
              },
              height: {
                get: function() {
                  return this._height;
                },
                set: function(value) {
                  this._height = value;
                  this.updateSystem();
                }
              },
              scrollX: {
                get: function() {
                  return this._scrollX;
                },
                set: function(value) {
                  if (value !== this._scrollX) {
                    this._scrollX = value;
                    this.dirty = true;
                  }
                }
              },
              scrollY: {
                get: function() {
                  return this._scrollY;
                },
                set: function(value) {
                  if (value !== this._scrollY) {
                    this._scrollY = value;
                    this.dirty = true;
                  }
                }
              },
              zoom: {
                get: function() {
                  return (this._zoomX + this._zoomY) / 2;
                },
                set: function(value) {
                  this._zoomX = value;
                  this._zoomY = value;
                  this.dirty = true;
                }
              },
              zoomX: {
                get: function() {
                  return this._zoomX;
                },
                set: function(value) {
                  this._zoomX = value;
                  this.dirty = true;
                }
              },
              zoomY: {
                get: function() {
                  return this._zoomY;
                },
                set: function(value) {
                  this._zoomY = value;
                  this.dirty = true;
                }
              },
              rotation: {
                get: function() {
                  return this._rotation;
                },
                set: function(value) {
                  this._rotation = value;
                  this.dirty = true;
                }
              },
              centerX: {
                get: function() {
                  return this.x + 0.5 * this.width;
                }
              },
              centerY: {
                get: function() {
                  return this.y + 0.5 * this.height;
                }
              },
              displayWidth: {
                get: function() {
                  return this.width / this.zoomX;
                }
              },
              displayHeight: {
                get: function() {
                  return this.height / this.zoomY;
                }
              }
            });
            module2.exports = BaseCamera;
          },
          47751: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseCamera = __webpack_require__2(51052);
            var CenterOn = __webpack_require__2(79993);
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var Effects = __webpack_require__2(53030);
            var Events = __webpack_require__2(89787);
            var Linear = __webpack_require__2(42798);
            var Rectangle = __webpack_require__2(74118);
            var Vector2 = __webpack_require__2(93736);
            var Camera = new Class({
              Extends: BaseCamera,
              Mixins: [
                Components.PostPipeline
              ],
              initialize: function Camera2(x, y, width, height) {
                BaseCamera.call(this, x, y, width, height);
                this.initPostPipeline();
                this.inputEnabled = true;
                this.fadeEffect = new Effects.Fade(this);
                this.flashEffect = new Effects.Flash(this);
                this.shakeEffect = new Effects.Shake(this);
                this.panEffect = new Effects.Pan(this);
                this.rotateToEffect = new Effects.RotateTo(this);
                this.zoomEffect = new Effects.Zoom(this);
                this.lerp = new Vector2(1, 1);
                this.followOffset = new Vector2();
                this.deadzone = null;
                this._follow = null;
              },
              setDeadzone: function(width, height) {
                if (width === void 0) {
                  this.deadzone = null;
                } else {
                  if (this.deadzone) {
                    this.deadzone.width = width;
                    this.deadzone.height = height;
                  } else {
                    this.deadzone = new Rectangle(0, 0, width, height);
                  }
                  if (this._follow) {
                    var originX = this.width / 2;
                    var originY = this.height / 2;
                    var fx = this._follow.x - this.followOffset.x;
                    var fy = this._follow.y - this.followOffset.y;
                    this.midPoint.set(fx, fy);
                    this.scrollX = fx - originX;
                    this.scrollY = fy - originY;
                  }
                  CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y);
                }
                return this;
              },
              fadeIn: function(duration, red, green, blue, callback, context) {
                return this.fadeEffect.start(false, duration, red, green, blue, true, callback, context);
              },
              fadeOut: function(duration, red, green, blue, callback, context) {
                return this.fadeEffect.start(true, duration, red, green, blue, true, callback, context);
              },
              fadeFrom: function(duration, red, green, blue, force, callback, context) {
                return this.fadeEffect.start(false, duration, red, green, blue, force, callback, context);
              },
              fade: function(duration, red, green, blue, force, callback, context) {
                return this.fadeEffect.start(true, duration, red, green, blue, force, callback, context);
              },
              flash: function(duration, red, green, blue, force, callback, context) {
                return this.flashEffect.start(duration, red, green, blue, force, callback, context);
              },
              shake: function(duration, intensity, force, callback, context) {
                return this.shakeEffect.start(duration, intensity, force, callback, context);
              },
              pan: function(x, y, duration, ease, force, callback, context) {
                return this.panEffect.start(x, y, duration, ease, force, callback, context);
              },
              rotateTo: function(radians, shortestPath, duration, ease, force, callback, context) {
                return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);
              },
              zoomTo: function(zoom, duration, ease, force, callback, context) {
                return this.zoomEffect.start(zoom, duration, ease, force, callback, context);
              },
              preRender: function() {
                this.renderList.length = 0;
                var width = this.width;
                var height = this.height;
                var halfWidth = width * 0.5;
                var halfHeight = height * 0.5;
                var zoom = this.zoom;
                var matrix = this.matrix;
                var originX = width * this.originX;
                var originY = height * this.originY;
                var follow = this._follow;
                var deadzone = this.deadzone;
                var sx = this.scrollX;
                var sy = this.scrollY;
                if (deadzone) {
                  CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
                }
                var emitFollowEvent = false;
                if (follow && !this.panEffect.isRunning) {
                  var lerp = this.lerp;
                  var fx = follow.x - this.followOffset.x;
                  var fy = follow.y - this.followOffset.y;
                  if (deadzone) {
                    if (fx < deadzone.x) {
                      sx = Linear(sx, sx - (deadzone.x - fx), lerp.x);
                    } else if (fx > deadzone.right) {
                      sx = Linear(sx, sx + (fx - deadzone.right), lerp.x);
                    }
                    if (fy < deadzone.y) {
                      sy = Linear(sy, sy - (deadzone.y - fy), lerp.y);
                    } else if (fy > deadzone.bottom) {
                      sy = Linear(sy, sy + (fy - deadzone.bottom), lerp.y);
                    }
                  } else {
                    sx = Linear(sx, fx - originX, lerp.x);
                    sy = Linear(sy, fy - originY, lerp.y);
                  }
                  emitFollowEvent = true;
                }
                if (this.useBounds) {
                  sx = this.clampX(sx);
                  sy = this.clampY(sy);
                }
                this.scrollX = sx;
                this.scrollY = sy;
                var midX = sx + halfWidth;
                var midY = sy + halfHeight;
                this.midPoint.set(midX, midY);
                var displayWidth = width / zoom;
                var displayHeight = height / zoom;
                var vwx = Math.floor(midX - displayWidth / 2);
                var vwy = Math.floor(midY - displayHeight / 2);
                this.worldView.setTo(vwx, vwy, displayWidth, displayHeight);
                matrix.applyITRS(Math.floor(this.x + originX), Math.floor(this.y + originY), this.rotation, zoom, zoom);
                matrix.translate(-originX, -originY);
                this.shakeEffect.preRender();
                if (emitFollowEvent) {
                  this.emit(Events.FOLLOW_UPDATE, this, follow);
                }
              },
              setLerp: function(x, y) {
                if (x === void 0) {
                  x = 1;
                }
                if (y === void 0) {
                  y = x;
                }
                this.lerp.set(x, y);
                return this;
              },
              setFollowOffset: function(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                this.followOffset.set(x, y);
                return this;
              },
              startFollow: function(target, roundPixels, lerpX, lerpY, offsetX, offsetY) {
                if (roundPixels === void 0) {
                  roundPixels = false;
                }
                if (lerpX === void 0) {
                  lerpX = 1;
                }
                if (lerpY === void 0) {
                  lerpY = lerpX;
                }
                if (offsetX === void 0) {
                  offsetX = 0;
                }
                if (offsetY === void 0) {
                  offsetY = offsetX;
                }
                this._follow = target;
                this.roundPixels = roundPixels;
                lerpX = Clamp(lerpX, 0, 1);
                lerpY = Clamp(lerpY, 0, 1);
                this.lerp.set(lerpX, lerpY);
                this.followOffset.set(offsetX, offsetY);
                var originX = this.width / 2;
                var originY = this.height / 2;
                var fx = target.x - offsetX;
                var fy = target.y - offsetY;
                this.midPoint.set(fx, fy);
                this.scrollX = fx - originX;
                this.scrollY = fy - originY;
                if (this.useBounds) {
                  this.scrollX = this.clampX(this.scrollX);
                  this.scrollY = this.clampY(this.scrollY);
                }
                return this;
              },
              stopFollow: function() {
                this._follow = null;
                return this;
              },
              resetFX: function() {
                this.rotateToEffect.reset();
                this.panEffect.reset();
                this.shakeEffect.reset();
                this.flashEffect.reset();
                this.fadeEffect.reset();
                return this;
              },
              update: function(time, delta) {
                if (this.visible) {
                  this.rotateToEffect.update(time, delta);
                  this.panEffect.update(time, delta);
                  this.zoomEffect.update(time, delta);
                  this.shakeEffect.update(time, delta);
                  this.flashEffect.update(time, delta);
                  this.fadeEffect.update(time, delta);
                }
              },
              destroy: function() {
                this.resetFX();
                BaseCamera.prototype.destroy.call(this);
                this._follow = null;
                this.deadzone = null;
              }
            });
            module2.exports = Camera;
          },
          62382: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Camera = __webpack_require__2(47751);
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var PluginCache = __webpack_require__2(91963);
            var RectangleContains = __webpack_require__2(94287);
            var ScaleEvents = __webpack_require__2(40444);
            var SceneEvents = __webpack_require__2(7599);
            var CameraManager = new Class({
              initialize: function CameraManager2(scene) {
                this.scene = scene;
                this.systems = scene.sys;
                this.roundPixels = scene.sys.game.config.roundPixels;
                this.cameras = [];
                this.main;
                this.default;
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                scene.sys.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                var sys = this.systems;
                if (sys.settings.cameras) {
                  this.fromJSON(sys.settings.cameras);
                } else {
                  this.add();
                }
                this.main = this.cameras[0];
                this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene);
                sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
                this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                if (!this.main) {
                  var sys = this.systems;
                  if (sys.settings.cameras) {
                    this.fromJSON(sys.settings.cameras);
                  } else {
                    this.add();
                  }
                  this.main = this.cameras[0];
                }
                var eventEmitter = this.systems.events;
                eventEmitter.on(SceneEvents.UPDATE, this.update, this);
                eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              add: function(x, y, width, height, makeMain, name) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = this.scene.sys.scale.width;
                }
                if (height === void 0) {
                  height = this.scene.sys.scale.height;
                }
                if (makeMain === void 0) {
                  makeMain = false;
                }
                if (name === void 0) {
                  name = "";
                }
                var camera = new Camera(x, y, width, height);
                camera.setName(name);
                camera.setScene(this.scene);
                camera.setRoundPixels(this.roundPixels);
                camera.id = this.getNextID();
                this.cameras.push(camera);
                if (makeMain) {
                  this.main = camera;
                }
                return camera;
              },
              addExisting: function(camera, makeMain) {
                if (makeMain === void 0) {
                  makeMain = false;
                }
                var index = this.cameras.indexOf(camera);
                if (index === -1) {
                  camera.id = this.getNextID();
                  camera.setRoundPixels(this.roundPixels);
                  this.cameras.push(camera);
                  if (makeMain) {
                    this.main = camera;
                  }
                  return camera;
                }
                return null;
              },
              getNextID: function() {
                var cameras = this.cameras;
                var testID = 1;
                for (var t = 0; t < 32; t++) {
                  var found = false;
                  for (var i = 0; i < cameras.length; i++) {
                    var camera = cameras[i];
                    if (camera && camera.id === testID) {
                      found = true;
                      continue;
                    }
                  }
                  if (found) {
                    testID = testID << 1;
                  } else {
                    return testID;
                  }
                }
                return 0;
              },
              getTotal: function(isVisible) {
                if (isVisible === void 0) {
                  isVisible = false;
                }
                var total = 0;
                var cameras = this.cameras;
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (!isVisible || isVisible && camera.visible) {
                    total++;
                  }
                }
                return total;
              },
              fromJSON: function(config2) {
                if (!Array.isArray(config2)) {
                  config2 = [config2];
                }
                var gameWidth = this.scene.sys.scale.width;
                var gameHeight = this.scene.sys.scale.height;
                for (var i = 0; i < config2.length; i++) {
                  var cameraConfig = config2[i];
                  var x = GetFastValue(cameraConfig, "x", 0);
                  var y = GetFastValue(cameraConfig, "y", 0);
                  var width = GetFastValue(cameraConfig, "width", gameWidth);
                  var height = GetFastValue(cameraConfig, "height", gameHeight);
                  var camera = this.add(x, y, width, height);
                  camera.name = GetFastValue(cameraConfig, "name", "");
                  camera.zoom = GetFastValue(cameraConfig, "zoom", 1);
                  camera.rotation = GetFastValue(cameraConfig, "rotation", 0);
                  camera.scrollX = GetFastValue(cameraConfig, "scrollX", 0);
                  camera.scrollY = GetFastValue(cameraConfig, "scrollY", 0);
                  camera.roundPixels = GetFastValue(cameraConfig, "roundPixels", false);
                  camera.visible = GetFastValue(cameraConfig, "visible", true);
                  var backgroundColor = GetFastValue(cameraConfig, "backgroundColor", false);
                  if (backgroundColor) {
                    camera.setBackgroundColor(backgroundColor);
                  }
                  var boundsConfig = GetFastValue(cameraConfig, "bounds", null);
                  if (boundsConfig) {
                    var bx = GetFastValue(boundsConfig, "x", 0);
                    var by = GetFastValue(boundsConfig, "y", 0);
                    var bwidth = GetFastValue(boundsConfig, "width", gameWidth);
                    var bheight = GetFastValue(boundsConfig, "height", gameHeight);
                    camera.setBounds(bx, by, bwidth, bheight);
                  }
                }
                return this;
              },
              getCamera: function(name) {
                var cameras = this.cameras;
                for (var i = 0; i < cameras.length; i++) {
                  if (cameras[i].name === name) {
                    return cameras[i];
                  }
                }
                return null;
              },
              getCamerasBelowPointer: function(pointer) {
                var cameras = this.cameras;
                var x = pointer.x;
                var y = pointer.y;
                var output = [];
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (camera.visible && camera.inputEnabled && RectangleContains(camera, x, y)) {
                    output.unshift(camera);
                  }
                }
                return output;
              },
              remove: function(camera, runDestroy) {
                if (runDestroy === void 0) {
                  runDestroy = true;
                }
                if (!Array.isArray(camera)) {
                  camera = [camera];
                }
                var total = 0;
                var cameras = this.cameras;
                for (var i = 0; i < camera.length; i++) {
                  var index = cameras.indexOf(camera[i]);
                  if (index !== -1) {
                    if (runDestroy) {
                      cameras[index].destroy();
                    } else {
                      cameras[index].renderList = [];
                    }
                    cameras.splice(index, 1);
                    total++;
                  }
                }
                if (!this.main && cameras[0]) {
                  this.main = cameras[0];
                }
                return total;
              },
              render: function(renderer, displayList) {
                var scene = this.scene;
                var cameras = this.cameras;
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (camera.visible && camera.alpha > 0) {
                    camera.preRender();
                    var visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera);
                    renderer.render(scene, visibleChildren, camera);
                  }
                }
              },
              getVisibleChildren: function(children, camera) {
                return children.filter(function(child) {
                  return child.willRender(camera);
                });
              },
              resetAll: function() {
                for (var i = 0; i < this.cameras.length; i++) {
                  this.cameras[i].destroy();
                }
                this.cameras = [];
                this.main = this.add();
                return this.main;
              },
              update: function(time, delta) {
                for (var i = 0; i < this.cameras.length; i++) {
                  this.cameras[i].update(time, delta);
                }
              },
              onResize: function(gameSize, baseSize, displaySize, previousWidth, previousHeight) {
                for (var i = 0; i < this.cameras.length; i++) {
                  var cam = this.cameras[i];
                  if (cam._x === 0 && cam._y === 0 && cam._width === previousWidth && cam._height === previousHeight) {
                    cam.setSize(baseSize.width, baseSize.height);
                  }
                }
              },
              resize: function(width, height) {
                for (var i = 0; i < this.cameras.length; i++) {
                  this.cameras[i].setSize(width, height);
                }
              },
              shutdown: function() {
                this.main = void 0;
                for (var i = 0; i < this.cameras.length; i++) {
                  this.cameras[i].destroy();
                }
                this.cameras = [];
                var eventEmitter = this.systems.events;
                eventEmitter.off(SceneEvents.UPDATE, this.update, this);
                eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                this.shutdown();
                this.default.destroy();
                this.systems.events.off(SceneEvents.START, this.start, this);
                this.systems.events.off(SceneEvents.DESTROY, this.destroy, this);
                this.systems.game.scale.off(ScaleEvents.RESIZE, this.onResize, this);
                this.scene = null;
                this.systems = null;
              }
            });
            PluginCache.register("CameraManager", CameraManager, "cameras");
            module2.exports = CameraManager;
          },
          92522: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(89787);
            var Fade = new Class({
              initialize: function Fade2(camera) {
                this.camera = camera;
                this.isRunning = false;
                this.isComplete = false;
                this.direction = true;
                this.duration = 0;
                this.red = 0;
                this.green = 0;
                this.blue = 0;
                this.alpha = 0;
                this.progress = 0;
                this._elapsed = 0;
                this._onUpdate;
                this._onUpdateScope;
              },
              start: function(direction, duration, red, green, blue, force, callback, context) {
                if (direction === void 0) {
                  direction = true;
                }
                if (duration === void 0) {
                  duration = 1e3;
                }
                if (red === void 0) {
                  red = 0;
                }
                if (green === void 0) {
                  green = 0;
                }
                if (blue === void 0) {
                  blue = 0;
                }
                if (force === void 0) {
                  force = false;
                }
                if (callback === void 0) {
                  callback = null;
                }
                if (context === void 0) {
                  context = this.camera.scene;
                }
                if (!force && this.isRunning) {
                  return this.camera;
                }
                this.isRunning = true;
                this.isComplete = false;
                this.duration = duration;
                this.direction = direction;
                this.progress = 0;
                this.red = red;
                this.green = green;
                this.blue = blue;
                this.alpha = direction ? Number.MIN_VALUE : 1;
                this._elapsed = 0;
                this._onUpdate = callback;
                this._onUpdateScope = context;
                var eventName = direction ? Events.FADE_OUT_START : Events.FADE_IN_START;
                this.camera.emit(eventName, this.camera, this, duration, red, green, blue);
                return this.camera;
              },
              update: function(time, delta) {
                if (!this.isRunning) {
                  return;
                }
                this._elapsed += delta;
                this.progress = Clamp(this._elapsed / this.duration, 0, 1);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
                }
                if (this._elapsed < this.duration) {
                  this.alpha = this.direction ? this.progress : 1 - this.progress;
                } else {
                  this.alpha = this.direction ? 1 : 0;
                  this.effectComplete();
                }
              },
              postRenderCanvas: function(ctx) {
                if (!this.isRunning && !this.isComplete) {
                  return false;
                }
                var camera = this.camera;
                ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
                ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
                return true;
              },
              postRenderWebGL: function(pipeline, getTintFunction) {
                if (!this.isRunning && !this.isComplete) {
                  return false;
                }
                var camera = this.camera;
                var red = this.red / 255;
                var green = this.green / 255;
                var blue = this.blue / 255;
                pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
                return true;
              },
              effectComplete: function() {
                this._onUpdate = null;
                this._onUpdateScope = null;
                this.isRunning = false;
                this.isComplete = true;
                var eventName = this.direction ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;
                this.camera.emit(eventName, this.camera, this);
              },
              reset: function() {
                this.isRunning = false;
                this.isComplete = false;
                this._onUpdate = null;
                this._onUpdateScope = null;
              },
              destroy: function() {
                this.reset();
                this.camera = null;
              }
            });
            module2.exports = Fade;
          },
          22151: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(89787);
            var Flash = new Class({
              initialize: function Flash2(camera) {
                this.camera = camera;
                this.isRunning = false;
                this.duration = 0;
                this.red = 0;
                this.green = 0;
                this.blue = 0;
                this.alpha = 1;
                this.progress = 0;
                this._elapsed = 0;
                this._alpha;
                this._onUpdate;
                this._onUpdateScope;
              },
              start: function(duration, red, green, blue, force, callback, context) {
                if (duration === void 0) {
                  duration = 250;
                }
                if (red === void 0) {
                  red = 255;
                }
                if (green === void 0) {
                  green = 255;
                }
                if (blue === void 0) {
                  blue = 255;
                }
                if (force === void 0) {
                  force = false;
                }
                if (callback === void 0) {
                  callback = null;
                }
                if (context === void 0) {
                  context = this.camera.scene;
                }
                if (!force && this.isRunning) {
                  return this.camera;
                }
                this.isRunning = true;
                this.duration = duration;
                this.progress = 0;
                this.red = red;
                this.green = green;
                this.blue = blue;
                this._alpha = this.alpha;
                this._elapsed = 0;
                this._onUpdate = callback;
                this._onUpdateScope = context;
                this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue);
                return this.camera;
              },
              update: function(time, delta) {
                if (!this.isRunning) {
                  return;
                }
                this._elapsed += delta;
                this.progress = Clamp(this._elapsed / this.duration, 0, 1);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
                }
                if (this._elapsed < this.duration) {
                  this.alpha = this._alpha * (1 - this.progress);
                } else {
                  this.effectComplete();
                }
              },
              postRenderCanvas: function(ctx) {
                if (!this.isRunning) {
                  return false;
                }
                var camera = this.camera;
                ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
                ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
                return true;
              },
              postRenderWebGL: function(pipeline, getTintFunction) {
                if (!this.isRunning) {
                  return false;
                }
                var camera = this.camera;
                var red = this.red / 255;
                var green = this.green / 255;
                var blue = this.blue / 255;
                pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
                return true;
              },
              effectComplete: function() {
                this.alpha = this._alpha;
                this._onUpdate = null;
                this._onUpdateScope = null;
                this.isRunning = false;
                this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);
              },
              reset: function() {
                this.isRunning = false;
                this._onUpdate = null;
                this._onUpdateScope = null;
              },
              destroy: function() {
                this.reset();
                this.camera = null;
              }
            });
            module2.exports = Flash;
          },
          37551: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var EaseMap = __webpack_require__2(35060);
            var Events = __webpack_require__2(89787);
            var Vector2 = __webpack_require__2(93736);
            var Pan = new Class({
              initialize: function Pan2(camera) {
                this.camera = camera;
                this.isRunning = false;
                this.duration = 0;
                this.source = new Vector2();
                this.current = new Vector2();
                this.destination = new Vector2();
                this.ease;
                this.progress = 0;
                this._elapsed = 0;
                this._onUpdate;
                this._onUpdateScope;
              },
              start: function(x, y, duration, ease, force, callback, context) {
                if (duration === void 0) {
                  duration = 1e3;
                }
                if (ease === void 0) {
                  ease = EaseMap.Linear;
                }
                if (force === void 0) {
                  force = false;
                }
                if (callback === void 0) {
                  callback = null;
                }
                if (context === void 0) {
                  context = this.camera.scene;
                }
                var cam = this.camera;
                if (!force && this.isRunning) {
                  return cam;
                }
                this.isRunning = true;
                this.duration = duration;
                this.progress = 0;
                this.source.set(cam.scrollX, cam.scrollY);
                this.destination.set(x, y);
                cam.getScroll(x, y, this.current);
                if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                  this.ease = EaseMap[ease];
                } else if (typeof ease === "function") {
                  this.ease = ease;
                }
                this._elapsed = 0;
                this._onUpdate = callback;
                this._onUpdateScope = context;
                this.camera.emit(Events.PAN_START, this.camera, this, duration, x, y);
                return cam;
              },
              update: function(time, delta) {
                if (!this.isRunning) {
                  return;
                }
                this._elapsed += delta;
                var progress = Clamp(this._elapsed / this.duration, 0, 1);
                this.progress = progress;
                var cam = this.camera;
                if (this._elapsed < this.duration) {
                  var v = this.ease(progress);
                  cam.getScroll(this.destination.x, this.destination.y, this.current);
                  var x = this.source.x + (this.current.x - this.source.x) * v;
                  var y = this.source.y + (this.current.y - this.source.y) * v;
                  cam.setScroll(x, y);
                  if (this._onUpdate) {
                    this._onUpdate.call(this._onUpdateScope, cam, progress, x, y);
                  }
                } else {
                  cam.centerOn(this.destination.x, this.destination.y);
                  if (this._onUpdate) {
                    this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);
                  }
                  this.effectComplete();
                }
              },
              effectComplete: function() {
                this._onUpdate = null;
                this._onUpdateScope = null;
                this.isRunning = false;
                this.camera.emit(Events.PAN_COMPLETE, this.camera, this);
              },
              reset: function() {
                this.isRunning = false;
                this._onUpdate = null;
                this._onUpdateScope = null;
              },
              destroy: function() {
                this.reset();
                this.camera = null;
                this.source = null;
                this.destination = null;
              }
            });
            module2.exports = Pan;
          },
          1771: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Jason Nicholls <nicholls.jason@gmail.com>
             * @copyright    2018 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(89787);
            var EaseMap = __webpack_require__2(35060);
            var RotateTo = new Class({
              initialize: function RotateTo2(camera) {
                this.camera = camera;
                this.isRunning = false;
                this.duration = 0;
                this.source = 0;
                this.current = 0;
                this.destination = 0;
                this.ease;
                this.progress = 0;
                this._elapsed = 0;
                this._onUpdate;
                this._onUpdateScope;
                this.clockwise = true;
                this.shortestPath = false;
              },
              start: function(radians, shortestPath, duration, ease, force, callback, context) {
                if (duration === void 0) {
                  duration = 1e3;
                }
                if (ease === void 0) {
                  ease = EaseMap.Linear;
                }
                if (force === void 0) {
                  force = false;
                }
                if (callback === void 0) {
                  callback = null;
                }
                if (context === void 0) {
                  context = this.camera.scene;
                }
                if (shortestPath === void 0) {
                  shortestPath = false;
                }
                this.shortestPath = shortestPath;
                var tmpDestination = radians;
                if (radians < 0) {
                  tmpDestination = -1 * radians;
                  this.clockwise = false;
                } else {
                  this.clockwise = true;
                }
                var maxRad = 360 * Math.PI / 180;
                tmpDestination = tmpDestination - Math.floor(tmpDestination / maxRad) * maxRad;
                var cam = this.camera;
                if (!force && this.isRunning) {
                  return cam;
                }
                this.isRunning = true;
                this.duration = duration;
                this.progress = 0;
                this.source = cam.rotation;
                this.destination = tmpDestination;
                if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                  this.ease = EaseMap[ease];
                } else if (typeof ease === "function") {
                  this.ease = ease;
                }
                this._elapsed = 0;
                this._onUpdate = callback;
                this._onUpdateScope = context;
                if (this.shortestPath) {
                  var cwDist = 0;
                  var acwDist = 0;
                  if (this.destination > this.source) {
                    cwDist = Math.abs(this.destination - this.source);
                  } else {
                    cwDist = Math.abs(this.destination + maxRad) - this.source;
                  }
                  if (this.source > this.destination) {
                    acwDist = Math.abs(this.source - this.destination);
                  } else {
                    acwDist = Math.abs(this.source + maxRad) - this.destination;
                  }
                  if (cwDist < acwDist) {
                    this.clockwise = true;
                  } else if (cwDist > acwDist) {
                    this.clockwise = false;
                  }
                }
                this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination);
                return cam;
              },
              update: function(time, delta) {
                if (!this.isRunning) {
                  return;
                }
                this._elapsed += delta;
                var progress = Clamp(this._elapsed / this.duration, 0, 1);
                this.progress = progress;
                var cam = this.camera;
                if (this._elapsed < this.duration) {
                  var v = this.ease(progress);
                  this.current = cam.rotation;
                  var distance = 0;
                  var maxRad = 360 * Math.PI / 180;
                  var target = this.destination;
                  var current = this.current;
                  if (this.clockwise === false) {
                    target = this.current;
                    current = this.destination;
                  }
                  if (target >= current) {
                    distance = Math.abs(target - current);
                  } else {
                    distance = Math.abs(target + maxRad) - current;
                  }
                  var r = 0;
                  if (this.clockwise) {
                    r = cam.rotation + distance * v;
                  } else {
                    r = cam.rotation - distance * v;
                  }
                  cam.rotation = r;
                  if (this._onUpdate) {
                    this._onUpdate.call(this._onUpdateScope, cam, progress, r);
                  }
                } else {
                  cam.rotation = this.destination;
                  if (this._onUpdate) {
                    this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination);
                  }
                  this.effectComplete();
                }
              },
              effectComplete: function() {
                this._onUpdate = null;
                this._onUpdateScope = null;
                this.isRunning = false;
                this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);
              },
              reset: function() {
                this.isRunning = false;
                this._onUpdate = null;
                this._onUpdateScope = null;
              },
              destroy: function() {
                this.reset();
                this.camera = null;
                this.source = null;
                this.destination = null;
              }
            });
            module2.exports = RotateTo;
          },
          3241: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(89787);
            var Vector2 = __webpack_require__2(93736);
            var Shake = new Class({
              initialize: function Shake2(camera) {
                this.camera = camera;
                this.isRunning = false;
                this.duration = 0;
                this.intensity = new Vector2();
                this.progress = 0;
                this._elapsed = 0;
                this._offsetX = 0;
                this._offsetY = 0;
                this._onUpdate;
                this._onUpdateScope;
              },
              start: function(duration, intensity, force, callback, context) {
                if (duration === void 0) {
                  duration = 100;
                }
                if (intensity === void 0) {
                  intensity = 0.05;
                }
                if (force === void 0) {
                  force = false;
                }
                if (callback === void 0) {
                  callback = null;
                }
                if (context === void 0) {
                  context = this.camera.scene;
                }
                if (!force && this.isRunning) {
                  return this.camera;
                }
                this.isRunning = true;
                this.duration = duration;
                this.progress = 0;
                if (typeof intensity === "number") {
                  this.intensity.set(intensity);
                } else {
                  this.intensity.set(intensity.x, intensity.y);
                }
                this._elapsed = 0;
                this._offsetX = 0;
                this._offsetY = 0;
                this._onUpdate = callback;
                this._onUpdateScope = context;
                this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity);
                return this.camera;
              },
              preRender: function() {
                if (this.isRunning) {
                  this.camera.matrix.translate(this._offsetX, this._offsetY);
                }
              },
              update: function(time, delta) {
                if (!this.isRunning) {
                  return;
                }
                this._elapsed += delta;
                this.progress = Clamp(this._elapsed / this.duration, 0, 1);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
                }
                if (this._elapsed < this.duration) {
                  var intensity = this.intensity;
                  var width = this.camera.width;
                  var height = this.camera.height;
                  var zoom = this.camera.zoom;
                  this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom;
                  this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom;
                  if (this.camera.roundPixels) {
                    this._offsetX = Math.round(this._offsetX);
                    this._offsetY = Math.round(this._offsetY);
                  }
                } else {
                  this.effectComplete();
                }
              },
              effectComplete: function() {
                this._offsetX = 0;
                this._offsetY = 0;
                this._onUpdate = null;
                this._onUpdateScope = null;
                this.isRunning = false;
                this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);
              },
              reset: function() {
                this.isRunning = false;
                this._offsetX = 0;
                this._offsetY = 0;
                this._onUpdate = null;
                this._onUpdateScope = null;
              },
              destroy: function() {
                this.reset();
                this.camera = null;
                this.intensity = null;
              }
            });
            module2.exports = Shake;
          },
          13383: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var EaseMap = __webpack_require__2(35060);
            var Events = __webpack_require__2(89787);
            var Zoom = new Class({
              initialize: function Zoom2(camera) {
                this.camera = camera;
                this.isRunning = false;
                this.duration = 0;
                this.source = 1;
                this.destination = 1;
                this.ease;
                this.progress = 0;
                this._elapsed = 0;
                this._onUpdate;
                this._onUpdateScope;
              },
              start: function(zoom, duration, ease, force, callback, context) {
                if (duration === void 0) {
                  duration = 1e3;
                }
                if (ease === void 0) {
                  ease = EaseMap.Linear;
                }
                if (force === void 0) {
                  force = false;
                }
                if (callback === void 0) {
                  callback = null;
                }
                if (context === void 0) {
                  context = this.camera.scene;
                }
                var cam = this.camera;
                if (!force && this.isRunning) {
                  return cam;
                }
                this.isRunning = true;
                this.duration = duration;
                this.progress = 0;
                this.source = cam.zoom;
                this.destination = zoom;
                if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                  this.ease = EaseMap[ease];
                } else if (typeof ease === "function") {
                  this.ease = ease;
                }
                this._elapsed = 0;
                this._onUpdate = callback;
                this._onUpdateScope = context;
                this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom);
                return cam;
              },
              update: function(time, delta) {
                if (!this.isRunning) {
                  return;
                }
                this._elapsed += delta;
                this.progress = Clamp(this._elapsed / this.duration, 0, 1);
                if (this._elapsed < this.duration) {
                  this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress);
                  if (this._onUpdate) {
                    this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);
                  }
                } else {
                  this.camera.zoom = this.destination;
                  if (this._onUpdate) {
                    this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);
                  }
                  this.effectComplete();
                }
              },
              effectComplete: function() {
                this._onUpdate = null;
                this._onUpdateScope = null;
                this.isRunning = false;
                this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);
              },
              reset: function() {
                this.isRunning = false;
                this._onUpdate = null;
                this._onUpdateScope = null;
              },
              destroy: function() {
                this.reset();
                this.camera = null;
              }
            });
            module2.exports = Zoom;
          },
          53030: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Fade: __webpack_require__2(92522),
              Flash: __webpack_require__2(22151),
              Pan: __webpack_require__2(37551),
              Shake: __webpack_require__2(3241),
              RotateTo: __webpack_require__2(1771),
              Zoom: __webpack_require__2(13383)
            };
          },
          39577: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "cameradestroy";
          },
          85373: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerafadeincomplete";
          },
          92057: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerafadeinstart";
          },
          1903: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerafadeoutcomplete";
          },
          96131: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerafadeoutstart";
          },
          85409: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "cameraflashcomplete";
          },
          25500: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "cameraflashstart";
          },
          44071: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "followupdate";
          },
          19818: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerapancomplete";
          },
          80002: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerapanstart";
          },
          87966: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "postrender";
          },
          74217: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "prerender";
          },
          34805: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerarotatecomplete";
          },
          30408: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerarotatestart";
          },
          49856: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerashakecomplete";
          },
          69189: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerashakestart";
          },
          67657: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerazoomcomplete";
          },
          14229: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "camerazoomstart";
          },
          89787: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              DESTROY: __webpack_require__2(39577),
              FADE_IN_COMPLETE: __webpack_require__2(85373),
              FADE_IN_START: __webpack_require__2(92057),
              FADE_OUT_COMPLETE: __webpack_require__2(1903),
              FADE_OUT_START: __webpack_require__2(96131),
              FLASH_COMPLETE: __webpack_require__2(85409),
              FLASH_START: __webpack_require__2(25500),
              FOLLOW_UPDATE: __webpack_require__2(44071),
              PAN_COMPLETE: __webpack_require__2(19818),
              PAN_START: __webpack_require__2(80002),
              POST_RENDER: __webpack_require__2(87966),
              PRE_RENDER: __webpack_require__2(74217),
              ROTATE_COMPLETE: __webpack_require__2(34805),
              ROTATE_START: __webpack_require__2(30408),
              SHAKE_COMPLETE: __webpack_require__2(49856),
              SHAKE_START: __webpack_require__2(69189),
              ZOOM_COMPLETE: __webpack_require__2(67657),
              ZOOM_START: __webpack_require__2(14229)
            };
          },
          32356: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Camera: __webpack_require__2(47751),
              BaseCamera: __webpack_require__2(51052),
              CameraManager: __webpack_require__2(62382),
              Effects: __webpack_require__2(53030),
              Events: __webpack_require__2(89787)
            };
          },
          84219: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetValue = __webpack_require__2(10850);
            var FixedKeyControl = new Class({
              initialize: function FixedKeyControl2(config2) {
                this.camera = GetValue(config2, "camera", null);
                this.left = GetValue(config2, "left", null);
                this.right = GetValue(config2, "right", null);
                this.up = GetValue(config2, "up", null);
                this.down = GetValue(config2, "down", null);
                this.zoomIn = GetValue(config2, "zoomIn", null);
                this.zoomOut = GetValue(config2, "zoomOut", null);
                this.zoomSpeed = GetValue(config2, "zoomSpeed", 0.01);
                this.minZoom = GetValue(config2, "minZoom", 1e-3);
                this.maxZoom = GetValue(config2, "maxZoom", 1e3);
                this.speedX = 0;
                this.speedY = 0;
                var speed = GetValue(config2, "speed", null);
                if (typeof speed === "number") {
                  this.speedX = speed;
                  this.speedY = speed;
                } else {
                  this.speedX = GetValue(config2, "speed.x", 0);
                  this.speedY = GetValue(config2, "speed.y", 0);
                }
                this._zoom = 0;
                this.active = this.camera !== null;
              },
              start: function() {
                this.active = this.camera !== null;
                return this;
              },
              stop: function() {
                this.active = false;
                return this;
              },
              setCamera: function(camera) {
                this.camera = camera;
                return this;
              },
              update: function(delta) {
                if (!this.active) {
                  return;
                }
                if (delta === void 0) {
                  delta = 1;
                }
                var cam = this.camera;
                if (this.up && this.up.isDown) {
                  cam.scrollY -= this.speedY * delta | 0;
                } else if (this.down && this.down.isDown) {
                  cam.scrollY += this.speedY * delta | 0;
                }
                if (this.left && this.left.isDown) {
                  cam.scrollX -= this.speedX * delta | 0;
                } else if (this.right && this.right.isDown) {
                  cam.scrollX += this.speedX * delta | 0;
                }
                if (this.zoomIn && this.zoomIn.isDown) {
                  cam.zoom -= this.zoomSpeed;
                  if (cam.zoom < this.minZoom) {
                    cam.zoom = this.minZoom;
                  }
                } else if (this.zoomOut && this.zoomOut.isDown) {
                  cam.zoom += this.zoomSpeed;
                  if (cam.zoom > this.maxZoom) {
                    cam.zoom = this.maxZoom;
                  }
                }
              },
              destroy: function() {
                this.camera = null;
                this.left = null;
                this.right = null;
                this.up = null;
                this.down = null;
                this.zoomIn = null;
                this.zoomOut = null;
              }
            });
            module2.exports = FixedKeyControl;
          },
          69370: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetValue = __webpack_require__2(10850);
            var SmoothedKeyControl = new Class({
              initialize: function SmoothedKeyControl2(config2) {
                this.camera = GetValue(config2, "camera", null);
                this.left = GetValue(config2, "left", null);
                this.right = GetValue(config2, "right", null);
                this.up = GetValue(config2, "up", null);
                this.down = GetValue(config2, "down", null);
                this.zoomIn = GetValue(config2, "zoomIn", null);
                this.zoomOut = GetValue(config2, "zoomOut", null);
                this.zoomSpeed = GetValue(config2, "zoomSpeed", 0.01);
                this.minZoom = GetValue(config2, "minZoom", 1e-3);
                this.maxZoom = GetValue(config2, "maxZoom", 1e3);
                this.accelX = 0;
                this.accelY = 0;
                var accel = GetValue(config2, "acceleration", null);
                if (typeof accel === "number") {
                  this.accelX = accel;
                  this.accelY = accel;
                } else {
                  this.accelX = GetValue(config2, "acceleration.x", 0);
                  this.accelY = GetValue(config2, "acceleration.y", 0);
                }
                this.dragX = 0;
                this.dragY = 0;
                var drag = GetValue(config2, "drag", null);
                if (typeof drag === "number") {
                  this.dragX = drag;
                  this.dragY = drag;
                } else {
                  this.dragX = GetValue(config2, "drag.x", 0);
                  this.dragY = GetValue(config2, "drag.y", 0);
                }
                this.maxSpeedX = 0;
                this.maxSpeedY = 0;
                var maxSpeed = GetValue(config2, "maxSpeed", null);
                if (typeof maxSpeed === "number") {
                  this.maxSpeedX = maxSpeed;
                  this.maxSpeedY = maxSpeed;
                } else {
                  this.maxSpeedX = GetValue(config2, "maxSpeed.x", 0);
                  this.maxSpeedY = GetValue(config2, "maxSpeed.y", 0);
                }
                this._speedX = 0;
                this._speedY = 0;
                this._zoom = 0;
                this.active = this.camera !== null;
              },
              start: function() {
                this.active = this.camera !== null;
                return this;
              },
              stop: function() {
                this.active = false;
                return this;
              },
              setCamera: function(camera) {
                this.camera = camera;
                return this;
              },
              update: function(delta) {
                if (!this.active) {
                  return;
                }
                if (delta === void 0) {
                  delta = 1;
                }
                var cam = this.camera;
                if (this._speedX > 0) {
                  this._speedX -= this.dragX * delta;
                  if (this._speedX < 0) {
                    this._speedX = 0;
                  }
                } else if (this._speedX < 0) {
                  this._speedX += this.dragX * delta;
                  if (this._speedX > 0) {
                    this._speedX = 0;
                  }
                }
                if (this._speedY > 0) {
                  this._speedY -= this.dragY * delta;
                  if (this._speedY < 0) {
                    this._speedY = 0;
                  }
                } else if (this._speedY < 0) {
                  this._speedY += this.dragY * delta;
                  if (this._speedY > 0) {
                    this._speedY = 0;
                  }
                }
                if (this.up && this.up.isDown) {
                  this._speedY += this.accelY;
                  if (this._speedY > this.maxSpeedY) {
                    this._speedY = this.maxSpeedY;
                  }
                } else if (this.down && this.down.isDown) {
                  this._speedY -= this.accelY;
                  if (this._speedY < -this.maxSpeedY) {
                    this._speedY = -this.maxSpeedY;
                  }
                }
                if (this.left && this.left.isDown) {
                  this._speedX += this.accelX;
                  if (this._speedX > this.maxSpeedX) {
                    this._speedX = this.maxSpeedX;
                  }
                } else if (this.right && this.right.isDown) {
                  this._speedX -= this.accelX;
                  if (this._speedX < -this.maxSpeedX) {
                    this._speedX = -this.maxSpeedX;
                  }
                }
                if (this.zoomIn && this.zoomIn.isDown) {
                  this._zoom = -this.zoomSpeed;
                } else if (this.zoomOut && this.zoomOut.isDown) {
                  this._zoom = this.zoomSpeed;
                } else {
                  this._zoom = 0;
                }
                if (this._speedX !== 0) {
                  cam.scrollX -= this._speedX * delta | 0;
                }
                if (this._speedY !== 0) {
                  cam.scrollY -= this._speedY * delta | 0;
                }
                if (this._zoom !== 0) {
                  cam.zoom += this._zoom;
                  if (cam.zoom < this.minZoom) {
                    cam.zoom = this.minZoom;
                  } else if (cam.zoom > this.maxZoom) {
                    cam.zoom = this.maxZoom;
                  }
                }
              },
              destroy: function() {
                this.camera = null;
                this.left = null;
                this.right = null;
                this.up = null;
                this.down = null;
                this.zoomIn = null;
                this.zoomOut = null;
              }
            });
            module2.exports = SmoothedKeyControl;
          },
          6524: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              FixedKeyControl: __webpack_require__2(84219),
              SmoothedKeyControl: __webpack_require__2(69370)
            };
          },
          44143: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Controls: __webpack_require__2(6524),
              Scene2D: __webpack_require__2(32356)
            };
          },
          86459: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = {
              VERSION: "3.70.0",
              BlendModes: __webpack_require__2(95723),
              ScaleModes: __webpack_require__2(27394),
              AUTO: 0,
              CANVAS: 1,
              WEBGL: 2,
              HEADLESS: 3,
              FOREVER: -1,
              NONE: 4,
              UP: 5,
              DOWN: 6,
              LEFT: 7,
              RIGHT: 8
            };
            module2.exports = CONST;
          },
          14033: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(86459);
            var DefaultPlugins = __webpack_require__2(18360);
            var Device = __webpack_require__2(77290);
            var GetFastValue = __webpack_require__2(72632);
            var GetValue = __webpack_require__2(10850);
            var IsPlainObject = __webpack_require__2(42911);
            var NOOP = __webpack_require__2(72283);
            var PhaserMath = __webpack_require__2(5923);
            var PIPELINE_CONST = __webpack_require__2(65641);
            var ValueToColor = __webpack_require__2(93222);
            var Config = new Class({
              initialize: function Config2(config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                var defaultBannerColor = [
                  "#ff0000",
                  "#ffff00",
                  "#00ff00",
                  "#00ffff",
                  "#000000"
                ];
                var defaultBannerTextColor = "#ffffff";
                var scaleConfig = GetValue(config2, "scale", null);
                this.width = GetValue(scaleConfig, "width", 1024, config2);
                this.height = GetValue(scaleConfig, "height", 768, config2);
                this.zoom = GetValue(scaleConfig, "zoom", 1, config2);
                this.parent = GetValue(scaleConfig, "parent", void 0, config2);
                this.scaleMode = GetValue(scaleConfig, scaleConfig ? "mode" : "scaleMode", 0, config2);
                this.expandParent = GetValue(scaleConfig, "expandParent", true, config2);
                this.autoRound = GetValue(scaleConfig, "autoRound", false, config2);
                this.autoCenter = GetValue(scaleConfig, "autoCenter", 0, config2);
                this.resizeInterval = GetValue(scaleConfig, "resizeInterval", 500, config2);
                this.fullscreenTarget = GetValue(scaleConfig, "fullscreenTarget", null, config2);
                this.minWidth = GetValue(scaleConfig, "min.width", 0, config2);
                this.maxWidth = GetValue(scaleConfig, "max.width", 0, config2);
                this.minHeight = GetValue(scaleConfig, "min.height", 0, config2);
                this.maxHeight = GetValue(scaleConfig, "max.height", 0, config2);
                this.renderType = GetValue(config2, "type", CONST.AUTO);
                this.canvas = GetValue(config2, "canvas", null);
                this.context = GetValue(config2, "context", null);
                this.canvasStyle = GetValue(config2, "canvasStyle", null);
                this.customEnvironment = GetValue(config2, "customEnvironment", false);
                this.sceneConfig = GetValue(config2, "scene", null);
                this.seed = GetValue(config2, "seed", [(Date.now() * Math.random()).toString()]);
                PhaserMath.RND = new PhaserMath.RandomDataGenerator(this.seed);
                this.gameTitle = GetValue(config2, "title", "");
                this.gameURL = GetValue(config2, "url", "https://phaser.io");
                this.gameVersion = GetValue(config2, "version", "");
                this.autoFocus = GetValue(config2, "autoFocus", true);
                this.stableSort = GetValue(config2, "stableSort", -1);
                if (this.stableSort === -1) {
                  this.stableSort = Device.browser.es2019 ? 1 : 0;
                }
                Device.features.stableSort = this.stableSort;
                this.domCreateContainer = GetValue(config2, "dom.createContainer", false);
                this.domPointerEvents = GetValue(config2, "dom.pointerEvents", "none");
                this.inputKeyboard = GetValue(config2, "input.keyboard", true);
                this.inputKeyboardEventTarget = GetValue(config2, "input.keyboard.target", window);
                this.inputKeyboardCapture = GetValue(config2, "input.keyboard.capture", []);
                this.inputMouse = GetValue(config2, "input.mouse", true);
                this.inputMouseEventTarget = GetValue(config2, "input.mouse.target", null);
                this.inputMousePreventDefaultDown = GetValue(config2, "input.mouse.preventDefaultDown", true);
                this.inputMousePreventDefaultUp = GetValue(config2, "input.mouse.preventDefaultUp", true);
                this.inputMousePreventDefaultMove = GetValue(config2, "input.mouse.preventDefaultMove", true);
                this.inputMousePreventDefaultWheel = GetValue(config2, "input.mouse.preventDefaultWheel", true);
                this.inputTouch = GetValue(config2, "input.touch", Device.input.touch);
                this.inputTouchEventTarget = GetValue(config2, "input.touch.target", null);
                this.inputTouchCapture = GetValue(config2, "input.touch.capture", true);
                this.inputActivePointers = GetValue(config2, "input.activePointers", 1);
                this.inputSmoothFactor = GetValue(config2, "input.smoothFactor", 0);
                this.inputWindowEvents = GetValue(config2, "input.windowEvents", true);
                this.inputGamepad = GetValue(config2, "input.gamepad", false);
                this.inputGamepadEventTarget = GetValue(config2, "input.gamepad.target", window);
                this.disableContextMenu = GetValue(config2, "disableContextMenu", false);
                this.audio = GetValue(config2, "audio", {});
                this.hideBanner = GetValue(config2, "banner", null) === false;
                this.hidePhaser = GetValue(config2, "banner.hidePhaser", false);
                this.bannerTextColor = GetValue(config2, "banner.text", defaultBannerTextColor);
                this.bannerBackgroundColor = GetValue(config2, "banner.background", defaultBannerColor);
                if (this.gameTitle === "" && this.hidePhaser) {
                  this.hideBanner = true;
                }
                this.fps = GetValue(config2, "fps", null);
                this.disablePreFX = GetValue(config2, "disablePreFX", false);
                this.disablePostFX = GetValue(config2, "disablePostFX", false);
                var renderConfig = GetValue(config2, "render", null);
                this.pipeline = GetValue(renderConfig, "pipeline", null, config2);
                this.autoMobilePipeline = GetValue(renderConfig, "autoMobilePipeline", true, config2);
                this.defaultPipeline = GetValue(renderConfig, "defaultPipeline", PIPELINE_CONST.MULTI_PIPELINE, config2);
                this.antialias = GetValue(renderConfig, "antialias", true, config2);
                this.antialiasGL = GetValue(renderConfig, "antialiasGL", true, config2);
                this.mipmapFilter = GetValue(renderConfig, "mipmapFilter", "", config2);
                this.desynchronized = GetValue(renderConfig, "desynchronized", false, config2);
                this.roundPixels = GetValue(renderConfig, "roundPixels", true, config2);
                this.pixelArt = GetValue(renderConfig, "pixelArt", this.zoom !== 1, config2);
                if (this.pixelArt) {
                  this.antialias = false;
                  this.antialiasGL = false;
                  this.roundPixels = true;
                }
                this.transparent = GetValue(renderConfig, "transparent", false, config2);
                this.clearBeforeRender = GetValue(renderConfig, "clearBeforeRender", true, config2);
                this.preserveDrawingBuffer = GetValue(renderConfig, "preserveDrawingBuffer", false, config2);
                this.premultipliedAlpha = GetValue(renderConfig, "premultipliedAlpha", true, config2);
                this.failIfMajorPerformanceCaveat = GetValue(renderConfig, "failIfMajorPerformanceCaveat", false, config2);
                this.powerPreference = GetValue(renderConfig, "powerPreference", "default", config2);
                this.batchSize = GetValue(renderConfig, "batchSize", 4096, config2);
                this.maxTextures = GetValue(renderConfig, "maxTextures", -1, config2);
                this.maxLights = GetValue(renderConfig, "maxLights", 10, config2);
                var bgc = GetValue(config2, "backgroundColor", 0);
                this.backgroundColor = ValueToColor(bgc);
                if (this.transparent) {
                  this.backgroundColor = ValueToColor(0);
                  this.backgroundColor.alpha = 0;
                }
                this.preBoot = GetValue(config2, "callbacks.preBoot", NOOP);
                this.postBoot = GetValue(config2, "callbacks.postBoot", NOOP);
                this.physics = GetValue(config2, "physics", {});
                this.defaultPhysicsSystem = GetValue(this.physics, "default", false);
                this.loaderBaseURL = GetValue(config2, "loader.baseURL", "");
                this.loaderPath = GetValue(config2, "loader.path", "");
                this.loaderMaxParallelDownloads = GetValue(config2, "loader.maxParallelDownloads", Device.os.android ? 6 : 32);
                this.loaderCrossOrigin = GetValue(config2, "loader.crossOrigin", void 0);
                this.loaderResponseType = GetValue(config2, "loader.responseType", "");
                this.loaderAsync = GetValue(config2, "loader.async", true);
                this.loaderUser = GetValue(config2, "loader.user", "");
                this.loaderPassword = GetValue(config2, "loader.password", "");
                this.loaderTimeout = GetValue(config2, "loader.timeout", 0);
                this.loaderWithCredentials = GetValue(config2, "loader.withCredentials", false);
                this.loaderImageLoadType = GetValue(config2, "loader.imageLoadType", "XHR");
                this.loaderLocalScheme = GetValue(config2, "loader.localScheme", ["file://", "capacitor://"]);
                this.glowFXQuality = GetValue(config2, "fx.glow.quality", 0.1);
                this.glowFXDistance = GetValue(config2, "fx.glow.distance", 10);
                this.installGlobalPlugins = [];
                this.installScenePlugins = [];
                var plugins = GetValue(config2, "plugins", null);
                var defaultPlugins = DefaultPlugins.DefaultScene;
                if (plugins) {
                  if (Array.isArray(plugins)) {
                    this.defaultPlugins = plugins;
                  } else if (IsPlainObject(plugins)) {
                    this.installGlobalPlugins = GetFastValue(plugins, "global", []);
                    this.installScenePlugins = GetFastValue(plugins, "scene", []);
                    if (Array.isArray(plugins.default)) {
                      defaultPlugins = plugins.default;
                    } else if (Array.isArray(plugins.defaultMerge)) {
                      defaultPlugins = defaultPlugins.concat(plugins.defaultMerge);
                    }
                  }
                }
                this.defaultPlugins = defaultPlugins;
                var pngPrefix = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
                this.defaultImage = GetValue(config2, "images.default", pngPrefix + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
                this.missingImage = GetValue(config2, "images.missing", pngPrefix + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
                this.whiteImage = GetValue(config2, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC");
                if (window) {
                  if (window.FORCE_WEBGL) {
                    this.renderType = CONST.WEBGL;
                  } else if (window.FORCE_CANVAS) {
                    this.renderType = CONST.CANVAS;
                  }
                }
              }
            });
            module2.exports = Config;
          },
          50150: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasInterpolation = __webpack_require__2(70616);
            var CanvasPool = __webpack_require__2(61068);
            var CONST = __webpack_require__2(86459);
            var Features = __webpack_require__2(90185);
            var CreateRenderer = function(game) {
              var config2 = game.config;
              if ((config2.customEnvironment || config2.canvas) && config2.renderType === CONST.AUTO) {
                throw new Error("Must set explicit renderType in custom environment");
              }
              if (!config2.customEnvironment && !config2.canvas && config2.renderType !== CONST.HEADLESS) {
                if (config2.renderType === CONST.AUTO) {
                  config2.renderType = Features.webGL ? CONST.WEBGL : CONST.CANVAS;
                }
                if (config2.renderType === CONST.WEBGL) {
                  if (!Features.webGL) {
                    throw new Error("Cannot create WebGL context, aborting.");
                  }
                } else if (config2.renderType === CONST.CANVAS) {
                  if (!Features.canvas) {
                    throw new Error("Cannot create Canvas context, aborting.");
                  }
                } else {
                  throw new Error("Unknown value for renderer type: " + config2.renderType);
                }
              }
              if (!config2.antialias) {
                CanvasPool.disableSmoothing();
              }
              var baseSize = game.scale.baseSize;
              var width = baseSize.width;
              var height = baseSize.height;
              if (config2.canvas) {
                game.canvas = config2.canvas;
                game.canvas.width = width;
                game.canvas.height = height;
              } else {
                game.canvas = CanvasPool.create(game, width, height, config2.renderType);
              }
              if (config2.canvasStyle) {
                game.canvas.style = config2.canvasStyle;
              }
              if (!config2.antialias) {
                CanvasInterpolation.setCrisp(game.canvas);
              }
              if (config2.renderType === CONST.HEADLESS) {
                return;
              }
              var CanvasRenderer;
              var WebGLRenderer;
              if (true) {
                CanvasRenderer = __webpack_require__2(91135);
                WebGLRenderer = __webpack_require__2(11857);
                if (config2.renderType === CONST.WEBGL) {
                  game.renderer = new WebGLRenderer(game);
                } else {
                  game.renderer = new CanvasRenderer(game);
                  game.context = game.renderer.gameContext;
                }
              }
              if (false) {
              }
              if (false) {
              }
            };
            module2.exports = CreateRenderer;
          },
          77291: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(86459);
            var DebugHeader = function(game) {
              var config2 = game.config;
              if (config2.hideBanner) {
                return;
              }
              var renderType = "WebGL";
              if (config2.renderType === CONST.CANVAS) {
                renderType = "Canvas";
              } else if (config2.renderType === CONST.HEADLESS) {
                renderType = "Headless";
              }
              var audioConfig = config2.audio;
              var deviceAudio = game.device.audio;
              var audioType;
              if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
                audioType = "Web Audio";
              } else if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
                audioType = "No Audio";
              } else {
                audioType = "HTML5 Audio";
              }
              if (!game.device.browser.ie) {
                var c = "";
                var args = [c];
                if (Array.isArray(config2.bannerBackgroundColor)) {
                  var lastColor;
                  config2.bannerBackgroundColor.forEach(function(color) {
                    c = c.concat("%c ");
                    args.push("background: " + color);
                    lastColor = color;
                  });
                  args[args.length - 1] = "color: " + config2.bannerTextColor + "; background: " + lastColor;
                } else {
                  c = c.concat("%c ");
                  args.push("color: " + config2.bannerTextColor + "; background: " + config2.bannerBackgroundColor);
                }
                args.push("background: transparent");
                if (config2.gameTitle) {
                  c = c.concat(config2.gameTitle);
                  if (config2.gameVersion) {
                    c = c.concat(" v" + config2.gameVersion);
                  }
                  if (!config2.hidePhaser) {
                    c = c.concat(" / ");
                  }
                }
                var fb = false ? 0 : "";
                if (!config2.hidePhaser) {
                  c = c.concat("Phaser v" + CONST.VERSION + fb + " (" + renderType + " | " + audioType + ")");
                }
                c = c.concat(" %c " + config2.gameURL);
                args[0] = c;
                console.log.apply(console, args);
              } else if (window["console"]) {
                console.log("Phaser v" + CONST.VERSION + " / https://phaser.io");
              }
            };
            module2.exports = DebugHeader;
          },
          15213: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AddToDOM = __webpack_require__2(99584);
            var AnimationManager = __webpack_require__2(90249);
            var CacheManager = __webpack_require__2(43474);
            var CanvasPool = __webpack_require__2(61068);
            var Class = __webpack_require__2(56694);
            var Config = __webpack_require__2(14033);
            var CreateDOMContainer = __webpack_require__2(85178);
            var CreateRenderer = __webpack_require__2(50150);
            var DataManager = __webpack_require__2(81078);
            var DebugHeader = __webpack_require__2(77291);
            var Device = __webpack_require__2(77290);
            var DOMContentLoaded = __webpack_require__2(21546);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(97081);
            var InputManager = __webpack_require__2(69898);
            var PluginCache = __webpack_require__2(91963);
            var PluginManager = __webpack_require__2(49274);
            var ScaleManager = __webpack_require__2(756);
            var SceneManager = __webpack_require__2(13553);
            var TextureEvents = __webpack_require__2(38203);
            var TextureManager = __webpack_require__2(6237);
            var TimeStep = __webpack_require__2(26617);
            var VisibilityHandler = __webpack_require__2(26493);
            if (true) {
              var SoundManagerCreator = __webpack_require__2(84191);
            }
            if (false) {
              var FacebookInstantGamesPlugin;
            }
            var Game2 = new Class({
              initialize: function Game3(config2) {
                this.config = new Config(config2);
                this.renderer = null;
                this.domContainer = null;
                this.canvas = null;
                this.context = null;
                this.isBooted = false;
                this.isRunning = false;
                this.events = new EventEmitter();
                this.anims = new AnimationManager(this);
                this.textures = new TextureManager(this);
                this.cache = new CacheManager(this);
                this.registry = new DataManager(this, new EventEmitter());
                this.input = new InputManager(this, this.config);
                this.scene = new SceneManager(this, this.config.sceneConfig);
                this.device = Device;
                this.scale = new ScaleManager(this, this.config);
                this.sound = null;
                if (true) {
                  this.sound = SoundManagerCreator.create(this);
                }
                this.loop = new TimeStep(this, this.config.fps);
                this.plugins = new PluginManager(this, this.config);
                if (false) {
                }
                this.pendingDestroy = false;
                this.removeCanvas = false;
                this.noReturn = false;
                this.hasFocus = false;
                this.isPaused = false;
                DOMContentLoaded(this.boot.bind(this));
              },
              boot: function() {
                if (!PluginCache.hasCore("EventEmitter")) {
                  console.warn("Aborting. Core Plugins missing.");
                  return;
                }
                this.isBooted = true;
                this.config.preBoot(this);
                this.scale.preBoot();
                CreateRenderer(this);
                CreateDOMContainer(this);
                DebugHeader(this);
                AddToDOM(this.canvas, this.config.parent);
                this.textures.once(TextureEvents.READY, this.texturesReady, this);
                this.events.emit(Events.BOOT);
                if (false) {
                }
              },
              texturesReady: function() {
                this.events.emit(Events.READY);
                this.start();
              },
              start: function() {
                this.isRunning = true;
                this.config.postBoot(this);
                if (this.renderer) {
                  this.loop.start(this.step.bind(this));
                } else {
                  this.loop.start(this.headlessStep.bind(this));
                }
                VisibilityHandler(this);
                var eventEmitter = this.events;
                eventEmitter.on(Events.HIDDEN, this.onHidden, this);
                eventEmitter.on(Events.VISIBLE, this.onVisible, this);
                eventEmitter.on(Events.BLUR, this.onBlur, this);
                eventEmitter.on(Events.FOCUS, this.onFocus, this);
              },
              step: function(time, delta) {
                if (this.pendingDestroy) {
                  return this.runDestroy();
                }
                if (this.isPaused) {
                  return;
                }
                var eventEmitter = this.events;
                eventEmitter.emit(Events.PRE_STEP, time, delta);
                eventEmitter.emit(Events.STEP, time, delta);
                this.scene.update(time, delta);
                eventEmitter.emit(Events.POST_STEP, time, delta);
                var renderer = this.renderer;
                renderer.preRender();
                eventEmitter.emit(Events.PRE_RENDER, renderer, time, delta);
                this.scene.render(renderer);
                renderer.postRender();
                eventEmitter.emit(Events.POST_RENDER, renderer, time, delta);
              },
              headlessStep: function(time, delta) {
                if (this.pendingDestroy) {
                  return this.runDestroy();
                }
                if (this.isPaused) {
                  return;
                }
                var eventEmitter = this.events;
                eventEmitter.emit(Events.PRE_STEP, time, delta);
                eventEmitter.emit(Events.STEP, time, delta);
                this.scene.update(time, delta);
                eventEmitter.emit(Events.POST_STEP, time, delta);
                this.scene.isProcessing = false;
                eventEmitter.emit(Events.PRE_RENDER, null, time, delta);
                eventEmitter.emit(Events.POST_RENDER, null, time, delta);
              },
              onHidden: function() {
                this.loop.pause();
                this.events.emit(Events.PAUSE);
              },
              pause: function() {
                var wasPaused = this.isPaused;
                this.isPaused = true;
                if (!wasPaused) {
                  this.events.emit(Events.PAUSE);
                }
              },
              onVisible: function() {
                this.loop.resume();
                this.events.emit(Events.RESUME);
              },
              resume: function() {
                var wasPaused = this.isPaused;
                this.isPaused = false;
                if (wasPaused) {
                  this.events.emit(Events.RESUME);
                }
              },
              onBlur: function() {
                this.hasFocus = false;
                this.loop.blur();
              },
              onFocus: function() {
                this.hasFocus = true;
                this.loop.focus();
              },
              getFrame: function() {
                return this.loop.frame;
              },
              getTime: function() {
                return this.loop.now;
              },
              destroy: function(removeCanvas, noReturn) {
                if (noReturn === void 0) {
                  noReturn = false;
                }
                this.pendingDestroy = true;
                this.removeCanvas = removeCanvas;
                this.noReturn = noReturn;
              },
              runDestroy: function() {
                this.scene.destroy();
                this.events.emit(Events.DESTROY);
                this.events.removeAllListeners();
                if (this.renderer) {
                  this.renderer.destroy();
                }
                if (this.removeCanvas && this.canvas) {
                  CanvasPool.remove(this.canvas);
                  if (this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                  }
                }
                if (this.domContainer && this.domContainer.parentNode) {
                  this.domContainer.parentNode.removeChild(this.domContainer);
                }
                this.loop.destroy();
                this.pendingDestroy = false;
              }
            });
            module2.exports = Game2;
          },
          26617: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetValue = __webpack_require__2(10850);
            var NOOP = __webpack_require__2(72283);
            var RequestAnimationFrame = __webpack_require__2(27385);
            var TimeStep = new Class({
              initialize: function TimeStep2(game, config2) {
                this.game = game;
                this.raf = new RequestAnimationFrame();
                this.started = false;
                this.running = false;
                this.minFps = GetValue(config2, "min", 5);
                this.targetFps = GetValue(config2, "target", 60);
                this.fpsLimit = GetValue(config2, "limit", 0);
                this.hasFpsLimit = this.fpsLimit > 0;
                this._limitRate = this.hasFpsLimit ? 1e3 / this.fpsLimit : 0;
                this._min = 1e3 / this.minFps;
                this._target = 1e3 / this.targetFps;
                this.actualFps = this.targetFps;
                this.nextFpsUpdate = 0;
                this.framesThisSecond = 0;
                this.callback = NOOP;
                this.forceSetTimeOut = GetValue(config2, "forceSetTimeOut", false);
                this.time = 0;
                this.startTime = 0;
                this.lastTime = 0;
                this.frame = 0;
                this.inFocus = true;
                this._pauseTime = 0;
                this._coolDown = 0;
                this.delta = 0;
                this.deltaIndex = 0;
                this.deltaHistory = [];
                this.deltaSmoothingMax = GetValue(config2, "deltaHistory", 10);
                this.panicMax = GetValue(config2, "panicMax", 120);
                this.rawDelta = 0;
                this.now = 0;
                this.smoothStep = GetValue(config2, "smoothStep", true);
              },
              blur: function() {
                this.inFocus = false;
              },
              focus: function() {
                this.inFocus = true;
                this.resetDelta();
              },
              pause: function() {
                this._pauseTime = window.performance.now();
              },
              resume: function() {
                this.resetDelta();
                this.startTime += this.time - this._pauseTime;
              },
              resetDelta: function() {
                var now = window.performance.now();
                this.time = now;
                this.lastTime = now;
                this.nextFpsUpdate = now + 1e3;
                this.framesThisSecond = 0;
                for (var i = 0; i < this.deltaSmoothingMax; i++) {
                  this.deltaHistory[i] = Math.min(this._target, this.deltaHistory[i]);
                }
                this.delta = 0;
                this.deltaIndex = 0;
                this._coolDown = this.panicMax;
              },
              start: function(callback) {
                if (this.started) {
                  return this;
                }
                this.started = true;
                this.running = true;
                for (var i = 0; i < this.deltaSmoothingMax; i++) {
                  this.deltaHistory[i] = this._target;
                }
                this.resetDelta();
                this.startTime = window.performance.now();
                this.callback = callback;
                var step = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this);
                this.raf.start(step, this.forceSetTimeOut, this._target);
              },
              smoothDelta: function(delta) {
                var idx = this.deltaIndex;
                var history = this.deltaHistory;
                var max = this.deltaSmoothingMax;
                if (this._coolDown > 0 || !this.inFocus) {
                  this._coolDown--;
                  delta = Math.min(delta, this._target);
                }
                if (delta > this._min) {
                  delta = history[idx];
                  delta = Math.min(delta, this._min);
                }
                history[idx] = delta;
                this.deltaIndex++;
                if (this.deltaIndex >= max) {
                  this.deltaIndex = 0;
                }
                var avg = 0;
                for (var i = 0; i < max; i++) {
                  avg += history[i];
                }
                avg /= max;
                return avg;
              },
              updateFPS: function(time) {
                this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps;
                this.nextFpsUpdate = time + 1e3;
                this.framesThisSecond = 0;
              },
              stepLimitFPS: function(time) {
                this.now = time;
                var delta = Math.max(0, time - this.lastTime);
                this.rawDelta = delta;
                this.time += this.rawDelta;
                if (this.smoothStep) {
                  delta = this.smoothDelta(delta);
                }
                this.delta += delta;
                if (time >= this.nextFpsUpdate) {
                  this.updateFPS(time);
                }
                this.framesThisSecond++;
                if (this.delta >= this._limitRate) {
                  this.callback(time, this.delta);
                  this.delta = 0;
                }
                this.lastTime = time;
                this.frame++;
              },
              step: function(time) {
                this.now = time;
                var delta = Math.max(0, time - this.lastTime);
                this.rawDelta = delta;
                this.time += this.rawDelta;
                if (this.smoothStep) {
                  delta = this.smoothDelta(delta);
                }
                this.delta = delta;
                if (time >= this.nextFpsUpdate) {
                  this.updateFPS(time);
                }
                this.framesThisSecond++;
                this.callback(time, delta);
                this.lastTime = time;
                this.frame++;
              },
              tick: function() {
                var now = window.performance.now();
                if (this.hasFpsLimit) {
                  this.stepLimitFPS(now);
                } else {
                  this.step(now);
                }
              },
              sleep: function() {
                if (this.running) {
                  this.raf.stop();
                  this.running = false;
                }
              },
              wake: function(seamless) {
                if (seamless === void 0) {
                  seamless = false;
                }
                var now = window.performance.now();
                if (this.running) {
                  return;
                } else if (seamless) {
                  this.startTime += -this.lastTime + (this.lastTime + now);
                }
                var step = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this);
                this.raf.start(step, this.forceSetTimeOut, this._target);
                this.running = true;
                this.nextFpsUpdate = now + 1e3;
                this.framesThisSecond = 0;
                this.fpsLimitTriggered = false;
                this.tick();
              },
              getDuration: function() {
                return Math.round(this.lastTime - this.startTime) / 1e3;
              },
              getDurationMS: function() {
                return Math.round(this.lastTime - this.startTime);
              },
              stop: function() {
                this.running = false;
                this.started = false;
                this.raf.stop();
                return this;
              },
              destroy: function() {
                this.stop();
                this.raf.destroy();
                this.raf = null;
                this.game = null;
                this.callback = null;
              }
            });
            module2.exports = TimeStep;
          },
          26493: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Events = __webpack_require__2(97081);
            var VisibilityHandler = function(game) {
              var hiddenVar;
              var eventEmitter = game.events;
              if (document.hidden !== void 0) {
                hiddenVar = "visibilitychange";
              } else {
                var vendors = ["webkit", "moz", "ms"];
                vendors.forEach(function(prefix) {
                  if (document[prefix + "Hidden"] !== void 0) {
                    document.hidden = function() {
                      return document[prefix + "Hidden"];
                    };
                    hiddenVar = prefix + "visibilitychange";
                  }
                });
              }
              var onChange = function(event) {
                if (document.hidden || event.type === "pause") {
                  eventEmitter.emit(Events.HIDDEN);
                } else {
                  eventEmitter.emit(Events.VISIBLE);
                }
              };
              if (hiddenVar) {
                document.addEventListener(hiddenVar, onChange, false);
              }
              window.onblur = function() {
                eventEmitter.emit(Events.BLUR);
              };
              window.onfocus = function() {
                eventEmitter.emit(Events.FOCUS);
              };
              if (window.focus && game.config.autoFocus) {
                window.focus();
              }
            };
            module2.exports = VisibilityHandler;
          },
          41651: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "blur";
          },
          5520: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "boot";
          },
          51673: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "contextlost";
          },
          25055: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "destroy";
          },
          23767: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "focus";
          },
          57564: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "hidden";
          },
          38327: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pause";
          },
          43807: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "postrender";
          },
          73652: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "poststep";
          },
          780: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "prerender";
          },
          13781: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "prestep";
          },
          38247: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "ready";
          },
          29129: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resume";
          },
          34994: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "step";
          },
          55237: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "systemready";
          },
          98704: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "visible";
          },
          97081: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BLUR: __webpack_require__2(41651),
              BOOT: __webpack_require__2(5520),
              CONTEXT_LOST: __webpack_require__2(51673),
              DESTROY: __webpack_require__2(25055),
              FOCUS: __webpack_require__2(23767),
              HIDDEN: __webpack_require__2(57564),
              PAUSE: __webpack_require__2(38327),
              POST_RENDER: __webpack_require__2(43807),
              POST_STEP: __webpack_require__2(73652),
              PRE_RENDER: __webpack_require__2(780),
              PRE_STEP: __webpack_require__2(13781),
              READY: __webpack_require__2(38247),
              RESUME: __webpack_require__2(29129),
              STEP: __webpack_require__2(34994),
              SYSTEM_READY: __webpack_require__2(55237),
              VISIBLE: __webpack_require__2(98704)
            };
          },
          80293: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Config: __webpack_require__2(14033),
              CreateRenderer: __webpack_require__2(50150),
              DebugHeader: __webpack_require__2(77291),
              Events: __webpack_require__2(97081),
              TimeStep: __webpack_require__2(26617),
              VisibilityHandler: __webpack_require__2(26493)
            };
          },
          52780: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Arne16 = __webpack_require__2(81543);
            var CanvasPool = __webpack_require__2(61068);
            var GetValue = __webpack_require__2(10850);
            var GenerateTexture = function(config2) {
              var data = GetValue(config2, "data", []);
              var canvas = GetValue(config2, "canvas", null);
              var palette = GetValue(config2, "palette", Arne16);
              var pixelWidth = GetValue(config2, "pixelWidth", 1);
              var pixelHeight = GetValue(config2, "pixelHeight", pixelWidth);
              var resizeCanvas = GetValue(config2, "resizeCanvas", true);
              var clearCanvas = GetValue(config2, "clearCanvas", true);
              var preRender = GetValue(config2, "preRender", null);
              var postRender = GetValue(config2, "postRender", null);
              var width = Math.floor(Math.abs(data[0].length * pixelWidth));
              var height = Math.floor(Math.abs(data.length * pixelHeight));
              if (!canvas) {
                canvas = CanvasPool.create2D(this, width, height);
                resizeCanvas = false;
                clearCanvas = false;
              }
              if (resizeCanvas) {
                canvas.width = width;
                canvas.height = height;
              }
              var ctx = canvas.getContext("2d", {willReadFrequently: true});
              if (clearCanvas) {
                ctx.clearRect(0, 0, width, height);
              }
              if (preRender) {
                preRender(canvas, ctx);
              }
              for (var y = 0; y < data.length; y++) {
                var row = data[y];
                for (var x = 0; x < row.length; x++) {
                  var d = row[x];
                  if (d !== "." && d !== " ") {
                    ctx.fillStyle = palette[d];
                    ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
                  }
                }
              }
              if (postRender) {
                postRender(canvas, ctx);
              }
              return canvas;
            };
            module2.exports = GenerateTexture;
          },
          84106: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              GenerateTexture: __webpack_require__2(52780),
              Palettes: __webpack_require__2(25235)
            };
          },
          81543: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              0: "#000",
              1: "#9D9D9D",
              2: "#FFF",
              3: "#BE2633",
              4: "#E06F8B",
              5: "#493C2B",
              6: "#A46422",
              7: "#EB8931",
              8: "#F7E26B",
              9: "#2F484E",
              A: "#44891A",
              B: "#A3CE27",
              C: "#1B2632",
              D: "#005784",
              E: "#31A2F2",
              F: "#B2DCEF"
            };
          },
          75846: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              0: "#000",
              1: "#fff",
              2: "#8b4131",
              3: "#7bbdc5",
              4: "#8b41ac",
              5: "#6aac41",
              6: "#3931a4",
              7: "#d5de73",
              8: "#945a20",
              9: "#5a4100",
              A: "#bd736a",
              B: "#525252",
              C: "#838383",
              D: "#acee8b",
              E: "#7b73de",
              F: "#acacac"
            };
          },
          83206: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              0: "#000",
              1: "#2234d1",
              2: "#0c7e45",
              3: "#44aacc",
              4: "#8a3622",
              5: "#5c2e78",
              6: "#aa5c3d",
              7: "#b5b5b5",
              8: "#5e606e",
              9: "#4c81fb",
              A: "#6cd947",
              B: "#7be2f9",
              C: "#eb8a60",
              D: "#e23d69",
              E: "#ffd93f",
              F: "#fff"
            };
          },
          13194: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              0: "#000",
              1: "#191028",
              2: "#46af45",
              3: "#a1d685",
              4: "#453e78",
              5: "#7664fe",
              6: "#833129",
              7: "#9ec2e8",
              8: "#dc534b",
              9: "#e18d79",
              A: "#d6b97b",
              B: "#e9d8a1",
              C: "#216c4b",
              D: "#d365c8",
              E: "#afaab9",
              F: "#f5f4eb"
            };
          },
          50686: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              0: "#000",
              1: "#191028",
              2: "#46af45",
              3: "#a1d685",
              4: "#453e78",
              5: "#7664fe",
              6: "#833129",
              7: "#9ec2e8",
              8: "#dc534b",
              9: "#e18d79",
              A: "#d6b97b",
              B: "#e9d8a1",
              C: "#216c4b",
              D: "#d365c8",
              E: "#afaab9",
              F: "#fff"
            };
          },
          25235: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ARNE16: __webpack_require__2(81543),
              C64: __webpack_require__2(75846),
              CGA: __webpack_require__2(83206),
              JMP: __webpack_require__2(13194),
              MSX: __webpack_require__2(50686)
            };
          },
          63120: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CubicBezier = __webpack_require__2(34631);
            var Curve = __webpack_require__2(38517);
            var Vector2 = __webpack_require__2(93736);
            var CubicBezierCurve = new Class({
              Extends: Curve,
              initialize: function CubicBezierCurve2(p0, p1, p2, p3) {
                Curve.call(this, "CubicBezierCurve");
                if (Array.isArray(p0)) {
                  p3 = new Vector2(p0[6], p0[7]);
                  p2 = new Vector2(p0[4], p0[5]);
                  p1 = new Vector2(p0[2], p0[3]);
                  p0 = new Vector2(p0[0], p0[1]);
                }
                this.p0 = p0;
                this.p1 = p1;
                this.p2 = p2;
                this.p3 = p3;
              },
              getStartPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return out.copy(this.p0);
              },
              getResolution: function(divisions) {
                return divisions;
              },
              getPoint: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                var p0 = this.p0;
                var p1 = this.p1;
                var p2 = this.p2;
                var p3 = this.p3;
                return out.set(CubicBezier(t, p0.x, p1.x, p2.x, p3.x), CubicBezier(t, p0.y, p1.y, p2.y, p3.y));
              },
              draw: function(graphics, pointsTotal) {
                if (pointsTotal === void 0) {
                  pointsTotal = 32;
                }
                var points = this.getPoints(pointsTotal);
                graphics.beginPath();
                graphics.moveTo(this.p0.x, this.p0.y);
                for (var i = 1; i < points.length; i++) {
                  graphics.lineTo(points[i].x, points[i].y);
                }
                graphics.strokePath();
                return graphics;
              },
              toJSON: function() {
                return {
                  type: this.type,
                  points: [
                    this.p0.x,
                    this.p0.y,
                    this.p1.x,
                    this.p1.y,
                    this.p2.x,
                    this.p2.y,
                    this.p3.x,
                    this.p3.y
                  ]
                };
              }
            });
            CubicBezierCurve.fromJSON = function(data) {
              var points = data.points;
              var p0 = new Vector2(points[0], points[1]);
              var p1 = new Vector2(points[2], points[3]);
              var p2 = new Vector2(points[4], points[5]);
              var p3 = new Vector2(points[6], points[7]);
              return new CubicBezierCurve(p0, p1, p2, p3);
            };
            module2.exports = CubicBezierCurve;
          },
          38517: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FromPoints = __webpack_require__2(80222);
            var Rectangle = __webpack_require__2(74118);
            var Vector2 = __webpack_require__2(93736);
            var Curve = new Class({
              initialize: function Curve2(type) {
                this.type = type;
                this.defaultDivisions = 5;
                this.arcLengthDivisions = 100;
                this.cacheArcLengths = [];
                this.needsUpdate = true;
                this.active = true;
                this._tmpVec2A = new Vector2();
                this._tmpVec2B = new Vector2();
              },
              draw: function(graphics, pointsTotal) {
                if (pointsTotal === void 0) {
                  pointsTotal = 32;
                }
                return graphics.strokePoints(this.getPoints(pointsTotal));
              },
              getBounds: function(out, accuracy) {
                if (!out) {
                  out = new Rectangle();
                }
                if (accuracy === void 0) {
                  accuracy = 16;
                }
                var len = this.getLength();
                if (accuracy > len) {
                  accuracy = len / 2;
                }
                var spaced = Math.max(1, Math.round(len / accuracy));
                return FromPoints(this.getSpacedPoints(spaced), out);
              },
              getDistancePoints: function(distance) {
                var len = this.getLength();
                var spaced = Math.max(1, len / distance);
                return this.getSpacedPoints(spaced);
              },
              getEndPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return this.getPointAt(1, out);
              },
              getLength: function() {
                var lengths = this.getLengths();
                return lengths[lengths.length - 1];
              },
              getLengths: function(divisions) {
                if (divisions === void 0) {
                  divisions = this.arcLengthDivisions;
                }
                if (this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
                  return this.cacheArcLengths;
                }
                this.needsUpdate = false;
                var cache = [];
                var current;
                var last = this.getPoint(0, this._tmpVec2A);
                var sum = 0;
                cache.push(0);
                for (var p = 1; p <= divisions; p++) {
                  current = this.getPoint(p / divisions, this._tmpVec2B);
                  sum += current.distance(last);
                  cache.push(sum);
                  last.copy(current);
                }
                this.cacheArcLengths = cache;
                return cache;
              },
              getPointAt: function(u, out) {
                var t = this.getUtoTmapping(u);
                return this.getPoint(t, out);
              },
              getPoints: function(divisions, stepRate, out) {
                if (out === void 0) {
                  out = [];
                }
                if (!divisions) {
                  if (!stepRate) {
                    divisions = this.defaultDivisions;
                  } else {
                    divisions = this.getLength() / stepRate;
                  }
                }
                for (var d = 0; d <= divisions; d++) {
                  out.push(this.getPoint(d / divisions));
                }
                return out;
              },
              getRandomPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return this.getPoint(Math.random(), out);
              },
              getSpacedPoints: function(divisions, stepRate, out) {
                if (out === void 0) {
                  out = [];
                }
                if (!divisions) {
                  if (!stepRate) {
                    divisions = this.defaultDivisions;
                  } else {
                    divisions = this.getLength() / stepRate;
                  }
                }
                for (var d = 0; d <= divisions; d++) {
                  var t = this.getUtoTmapping(d / divisions, null, divisions);
                  out.push(this.getPoint(t));
                }
                return out;
              },
              getStartPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return this.getPointAt(0, out);
              },
              getTangent: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                var delta = 1e-4;
                var t1 = t - delta;
                var t2 = t + delta;
                if (t1 < 0) {
                  t1 = 0;
                }
                if (t2 > 1) {
                  t2 = 1;
                }
                this.getPoint(t1, this._tmpVec2A);
                this.getPoint(t2, out);
                return out.subtract(this._tmpVec2A).normalize();
              },
              getTangentAt: function(u, out) {
                var t = this.getUtoTmapping(u);
                return this.getTangent(t, out);
              },
              getTFromDistance: function(distance, divisions) {
                if (distance <= 0) {
                  return 0;
                }
                return this.getUtoTmapping(0, distance, divisions);
              },
              getUtoTmapping: function(u, distance, divisions) {
                var arcLengths = this.getLengths(divisions);
                var i = 0;
                var il = arcLengths.length;
                var targetArcLength;
                if (distance) {
                  targetArcLength = Math.min(distance, arcLengths[il - 1]);
                } else {
                  targetArcLength = u * arcLengths[il - 1];
                }
                var low = 0;
                var high = il - 1;
                var comparison;
                while (low <= high) {
                  i = Math.floor(low + (high - low) / 2);
                  comparison = arcLengths[i] - targetArcLength;
                  if (comparison < 0) {
                    low = i + 1;
                  } else if (comparison > 0) {
                    high = i - 1;
                  } else {
                    high = i;
                    break;
                  }
                }
                i = high;
                if (arcLengths[i] === targetArcLength) {
                  return i / (il - 1);
                }
                var lengthBefore = arcLengths[i];
                var lengthAfter = arcLengths[i + 1];
                var segmentLength = lengthAfter - lengthBefore;
                var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
                return (i + segmentFraction) / (il - 1);
              },
              updateArcLengths: function() {
                this.needsUpdate = true;
                this.getLengths();
              }
            });
            module2.exports = Curve;
          },
          48835: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Curve = __webpack_require__2(38517);
            var DegToRad = __webpack_require__2(75606);
            var GetValue = __webpack_require__2(10850);
            var RadToDeg = __webpack_require__2(23701);
            var Vector2 = __webpack_require__2(93736);
            var EllipseCurve = new Class({
              Extends: Curve,
              initialize: function EllipseCurve2(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
                if (typeof x === "object") {
                  var config2 = x;
                  x = GetValue(config2, "x", 0);
                  y = GetValue(config2, "y", 0);
                  xRadius = GetValue(config2, "xRadius", 0);
                  yRadius = GetValue(config2, "yRadius", xRadius);
                  startAngle = GetValue(config2, "startAngle", 0);
                  endAngle = GetValue(config2, "endAngle", 360);
                  clockwise = GetValue(config2, "clockwise", false);
                  rotation = GetValue(config2, "rotation", 0);
                } else {
                  if (yRadius === void 0) {
                    yRadius = xRadius;
                  }
                  if (startAngle === void 0) {
                    startAngle = 0;
                  }
                  if (endAngle === void 0) {
                    endAngle = 360;
                  }
                  if (clockwise === void 0) {
                    clockwise = false;
                  }
                  if (rotation === void 0) {
                    rotation = 0;
                  }
                }
                Curve.call(this, "EllipseCurve");
                this.p0 = new Vector2(x, y);
                this._xRadius = xRadius;
                this._yRadius = yRadius;
                this._startAngle = DegToRad(startAngle);
                this._endAngle = DegToRad(endAngle);
                this._clockwise = clockwise;
                this._rotation = DegToRad(rotation);
              },
              getStartPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return this.getPoint(0, out);
              },
              getResolution: function(divisions) {
                return divisions * 2;
              },
              getPoint: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                var twoPi = Math.PI * 2;
                var deltaAngle = this._endAngle - this._startAngle;
                var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
                while (deltaAngle < 0) {
                  deltaAngle += twoPi;
                }
                while (deltaAngle > twoPi) {
                  deltaAngle -= twoPi;
                }
                if (deltaAngle < Number.EPSILON) {
                  if (samePoints) {
                    deltaAngle = 0;
                  } else {
                    deltaAngle = twoPi;
                  }
                }
                if (this._clockwise && !samePoints) {
                  if (deltaAngle === twoPi) {
                    deltaAngle = -twoPi;
                  } else {
                    deltaAngle = deltaAngle - twoPi;
                  }
                }
                var angle = this._startAngle + t * deltaAngle;
                var x = this.p0.x + this._xRadius * Math.cos(angle);
                var y = this.p0.y + this._yRadius * Math.sin(angle);
                if (this._rotation !== 0) {
                  var cos = Math.cos(this._rotation);
                  var sin = Math.sin(this._rotation);
                  var tx = x - this.p0.x;
                  var ty = y - this.p0.y;
                  x = tx * cos - ty * sin + this.p0.x;
                  y = tx * sin + ty * cos + this.p0.y;
                }
                return out.set(x, y);
              },
              setXRadius: function(value) {
                this.xRadius = value;
                return this;
              },
              setYRadius: function(value) {
                this.yRadius = value;
                return this;
              },
              setWidth: function(value) {
                this.xRadius = value / 2;
                return this;
              },
              setHeight: function(value) {
                this.yRadius = value / 2;
                return this;
              },
              setStartAngle: function(value) {
                this.startAngle = value;
                return this;
              },
              setEndAngle: function(value) {
                this.endAngle = value;
                return this;
              },
              setClockwise: function(value) {
                this.clockwise = value;
                return this;
              },
              setRotation: function(value) {
                this.rotation = value;
                return this;
              },
              x: {
                get: function() {
                  return this.p0.x;
                },
                set: function(value) {
                  this.p0.x = value;
                }
              },
              y: {
                get: function() {
                  return this.p0.y;
                },
                set: function(value) {
                  this.p0.y = value;
                }
              },
              xRadius: {
                get: function() {
                  return this._xRadius;
                },
                set: function(value) {
                  this._xRadius = value;
                }
              },
              yRadius: {
                get: function() {
                  return this._yRadius;
                },
                set: function(value) {
                  this._yRadius = value;
                }
              },
              startAngle: {
                get: function() {
                  return RadToDeg(this._startAngle);
                },
                set: function(value) {
                  this._startAngle = DegToRad(value);
                }
              },
              endAngle: {
                get: function() {
                  return RadToDeg(this._endAngle);
                },
                set: function(value) {
                  this._endAngle = DegToRad(value);
                }
              },
              clockwise: {
                get: function() {
                  return this._clockwise;
                },
                set: function(value) {
                  this._clockwise = value;
                }
              },
              angle: {
                get: function() {
                  return RadToDeg(this._rotation);
                },
                set: function(value) {
                  this._rotation = DegToRad(value);
                }
              },
              rotation: {
                get: function() {
                  return this._rotation;
                },
                set: function(value) {
                  this._rotation = value;
                }
              },
              toJSON: function() {
                return {
                  type: this.type,
                  x: this.p0.x,
                  y: this.p0.y,
                  xRadius: this._xRadius,
                  yRadius: this._yRadius,
                  startAngle: RadToDeg(this._startAngle),
                  endAngle: RadToDeg(this._endAngle),
                  clockwise: this._clockwise,
                  rotation: RadToDeg(this._rotation)
                };
              }
            });
            EllipseCurve.fromJSON = function(data) {
              return new EllipseCurve(data);
            };
            module2.exports = EllipseCurve;
          },
          58084: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Curve = __webpack_require__2(38517);
            var FromPoints = __webpack_require__2(80222);
            var Rectangle = __webpack_require__2(74118);
            var Vector2 = __webpack_require__2(93736);
            var LineCurve = new Class({
              Extends: Curve,
              initialize: function LineCurve2(p0, p1) {
                Curve.call(this, "LineCurve");
                if (Array.isArray(p0)) {
                  p1 = new Vector2(p0[2], p0[3]);
                  p0 = new Vector2(p0[0], p0[1]);
                }
                this.p0 = p0;
                this.p1 = p1;
                this.arcLengthDivisions = 1;
              },
              getBounds: function(out) {
                if (out === void 0) {
                  out = new Rectangle();
                }
                return FromPoints([this.p0, this.p1], out);
              },
              getStartPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return out.copy(this.p0);
              },
              getResolution: function(divisions) {
                if (divisions === void 0) {
                  divisions = 1;
                }
                return divisions;
              },
              getPoint: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                if (t === 1) {
                  return out.copy(this.p1);
                }
                out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);
                return out;
              },
              getPointAt: function(u, out) {
                return this.getPoint(u, out);
              },
              getTangent: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                out.copy(this.p1).subtract(this.p0).normalize();
                return out;
              },
              getUtoTmapping: function(u, distance, divisions) {
                var t;
                if (distance) {
                  var arcLengths = this.getLengths(divisions);
                  var lineLength = arcLengths[arcLengths.length - 1];
                  var targetLineLength = Math.min(distance, lineLength);
                  t = targetLineLength / lineLength;
                } else {
                  t = u;
                }
                return t;
              },
              draw: function(graphics) {
                graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);
                return graphics;
              },
              toJSON: function() {
                return {
                  type: this.type,
                  points: [
                    this.p0.x,
                    this.p0.y,
                    this.p1.x,
                    this.p1.y
                  ]
                };
              }
            });
            LineCurve.fromJSON = function(data) {
              var points = data.points;
              var p0 = new Vector2(points[0], points[1]);
              var p1 = new Vector2(points[2], points[3]);
              return new LineCurve(p0, p1);
            };
            module2.exports = LineCurve;
          },
          64761: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Curve = __webpack_require__2(38517);
            var QuadraticBezierInterpolation = __webpack_require__2(16252);
            var Vector2 = __webpack_require__2(93736);
            var QuadraticBezier = new Class({
              Extends: Curve,
              initialize: function QuadraticBezier2(p0, p1, p2) {
                Curve.call(this, "QuadraticBezierCurve");
                if (Array.isArray(p0)) {
                  p2 = new Vector2(p0[4], p0[5]);
                  p1 = new Vector2(p0[2], p0[3]);
                  p0 = new Vector2(p0[0], p0[1]);
                }
                this.p0 = p0;
                this.p1 = p1;
                this.p2 = p2;
              },
              getStartPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return out.copy(this.p0);
              },
              getResolution: function(divisions) {
                return divisions;
              },
              getPoint: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                var p0 = this.p0;
                var p1 = this.p1;
                var p2 = this.p2;
                return out.set(QuadraticBezierInterpolation(t, p0.x, p1.x, p2.x), QuadraticBezierInterpolation(t, p0.y, p1.y, p2.y));
              },
              draw: function(graphics, pointsTotal) {
                if (pointsTotal === void 0) {
                  pointsTotal = 32;
                }
                var points = this.getPoints(pointsTotal);
                graphics.beginPath();
                graphics.moveTo(this.p0.x, this.p0.y);
                for (var i = 1; i < points.length; i++) {
                  graphics.lineTo(points[i].x, points[i].y);
                }
                graphics.strokePath();
                return graphics;
              },
              toJSON: function() {
                return {
                  type: this.type,
                  points: [
                    this.p0.x,
                    this.p0.y,
                    this.p1.x,
                    this.p1.y,
                    this.p2.x,
                    this.p2.y
                  ]
                };
              }
            });
            QuadraticBezier.fromJSON = function(data) {
              var points = data.points;
              var p0 = new Vector2(points[0], points[1]);
              var p1 = new Vector2(points[2], points[3]);
              var p2 = new Vector2(points[4], points[5]);
              return new QuadraticBezier(p0, p1, p2);
            };
            module2.exports = QuadraticBezier;
          },
          11956: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CatmullRom = __webpack_require__2(14976);
            var Class = __webpack_require__2(56694);
            var Curve = __webpack_require__2(38517);
            var Vector2 = __webpack_require__2(93736);
            var SplineCurve = new Class({
              Extends: Curve,
              initialize: function SplineCurve2(points) {
                if (points === void 0) {
                  points = [];
                }
                Curve.call(this, "SplineCurve");
                this.points = [];
                this.addPoints(points);
              },
              addPoints: function(points) {
                for (var i = 0; i < points.length; i++) {
                  var p = new Vector2();
                  if (typeof points[i] === "number") {
                    p.x = points[i];
                    p.y = points[i + 1];
                    i++;
                  } else if (Array.isArray(points[i])) {
                    p.x = points[i][0];
                    p.y = points[i][1];
                  } else {
                    p.x = points[i].x;
                    p.y = points[i].y;
                  }
                  this.points.push(p);
                }
                return this;
              },
              addPoint: function(x, y) {
                var vec = new Vector2(x, y);
                this.points.push(vec);
                return vec;
              },
              getStartPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return out.copy(this.points[0]);
              },
              getResolution: function(divisions) {
                return divisions * this.points.length;
              },
              getPoint: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                var points = this.points;
                var point = (points.length - 1) * t;
                var intPoint = Math.floor(point);
                var weight = point - intPoint;
                var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
                var p1 = points[intPoint];
                var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
                var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
                return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
              },
              toJSON: function() {
                var points = [];
                for (var i = 0; i < this.points.length; i++) {
                  points.push(this.points[i].x);
                  points.push(this.points[i].y);
                }
                return {
                  type: this.type,
                  points
                };
              }
            });
            SplineCurve.fromJSON = function(data) {
              return new SplineCurve(data.points);
            };
            module2.exports = SplineCurve;
          },
          73962: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Path: __webpack_require__2(12822),
              MoveTo: __webpack_require__2(53639),
              CubicBezier: __webpack_require__2(63120),
              Curve: __webpack_require__2(38517),
              Ellipse: __webpack_require__2(48835),
              Line: __webpack_require__2(58084),
              QuadraticBezier: __webpack_require__2(64761),
              Spline: __webpack_require__2(11956)
            };
          },
          53639: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Vector2 = __webpack_require__2(93736);
            var MoveTo = new Class({
              initialize: function MoveTo2(x, y) {
                this.active = false;
                this.p0 = new Vector2(x, y);
              },
              getPoint: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return out.copy(this.p0);
              },
              getPointAt: function(u, out) {
                return this.getPoint(u, out);
              },
              getResolution: function() {
                return 1;
              },
              getLength: function() {
                return 0;
              },
              toJSON: function() {
                return {
                  type: "MoveTo",
                  points: [
                    this.p0.x,
                    this.p0.y
                  ]
                };
              }
            });
            module2.exports = MoveTo;
          },
          12822: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CubicBezierCurve = __webpack_require__2(63120);
            var EllipseCurve = __webpack_require__2(48835);
            var GameObjectFactory = __webpack_require__2(61286);
            var LineCurve = __webpack_require__2(58084);
            var MovePathTo = __webpack_require__2(53639);
            var QuadraticBezierCurve = __webpack_require__2(64761);
            var Rectangle = __webpack_require__2(74118);
            var SplineCurve = __webpack_require__2(11956);
            var Vector2 = __webpack_require__2(93736);
            var MATH_CONST = __webpack_require__2(83392);
            var Path = new Class({
              initialize: function Path2(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                this.name = "";
                this.defaultDivisions = 12;
                this.curves = [];
                this.cacheLengths = [];
                this.autoClose = false;
                this.startPoint = new Vector2();
                this._tmpVec2A = new Vector2();
                this._tmpVec2B = new Vector2();
                if (typeof x === "object") {
                  this.fromJSON(x);
                } else {
                  this.startPoint.set(x, y);
                }
              },
              add: function(curve) {
                this.curves.push(curve);
                return this;
              },
              circleTo: function(radius, clockwise, rotation) {
                if (clockwise === void 0) {
                  clockwise = false;
                }
                return this.ellipseTo(radius, radius, 0, 360, clockwise, rotation);
              },
              closePath: function() {
                var startPoint = this.curves[0].getPoint(0);
                var endPoint = this.curves[this.curves.length - 1].getPoint(1);
                if (!startPoint.equals(endPoint)) {
                  this.curves.push(new LineCurve(endPoint, startPoint));
                }
                return this;
              },
              cubicBezierTo: function(x, y, control1X, control1Y, control2X, control2Y) {
                var p0 = this.getEndPoint();
                var p1;
                var p2;
                var p3;
                if (x instanceof Vector2) {
                  p1 = x;
                  p2 = y;
                  p3 = control1X;
                } else {
                  p1 = new Vector2(control1X, control1Y);
                  p2 = new Vector2(control2X, control2Y);
                  p3 = new Vector2(x, y);
                }
                return this.add(new CubicBezierCurve(p0, p1, p2, p3));
              },
              quadraticBezierTo: function(x, y, controlX, controlY) {
                var p0 = this.getEndPoint();
                var p1;
                var p2;
                if (x instanceof Vector2) {
                  p1 = x;
                  p2 = y;
                } else {
                  p1 = new Vector2(controlX, controlY);
                  p2 = new Vector2(x, y);
                }
                return this.add(new QuadraticBezierCurve(p0, p1, p2));
              },
              draw: function(graphics, pointsTotal) {
                for (var i = 0; i < this.curves.length; i++) {
                  var curve = this.curves[i];
                  if (!curve.active) {
                    continue;
                  }
                  curve.draw(graphics, pointsTotal);
                }
                return graphics;
              },
              ellipseTo: function(xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
                var ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);
                var end = this.getEndPoint(this._tmpVec2A);
                var start = ellipse.getStartPoint(this._tmpVec2B);
                end.subtract(start);
                ellipse.x = end.x;
                ellipse.y = end.y;
                return this.add(ellipse);
              },
              fromJSON: function(data) {
                this.curves = [];
                this.cacheLengths = [];
                this.startPoint.set(data.x, data.y);
                this.autoClose = data.autoClose;
                for (var i = 0; i < data.curves.length; i++) {
                  var curve = data.curves[i];
                  switch (curve.type) {
                    case "LineCurve":
                      this.add(LineCurve.fromJSON(curve));
                      break;
                    case "EllipseCurve":
                      this.add(EllipseCurve.fromJSON(curve));
                      break;
                    case "SplineCurve":
                      this.add(SplineCurve.fromJSON(curve));
                      break;
                    case "CubicBezierCurve":
                      this.add(CubicBezierCurve.fromJSON(curve));
                      break;
                    case "QuadraticBezierCurve":
                      this.add(QuadraticBezierCurve.fromJSON(curve));
                      break;
                  }
                }
                return this;
              },
              getBounds: function(out, accuracy) {
                if (out === void 0) {
                  out = new Rectangle();
                }
                if (accuracy === void 0) {
                  accuracy = 16;
                }
                out.x = Number.MAX_VALUE;
                out.y = Number.MAX_VALUE;
                var bounds = new Rectangle();
                var maxRight = MATH_CONST.MIN_SAFE_INTEGER;
                var maxBottom = MATH_CONST.MIN_SAFE_INTEGER;
                for (var i = 0; i < this.curves.length; i++) {
                  var curve = this.curves[i];
                  if (!curve.active) {
                    continue;
                  }
                  curve.getBounds(bounds, accuracy);
                  out.x = Math.min(out.x, bounds.x);
                  out.y = Math.min(out.y, bounds.y);
                  maxRight = Math.max(maxRight, bounds.right);
                  maxBottom = Math.max(maxBottom, bounds.bottom);
                }
                out.right = maxRight;
                out.bottom = maxBottom;
                return out;
              },
              getCurveLengths: function() {
                if (this.cacheLengths.length === this.curves.length) {
                  return this.cacheLengths;
                }
                var lengths = [];
                var sums = 0;
                for (var i = 0; i < this.curves.length; i++) {
                  sums += this.curves[i].getLength();
                  lengths.push(sums);
                }
                this.cacheLengths = lengths;
                return lengths;
              },
              getCurveAt: function(t) {
                var d = t * this.getLength();
                var curveLengths = this.getCurveLengths();
                var i = 0;
                while (i < curveLengths.length) {
                  if (curveLengths[i] >= d) {
                    return this.curves[i];
                  }
                  i++;
                }
                return null;
              },
              getEndPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                if (this.curves.length > 0) {
                  this.curves[this.curves.length - 1].getPoint(1, out);
                } else {
                  out.copy(this.startPoint);
                }
                return out;
              },
              getLength: function() {
                var lens = this.getCurveLengths();
                return lens[lens.length - 1];
              },
              getPoint: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                var d = t * this.getLength();
                var curveLengths = this.getCurveLengths();
                var i = 0;
                while (i < curveLengths.length) {
                  if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d;
                    var curve = this.curves[i];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u, out);
                  }
                  i++;
                }
                return null;
              },
              getPoints: function(divisions, stepRate) {
                if (!divisions && !stepRate) {
                  divisions = this.defaultDivisions;
                }
                var points = [];
                var last;
                for (var i = 0; i < this.curves.length; i++) {
                  var curve = this.curves[i];
                  if (!curve.active) {
                    continue;
                  }
                  var resolution = curve.getResolution(divisions);
                  var pts = curve.getPoints(resolution, stepRate);
                  for (var j = 0; j < pts.length; j++) {
                    var point = pts[j];
                    if (last && last.equals(point)) {
                      continue;
                    }
                    points.push(point);
                    last = point;
                  }
                }
                if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                  points.push(points[0]);
                }
                return points;
              },
              getRandomPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return this.getPoint(Math.random(), out);
              },
              getSpacedPoints: function(divisions) {
                if (divisions === void 0) {
                  divisions = 40;
                }
                var points = [];
                for (var i = 0; i <= divisions; i++) {
                  points.push(this.getPoint(i / divisions));
                }
                if (this.autoClose) {
                  points.push(points[0]);
                }
                return points;
              },
              getStartPoint: function(out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                return out.copy(this.startPoint);
              },
              getTangent: function(t, out) {
                if (out === void 0) {
                  out = new Vector2();
                }
                var d = t * this.getLength();
                var curveLengths = this.getCurveLengths();
                var i = 0;
                while (i < curveLengths.length) {
                  if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d;
                    var curve = this.curves[i];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getTangentAt(u, out);
                  }
                  i++;
                }
                return null;
              },
              lineTo: function(x, y) {
                if (x instanceof Vector2) {
                  this._tmpVec2B.copy(x);
                } else {
                  this._tmpVec2B.set(x, y);
                }
                var end = this.getEndPoint(this._tmpVec2A);
                return this.add(new LineCurve([end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y]));
              },
              splineTo: function(points) {
                points.unshift(this.getEndPoint());
                return this.add(new SplineCurve(points));
              },
              moveTo: function(x, y) {
                if (x instanceof Vector2) {
                  return this.add(new MovePathTo(x.x, x.y));
                } else {
                  return this.add(new MovePathTo(x, y));
                }
              },
              toJSON: function() {
                var out = [];
                for (var i = 0; i < this.curves.length; i++) {
                  out.push(this.curves[i].toJSON());
                }
                return {
                  type: "Path",
                  x: this.startPoint.x,
                  y: this.startPoint.y,
                  autoClose: this.autoClose,
                  curves: out
                };
              },
              updateArcLengths: function() {
                this.cacheLengths = [];
                this.getCurveLengths();
              },
              destroy: function() {
                this.curves.length = 0;
                this.cacheLengths.length = 0;
                this.startPoint = void 0;
              }
            });
            GameObjectFactory.register("path", function(x, y) {
              return new Path(x, y);
            });
            module2.exports = Path;
          },
          81078: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(35026);
            var DataManager = new Class({
              initialize: function DataManager2(parent, eventEmitter) {
                this.parent = parent;
                this.events = eventEmitter;
                if (!eventEmitter) {
                  this.events = parent.events ? parent.events : parent;
                }
                this.list = {};
                this.values = {};
                this._frozen = false;
                if (!parent.hasOwnProperty("sys") && this.events) {
                  this.events.once(Events.DESTROY, this.destroy, this);
                }
              },
              get: function(key) {
                var list = this.list;
                if (Array.isArray(key)) {
                  var output = [];
                  for (var i = 0; i < key.length; i++) {
                    output.push(list[key[i]]);
                  }
                  return output;
                } else {
                  return list[key];
                }
              },
              getAll: function() {
                var results = {};
                for (var key in this.list) {
                  if (this.list.hasOwnProperty(key)) {
                    results[key] = this.list[key];
                  }
                }
                return results;
              },
              query: function(search) {
                var results = {};
                for (var key in this.list) {
                  if (this.list.hasOwnProperty(key) && key.match(search)) {
                    results[key] = this.list[key];
                  }
                }
                return results;
              },
              set: function(key, data) {
                if (this._frozen) {
                  return this;
                }
                if (typeof key === "string") {
                  return this.setValue(key, data);
                } else {
                  for (var entry in key) {
                    this.setValue(entry, key[entry]);
                  }
                }
                return this;
              },
              inc: function(key, amount) {
                if (this._frozen) {
                  return this;
                }
                if (amount === void 0) {
                  amount = 1;
                }
                var value = this.get(key);
                if (value === void 0) {
                  value = 0;
                }
                this.set(key, value + amount);
                return this;
              },
              toggle: function(key) {
                if (this._frozen) {
                  return this;
                }
                this.set(key, !this.get(key));
                return this;
              },
              setValue: function(key, data) {
                if (this._frozen) {
                  return this;
                }
                if (this.has(key)) {
                  this.values[key] = data;
                } else {
                  var _this = this;
                  var list = this.list;
                  var events = this.events;
                  var parent = this.parent;
                  Object.defineProperty(this.values, key, {
                    enumerable: true,
                    configurable: true,
                    get: function() {
                      return list[key];
                    },
                    set: function(value) {
                      if (!_this._frozen) {
                        var previousValue = list[key];
                        list[key] = value;
                        events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);
                        events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);
                      }
                    }
                  });
                  list[key] = data;
                  events.emit(Events.SET_DATA, parent, key, data);
                }
                return this;
              },
              each: function(callback, context) {
                var args = [this.parent, null, void 0];
                for (var i = 1; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                for (var key in this.list) {
                  args[1] = key;
                  args[2] = this.list[key];
                  callback.apply(context, args);
                }
                return this;
              },
              merge: function(data, overwrite) {
                if (overwrite === void 0) {
                  overwrite = true;
                }
                for (var key in data) {
                  if (data.hasOwnProperty(key) && (overwrite || !overwrite && !this.has(key))) {
                    this.setValue(key, data[key]);
                  }
                }
                return this;
              },
              remove: function(key) {
                if (this._frozen) {
                  return this;
                }
                if (Array.isArray(key)) {
                  for (var i = 0; i < key.length; i++) {
                    this.removeValue(key[i]);
                  }
                } else {
                  return this.removeValue(key);
                }
                return this;
              },
              removeValue: function(key) {
                if (this.has(key)) {
                  var data = this.list[key];
                  delete this.list[key];
                  delete this.values[key];
                  this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
                }
                return this;
              },
              pop: function(key) {
                var data = void 0;
                if (!this._frozen && this.has(key)) {
                  data = this.list[key];
                  delete this.list[key];
                  delete this.values[key];
                  this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
                }
                return data;
              },
              has: function(key) {
                return this.list.hasOwnProperty(key);
              },
              setFreeze: function(value) {
                this._frozen = value;
                return this;
              },
              reset: function() {
                for (var key in this.list) {
                  delete this.list[key];
                  delete this.values[key];
                }
                this._frozen = false;
                return this;
              },
              destroy: function() {
                this.reset();
                this.events.off(Events.CHANGE_DATA);
                this.events.off(Events.SET_DATA);
                this.events.off(Events.REMOVE_DATA);
                this.parent = null;
              },
              freeze: {
                get: function() {
                  return this._frozen;
                },
                set: function(value) {
                  this._frozen = value ? true : false;
                }
              },
              count: {
                get: function() {
                  var i = 0;
                  for (var key in this.list) {
                    if (this.list[key] !== void 0) {
                      i++;
                    }
                  }
                  return i;
                }
              }
            });
            module2.exports = DataManager;
          },
          76508: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var DataManager = __webpack_require__2(81078);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var DataManagerPlugin = new Class({
              Extends: DataManager,
              initialize: function DataManagerPlugin2(scene) {
                DataManager.call(this, scene, scene.sys.events);
                this.scene = scene;
                this.systems = scene.sys;
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                scene.sys.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.events = this.systems.events;
                this.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              shutdown: function() {
                this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                DataManager.prototype.destroy.call(this);
                this.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.systems = null;
              }
            });
            PluginCache.register("DataManagerPlugin", DataManagerPlugin, "data");
            module2.exports = DataManagerPlugin;
          },
          73569: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "changedata";
          },
          15590: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "changedata-";
          },
          37669: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "destroy";
          },
          87090: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "removedata";
          },
          90142: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "setdata";
          },
          35026: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              CHANGE_DATA: __webpack_require__2(73569),
              CHANGE_DATA_KEY: __webpack_require__2(15590),
              DESTROY: __webpack_require__2(37669),
              REMOVE_DATA: __webpack_require__2(87090),
              SET_DATA: __webpack_require__2(90142)
            };
          },
          1999: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              DataManager: __webpack_require__2(81078),
              DataManagerPlugin: __webpack_require__2(76508),
              Events: __webpack_require__2(35026)
            };
          },
          10720: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Browser = __webpack_require__2(1350);
            var Audio2 = {
              flac: false,
              aac: false,
              audioData: false,
              dolby: false,
              m4a: false,
              mp3: false,
              ogg: false,
              opus: false,
              wav: false,
              webAudio: false,
              webm: false
            };
            function init() {
              if (typeof importScripts === "function") {
                return Audio2;
              }
              Audio2.audioData = !!window["Audio"];
              Audio2.webAudio = !!(window["AudioContext"] || window["webkitAudioContext"]);
              var audioElement = document.createElement("audio");
              var result = !!audioElement.canPlayType;
              try {
                if (result) {
                  var CanPlay = function(type1, type2) {
                    var canPlayType1 = audioElement.canPlayType("audio/" + type1).replace(/^no$/, "");
                    if (type2) {
                      return Boolean(canPlayType1 || audioElement.canPlayType("audio/" + type2).replace(/^no$/, ""));
                    } else {
                      return Boolean(canPlayType1);
                    }
                  };
                  Audio2.ogg = CanPlay('ogg; codecs="vorbis"');
                  Audio2.opus = CanPlay('ogg; codecs="opus"', "opus");
                  Audio2.mp3 = CanPlay("mpeg");
                  Audio2.wav = CanPlay("wav");
                  Audio2.m4a = CanPlay("x-m4a");
                  Audio2.aac = CanPlay("aac");
                  Audio2.flac = CanPlay("flac", "x-flac");
                  Audio2.webm = CanPlay('webm; codecs="vorbis"');
                  if (audioElement.canPlayType('audio/mp4; codecs="ec-3"') !== "") {
                    if (Browser.edge) {
                      Audio2.dolby = true;
                    } else if (Browser.safari && Browser.safariVersion >= 9) {
                      if (/Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var major = parseInt(RegExp.$1, 10);
                        var minor = parseInt(RegExp.$2, 10);
                        if (major === 10 && minor >= 11 || major > 10) {
                          Audio2.dolby = true;
                        }
                      }
                    }
                  }
                }
              } catch (e) {
              }
              return Audio2;
            }
            module2.exports = init();
          },
          1350: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var OS = __webpack_require__2(36580);
            var Browser = {
              chrome: false,
              chromeVersion: 0,
              edge: false,
              firefox: false,
              firefoxVersion: 0,
              ie: false,
              ieVersion: 0,
              mobileSafari: false,
              opera: false,
              safari: false,
              safariVersion: 0,
              silk: false,
              trident: false,
              tridentVersion: 0,
              es2019: false
            };
            function init() {
              var ua = navigator.userAgent;
              if (/Edg\/\d+/.test(ua)) {
                Browser.edge = true;
                Browser.es2019 = true;
              } else if (/OPR/.test(ua)) {
                Browser.opera = true;
                Browser.es2019 = true;
              } else if (/Chrome\/(\d+)/.test(ua) && !OS.windowsPhone) {
                Browser.chrome = true;
                Browser.chromeVersion = parseInt(RegExp.$1, 10);
                Browser.es2019 = Browser.chromeVersion > 69;
              } else if (/Firefox\D+(\d+)/.test(ua)) {
                Browser.firefox = true;
                Browser.firefoxVersion = parseInt(RegExp.$1, 10);
                Browser.es2019 = Browser.firefoxVersion > 10;
              } else if (/AppleWebKit/.test(ua) && OS.iOS) {
                Browser.mobileSafari = true;
                Browser.es2019 = true;
              } else if (/MSIE (\d+\.\d+);/.test(ua)) {
                Browser.ie = true;
                Browser.ieVersion = parseInt(RegExp.$1, 10);
              } else if (/Version\/(\d+\.\d+) Safari/.test(ua) && !OS.windowsPhone) {
                Browser.safari = true;
                Browser.safariVersion = parseInt(RegExp.$1, 10);
                Browser.es2019 = Browser.safariVersion > 10;
              } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) {
                Browser.ie = true;
                Browser.trident = true;
                Browser.tridentVersion = parseInt(RegExp.$1, 10);
                Browser.ieVersion = parseInt(RegExp.$3, 10);
              }
              if (/Silk/.test(ua)) {
                Browser.silk = true;
              }
              return Browser;
            }
            module2.exports = init();
          },
          98581: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasPool = __webpack_require__2(61068);
            var CanvasFeatures = {
              supportInverseAlpha: false,
              supportNewBlendModes: false
            };
            function checkBlendMode() {
              var pngHead = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/";
              var pngEnd = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
              var magenta = new Image();
              magenta.onload = function() {
                var yellow = new Image();
                yellow.onload = function() {
                  var canvas = CanvasPool.create2D(yellow, 6);
                  var context = canvas.getContext("2d", {willReadFrequently: true});
                  context.globalCompositeOperation = "multiply";
                  context.drawImage(magenta, 0, 0);
                  context.drawImage(yellow, 2, 0);
                  if (!context.getImageData(2, 0, 1, 1)) {
                    return false;
                  }
                  var data = context.getImageData(2, 0, 1, 1).data;
                  CanvasPool.remove(yellow);
                  CanvasFeatures.supportNewBlendModes = data[0] === 255 && data[1] === 0 && data[2] === 0;
                };
                yellow.src = pngHead + "/wCKxvRF" + pngEnd;
              };
              magenta.src = pngHead + "AP804Oa6" + pngEnd;
              return false;
            }
            function checkInverseAlpha() {
              var canvas = CanvasPool.create2D(this, 2);
              var context = canvas.getContext("2d", {willReadFrequently: true});
              context.fillStyle = "rgba(10, 20, 30, 0.5)";
              context.fillRect(0, 0, 1, 1);
              var s1 = context.getImageData(0, 0, 1, 1);
              if (s1 === null) {
                return false;
              }
              context.putImageData(s1, 1, 0);
              var s2 = context.getImageData(1, 0, 1, 1);
              var result = s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3];
              CanvasPool.remove(this);
              return result;
            }
            function init() {
              if (typeof importScripts !== "function" && document !== void 0) {
                CanvasFeatures.supportNewBlendModes = checkBlendMode();
                CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
              }
              return CanvasFeatures;
            }
            module2.exports = init();
          },
          90185: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var OS = __webpack_require__2(36580);
            var Browser = __webpack_require__2(1350);
            var CanvasPool = __webpack_require__2(61068);
            var Features = {
              canvas: false,
              canvasBitBltShift: null,
              file: false,
              fileSystem: false,
              getUserMedia: true,
              littleEndian: false,
              localStorage: false,
              pointerLock: false,
              stableSort: false,
              support32bit: false,
              vibration: false,
              webGL: false,
              worker: false
            };
            function checkIsLittleEndian() {
              var a = new ArrayBuffer(4);
              var b = new Uint8Array(a);
              var c = new Uint32Array(a);
              b[0] = 161;
              b[1] = 178;
              b[2] = 195;
              b[3] = 212;
              if (c[0] === 3569595041) {
                return true;
              }
              if (c[0] === 2712847316) {
                return false;
              } else {
                return null;
              }
            }
            function init() {
              if (typeof importScripts === "function") {
                return Features;
              }
              Features.canvas = !!window["CanvasRenderingContext2D"];
              try {
                Features.localStorage = !!localStorage.getItem;
              } catch (error) {
                Features.localStorage = false;
              }
              Features.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
              Features.fileSystem = !!window["requestFileSystem"];
              var isUint8 = false;
              var testWebGL = function() {
                if (window["WebGLRenderingContext"]) {
                  try {
                    var canvas = CanvasPool.createWebGL(this);
                    var ctx = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                    var canvas2D = CanvasPool.create2D(this);
                    var ctx2D = canvas2D.getContext("2d", {willReadFrequently: true});
                    var image = ctx2D.createImageData(1, 1);
                    isUint8 = image.data instanceof Uint8ClampedArray;
                    CanvasPool.remove(canvas);
                    CanvasPool.remove(canvas2D);
                    return !!ctx;
                  } catch (e) {
                    return false;
                  }
                }
                return false;
              };
              Features.webGL = testWebGL();
              Features.worker = !!window["Worker"];
              Features.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
              navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
              window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
              Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;
              if (Browser.firefox && Browser.firefoxVersion < 21) {
                Features.getUserMedia = false;
              }
              if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome)) {
                Features.canvasBitBltShift = true;
              }
              if (Browser.safari || Browser.mobileSafari) {
                Features.canvasBitBltShift = false;
              }
              navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
              if (navigator.vibrate) {
                Features.vibration = true;
              }
              if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
                Features.littleEndian = checkIsLittleEndian();
              }
              Features.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && Features.littleEndian !== null && isUint8;
              return Features;
            }
            module2.exports = init();
          },
          33553: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Fullscreen = {
              available: false,
              cancel: "",
              keyboard: false,
              request: ""
            };
            function init() {
              if (typeof importScripts === "function") {
                return Fullscreen;
              }
              var i;
              var suffix1 = "Fullscreen";
              var suffix2 = "FullScreen";
              var fs = [
                "request" + suffix1,
                "request" + suffix2,
                "webkitRequest" + suffix1,
                "webkitRequest" + suffix2,
                "msRequest" + suffix1,
                "msRequest" + suffix2,
                "mozRequest" + suffix2,
                "mozRequest" + suffix1
              ];
              for (i = 0; i < fs.length; i++) {
                if (document.documentElement[fs[i]]) {
                  Fullscreen.available = true;
                  Fullscreen.request = fs[i];
                  break;
                }
              }
              var cfs = [
                "cancel" + suffix2,
                "exit" + suffix1,
                "webkitCancel" + suffix2,
                "webkitExit" + suffix1,
                "msCancel" + suffix2,
                "msExit" + suffix1,
                "mozCancel" + suffix2,
                "mozExit" + suffix1
              ];
              if (Fullscreen.available) {
                for (i = 0; i < cfs.length; i++) {
                  if (document[cfs[i]]) {
                    Fullscreen.cancel = cfs[i];
                    break;
                  }
                }
              }
              if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"] && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent)) {
                Fullscreen.keyboard = true;
              }
              Object.defineProperty(Fullscreen, "active", {get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
              }});
              return Fullscreen;
            }
            module2.exports = init();
          },
          95872: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Browser = __webpack_require__2(1350);
            var Input = {
              gamepads: false,
              mspointer: false,
              touch: false,
              wheelEvent: null
            };
            function init() {
              if (typeof importScripts === "function") {
                return Input;
              }
              if ("ontouchstart" in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) {
                Input.touch = true;
              }
              if (navigator.msPointerEnabled || navigator.pointerEnabled) {
                Input.mspointer = true;
              }
              if (navigator.getGamepads) {
                Input.gamepads = true;
              }
              if ("onwheel" in window || Browser.ie && "WheelEvent" in window) {
                Input.wheelEvent = "wheel";
              } else if ("onmousewheel" in window) {
                Input.wheelEvent = "mousewheel";
              } else if (Browser.firefox && "MouseScrollEvent" in window) {
                Input.wheelEvent = "DOMMouseScroll";
              }
              return Input;
            }
            module2.exports = init();
          },
          36580: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var OS = {
              android: false,
              chromeOS: false,
              cordova: false,
              crosswalk: false,
              desktop: false,
              ejecta: false,
              electron: false,
              iOS: false,
              iOSVersion: 0,
              iPad: false,
              iPhone: false,
              kindle: false,
              linux: false,
              macOS: false,
              node: false,
              nodeWebkit: false,
              pixelRatio: 1,
              webApp: false,
              windows: false,
              windowsPhone: false
            };
            function init() {
              if (typeof importScripts === "function") {
                return OS;
              }
              var ua = navigator.userAgent;
              if (/Windows/.test(ua)) {
                OS.windows = true;
              } else if (/Mac OS/.test(ua) && !/like Mac OS/.test(ua)) {
                if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) {
                  OS.iOS = true;
                  OS.iPad = true;
                  navigator.appVersion.match(/Version\/(\d+)/);
                  OS.iOSVersion = parseInt(RegExp.$1, 10);
                } else {
                  OS.macOS = true;
                }
              } else if (/Android/.test(ua)) {
                OS.android = true;
              } else if (/Linux/.test(ua)) {
                OS.linux = true;
              } else if (/iP[ao]d|iPhone/i.test(ua)) {
                OS.iOS = true;
                navigator.appVersion.match(/OS (\d+)/);
                OS.iOSVersion = parseInt(RegExp.$1, 10);
                OS.iPhone = ua.toLowerCase().indexOf("iphone") !== -1;
                OS.iPad = ua.toLowerCase().indexOf("ipad") !== -1;
              } else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) {
                OS.kindle = true;
              } else if (/CrOS/.test(ua)) {
                OS.chromeOS = true;
              }
              if (/Windows Phone/i.test(ua) || /IEMobile/i.test(ua)) {
                OS.android = false;
                OS.iOS = false;
                OS.macOS = false;
                OS.windows = true;
                OS.windowsPhone = true;
              }
              var silk = /Silk/.test(ua);
              if (OS.windows || OS.macOS || OS.linux && !silk || OS.chromeOS) {
                OS.desktop = true;
              }
              if (OS.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) {
                OS.desktop = false;
              }
              if (navigator.standalone) {
                OS.webApp = true;
              }
              if (typeof importScripts !== "function") {
                if (window.cordova !== void 0) {
                  OS.cordova = true;
                }
                if (window.ejecta !== void 0) {
                  OS.ejecta = true;
                }
              }
              if (typeof process !== "undefined" && process.versions && process.versions.node) {
                OS.node = true;
              }
              if (OS.node && typeof process.versions === "object") {
                OS.nodeWebkit = !!process.versions["node-webkit"];
                OS.electron = !!process.versions.electron;
              }
              if (/Crosswalk/.test(ua)) {
                OS.crosswalk = true;
              }
              OS.pixelRatio = window["devicePixelRatio"] || 1;
              return OS;
            }
            module2.exports = init();
          },
          53861: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var Video = {
              h264: false,
              hls: false,
              mp4: false,
              m4v: false,
              ogg: false,
              vp9: false,
              webm: false,
              hasRequestVideoFrame: false
            };
            function init() {
              if (typeof importScripts === "function") {
                return Video;
              }
              var videoElement = document.createElement("video");
              var result = !!videoElement.canPlayType;
              var no = /^no$/;
              try {
                if (result) {
                  if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(no, "")) {
                    Video.ogg = true;
                  }
                  if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(no, "")) {
                    Video.h264 = true;
                    Video.mp4 = true;
                  }
                  if (videoElement.canPlayType("video/x-m4v").replace(no, "")) {
                    Video.m4v = true;
                  }
                  if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(no, "")) {
                    Video.webm = true;
                  }
                  if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(no, "")) {
                    Video.vp9 = true;
                  }
                  if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(no, "")) {
                    Video.hls = true;
                  }
                }
              } catch (e) {
              }
              if (videoElement.parentNode) {
                videoElement.parentNode.removeChild(videoElement);
              }
              Video.getVideoURL = function(urls) {
                if (!Array.isArray(urls)) {
                  urls = [urls];
                }
                for (var i = 0; i < urls.length; i++) {
                  var url = GetFastValue(urls[i], "url", urls[i]);
                  if (url.indexOf("blob:") === 0) {
                    return {
                      url,
                      type: ""
                    };
                  }
                  var videoType;
                  if (url.indexOf("data:") === 0) {
                    videoType = url.split(",")[0].match(/\/(.*?);/);
                  } else {
                    videoType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
                  }
                  videoType = GetFastValue(urls[i], "type", videoType ? videoType[1] : "").toLowerCase();
                  if (Video[videoType]) {
                    return {
                      url,
                      type: videoType
                    };
                  }
                }
                return null;
              };
              return Video;
            }
            module2.exports = init();
          },
          77290: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              os: __webpack_require__2(36580),
              browser: __webpack_require__2(1350),
              features: __webpack_require__2(90185),
              input: __webpack_require__2(95872),
              audio: __webpack_require__2(10720),
              video: __webpack_require__2(53861),
              fullscreen: __webpack_require__2(33553),
              canvasFeatures: __webpack_require__2(98581)
            };
          },
          65246: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var tempMatrix = new Float32Array(20);
            var ColorMatrix = new Class({
              initialize: function ColorMatrix2() {
                this._matrix = new Float32Array(20);
                this.alpha = 1;
                this._dirty = true;
                this._data = new Float32Array(20);
                this.reset();
              },
              set: function(value) {
                this._matrix.set(value);
                this._dirty = true;
                return this;
              },
              reset: function() {
                var m = this._matrix;
                m.fill(0);
                m[0] = 1;
                m[6] = 1;
                m[12] = 1;
                m[18] = 1;
                this.alpha = 1;
                this._dirty = true;
                return this;
              },
              getData: function() {
                var data = this._data;
                if (this._dirty) {
                  data.set(this._matrix);
                  data[4] /= 255;
                  data[9] /= 255;
                  data[14] /= 255;
                  data[19] /= 255;
                  this._dirty = false;
                }
                return data;
              },
              brightness: function(value, multiply) {
                if (value === void 0) {
                  value = 0;
                }
                if (multiply === void 0) {
                  multiply = false;
                }
                var b = value;
                return this.multiply([
                  b,
                  0,
                  0,
                  0,
                  0,
                  0,
                  b,
                  0,
                  0,
                  0,
                  0,
                  0,
                  b,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0
                ], multiply);
              },
              saturate: function(value, multiply) {
                if (value === void 0) {
                  value = 0;
                }
                if (multiply === void 0) {
                  multiply = false;
                }
                var x = value * 2 / 3 + 1;
                var y = (x - 1) * -0.5;
                return this.multiply([
                  x,
                  y,
                  y,
                  0,
                  0,
                  y,
                  x,
                  y,
                  0,
                  0,
                  y,
                  y,
                  x,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0
                ], multiply);
              },
              desaturate: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.saturate(-1, multiply);
              },
              hue: function(rotation, multiply) {
                if (rotation === void 0) {
                  rotation = 0;
                }
                if (multiply === void 0) {
                  multiply = false;
                }
                rotation = rotation / 180 * Math.PI;
                var cos = Math.cos(rotation);
                var sin = Math.sin(rotation);
                var lumR = 0.213;
                var lumG = 0.715;
                var lumB = 0.072;
                return this.multiply([
                  lumR + cos * (1 - lumR) + sin * -lumR,
                  lumG + cos * -lumG + sin * -lumG,
                  lumB + cos * -lumB + sin * (1 - lumB),
                  0,
                  0,
                  lumR + cos * -lumR + sin * 0.143,
                  lumG + cos * (1 - lumG) + sin * 0.14,
                  lumB + cos * -lumB + sin * -0.283,
                  0,
                  0,
                  lumR + cos * -lumR + sin * -(1 - lumR),
                  lumG + cos * -lumG + sin * lumG,
                  lumB + cos * (1 - lumB) + sin * lumB,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0
                ], multiply);
              },
              grayscale: function(value, multiply) {
                if (value === void 0) {
                  value = 1;
                }
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.saturate(-value, multiply);
              },
              blackWhite: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.BLACK_WHITE, multiply);
              },
              contrast: function(value, multiply) {
                if (value === void 0) {
                  value = 0;
                }
                if (multiply === void 0) {
                  multiply = false;
                }
                var v = value + 1;
                var o = -0.5 * (v - 1);
                return this.multiply([
                  v,
                  0,
                  0,
                  0,
                  o,
                  0,
                  v,
                  0,
                  0,
                  o,
                  0,
                  0,
                  v,
                  0,
                  o,
                  0,
                  0,
                  0,
                  1,
                  0
                ], multiply);
              },
              negative: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.NEGATIVE, multiply);
              },
              desaturateLuminance: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.DESATURATE_LUMINANCE, multiply);
              },
              sepia: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.SEPIA, multiply);
              },
              night: function(intensity, multiply) {
                if (intensity === void 0) {
                  intensity = 0.1;
                }
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply([
                  intensity * -2,
                  -intensity,
                  0,
                  0,
                  0,
                  -intensity,
                  0,
                  intensity,
                  0,
                  0,
                  0,
                  intensity,
                  intensity * 2,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0
                ], multiply);
              },
              lsd: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.LSD, multiply);
              },
              brown: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.BROWN, multiply);
              },
              vintagePinhole: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.VINTAGE, multiply);
              },
              kodachrome: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.KODACHROME, multiply);
              },
              technicolor: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.TECHNICOLOR, multiply);
              },
              polaroid: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.POLAROID, multiply);
              },
              shiftToBGR: function(multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                return this.multiply(ColorMatrix.SHIFT_BGR, multiply);
              },
              multiply: function(a, multiply) {
                if (multiply === void 0) {
                  multiply = false;
                }
                if (!multiply) {
                  this.reset();
                }
                var m = this._matrix;
                var c = tempMatrix;
                c.set(m);
                m.set([
                  c[0] * a[0] + c[1] * a[5] + c[2] * a[10] + c[3] * a[15],
                  c[0] * a[1] + c[1] * a[6] + c[2] * a[11] + c[3] * a[16],
                  c[0] * a[2] + c[1] * a[7] + c[2] * a[12] + c[3] * a[17],
                  c[0] * a[3] + c[1] * a[8] + c[2] * a[13] + c[3] * a[18],
                  c[0] * a[4] + c[1] * a[9] + c[2] * a[14] + c[3] * a[19] + c[4],
                  c[5] * a[0] + c[6] * a[5] + c[7] * a[10] + c[8] * a[15],
                  c[5] * a[1] + c[6] * a[6] + c[7] * a[11] + c[8] * a[16],
                  c[5] * a[2] + c[6] * a[7] + c[7] * a[12] + c[8] * a[17],
                  c[5] * a[3] + c[6] * a[8] + c[7] * a[13] + c[8] * a[18],
                  c[5] * a[4] + c[6] * a[9] + c[7] * a[14] + c[8] * a[19] + c[9],
                  c[10] * a[0] + c[11] * a[5] + c[12] * a[10] + c[13] * a[15],
                  c[10] * a[1] + c[11] * a[6] + c[12] * a[11] + c[13] * a[16],
                  c[10] * a[2] + c[11] * a[7] + c[12] * a[12] + c[13] * a[17],
                  c[10] * a[3] + c[11] * a[8] + c[12] * a[13] + c[13] * a[18],
                  c[10] * a[4] + c[11] * a[9] + c[12] * a[14] + c[13] * a[19] + c[14],
                  c[15] * a[0] + c[16] * a[5] + c[17] * a[10] + c[18] * a[15],
                  c[15] * a[1] + c[16] * a[6] + c[17] * a[11] + c[18] * a[16],
                  c[15] * a[2] + c[16] * a[7] + c[17] * a[12] + c[18] * a[17],
                  c[15] * a[3] + c[16] * a[8] + c[17] * a[13] + c[18] * a[18],
                  c[15] * a[4] + c[16] * a[9] + c[17] * a[14] + c[18] * a[19] + c[19]
                ]);
                this._dirty = true;
                return this;
              }
            });
            ColorMatrix.BLACK_WHITE = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0];
            ColorMatrix.NEGATIVE = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
            ColorMatrix.DESATURATE_LUMINANCE = [0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0];
            ColorMatrix.SEPIA = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0];
            ColorMatrix.LSD = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0];
            ColorMatrix.BROWN = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
            ColorMatrix.VINTAGE = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
            ColorMatrix.KODACHROME = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
            ColorMatrix.TECHNICOLOR = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
            ColorMatrix.POLAROID = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
            ColorMatrix.SHIFT_BGR = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
            module2.exports = ColorMatrix;
          },
          39298: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var NOOP = __webpack_require__2(72283);
            var RGB = new Class({
              initialize: function RGB2(red, green, blue) {
                this._rgb = [0, 0, 0];
                this.onChangeCallback = NOOP;
                this.dirty = false;
                this.set(red, green, blue);
              },
              set: function(red, green, blue) {
                if (red === void 0) {
                  red = 0;
                }
                if (green === void 0) {
                  green = 0;
                }
                if (blue === void 0) {
                  blue = 0;
                }
                this._rgb = [red, green, blue];
                this.onChange();
                return this;
              },
              equals: function(red, green, blue) {
                var rgb = this._rgb;
                return rgb[0] === red && rgb[1] === green && rgb[2] === blue;
              },
              onChange: function() {
                this.dirty = true;
                var rgb = this._rgb;
                this.onChangeCallback.call(this, rgb[0], rgb[1], rgb[2]);
              },
              r: {
                get: function() {
                  return this._rgb[0];
                },
                set: function(value) {
                  this._rgb[0] = value;
                  this.onChange();
                }
              },
              g: {
                get: function() {
                  return this._rgb[1];
                },
                set: function(value) {
                  this._rgb[1] = value;
                  this.onChange();
                }
              },
              b: {
                get: function() {
                  return this._rgb[2];
                },
                set: function(value) {
                  this._rgb[2] = value;
                  this.onChange();
                }
              },
              destroy: function() {
                this.onChangeCallback = null;
              }
            });
            module2.exports = RGB;
          },
          84093: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ALIGN_CONST = {
              TOP_LEFT: 0,
              TOP_CENTER: 1,
              TOP_RIGHT: 2,
              LEFT_TOP: 3,
              LEFT_CENTER: 4,
              LEFT_BOTTOM: 5,
              CENTER: 6,
              RIGHT_TOP: 7,
              RIGHT_CENTER: 8,
              RIGHT_BOTTOM: 9,
              BOTTOM_LEFT: 10,
              BOTTOM_CENTER: 11,
              BOTTOM_RIGHT: 12
            };
            module2.exports = ALIGN_CONST;
          },
          32058: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetCenterX = __webpack_require__2(59994);
            var SetBottom = __webpack_require__2(73174);
            var SetCenterX = __webpack_require__2(28417);
            var BottomCenter = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
              SetBottom(gameObject, GetBottom(alignIn) + offsetY);
              return gameObject;
            };
            module2.exports = BottomCenter;
          },
          85535: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetLeft = __webpack_require__2(40163);
            var SetBottom = __webpack_require__2(73174);
            var SetLeft = __webpack_require__2(74465);
            var BottomLeft = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetLeft(gameObject, GetLeft(alignIn) - offsetX);
              SetBottom(gameObject, GetBottom(alignIn) + offsetY);
              return gameObject;
            };
            module2.exports = BottomLeft;
          },
          9605: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetRight = __webpack_require__2(70271);
            var SetBottom = __webpack_require__2(73174);
            var SetRight = __webpack_require__2(19298);
            var BottomRight = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetRight(gameObject, GetRight(alignIn) + offsetX);
              SetBottom(gameObject, GetBottom(alignIn) + offsetY);
              return gameObject;
            };
            module2.exports = BottomRight;
          },
          22529: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CenterOn = __webpack_require__2(21843);
            var GetCenterX = __webpack_require__2(59994);
            var GetCenterY = __webpack_require__2(29568);
            var Center = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
              return gameObject;
            };
            module2.exports = Center;
          },
          5739: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCenterY = __webpack_require__2(29568);
            var GetLeft = __webpack_require__2(40163);
            var SetCenterY = __webpack_require__2(81711);
            var SetLeft = __webpack_require__2(74465);
            var LeftCenter = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetLeft(gameObject, GetLeft(alignIn) - offsetX);
              SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
              return gameObject;
            };
            module2.exports = LeftCenter;
          },
          40327: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ALIGN_CONST = __webpack_require__2(84093);
            var AlignInMap = [];
            AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__2(32058);
            AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__2(85535);
            AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__2(9605);
            AlignInMap[ALIGN_CONST.CENTER] = __webpack_require__2(22529);
            AlignInMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__2(5739);
            AlignInMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__2(27683);
            AlignInMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__2(96439);
            AlignInMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__2(81447);
            AlignInMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__2(47888);
            AlignInMap[ALIGN_CONST.LEFT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_LEFT];
            AlignInMap[ALIGN_CONST.LEFT_TOP] = AlignInMap[ALIGN_CONST.TOP_LEFT];
            AlignInMap[ALIGN_CONST.RIGHT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_RIGHT];
            AlignInMap[ALIGN_CONST.RIGHT_TOP] = AlignInMap[ALIGN_CONST.TOP_RIGHT];
            var QuickSet = function(child, alignIn, position, offsetX, offsetY) {
              return AlignInMap[position](child, alignIn, offsetX, offsetY);
            };
            module2.exports = QuickSet;
          },
          27683: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCenterY = __webpack_require__2(29568);
            var GetRight = __webpack_require__2(70271);
            var SetCenterY = __webpack_require__2(81711);
            var SetRight = __webpack_require__2(19298);
            var RightCenter = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetRight(gameObject, GetRight(alignIn) + offsetX);
              SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
              return gameObject;
            };
            module2.exports = RightCenter;
          },
          96439: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCenterX = __webpack_require__2(59994);
            var GetTop = __webpack_require__2(47196);
            var SetCenterX = __webpack_require__2(28417);
            var SetTop = __webpack_require__2(84349);
            var TopCenter = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
              SetTop(gameObject, GetTop(alignIn) - offsetY);
              return gameObject;
            };
            module2.exports = TopCenter;
          },
          81447: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLeft = __webpack_require__2(40163);
            var GetTop = __webpack_require__2(47196);
            var SetLeft = __webpack_require__2(74465);
            var SetTop = __webpack_require__2(84349);
            var TopLeft = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetLeft(gameObject, GetLeft(alignIn) - offsetX);
              SetTop(gameObject, GetTop(alignIn) - offsetY);
              return gameObject;
            };
            module2.exports = TopLeft;
          },
          47888: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetRight = __webpack_require__2(70271);
            var GetTop = __webpack_require__2(47196);
            var SetRight = __webpack_require__2(19298);
            var SetTop = __webpack_require__2(84349);
            var TopRight = function(gameObject, alignIn, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetRight(gameObject, GetRight(alignIn) + offsetX);
              SetTop(gameObject, GetTop(alignIn) - offsetY);
              return gameObject;
            };
            module2.exports = TopRight;
          },
          46997: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BottomCenter: __webpack_require__2(32058),
              BottomLeft: __webpack_require__2(85535),
              BottomRight: __webpack_require__2(9605),
              Center: __webpack_require__2(22529),
              LeftCenter: __webpack_require__2(5739),
              QuickSet: __webpack_require__2(40327),
              RightCenter: __webpack_require__2(27683),
              TopCenter: __webpack_require__2(96439),
              TopLeft: __webpack_require__2(81447),
              TopRight: __webpack_require__2(47888)
            };
          },
          93545: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(84093);
            var Extend = __webpack_require__2(98611);
            var Align = {
              In: __webpack_require__2(46997),
              To: __webpack_require__2(86639)
            };
            Align = Extend(false, Align, CONST);
            module2.exports = Align;
          },
          27118: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetCenterX = __webpack_require__2(59994);
            var SetCenterX = __webpack_require__2(28417);
            var SetTop = __webpack_require__2(84349);
            var BottomCenter = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
              SetTop(gameObject, GetBottom(alignTo) + offsetY);
              return gameObject;
            };
            module2.exports = BottomCenter;
          },
          84469: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetLeft = __webpack_require__2(40163);
            var SetLeft = __webpack_require__2(74465);
            var SetTop = __webpack_require__2(84349);
            var BottomLeft = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetLeft(gameObject, GetLeft(alignTo) - offsetX);
              SetTop(gameObject, GetBottom(alignTo) + offsetY);
              return gameObject;
            };
            module2.exports = BottomLeft;
          },
          51577: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetRight = __webpack_require__2(70271);
            var SetRight = __webpack_require__2(19298);
            var SetTop = __webpack_require__2(84349);
            var BottomRight = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetRight(gameObject, GetRight(alignTo) + offsetX);
              SetTop(gameObject, GetBottom(alignTo) + offsetY);
              return gameObject;
            };
            module2.exports = BottomRight;
          },
          90271: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetLeft = __webpack_require__2(40163);
            var SetBottom = __webpack_require__2(73174);
            var SetRight = __webpack_require__2(19298);
            var LeftBottom = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetRight(gameObject, GetLeft(alignTo) - offsetX);
              SetBottom(gameObject, GetBottom(alignTo) + offsetY);
              return gameObject;
            };
            module2.exports = LeftBottom;
          },
          30466: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCenterY = __webpack_require__2(29568);
            var GetLeft = __webpack_require__2(40163);
            var SetCenterY = __webpack_require__2(81711);
            var SetRight = __webpack_require__2(19298);
            var LeftCenter = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetRight(gameObject, GetLeft(alignTo) - offsetX);
              SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
              return gameObject;
            };
            module2.exports = LeftCenter;
          },
          50087: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLeft = __webpack_require__2(40163);
            var GetTop = __webpack_require__2(47196);
            var SetRight = __webpack_require__2(19298);
            var SetTop = __webpack_require__2(84349);
            var LeftTop = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetRight(gameObject, GetLeft(alignTo) - offsetX);
              SetTop(gameObject, GetTop(alignTo) - offsetY);
              return gameObject;
            };
            module2.exports = LeftTop;
          },
          82590: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ALIGN_CONST = __webpack_require__2(84093);
            var AlignToMap = [];
            AlignToMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__2(27118);
            AlignToMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__2(84469);
            AlignToMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__2(51577);
            AlignToMap[ALIGN_CONST.LEFT_BOTTOM] = __webpack_require__2(90271);
            AlignToMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__2(30466);
            AlignToMap[ALIGN_CONST.LEFT_TOP] = __webpack_require__2(50087);
            AlignToMap[ALIGN_CONST.RIGHT_BOTTOM] = __webpack_require__2(13555);
            AlignToMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__2(99049);
            AlignToMap[ALIGN_CONST.RIGHT_TOP] = __webpack_require__2(67788);
            AlignToMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__2(78170);
            AlignToMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__2(54145);
            AlignToMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__2(75548);
            var QuickSet = function(child, alignTo, position, offsetX, offsetY) {
              return AlignToMap[position](child, alignTo, offsetX, offsetY);
            };
            module2.exports = QuickSet;
          },
          13555: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetRight = __webpack_require__2(70271);
            var SetBottom = __webpack_require__2(73174);
            var SetLeft = __webpack_require__2(74465);
            var RightBottom = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetLeft(gameObject, GetRight(alignTo) + offsetX);
              SetBottom(gameObject, GetBottom(alignTo) + offsetY);
              return gameObject;
            };
            module2.exports = RightBottom;
          },
          99049: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCenterY = __webpack_require__2(29568);
            var GetRight = __webpack_require__2(70271);
            var SetCenterY = __webpack_require__2(81711);
            var SetLeft = __webpack_require__2(74465);
            var RightCenter = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetLeft(gameObject, GetRight(alignTo) + offsetX);
              SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
              return gameObject;
            };
            module2.exports = RightCenter;
          },
          67788: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetRight = __webpack_require__2(70271);
            var GetTop = __webpack_require__2(47196);
            var SetLeft = __webpack_require__2(74465);
            var SetTop = __webpack_require__2(84349);
            var RightTop = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetLeft(gameObject, GetRight(alignTo) + offsetX);
              SetTop(gameObject, GetTop(alignTo) - offsetY);
              return gameObject;
            };
            module2.exports = RightTop;
          },
          78170: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCenterX = __webpack_require__2(59994);
            var GetTop = __webpack_require__2(47196);
            var SetBottom = __webpack_require__2(73174);
            var SetCenterX = __webpack_require__2(28417);
            var TopCenter = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
              SetBottom(gameObject, GetTop(alignTo) - offsetY);
              return gameObject;
            };
            module2.exports = TopCenter;
          },
          54145: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLeft = __webpack_require__2(40163);
            var GetTop = __webpack_require__2(47196);
            var SetBottom = __webpack_require__2(73174);
            var SetLeft = __webpack_require__2(74465);
            var TopLeft = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetLeft(gameObject, GetLeft(alignTo) - offsetX);
              SetBottom(gameObject, GetTop(alignTo) - offsetY);
              return gameObject;
            };
            module2.exports = TopLeft;
          },
          75548: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetRight = __webpack_require__2(70271);
            var GetTop = __webpack_require__2(47196);
            var SetBottom = __webpack_require__2(73174);
            var SetRight = __webpack_require__2(19298);
            var TopRight = function(gameObject, alignTo, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              SetRight(gameObject, GetRight(alignTo) + offsetX);
              SetBottom(gameObject, GetTop(alignTo) - offsetY);
              return gameObject;
            };
            module2.exports = TopRight;
          },
          86639: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BottomCenter: __webpack_require__2(27118),
              BottomLeft: __webpack_require__2(84469),
              BottomRight: __webpack_require__2(51577),
              LeftBottom: __webpack_require__2(90271),
              LeftCenter: __webpack_require__2(30466),
              LeftTop: __webpack_require__2(50087),
              QuickSet: __webpack_require__2(82590),
              RightBottom: __webpack_require__2(13555),
              RightCenter: __webpack_require__2(99049),
              RightTop: __webpack_require__2(67788),
              TopCenter: __webpack_require__2(78170),
              TopLeft: __webpack_require__2(54145),
              TopRight: __webpack_require__2(75548)
            };
          },
          21843: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetCenterX = __webpack_require__2(28417);
            var SetCenterY = __webpack_require__2(81711);
            var CenterOn = function(gameObject, x, y) {
              SetCenterX(gameObject, x);
              return SetCenterY(gameObject, y);
            };
            module2.exports = CenterOn;
          },
          97328: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = function(gameObject) {
              return gameObject.y + gameObject.height - gameObject.height * gameObject.originY;
            };
            module2.exports = GetBottom;
          },
          7126: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBottom = __webpack_require__2(97328);
            var GetLeft = __webpack_require__2(40163);
            var GetRight = __webpack_require__2(70271);
            var GetTop = __webpack_require__2(47196);
            var Rectangle = __webpack_require__2(74118);
            var GetBounds = function(gameObject, output) {
              if (output === void 0) {
                output = new Rectangle();
              }
              var left = GetLeft(gameObject);
              var top = GetTop(gameObject);
              output.x = left;
              output.y = top;
              output.width = GetRight(gameObject) - left;
              output.height = GetBottom(gameObject) - top;
              return output;
            };
            module2.exports = GetBounds;
          },
          59994: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCenterX = function(gameObject) {
              return gameObject.x - gameObject.width * gameObject.originX + gameObject.width * 0.5;
            };
            module2.exports = GetCenterX;
          },
          29568: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCenterY = function(gameObject) {
              return gameObject.y - gameObject.height * gameObject.originY + gameObject.height * 0.5;
            };
            module2.exports = GetCenterY;
          },
          40163: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLeft = function(gameObject) {
              return gameObject.x - gameObject.width * gameObject.originX;
            };
            module2.exports = GetLeft;
          },
          52088: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetOffsetX = function(gameObject) {
              return gameObject.width * gameObject.originX;
            };
            module2.exports = GetOffsetX;
          },
          23379: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetOffsetY = function(gameObject) {
              return gameObject.height * gameObject.originY;
            };
            module2.exports = GetOffsetY;
          },
          70271: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetRight = function(gameObject) {
              return gameObject.x + gameObject.width - gameObject.width * gameObject.originX;
            };
            module2.exports = GetRight;
          },
          47196: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTop = function(gameObject) {
              return gameObject.y - gameObject.height * gameObject.originY;
            };
            module2.exports = GetTop;
          },
          73174: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetBottom = function(gameObject, value) {
              gameObject.y = value - gameObject.height + gameObject.height * gameObject.originY;
              return gameObject;
            };
            module2.exports = SetBottom;
          },
          28417: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetCenterX = function(gameObject, x) {
              var offsetX = gameObject.width * gameObject.originX;
              gameObject.x = x + offsetX - gameObject.width * 0.5;
              return gameObject;
            };
            module2.exports = SetCenterX;
          },
          81711: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetCenterY = function(gameObject, y) {
              var offsetY = gameObject.height * gameObject.originY;
              gameObject.y = y + offsetY - gameObject.height * 0.5;
              return gameObject;
            };
            module2.exports = SetCenterY;
          },
          74465: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetLeft = function(gameObject, value) {
              gameObject.x = value + gameObject.width * gameObject.originX;
              return gameObject;
            };
            module2.exports = SetLeft;
          },
          19298: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetRight = function(gameObject, value) {
              gameObject.x = value - gameObject.width + gameObject.width * gameObject.originX;
              return gameObject;
            };
            module2.exports = SetRight;
          },
          84349: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTop = function(gameObject, value) {
              gameObject.y = value + gameObject.height * gameObject.originY;
              return gameObject;
            };
            module2.exports = SetTop;
          },
          15252: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              CenterOn: __webpack_require__2(21843),
              GetBottom: __webpack_require__2(97328),
              GetBounds: __webpack_require__2(7126),
              GetCenterX: __webpack_require__2(59994),
              GetCenterY: __webpack_require__2(29568),
              GetLeft: __webpack_require__2(40163),
              GetOffsetX: __webpack_require__2(52088),
              GetOffsetY: __webpack_require__2(23379),
              GetRight: __webpack_require__2(70271),
              GetTop: __webpack_require__2(47196),
              SetBottom: __webpack_require__2(73174),
              SetCenterX: __webpack_require__2(28417),
              SetCenterY: __webpack_require__2(81711),
              SetLeft: __webpack_require__2(74465),
              SetRight: __webpack_require__2(19298),
              SetTop: __webpack_require__2(84349)
            };
          },
          70616: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasInterpolation = {
              setCrisp: function(canvas) {
                var types = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"];
                types.forEach(function(type) {
                  canvas.style["image-rendering"] = type;
                });
                canvas.style.msInterpolationMode = "nearest-neighbor";
                return canvas;
              },
              setBicubic: function(canvas) {
                canvas.style["image-rendering"] = "auto";
                canvas.style.msInterpolationMode = "bicubic";
                return canvas;
              }
            };
            module2.exports = CanvasInterpolation;
          },
          61068: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(86459);
            var Smoothing = __webpack_require__2(8213);
            var pool = [];
            var _disableContextSmoothing = false;
            var CanvasPool = function() {
              var create = function(parent, width, height, canvasType, selfParent) {
                if (width === void 0) {
                  width = 1;
                }
                if (height === void 0) {
                  height = 1;
                }
                if (canvasType === void 0) {
                  canvasType = CONST.CANVAS;
                }
                if (selfParent === void 0) {
                  selfParent = false;
                }
                var canvas;
                var container = first(canvasType);
                if (container === null) {
                  container = {
                    parent,
                    canvas: document.createElement("canvas"),
                    type: canvasType
                  };
                  if (canvasType === CONST.CANVAS) {
                    pool.push(container);
                  }
                  canvas = container.canvas;
                } else {
                  container.parent = parent;
                  canvas = container.canvas;
                }
                if (selfParent) {
                  container.parent = canvas;
                }
                canvas.width = width;
                canvas.height = height;
                if (_disableContextSmoothing && canvasType === CONST.CANVAS) {
                  Smoothing.disable(canvas.getContext("2d", {willReadFrequently: false}));
                }
                return canvas;
              };
              var create2D = function(parent, width, height) {
                return create(parent, width, height, CONST.CANVAS);
              };
              var createWebGL = function(parent, width, height) {
                return create(parent, width, height, CONST.WEBGL);
              };
              var first = function(canvasType) {
                if (canvasType === void 0) {
                  canvasType = CONST.CANVAS;
                }
                if (canvasType === CONST.WEBGL) {
                  return null;
                }
                for (var i = 0; i < pool.length; i++) {
                  var container = pool[i];
                  if (!container.parent && container.type === canvasType) {
                    return container;
                  }
                }
                return null;
              };
              var remove = function(parent) {
                var isCanvas = parent instanceof HTMLCanvasElement;
                pool.forEach(function(container) {
                  if (isCanvas && container.canvas === parent || !isCanvas && container.parent === parent) {
                    container.parent = null;
                    container.canvas.width = 1;
                    container.canvas.height = 1;
                  }
                });
              };
              var total = function() {
                var c = 0;
                pool.forEach(function(container) {
                  if (container.parent) {
                    c++;
                  }
                });
                return c;
              };
              var free = function() {
                return pool.length - total();
              };
              var disableSmoothing = function() {
                _disableContextSmoothing = true;
              };
              var enableSmoothing = function() {
                _disableContextSmoothing = false;
              };
              return {
                create2D,
                create,
                createWebGL,
                disableSmoothing,
                enableSmoothing,
                first,
                free,
                pool,
                remove,
                total
              };
            };
            module2.exports = CanvasPool();
          },
          8213: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var prefix = "";
            var Smoothing = function() {
              var getPrefix = function(context) {
                var vendors = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var i = 0; i < vendors.length; i++) {
                  var s = vendors[i] + "mageSmoothingEnabled";
                  if (s in context) {
                    return s;
                  }
                }
                return null;
              };
              var enable = function(context) {
                if (prefix === "") {
                  prefix = getPrefix(context);
                }
                if (prefix) {
                  context[prefix] = true;
                }
                return context;
              };
              var disable = function(context) {
                if (prefix === "") {
                  prefix = getPrefix(context);
                }
                if (prefix) {
                  context[prefix] = false;
                }
                return context;
              };
              var isEnabled = function(context) {
                return prefix !== null ? context[prefix] : null;
              };
              return {
                disable,
                enable,
                getPrefix,
                isEnabled
              };
            };
            module2.exports = Smoothing();
          },
          59271: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TouchAction = function(canvas, value) {
              if (value === void 0) {
                value = "none";
              }
              canvas.style["msTouchAction"] = value;
              canvas.style["ms-touch-action"] = value;
              canvas.style["touch-action"] = value;
              return canvas;
            };
            module2.exports = TouchAction;
          },
          36505: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var UserSelect = function(canvas, value) {
              if (value === void 0) {
                value = "none";
              }
              var vendors = [
                "-webkit-",
                "-khtml-",
                "-moz-",
                "-ms-",
                ""
              ];
              vendors.forEach(function(vendor) {
                canvas.style[vendor + "user-select"] = value;
              });
              canvas.style["-webkit-touch-callout"] = value;
              canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
              return canvas;
            };
            module2.exports = UserSelect;
          },
          23514: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              CanvasInterpolation: __webpack_require__2(70616),
              CanvasPool: __webpack_require__2(61068),
              Smoothing: __webpack_require__2(8213),
              TouchAction: __webpack_require__2(59271),
              UserSelect: __webpack_require__2(36505)
            };
          },
          27119: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetColor = __webpack_require__2(22946);
            var GetColor32 = __webpack_require__2(5657);
            var HSVToRGB = __webpack_require__2(24650);
            var RGBToHSV = __webpack_require__2(68033);
            var Color = new Class({
              initialize: function Color2(red, green, blue, alpha) {
                if (red === void 0) {
                  red = 0;
                }
                if (green === void 0) {
                  green = 0;
                }
                if (blue === void 0) {
                  blue = 0;
                }
                if (alpha === void 0) {
                  alpha = 255;
                }
                this.r = 0;
                this.g = 0;
                this.b = 0;
                this.a = 255;
                this._h = 0;
                this._s = 0;
                this._v = 0;
                this._locked = false;
                this.gl = [0, 0, 0, 1];
                this._color = 0;
                this._color32 = 0;
                this._rgba = "";
                this.setTo(red, green, blue, alpha);
              },
              transparent: function() {
                this._locked = true;
                this.red = 0;
                this.green = 0;
                this.blue = 0;
                this.alpha = 0;
                this._locked = false;
                return this.update(true);
              },
              setTo: function(red, green, blue, alpha, updateHSV) {
                if (alpha === void 0) {
                  alpha = 255;
                }
                if (updateHSV === void 0) {
                  updateHSV = true;
                }
                this._locked = true;
                this.red = red;
                this.green = green;
                this.blue = blue;
                this.alpha = alpha;
                this._locked = false;
                return this.update(updateHSV);
              },
              setGLTo: function(red, green, blue, alpha) {
                if (alpha === void 0) {
                  alpha = 1;
                }
                this._locked = true;
                this.redGL = red;
                this.greenGL = green;
                this.blueGL = blue;
                this.alphaGL = alpha;
                this._locked = false;
                return this.update(true);
              },
              setFromRGB: function(color) {
                this._locked = true;
                this.red = color.r;
                this.green = color.g;
                this.blue = color.b;
                if (color.hasOwnProperty("a")) {
                  this.alpha = color.a;
                }
                this._locked = false;
                return this.update(true);
              },
              setFromHSV: function(h, s, v) {
                return HSVToRGB(h, s, v, this);
              },
              update: function(updateHSV) {
                if (updateHSV === void 0) {
                  updateHSV = false;
                }
                if (this._locked) {
                  return this;
                }
                var r = this.r;
                var g = this.g;
                var b = this.b;
                var a = this.a;
                this._color = GetColor(r, g, b);
                this._color32 = GetColor32(r, g, b, a);
                this._rgba = "rgba(" + r + "," + g + "," + b + "," + a / 255 + ")";
                if (updateHSV) {
                  RGBToHSV(r, g, b, this);
                }
                return this;
              },
              updateHSV: function() {
                var r = this.r;
                var g = this.g;
                var b = this.b;
                RGBToHSV(r, g, b, this);
                return this;
              },
              clone: function() {
                return new Color(this.r, this.g, this.b, this.a);
              },
              gray: function(shade) {
                return this.setTo(shade, shade, shade);
              },
              random: function(min, max) {
                if (min === void 0) {
                  min = 0;
                }
                if (max === void 0) {
                  max = 255;
                }
                var r = Math.floor(min + Math.random() * (max - min));
                var g = Math.floor(min + Math.random() * (max - min));
                var b = Math.floor(min + Math.random() * (max - min));
                return this.setTo(r, g, b);
              },
              randomGray: function(min, max) {
                if (min === void 0) {
                  min = 0;
                }
                if (max === void 0) {
                  max = 255;
                }
                var s = Math.floor(min + Math.random() * (max - min));
                return this.setTo(s, s, s);
              },
              saturate: function(amount) {
                this.s += amount / 100;
                return this;
              },
              desaturate: function(amount) {
                this.s -= amount / 100;
                return this;
              },
              lighten: function(amount) {
                this.v += amount / 100;
                return this;
              },
              darken: function(amount) {
                this.v -= amount / 100;
                return this;
              },
              brighten: function(amount) {
                var r = this.r;
                var g = this.g;
                var b = this.b;
                r = Math.max(0, Math.min(255, r - Math.round(255 * -(amount / 100))));
                g = Math.max(0, Math.min(255, g - Math.round(255 * -(amount / 100))));
                b = Math.max(0, Math.min(255, b - Math.round(255 * -(amount / 100))));
                return this.setTo(r, g, b);
              },
              color: {
                get: function() {
                  return this._color;
                }
              },
              color32: {
                get: function() {
                  return this._color32;
                }
              },
              rgba: {
                get: function() {
                  return this._rgba;
                }
              },
              redGL: {
                get: function() {
                  return this.gl[0];
                },
                set: function(value) {
                  this.gl[0] = Math.min(Math.abs(value), 1);
                  this.r = Math.floor(this.gl[0] * 255);
                  this.update(true);
                }
              },
              greenGL: {
                get: function() {
                  return this.gl[1];
                },
                set: function(value) {
                  this.gl[1] = Math.min(Math.abs(value), 1);
                  this.g = Math.floor(this.gl[1] * 255);
                  this.update(true);
                }
              },
              blueGL: {
                get: function() {
                  return this.gl[2];
                },
                set: function(value) {
                  this.gl[2] = Math.min(Math.abs(value), 1);
                  this.b = Math.floor(this.gl[2] * 255);
                  this.update(true);
                }
              },
              alphaGL: {
                get: function() {
                  return this.gl[3];
                },
                set: function(value) {
                  this.gl[3] = Math.min(Math.abs(value), 1);
                  this.a = Math.floor(this.gl[3] * 255);
                  this.update();
                }
              },
              red: {
                get: function() {
                  return this.r;
                },
                set: function(value) {
                  value = Math.floor(Math.abs(value));
                  this.r = Math.min(value, 255);
                  this.gl[0] = value / 255;
                  this.update(true);
                }
              },
              green: {
                get: function() {
                  return this.g;
                },
                set: function(value) {
                  value = Math.floor(Math.abs(value));
                  this.g = Math.min(value, 255);
                  this.gl[1] = value / 255;
                  this.update(true);
                }
              },
              blue: {
                get: function() {
                  return this.b;
                },
                set: function(value) {
                  value = Math.floor(Math.abs(value));
                  this.b = Math.min(value, 255);
                  this.gl[2] = value / 255;
                  this.update(true);
                }
              },
              alpha: {
                get: function() {
                  return this.a;
                },
                set: function(value) {
                  value = Math.floor(Math.abs(value));
                  this.a = Math.min(value, 255);
                  this.gl[3] = value / 255;
                  this.update();
                }
              },
              h: {
                get: function() {
                  return this._h;
                },
                set: function(value) {
                  this._h = value;
                  HSVToRGB(value, this._s, this._v, this);
                }
              },
              s: {
                get: function() {
                  return this._s;
                },
                set: function(value) {
                  this._s = value;
                  HSVToRGB(this._h, value, this._v, this);
                }
              },
              v: {
                get: function() {
                  return this._v;
                },
                set: function(value) {
                  this._v = value;
                  HSVToRGB(this._h, this._s, value, this);
                }
              }
            });
            module2.exports = Color;
          },
          30245: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetColor = __webpack_require__2(22946);
            var ColorSpectrum = function(limit) {
              if (limit === void 0) {
                limit = 1024;
              }
              var colors = [];
              var range = 255;
              var i;
              var r = 255;
              var g = 0;
              var b = 0;
              for (i = 0; i <= range; i++) {
                colors.push({r, g: i, b, color: GetColor(r, i, b)});
              }
              g = 255;
              for (i = range; i >= 0; i--) {
                colors.push({r: i, g, b, color: GetColor(i, g, b)});
              }
              r = 0;
              for (i = 0; i <= range; i++, g--) {
                colors.push({r, g, b: i, color: GetColor(r, g, i)});
              }
              g = 0;
              b = 255;
              for (i = 0; i <= range; i++, b--, r++) {
                colors.push({r, g, b, color: GetColor(r, g, b)});
              }
              if (limit === 1024) {
                return colors;
              } else {
                var out = [];
                var t = 0;
                var inc = 1024 / limit;
                for (i = 0; i < limit; i++) {
                  out.push(colors[Math.floor(t)]);
                  t += inc;
                }
                return out;
              }
            };
            module2.exports = ColorSpectrum;
          },
          86672: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ColorToRGBA = function(color) {
              var output = {
                r: color >> 16 & 255,
                g: color >> 8 & 255,
                b: color & 255,
                a: 255
              };
              if (color > 16777215) {
                output.a = color >>> 24;
              }
              return output;
            };
            module2.exports = ColorToRGBA;
          },
          25409: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ComponentToHex = function(color) {
              var hex = color.toString(16);
              return hex.length === 1 ? "0" + hex : hex;
            };
            module2.exports = ComponentToHex;
          },
          22946: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetColor = function(red, green, blue) {
              return red << 16 | green << 8 | blue;
            };
            module2.exports = GetColor;
          },
          5657: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetColor32 = function(red, green, blue, alpha) {
              return alpha << 24 | red << 16 | green << 8 | blue;
            };
            module2.exports = GetColor32;
          },
          74777: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Color = __webpack_require__2(27119);
            var HueToComponent = __webpack_require__2(59998);
            var HSLToColor = function(h, s, l) {
              var r = l;
              var g = l;
              var b = l;
              if (s !== 0) {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = HueToComponent(p, q, h + 1 / 3);
                g = HueToComponent(p, q, h);
                b = HueToComponent(p, q, h - 1 / 3);
              }
              var color = new Color();
              return color.setGLTo(r, g, b, 1);
            };
            module2.exports = HSLToColor;
          },
          89263: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HSVToRGB = __webpack_require__2(24650);
            var HSVColorWheel = function(s, v) {
              if (s === void 0) {
                s = 1;
              }
              if (v === void 0) {
                v = 1;
              }
              var colors = [];
              for (var c = 0; c <= 359; c++) {
                colors.push(HSVToRGB(c / 359, s, v));
              }
              return colors;
            };
            module2.exports = HSVColorWheel;
          },
          24650: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetColor = __webpack_require__2(22946);
            function ConvertValue(n, h, s, v) {
              var k = (n + h * 6) % 6;
              var min = Math.min(k, 4 - k, 1);
              return Math.round(255 * (v - v * s * Math.max(0, min)));
            }
            var HSVToRGB = function(h, s, v, out) {
              if (s === void 0) {
                s = 1;
              }
              if (v === void 0) {
                v = 1;
              }
              var r = ConvertValue(5, h, s, v);
              var g = ConvertValue(3, h, s, v);
              var b = ConvertValue(1, h, s, v);
              if (!out) {
                return {r, g, b, color: GetColor(r, g, b)};
              } else if (out.setTo) {
                return out.setTo(r, g, b, out.alpha, true);
              } else {
                out.r = r;
                out.g = g;
                out.b = b;
                out.color = GetColor(r, g, b);
                return out;
              }
            };
            module2.exports = HSVToRGB;
          },
          91487: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Color = __webpack_require__2(27119);
            var HexStringToColor = function(hex) {
              var color = new Color();
              hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r2, g2, b2) {
                return r2 + r2 + g2 + g2 + b2 + b2;
              });
              var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
              if (result) {
                var r = parseInt(result[1], 16);
                var g = parseInt(result[2], 16);
                var b = parseInt(result[3], 16);
                color.setTo(r, g, b);
              }
              return color;
            };
            module2.exports = HexStringToColor;
          },
          59998: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HueToComponent = function(p, q, t) {
              if (t < 0) {
                t += 1;
              }
              if (t > 1) {
                t -= 1;
              }
              if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
              }
              if (t < 1 / 2) {
                return q;
              }
              if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
              }
              return p;
            };
            module2.exports = HueToComponent;
          },
          74853: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Color = __webpack_require__2(27119);
            var IntegerToRGB = __webpack_require__2(15978);
            var IntegerToColor = function(input) {
              var rgb = IntegerToRGB(input);
              return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
            };
            module2.exports = IntegerToColor;
          },
          15978: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IntegerToRGB = function(color) {
              if (color > 16777215) {
                return {
                  a: color >>> 24,
                  r: color >> 16 & 255,
                  g: color >> 8 & 255,
                  b: color & 255
                };
              } else {
                return {
                  a: 255,
                  r: color >> 16 & 255,
                  g: color >> 8 & 255,
                  b: color & 255
                };
              }
            };
            module2.exports = IntegerToRGB;
          },
          53756: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Linear = __webpack_require__2(42798);
            var RGBWithRGB = function(r1, g1, b1, r2, g2, b2, length, index) {
              if (length === void 0) {
                length = 100;
              }
              if (index === void 0) {
                index = 0;
              }
              var t = index / length;
              return {
                r: Linear(r1, r2, t),
                g: Linear(g1, g2, t),
                b: Linear(b1, b2, t)
              };
            };
            var ColorWithColor = function(color1, color2, length, index) {
              if (length === void 0) {
                length = 100;
              }
              if (index === void 0) {
                index = 0;
              }
              return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
            };
            var ColorWithRGB = function(color, r, g, b, length, index) {
              if (length === void 0) {
                length = 100;
              }
              if (index === void 0) {
                index = 0;
              }
              return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
            };
            module2.exports = {
              RGBWithRGB,
              ColorWithRGB,
              ColorWithColor
            };
          },
          73904: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Color = __webpack_require__2(27119);
            var ObjectToColor = function(input) {
              return new Color(input.r, input.g, input.b, input.a);
            };
            module2.exports = ObjectToColor;
          },
          26841: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Color = __webpack_require__2(27119);
            var RGBStringToColor = function(rgb) {
              var color = new Color();
              var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());
              if (result) {
                var r = parseInt(result[1], 10);
                var g = parseInt(result[2], 10);
                var b = parseInt(result[3], 10);
                var a = result[4] !== void 0 ? parseFloat(result[4]) : 1;
                color.setTo(r, g, b, a * 255);
              }
              return color;
            };
            module2.exports = RGBStringToColor;
          },
          68033: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RGBToHSV = function(r, g, b, out) {
              if (out === void 0) {
                out = {h: 0, s: 0, v: 0};
              }
              r /= 255;
              g /= 255;
              b /= 255;
              var min = Math.min(r, g, b);
              var max = Math.max(r, g, b);
              var d = max - min;
              var h = 0;
              var s = max === 0 ? 0 : d / max;
              var v = max;
              if (max !== min) {
                if (max === r) {
                  h = (g - b) / d + (g < b ? 6 : 0);
                } else if (max === g) {
                  h = (b - r) / d + 2;
                } else if (max === b) {
                  h = (r - g) / d + 4;
                }
                h /= 6;
              }
              if (out.hasOwnProperty("_h")) {
                out._h = h;
                out._s = s;
                out._v = v;
              } else {
                out.h = h;
                out.s = s;
                out.v = v;
              }
              return out;
            };
            module2.exports = RGBToHSV;
          },
          4880: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ComponentToHex = __webpack_require__2(25409);
            var RGBToString = function(r, g, b, a, prefix) {
              if (a === void 0) {
                a = 255;
              }
              if (prefix === void 0) {
                prefix = "#";
              }
              if (prefix === "#") {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);
              } else {
                return "0x" + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
              }
            };
            module2.exports = RGBToString;
          },
          37243: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Between = __webpack_require__2(17489);
            var Color = __webpack_require__2(27119);
            var RandomRGB = function(min, max) {
              if (min === void 0) {
                min = 0;
              }
              if (max === void 0) {
                max = 255;
              }
              return new Color(Between(min, max), Between(min, max), Between(min, max));
            };
            module2.exports = RandomRGB;
          },
          93222: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HexStringToColor = __webpack_require__2(91487);
            var IntegerToColor = __webpack_require__2(74853);
            var ObjectToColor = __webpack_require__2(73904);
            var RGBStringToColor = __webpack_require__2(26841);
            var ValueToColor = function(input) {
              var t = typeof input;
              switch (t) {
                case "string":
                  if (input.substr(0, 3).toLowerCase() === "rgb") {
                    return RGBStringToColor(input);
                  } else {
                    return HexStringToColor(input);
                  }
                case "number":
                  return IntegerToColor(input);
                case "object":
                  return ObjectToColor(input);
              }
            };
            module2.exports = ValueToColor;
          },
          95509: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Color = __webpack_require__2(27119);
            Color.ColorSpectrum = __webpack_require__2(30245);
            Color.ColorToRGBA = __webpack_require__2(86672);
            Color.ComponentToHex = __webpack_require__2(25409);
            Color.GetColor = __webpack_require__2(22946);
            Color.GetColor32 = __webpack_require__2(5657);
            Color.HexStringToColor = __webpack_require__2(91487);
            Color.HSLToColor = __webpack_require__2(74777);
            Color.HSVColorWheel = __webpack_require__2(89263);
            Color.HSVToRGB = __webpack_require__2(24650);
            Color.HueToComponent = __webpack_require__2(59998);
            Color.IntegerToColor = __webpack_require__2(74853);
            Color.IntegerToRGB = __webpack_require__2(15978);
            Color.Interpolate = __webpack_require__2(53756);
            Color.ObjectToColor = __webpack_require__2(73904);
            Color.RandomRGB = __webpack_require__2(37243);
            Color.RGBStringToColor = __webpack_require__2(26841);
            Color.RGBToHSV = __webpack_require__2(68033);
            Color.RGBToString = __webpack_require__2(4880);
            Color.ValueToColor = __webpack_require__2(93222);
            module2.exports = Color;
          },
          24816: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Align: __webpack_require__2(93545),
              BaseShader: __webpack_require__2(31053),
              Bounds: __webpack_require__2(15252),
              Canvas: __webpack_require__2(23514),
              Color: __webpack_require__2(95509),
              ColorMatrix: __webpack_require__2(65246),
              Masks: __webpack_require__2(93310),
              RGB: __webpack_require__2(39298)
            };
          },
          76756: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GameObjectFactory = __webpack_require__2(61286);
            var BitmapMask = new Class({
              initialize: function BitmapMask2(scene, maskObject, x, y, texture, frame) {
                if (!maskObject) {
                  maskObject = scene.sys.make.image({x, y, key: texture, frame, add: false});
                }
                this.bitmapMask = maskObject;
                this.invertAlpha = false;
                this.isStencil = false;
              },
              setBitmap: function(maskObject) {
                this.bitmapMask = maskObject;
              },
              preRenderWebGL: function(renderer, maskedObject, camera) {
                renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);
              },
              postRenderWebGL: function(renderer, camera, renderTarget) {
                renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera, renderTarget);
              },
              preRenderCanvas: function() {
              },
              postRenderCanvas: function() {
              },
              destroy: function() {
                this.bitmapMask = null;
              }
            });
            GameObjectFactory.register("bitmapMask", function(maskObject, x, y, key, frame) {
              return new BitmapMask(this.scene, maskObject, x, y, key, frame);
            });
            module2.exports = BitmapMask;
          },
          63037: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GeometryMask = new Class({
              initialize: function GeometryMask2(scene, graphicsGeometry) {
                this.geometryMask = graphicsGeometry;
                this.invertAlpha = false;
                this.isStencil = true;
                this.level = 0;
              },
              setShape: function(graphicsGeometry) {
                this.geometryMask = graphicsGeometry;
                return this;
              },
              setInvertAlpha: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.invertAlpha = value;
                return this;
              },
              preRenderWebGL: function(renderer, child, camera) {
                var gl = renderer.gl;
                renderer.flush();
                if (renderer.maskStack.length === 0) {
                  gl.enable(gl.STENCIL_TEST);
                  gl.clear(gl.STENCIL_BUFFER_BIT);
                  renderer.maskCount = 0;
                }
                if (renderer.currentCameraMask.mask !== this) {
                  renderer.currentMask.mask = this;
                }
                renderer.maskStack.push({mask: this, camera});
                this.applyStencil(renderer, camera, true);
                renderer.maskCount++;
              },
              applyStencil: function(renderer, camera, inc) {
                var gl = renderer.gl;
                var geometryMask = this.geometryMask;
                var level = renderer.maskCount;
                var mask = 255;
                gl.colorMask(false, false, false, false);
                if (inc) {
                  gl.stencilFunc(gl.EQUAL, level, mask);
                  gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                  level++;
                } else {
                  gl.stencilFunc(gl.EQUAL, level + 1, mask);
                  gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                }
                this.level = level;
                geometryMask.renderWebGL(renderer, geometryMask, camera);
                renderer.flush();
                gl.colorMask(true, true, true, true);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                if (this.invertAlpha) {
                  gl.stencilFunc(gl.NOTEQUAL, level, mask);
                } else {
                  gl.stencilFunc(gl.EQUAL, level, mask);
                }
              },
              postRenderWebGL: function(renderer) {
                var gl = renderer.gl;
                renderer.maskStack.pop();
                renderer.maskCount--;
                renderer.flush();
                var current = renderer.currentMask;
                if (renderer.maskStack.length === 0) {
                  current.mask = null;
                  gl.disable(gl.STENCIL_TEST);
                } else {
                  var prev = renderer.maskStack[renderer.maskStack.length - 1];
                  prev.mask.applyStencil(renderer, prev.camera, false);
                  if (renderer.currentCameraMask.mask !== prev.mask) {
                    current.mask = prev.mask;
                    current.camera = prev.camera;
                  } else {
                    current.mask = null;
                  }
                }
              },
              preRenderCanvas: function(renderer, mask, camera) {
                var geometryMask = this.geometryMask;
                renderer.currentContext.save();
                geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, true);
                renderer.currentContext.clip();
              },
              postRenderCanvas: function(renderer) {
                renderer.currentContext.restore();
              },
              destroy: function() {
                this.geometryMask = null;
              }
            });
            module2.exports = GeometryMask;
          },
          93310: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BitmapMask: __webpack_require__2(76756),
              GeometryMask: __webpack_require__2(63037)
            };
          },
          31053: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var BaseShader = new Class({
              initialize: function BaseShader2(key, fragmentSrc, vertexSrc, uniforms) {
                if (!fragmentSrc || fragmentSrc === "") {
                  fragmentSrc = [
                    "precision mediump float;",
                    "uniform vec2 resolution;",
                    "varying vec2 fragCoord;",
                    "void main () {",
                    "    vec2 uv = fragCoord / resolution.xy;",
                    "    gl_FragColor = vec4(uv.xyx, 1.0);",
                    "}"
                  ].join("\n");
                }
                if (!vertexSrc || vertexSrc === "") {
                  vertexSrc = [
                    "precision mediump float;",
                    "uniform mat4 uProjectionMatrix;",
                    "uniform mat4 uViewMatrix;",
                    "uniform vec2 uResolution;",
                    "attribute vec2 inPosition;",
                    "varying vec2 fragCoord;",
                    "varying vec2 outTexCoord;",
                    "void main () {",
                    "   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);",
                    "   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);",
                    "   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);",
                    "}"
                  ].join("\n");
                }
                if (uniforms === void 0) {
                  uniforms = null;
                }
                this.key = key;
                this.fragmentSrc = fragmentSrc;
                this.vertexSrc = vertexSrc;
                this.uniforms = uniforms;
              }
            });
            module2.exports = BaseShader;
          },
          99584: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AddToDOM = function(element, parent) {
              var target;
              if (parent) {
                if (typeof parent === "string") {
                  target = document.getElementById(parent);
                } else if (typeof parent === "object" && parent.nodeType === 1) {
                  target = parent;
                }
              } else if (element.parentElement || parent === null) {
                return element;
              }
              if (!target) {
                target = document.body;
              }
              target.appendChild(element);
              return element;
            };
            module2.exports = AddToDOM;
          },
          85178: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AddToDOM = __webpack_require__2(99584);
            var CreateDOMContainer = function(game) {
              var config2 = game.config;
              if (!config2.parent || !config2.domCreateContainer) {
                return;
              }
              var div = document.createElement("div");
              div.style.cssText = [
                "display: block;",
                "width: " + game.scale.width + "px;",
                "height: " + game.scale.height + "px;",
                "padding: 0; margin: 0;",
                "position: absolute;",
                "overflow: hidden;",
                "pointer-events: " + config2.domPointerEvents + ";",
                "transform: scale(1);",
                "transform-origin: left top;"
              ].join(" ");
              game.domContainer = div;
              AddToDOM(div, config2.parent);
            };
            module2.exports = CreateDOMContainer;
          },
          21546: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var OS = __webpack_require__2(36580);
            var DOMContentLoaded = function(callback) {
              if (document.readyState === "complete" || document.readyState === "interactive") {
                callback();
                return;
              }
              var check = function() {
                document.removeEventListener("deviceready", check, true);
                document.removeEventListener("DOMContentLoaded", check, true);
                window.removeEventListener("load", check, true);
                callback();
              };
              if (!document.body) {
                window.setTimeout(check, 20);
              } else if (OS.cordova) {
                document.addEventListener("deviceready", check, false);
              } else {
                document.addEventListener("DOMContentLoaded", check, true);
                window.addEventListener("load", check, true);
              }
            };
            module2.exports = DOMContentLoaded;
          },
          74181: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetInnerHeight = function(iOS) {
              if (!iOS) {
                return window.innerHeight;
              }
              var axis = Math.abs(window.orientation);
              var size = {w: 0, h: 0};
              var ruler = document.createElement("div");
              ruler.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0");
              document.documentElement.appendChild(ruler);
              size.w = axis === 90 ? ruler.offsetHeight : window.innerWidth;
              size.h = axis === 90 ? window.innerWidth : ruler.offsetHeight;
              document.documentElement.removeChild(ruler);
              ruler = null;
              if (Math.abs(window.orientation) !== 90) {
                return size.h;
              } else {
                return size.w;
              }
            };
            module2.exports = GetInnerHeight;
          },
          9229: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(55301);
            var GetScreenOrientation = function(width, height) {
              var screen2 = window.screen;
              var orientation = screen2 ? screen2.orientation || screen2.mozOrientation || screen2.msOrientation : false;
              if (orientation && typeof orientation.type === "string") {
                return orientation.type;
              } else if (typeof orientation === "string") {
                return orientation;
              }
              if (typeof window.orientation === "number") {
                return window.orientation === 0 || window.orientation === 180 ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
              } else if (window.matchMedia) {
                if (window.matchMedia("(orientation: portrait)").matches) {
                  return CONST.ORIENTATION.PORTRAIT;
                } else if (window.matchMedia("(orientation: landscape)").matches) {
                  return CONST.ORIENTATION.LANDSCAPE;
                }
              } else {
                return height > width ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
              }
            };
            module2.exports = GetScreenOrientation;
          },
          2893: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTarget = function(element) {
              var target;
              if (element !== "") {
                if (typeof element === "string") {
                  target = document.getElementById(element);
                } else if (element && element.nodeType === 1) {
                  target = element;
                }
              }
              if (!target) {
                target = document.body;
              }
              return target;
            };
            module2.exports = GetTarget;
          },
          89200: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ParseXML = function(data) {
              var xml = "";
              try {
                if (window["DOMParser"]) {
                  var domparser = new DOMParser();
                  xml = domparser.parseFromString(data, "text/xml");
                } else {
                  xml = new ActiveXObject("Microsoft.XMLDOM");
                  xml.loadXML(data);
                }
              } catch (e) {
                xml = null;
              }
              if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                return null;
              } else {
                return xml;
              }
            };
            module2.exports = ParseXML;
          },
          55638: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RemoveFromDOM = function(element) {
              if (element.parentNode) {
                element.parentNode.removeChild(element);
              }
            };
            module2.exports = RemoveFromDOM;
          },
          27385: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var NOOP = __webpack_require__2(72283);
            var RequestAnimationFrame = new Class({
              initialize: function RequestAnimationFrame2() {
                this.isRunning = false;
                this.callback = NOOP;
                this.isSetTimeOut = false;
                this.timeOutID = null;
                this.delay = 0;
                var _this = this;
                this.step = function step(time) {
                  _this.callback(time);
                  if (_this.isRunning) {
                    _this.timeOutID = window.requestAnimationFrame(step);
                  }
                };
                this.stepTimeout = function stepTimeout() {
                  if (_this.isRunning) {
                    _this.timeOutID = window.setTimeout(stepTimeout, _this.delay);
                  }
                  _this.callback(window.performance.now());
                };
              },
              start: function(callback, forceSetTimeOut, delay) {
                if (this.isRunning) {
                  return;
                }
                this.callback = callback;
                this.isSetTimeOut = forceSetTimeOut;
                this.delay = delay;
                this.isRunning = true;
                this.timeOutID = forceSetTimeOut ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step);
              },
              stop: function() {
                this.isRunning = false;
                if (this.isSetTimeOut) {
                  clearTimeout(this.timeOutID);
                } else {
                  window.cancelAnimationFrame(this.timeOutID);
                }
              },
              destroy: function() {
                this.stop();
                this.callback = NOOP;
              }
            });
            module2.exports = RequestAnimationFrame;
          },
          3590: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Dom = {
              AddToDOM: __webpack_require__2(99584),
              DOMContentLoaded: __webpack_require__2(21546),
              GetInnerHeight: __webpack_require__2(74181),
              GetScreenOrientation: __webpack_require__2(9229),
              GetTarget: __webpack_require__2(2893),
              ParseXML: __webpack_require__2(89200),
              RemoveFromDOM: __webpack_require__2(55638),
              RequestAnimationFrame: __webpack_require__2(27385)
            };
            module2.exports = Dom;
          },
          78491: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EE = __webpack_require__2(6659);
            var PluginCache = __webpack_require__2(91963);
            var EventEmitter = new Class({
              Extends: EE,
              initialize: function EventEmitter2() {
                EE.call(this);
              },
              shutdown: function() {
                this.removeAllListeners();
              },
              destroy: function() {
                this.removeAllListeners();
              }
            });
            PluginCache.register("EventEmitter", EventEmitter, "events");
            module2.exports = EventEmitter;
          },
          95146: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {EventEmitter: __webpack_require__2(78491)};
          },
          20170: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Barrel = new Class({
              Extends: Controller,
              initialize: function Barrel2(gameObject, amount) {
                if (amount === void 0) {
                  amount = 1;
                }
                Controller.call(this, FX_CONST.BARREL, gameObject);
                this.amount = amount;
              }
            });
            module2.exports = Barrel;
          },
          51182: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Bloom = new Class({
              Extends: Controller,
              initialize: function Bloom2(gameObject, color, offsetX, offsetY, blurStrength, strength, steps) {
                if (offsetX === void 0) {
                  offsetX = 1;
                }
                if (offsetY === void 0) {
                  offsetY = 1;
                }
                if (blurStrength === void 0) {
                  blurStrength = 1;
                }
                if (strength === void 0) {
                  strength = 1;
                }
                if (steps === void 0) {
                  steps = 4;
                }
                Controller.call(this, FX_CONST.BLOOM, gameObject);
                this.steps = steps;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                this.blurStrength = blurStrength;
                this.strength = strength;
                this.glcolor = [1, 1, 1];
                if (color !== void 0 && color !== null) {
                  this.color = color;
                }
              },
              color: {
                get: function() {
                  var color = this.glcolor;
                  return (color[0] * 255 << 16) + (color[1] * 255 << 8) + (color[2] * 255 | 0);
                },
                set: function(value) {
                  var color = this.glcolor;
                  color[0] = (value >> 16 & 255) / 255;
                  color[1] = (value >> 8 & 255) / 255;
                  color[2] = (value & 255) / 255;
                }
              }
            });
            module2.exports = Bloom;
          },
          51498: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Blur = new Class({
              Extends: Controller,
              initialize: function Blur2(gameObject, quality, x, y, strength, color, steps) {
                if (quality === void 0) {
                  quality = 0;
                }
                if (x === void 0) {
                  x = 2;
                }
                if (y === void 0) {
                  y = 2;
                }
                if (strength === void 0) {
                  strength = 1;
                }
                if (steps === void 0) {
                  steps = 4;
                }
                Controller.call(this, FX_CONST.BLUR, gameObject);
                this.quality = quality;
                this.x = x;
                this.y = y;
                this.steps = steps;
                this.strength = strength;
                this.glcolor = [1, 1, 1];
                if (color !== void 0 && color !== null) {
                  this.color = color;
                }
              },
              color: {
                get: function() {
                  var color = this.glcolor;
                  return (color[0] * 255 << 16) + (color[1] * 255 << 8) + (color[2] * 255 | 0);
                },
                set: function(value) {
                  var color = this.glcolor;
                  color[0] = (value >> 16 & 255) / 255;
                  color[1] = (value >> 8 & 255) / 255;
                  color[2] = (value & 255) / 255;
                }
              }
            });
            module2.exports = Blur;
          },
          12042: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Bokeh = new Class({
              Extends: Controller,
              initialize: function Bokeh2(gameObject, radius, amount, contrast, isTiltShift, blurX, blurY, strength) {
                if (radius === void 0) {
                  radius = 0.5;
                }
                if (amount === void 0) {
                  amount = 1;
                }
                if (contrast === void 0) {
                  contrast = 0.2;
                }
                if (isTiltShift === void 0) {
                  isTiltShift = false;
                }
                if (blurX === void 0) {
                  blurX = 1;
                }
                if (blurY === void 0) {
                  blurY = 1;
                }
                if (strength === void 0) {
                  strength = 1;
                }
                Controller.call(this, FX_CONST.BOKEH, gameObject);
                this.radius = radius;
                this.amount = amount;
                this.contrast = contrast;
                this.isTiltShift = isTiltShift;
                this.strength = strength;
                this.blurX = blurX;
                this.blurY = blurY;
              }
            });
            module2.exports = Bokeh;
          },
          69900: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Circle = new Class({
              Extends: Controller,
              initialize: function Circle2(gameObject, thickness, color, backgroundColor, scale, feather) {
                if (thickness === void 0) {
                  thickness = 8;
                }
                if (scale === void 0) {
                  scale = 1;
                }
                if (feather === void 0) {
                  feather = 5e-3;
                }
                Controller.call(this, FX_CONST.CIRCLE, gameObject);
                this.scale = scale;
                this.feather = feather;
                this.thickness = thickness;
                this.glcolor = [1, 0.2, 0.7];
                this.glcolor2 = [1, 0, 0, 0.4];
                if (color !== void 0 && color !== null) {
                  this.color = color;
                }
                if (backgroundColor !== void 0 && backgroundColor !== null) {
                  this.backgroundColor = backgroundColor;
                }
              },
              color: {
                get: function() {
                  var color = this.glcolor;
                  return (color[0] * 255 << 16) + (color[1] * 255 << 8) + (color[2] * 255 | 0);
                },
                set: function(value) {
                  var color = this.glcolor;
                  color[0] = (value >> 16 & 255) / 255;
                  color[1] = (value >> 8 & 255) / 255;
                  color[2] = (value & 255) / 255;
                }
              },
              backgroundColor: {
                get: function() {
                  var color = this.glcolor2;
                  return (color[0] * 255 << 16) + (color[1] * 255 << 8) + (color[2] * 255 | 0);
                },
                set: function(value) {
                  var color = this.glcolor2;
                  color[0] = (value >> 16 & 255) / 255;
                  color[1] = (value >> 8 & 255) / 255;
                  color[2] = (value & 255) / 255;
                }
              },
              backgroundAlpha: {
                get: function() {
                  return this.glcolor2[3];
                },
                set: function(value) {
                  this.glcolor2[3] = value;
                }
              }
            });
            module2.exports = Circle;
          },
          48991: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var BaseColorMatrix = __webpack_require__2(65246);
            var FX_CONST = __webpack_require__2(47406);
            var ColorMatrix = new Class({
              Extends: BaseColorMatrix,
              initialize: function ColorMatrix2(gameObject) {
                BaseColorMatrix.call(this);
                this.type = FX_CONST.COLOR_MATRIX;
                this.gameObject = gameObject;
                this.active = true;
              },
              destroy: function() {
                this.gameObject = null;
                this._matrix = null;
                this._data = null;
              }
            });
            module2.exports = ColorMatrix;
          },
          47551: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = new Class({
              initialize: function Controller2(type, gameObject) {
                this.type = type;
                this.gameObject = gameObject;
                this.active = true;
              },
              setActive: function(value) {
                this.active = value;
                return this;
              },
              destroy: function() {
                this.gameObject = null;
                this.active = false;
              }
            });
            module2.exports = Controller;
          },
          47909: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Displacement = new Class({
              Extends: Controller,
              initialize: function Displacement2(gameObject, texture, x, y) {
                if (texture === void 0) {
                  texture = "__WHITE";
                }
                if (x === void 0) {
                  x = 5e-3;
                }
                if (y === void 0) {
                  y = 5e-3;
                }
                Controller.call(this, FX_CONST.DISPLACEMENT, gameObject);
                this.x = x;
                this.y = y;
                this.glTexture;
                this.setTexture(texture);
              },
              setTexture: function(texture) {
                var phaserTexture = this.gameObject.scene.sys.textures.getFrame(texture);
                if (phaserTexture) {
                  this.glTexture = phaserTexture.glTexture;
                }
                return this;
              }
            });
            module2.exports = Displacement;
          },
          18919: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Glow = new Class({
              Extends: Controller,
              initialize: function Glow2(gameObject, color, outerStrength, innerStrength, knockout) {
                if (outerStrength === void 0) {
                  outerStrength = 4;
                }
                if (innerStrength === void 0) {
                  innerStrength = 0;
                }
                if (knockout === void 0) {
                  knockout = false;
                }
                Controller.call(this, FX_CONST.GLOW, gameObject);
                this.outerStrength = outerStrength;
                this.innerStrength = innerStrength;
                this.knockout = knockout;
                this.glcolor = [1, 1, 1, 1];
                if (color !== void 0) {
                  this.color = color;
                }
              },
              color: {
                get: function() {
                  var color = this.glcolor;
                  return (color[0] * 255 << 16) + (color[1] * 255 << 8) + (color[2] * 255 | 0);
                },
                set: function(value) {
                  var color = this.glcolor;
                  color[0] = (value >> 16 & 255) / 255;
                  color[1] = (value >> 8 & 255) / 255;
                  color[2] = (value & 255) / 255;
                }
              }
            });
            module2.exports = Glow;
          },
          62494: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Gradient = new Class({
              Extends: Controller,
              initialize: function Gradient2(gameObject, color1, color2, alpha, fromX, fromY, toX, toY, size) {
                if (alpha === void 0) {
                  alpha = 0.2;
                }
                if (fromX === void 0) {
                  fromX = 0;
                }
                if (fromY === void 0) {
                  fromY = 0;
                }
                if (toX === void 0) {
                  toX = 0;
                }
                if (toY === void 0) {
                  toY = 1;
                }
                if (size === void 0) {
                  size = 0;
                }
                Controller.call(this, FX_CONST.GRADIENT, gameObject);
                this.alpha = alpha;
                this.size = size;
                this.fromX = fromX;
                this.fromY = fromY;
                this.toX = toX;
                this.toY = toY;
                this.glcolor1 = [255, 0, 0];
                this.glcolor2 = [0, 255, 0];
                if (color1 !== void 0 && color1 !== null) {
                  this.color1 = color1;
                }
                if (color2 !== void 0 && color2 !== null) {
                  this.color2 = color2;
                }
              },
              color1: {
                get: function() {
                  var color = this.glcolor1;
                  return (color[0] << 16) + (color[1] << 8) + (color[2] | 0);
                },
                set: function(value) {
                  var color = this.glcolor1;
                  color[0] = value >> 16 & 255;
                  color[1] = value >> 8 & 255;
                  color[2] = value & 255;
                }
              },
              color2: {
                get: function() {
                  var color = this.glcolor2;
                  return (color[0] << 16) + (color[1] << 8) + (color[2] | 0);
                },
                set: function(value) {
                  var color = this.glcolor2;
                  color[0] = value >> 16 & 255;
                  color[1] = value >> 8 & 255;
                  color[2] = value & 255;
                }
              }
            });
            module2.exports = Gradient;
          },
          68897: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Pixelate = new Class({
              Extends: Controller,
              initialize: function Pixelate2(gameObject, amount) {
                if (amount === void 0) {
                  amount = 1;
                }
                Controller.call(this, FX_CONST.PIXELATE, gameObject);
                this.amount = amount;
              }
            });
            module2.exports = Pixelate;
          },
          58575: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Shadow = new Class({
              Extends: Controller,
              initialize: function Shadow2(gameObject, x, y, decay, power, color, samples, intensity) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (decay === void 0) {
                  decay = 0.1;
                }
                if (power === void 0) {
                  power = 1;
                }
                if (samples === void 0) {
                  samples = 6;
                }
                if (intensity === void 0) {
                  intensity = 1;
                }
                Controller.call(this, FX_CONST.SHADOW, gameObject);
                this.x = x;
                this.y = y;
                this.decay = decay;
                this.power = power;
                this.glcolor = [0, 0, 0, 1];
                this.samples = samples;
                this.intensity = intensity;
                if (color !== void 0) {
                  this.color = color;
                }
              },
              color: {
                get: function() {
                  var color = this.glcolor;
                  return (color[0] * 255 << 16) + (color[1] * 255 << 8) + (color[2] * 255 | 0);
                },
                set: function(value) {
                  var color = this.glcolor;
                  color[0] = (value >> 16 & 255) / 255;
                  color[1] = (value >> 8 & 255) / 255;
                  color[2] = (value & 255) / 255;
                }
              }
            });
            module2.exports = Shadow;
          },
          33755: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Shine = new Class({
              Extends: Controller,
              initialize: function Shine2(gameObject, speed, lineWidth, gradient, reveal) {
                if (speed === void 0) {
                  speed = 0.5;
                }
                if (lineWidth === void 0) {
                  lineWidth = 0.5;
                }
                if (gradient === void 0) {
                  gradient = 3;
                }
                if (reveal === void 0) {
                  reveal = false;
                }
                Controller.call(this, FX_CONST.SHINE, gameObject);
                this.speed = speed;
                this.lineWidth = lineWidth;
                this.gradient = gradient;
                this.reveal = reveal;
              }
            });
            module2.exports = Shine;
          },
          24949: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Vignette = new Class({
              Extends: Controller,
              initialize: function Vignette2(gameObject, x, y, radius, strength) {
                if (x === void 0) {
                  x = 0.5;
                }
                if (y === void 0) {
                  y = 0.5;
                }
                if (radius === void 0) {
                  radius = 0.5;
                }
                if (strength === void 0) {
                  strength = 0.5;
                }
                Controller.call(this, FX_CONST.VIGNETTE, gameObject);
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.strength = strength;
              }
            });
            module2.exports = Vignette;
          },
          66241: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Controller = __webpack_require__2(47551);
            var FX_CONST = __webpack_require__2(47406);
            var Wipe = new Class({
              Extends: Controller,
              initialize: function Wipe2(gameObject, wipeWidth, direction, axis, reveal) {
                if (wipeWidth === void 0) {
                  wipeWidth = 0.1;
                }
                if (direction === void 0) {
                  direction = 0;
                }
                if (axis === void 0) {
                  axis = 0;
                }
                if (reveal === void 0) {
                  reveal = false;
                }
                Controller.call(this, FX_CONST.WIPE, gameObject);
                this.progress = 0;
                this.wipeWidth = wipeWidth;
                this.direction = direction;
                this.axis = axis;
                this.reveal = reveal;
              }
            });
            module2.exports = Wipe;
          },
          47406: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FX_CONST = {
              GLOW: 4,
              SHADOW: 5,
              PIXELATE: 6,
              VIGNETTE: 7,
              SHINE: 8,
              BLUR: 9,
              GRADIENT: 12,
              BLOOM: 13,
              COLOR_MATRIX: 14,
              CIRCLE: 15,
              BARREL: 16,
              DISPLACEMENT: 17,
              WIPE: 18,
              BOKEH: 19
            };
            module2.exports = FX_CONST;
          },
          96910: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Extend = __webpack_require__2(98611);
            var FX_CONST = __webpack_require__2(47406);
            var FX = {
              Barrel: __webpack_require__2(20170),
              Controller: __webpack_require__2(47551),
              Bloom: __webpack_require__2(51182),
              Blur: __webpack_require__2(51498),
              Bokeh: __webpack_require__2(12042),
              Circle: __webpack_require__2(69900),
              ColorMatrix: __webpack_require__2(48991),
              Displacement: __webpack_require__2(47909),
              Glow: __webpack_require__2(18919),
              Gradient: __webpack_require__2(62494),
              Pixelate: __webpack_require__2(68897),
              Shadow: __webpack_require__2(58575),
              Shine: __webpack_require__2(33755),
              Vignette: __webpack_require__2(24949),
              Wipe: __webpack_require__2(66241)
            };
            FX = Extend(false, FX, FX_CONST);
            module2.exports = FX;
          },
          88933: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BlendModes = __webpack_require__2(95723);
            var GetAdvancedValue = __webpack_require__2(20494);
            var BuildGameObject = function(scene, gameObject, config2) {
              gameObject.x = GetAdvancedValue(config2, "x", 0);
              gameObject.y = GetAdvancedValue(config2, "y", 0);
              gameObject.depth = GetAdvancedValue(config2, "depth", 0);
              gameObject.flipX = GetAdvancedValue(config2, "flipX", false);
              gameObject.flipY = GetAdvancedValue(config2, "flipY", false);
              var scale = GetAdvancedValue(config2, "scale", null);
              if (typeof scale === "number") {
                gameObject.setScale(scale);
              } else if (scale !== null) {
                gameObject.scaleX = GetAdvancedValue(scale, "x", 1);
                gameObject.scaleY = GetAdvancedValue(scale, "y", 1);
              }
              var scrollFactor = GetAdvancedValue(config2, "scrollFactor", null);
              if (typeof scrollFactor === "number") {
                gameObject.setScrollFactor(scrollFactor);
              } else if (scrollFactor !== null) {
                gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, "x", 1);
                gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, "y", 1);
              }
              gameObject.rotation = GetAdvancedValue(config2, "rotation", 0);
              var angle = GetAdvancedValue(config2, "angle", null);
              if (angle !== null) {
                gameObject.angle = angle;
              }
              gameObject.alpha = GetAdvancedValue(config2, "alpha", 1);
              var origin = GetAdvancedValue(config2, "origin", null);
              if (typeof origin === "number") {
                gameObject.setOrigin(origin);
              } else if (origin !== null) {
                var ox = GetAdvancedValue(origin, "x", 0.5);
                var oy = GetAdvancedValue(origin, "y", 0.5);
                gameObject.setOrigin(ox, oy);
              }
              gameObject.blendMode = GetAdvancedValue(config2, "blendMode", BlendModes.NORMAL);
              gameObject.visible = GetAdvancedValue(config2, "visible", true);
              var add = GetAdvancedValue(config2, "add", true);
              if (add) {
                scene.sys.displayList.add(gameObject);
              }
              if (gameObject.preUpdate) {
                scene.sys.updateList.add(gameObject);
              }
              return gameObject;
            };
            module2.exports = BuildGameObject;
          },
          32291: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetAdvancedValue = __webpack_require__2(20494);
            var BuildGameObjectAnimation = function(sprite, config2) {
              var animConfig = GetAdvancedValue(config2, "anims", null);
              if (animConfig === null) {
                return sprite;
              }
              if (typeof animConfig === "string") {
                sprite.anims.play(animConfig);
              } else if (typeof animConfig === "object") {
                var anims = sprite.anims;
                var key = GetAdvancedValue(animConfig, "key", void 0);
                if (key) {
                  var startFrame = GetAdvancedValue(animConfig, "startFrame", void 0);
                  var delay = GetAdvancedValue(animConfig, "delay", 0);
                  var repeat = GetAdvancedValue(animConfig, "repeat", 0);
                  var repeatDelay = GetAdvancedValue(animConfig, "repeatDelay", 0);
                  var yoyo = GetAdvancedValue(animConfig, "yoyo", false);
                  var play = GetAdvancedValue(animConfig, "play", false);
                  var delayedPlay = GetAdvancedValue(animConfig, "delayedPlay", 0);
                  var playConfig = {
                    key,
                    delay,
                    repeat,
                    repeatDelay,
                    yoyo,
                    startFrame
                  };
                  if (play) {
                    anims.play(playConfig);
                  } else if (delayedPlay > 0) {
                    anims.playAfterDelay(playConfig, delayedPlay);
                  } else {
                    anims.load(playConfig);
                  }
                }
              }
              return sprite;
            };
            module2.exports = BuildGameObjectAnimation;
          },
          91713: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var List = __webpack_require__2(71207);
            var PluginCache = __webpack_require__2(91963);
            var GameObjectEvents = __webpack_require__2(56631);
            var SceneEvents = __webpack_require__2(7599);
            var StableSort = __webpack_require__2(17922);
            var DisplayList = new Class({
              Extends: List,
              initialize: function DisplayList2(scene) {
                List.call(this, scene);
                this.sortChildrenFlag = false;
                this.scene = scene;
                this.systems = scene.sys;
                this.events = scene.sys.events;
                this.addCallback = this.addChildCallback;
                this.removeCallback = this.removeChildCallback;
                this.events.once(SceneEvents.BOOT, this.boot, this);
                this.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              addChildCallback: function(gameObject) {
                if (gameObject.displayList && gameObject.displayList !== this) {
                  gameObject.removeFromDisplayList();
                }
                if (gameObject.parentContainer) {
                  gameObject.parentContainer.remove(gameObject);
                }
                if (!gameObject.displayList) {
                  this.queueDepthSort();
                  gameObject.displayList = this;
                  gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
                  this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
                }
              },
              removeChildCallback: function(gameObject) {
                this.queueDepthSort();
                gameObject.displayList = null;
                gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
                this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
              },
              start: function() {
                this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              queueDepthSort: function() {
                this.sortChildrenFlag = true;
              },
              depthSort: function() {
                if (this.sortChildrenFlag) {
                  StableSort(this.list, this.sortByDepth);
                  this.sortChildrenFlag = false;
                }
              },
              sortByDepth: function(childA, childB) {
                return childA._depth - childB._depth;
              },
              getChildren: function() {
                return this.list;
              },
              shutdown: function() {
                var list = this.list;
                while (list.length) {
                  list[0].destroy(true);
                }
                this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                this.shutdown();
                this.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.systems = null;
                this.events = null;
              }
            });
            PluginCache.register("DisplayList", DisplayList, "displayList");
            module2.exports = DisplayList;
          },
          89980: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ComponentsToJSON = __webpack_require__2(48129);
            var DataManager = __webpack_require__2(81078);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(56631);
            var SceneEvents = __webpack_require__2(7599);
            var GameObject = new Class({
              Extends: EventEmitter,
              initialize: function GameObject2(scene, type) {
                EventEmitter.call(this);
                this.scene = scene;
                this.displayList = null;
                this.type = type;
                this.state = 0;
                this.parentContainer = null;
                this.name = "";
                this.active = true;
                this.tabIndex = -1;
                this.data = null;
                this.renderFlags = 15;
                this.cameraFilter = 0;
                this.input = null;
                this.body = null;
                this.ignoreDestroy = false;
                this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
                this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
                scene.sys.queueDepthSort();
              },
              setActive: function(value) {
                this.active = value;
                return this;
              },
              setName: function(value) {
                this.name = value;
                return this;
              },
              setState: function(value) {
                this.state = value;
                return this;
              },
              setDataEnabled: function() {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                return this;
              },
              setData: function(key, value) {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                this.data.set(key, value);
                return this;
              },
              incData: function(key, amount) {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                this.data.inc(key, amount);
                return this;
              },
              toggleData: function(key) {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                this.data.toggle(key);
                return this;
              },
              getData: function(key) {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                return this.data.get(key);
              },
              setInteractive: function(hitArea, hitAreaCallback, dropZone) {
                this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone);
                return this;
              },
              disableInteractive: function() {
                this.scene.sys.input.disable(this);
                return this;
              },
              removeInteractive: function() {
                this.scene.sys.input.clear(this);
                this.input = void 0;
                return this;
              },
              addedToScene: function() {
              },
              removedFromScene: function() {
              },
              update: function() {
              },
              toJSON: function() {
                return ComponentsToJSON(this);
              },
              willRender: function(camera) {
                var listWillRender = this.displayList && this.displayList.active ? this.displayList.willRender(camera) : true;
                return !(!listWillRender || GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
              },
              getIndexList: function() {
                var child = this;
                var parent = this.parentContainer;
                var indexes = [];
                while (parent) {
                  indexes.unshift(parent.getIndex(child));
                  child = parent;
                  if (!parent.parentContainer) {
                    break;
                  } else {
                    parent = parent.parentContainer;
                  }
                }
                if (this.displayList) {
                  indexes.unshift(this.displayList.getIndex(child));
                } else {
                  indexes.unshift(this.scene.sys.displayList.getIndex(child));
                }
                return indexes;
              },
              addToDisplayList: function(displayList) {
                if (displayList === void 0) {
                  displayList = this.scene.sys.displayList;
                }
                if (this.displayList && this.displayList !== displayList) {
                  this.removeFromDisplayList();
                }
                if (!displayList.exists(this)) {
                  this.displayList = displayList;
                  displayList.add(this, true);
                  displayList.queueDepthSort();
                  this.emit(Events.ADDED_TO_SCENE, this, this.scene);
                  displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);
                }
                return this;
              },
              addToUpdateList: function() {
                if (this.scene && this.preUpdate) {
                  this.scene.sys.updateList.add(this);
                }
                return this;
              },
              removeFromDisplayList: function() {
                var displayList = this.displayList || this.scene.sys.displayList;
                if (displayList && displayList.exists(this)) {
                  displayList.remove(this, true);
                  displayList.queueDepthSort();
                  this.displayList = null;
                  this.emit(Events.REMOVED_FROM_SCENE, this, this.scene);
                  displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);
                }
                return this;
              },
              removeFromUpdateList: function() {
                if (this.scene && this.preUpdate) {
                  this.scene.sys.updateList.remove(this);
                }
                return this;
              },
              destroy: function(fromScene) {
                if (!this.scene || this.ignoreDestroy) {
                  return;
                }
                if (fromScene === void 0) {
                  fromScene = false;
                }
                if (this.preDestroy) {
                  this.preDestroy.call(this);
                }
                this.emit(Events.DESTROY, this, fromScene);
                this.removeAllListeners();
                if (this.postPipelines) {
                  this.resetPostPipeline(true);
                }
                this.removeFromDisplayList();
                this.removeFromUpdateList();
                if (this.input) {
                  this.scene.sys.input.clear(this);
                  this.input = void 0;
                }
                if (this.data) {
                  this.data.destroy();
                  this.data = void 0;
                }
                if (this.body) {
                  this.body.destroy();
                  this.body = void 0;
                }
                if (this.preFX) {
                  this.preFX.destroy();
                  this.preFX = void 0;
                }
                if (this.postFX) {
                  this.postFX.destroy();
                  this.postFX = void 0;
                }
                this.active = false;
                this.visible = false;
                this.scene = void 0;
                this.parentContainer = void 0;
              }
            });
            GameObject.RENDER_MASK = 15;
            module2.exports = GameObject;
          },
          99325: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var GameObjectCreator = new Class({
              initialize: function GameObjectCreator2(scene) {
                this.scene = scene;
                this.systems = scene.sys;
                this.events = scene.sys.events;
                this.displayList;
                this.updateList;
                this.events.once(SceneEvents.BOOT, this.boot, this);
                this.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.displayList = this.systems.displayList;
                this.updateList = this.systems.updateList;
                this.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              shutdown: function() {
                this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                this.shutdown();
                this.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.systems = null;
                this.events = null;
                this.displayList = null;
                this.updateList = null;
              }
            });
            GameObjectCreator.register = function(factoryType, factoryFunction) {
              if (!GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
                GameObjectCreator.prototype[factoryType] = factoryFunction;
              }
            };
            GameObjectCreator.remove = function(factoryType) {
              if (GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
                delete GameObjectCreator.prototype[factoryType];
              }
            };
            PluginCache.register("GameObjectCreator", GameObjectCreator, "make");
            module2.exports = GameObjectCreator;
          },
          61286: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var GameObjectFactory = new Class({
              initialize: function GameObjectFactory2(scene) {
                this.scene = scene;
                this.systems = scene.sys;
                this.events = scene.sys.events;
                this.displayList;
                this.updateList;
                this.events.once(SceneEvents.BOOT, this.boot, this);
                this.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.displayList = this.systems.displayList;
                this.updateList = this.systems.updateList;
                this.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              existing: function(child) {
                if (child.renderCanvas || child.renderWebGL) {
                  this.displayList.add(child);
                }
                if (child.preUpdate) {
                  this.updateList.add(child);
                }
                return child;
              },
              shutdown: function() {
                this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                this.shutdown();
                this.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.systems = null;
                this.events = null;
                this.displayList = null;
                this.updateList = null;
              }
            });
            GameObjectFactory.register = function(factoryType, factoryFunction) {
              if (!GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
                GameObjectFactory.prototype[factoryType] = factoryFunction;
              }
            };
            GameObjectFactory.remove = function(factoryType) {
              if (GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
                delete GameObjectFactory.prototype[factoryType];
              }
            };
            PluginCache.register("GameObjectFactory", GameObjectFactory, "add");
            module2.exports = GameObjectFactory;
          },
          73329: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TransformMatrix = __webpack_require__2(69360);
            var tempMatrix1 = new TransformMatrix();
            var tempMatrix2 = new TransformMatrix();
            var tempMatrix3 = new TransformMatrix();
            var result = {camera: tempMatrix1, sprite: tempMatrix2, calc: tempMatrix3};
            var GetCalcMatrix = function(src, camera, parentMatrix) {
              var camMatrix = tempMatrix1;
              var spriteMatrix = tempMatrix2;
              var calcMatrix = tempMatrix3;
              spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
              camMatrix.copyFrom(camera.matrix);
              if (parentMatrix) {
                camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
                spriteMatrix.e = src.x;
                spriteMatrix.f = src.y;
              } else {
                spriteMatrix.e -= camera.scrollX * src.scrollFactorX;
                spriteMatrix.f -= camera.scrollY * src.scrollFactorY;
              }
              camMatrix.multiply(spriteMatrix, calcMatrix);
              return result;
            };
            module2.exports = GetCalcMatrix;
          },
          92034: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ProcessQueue = __webpack_require__2(74623);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var UpdateList = new Class({
              Extends: ProcessQueue,
              initialize: function UpdateList2(scene) {
                ProcessQueue.call(this);
                this.checkQueue = true;
                this.scene = scene;
                this.systems = scene.sys;
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                scene.sys.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                var eventEmitter = this.systems.events;
                eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);
                eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);
                eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              sceneUpdate: function(time, delta) {
                var list = this._active;
                var length = list.length;
                for (var i = 0; i < length; i++) {
                  var gameObject = list[i];
                  if (gameObject.active) {
                    gameObject.preUpdate.call(gameObject, time, delta);
                  }
                }
              },
              shutdown: function() {
                var i = this._active.length;
                while (i--) {
                  this._active[i].destroy(true);
                }
                i = this._pending.length;
                while (i--) {
                  this._pending[i].destroy(true);
                }
                i = this._destroy.length;
                while (i--) {
                  this._destroy[i].destroy(true);
                }
                this._toProcess = 0;
                this._pending = [];
                this._active = [];
                this._destroy = [];
                this.removeAllListeners();
                var eventEmitter = this.systems.events;
                eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this);
                eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);
                eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                this.shutdown();
                this.systems.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.systems = null;
              }
            });
            PluginCache.register("UpdateList", UpdateList, "updateList");
            module2.exports = UpdateList;
          },
          8810: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BatchChar = function(pipeline, src, char, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit) {
              var x = char.x - src.displayOriginX + offsetX;
              var y = char.y - src.displayOriginY + offsetY;
              var xw = x + char.w;
              var yh = y + char.h;
              var tx0 = calcMatrix.getXRound(x, y, roundPixels);
              var ty0 = calcMatrix.getYRound(x, y, roundPixels);
              var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
              var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
              var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
              var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
              var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
              var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
              pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
            };
            module2.exports = BatchChar;
          },
          82173: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBitmapTextSize = function(src, round, updateOrigin, out) {
              if (updateOrigin === void 0) {
                updateOrigin = false;
              }
              if (out === void 0) {
                out = {
                  local: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  },
                  global: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  },
                  lines: {
                    shortest: 0,
                    longest: 0,
                    lengths: null,
                    height: 0
                  },
                  wrappedText: "",
                  words: [],
                  characters: [],
                  scaleX: 0,
                  scaleY: 0
                };
                return out;
              }
              var text = src.text;
              var textLength = text.length;
              var maxWidth = src.maxWidth;
              var wordWrapCharCode = src.wordWrapCharCode;
              var bx = Number.MAX_VALUE;
              var by = Number.MAX_VALUE;
              var bw = 0;
              var bh = 0;
              var chars = src.fontData.chars;
              var lineHeight = src.fontData.lineHeight;
              var letterSpacing = src.letterSpacing;
              var lineSpacing = src.lineSpacing;
              var xAdvance = 0;
              var yAdvance = 0;
              var charCode = 0;
              var glyph = null;
              var align = src._align;
              var x = 0;
              var y = 0;
              var scale = src.fontSize / src.fontData.size;
              var sx = scale * src.scaleX;
              var sy = scale * src.scaleY;
              var lastGlyph = null;
              var lastCharCode = 0;
              var lineWidths = [];
              var shortestLine = Number.MAX_VALUE;
              var longestLine = 0;
              var currentLine = 0;
              var currentLineWidth = 0;
              var i;
              var words = [];
              var characters = [];
              var current = null;
              if (maxWidth > 0) {
                for (i = 0; i < textLength; i++) {
                  charCode = text.charCodeAt(i);
                  if (charCode === 10) {
                    if (current !== null) {
                      words.push({
                        word: current.word,
                        i: current.i,
                        x: current.x * sx,
                        y: current.y * sy,
                        w: current.w * sx,
                        h: current.h * sy,
                        cr: true
                      });
                      current = null;
                    }
                    xAdvance = 0;
                    yAdvance += lineHeight + lineSpacing;
                    lastGlyph = null;
                    continue;
                  }
                  glyph = chars[charCode];
                  if (!glyph) {
                    continue;
                  }
                  if (lastGlyph !== null) {
                    var glyphKerningOffset = glyph.kerning[lastCharCode];
                  }
                  if (charCode === wordWrapCharCode) {
                    if (current !== null) {
                      words.push({
                        word: current.word,
                        i: current.i,
                        x: current.x * sx,
                        y: current.y * sy,
                        w: current.w * sx,
                        h: current.h * sy,
                        cr: false
                      });
                      current = null;
                    }
                  } else {
                    if (current === null) {
                      current = {word: "", i, x: xAdvance, y: yAdvance, w: 0, h: lineHeight, cr: false};
                    }
                    current.word = current.word.concat(text[i]);
                    current.w += glyph.xOffset + glyph.xAdvance + (glyphKerningOffset !== void 0 ? glyphKerningOffset : 0);
                  }
                  xAdvance += glyph.xAdvance + letterSpacing;
                  lastGlyph = glyph;
                  lastCharCode = charCode;
                }
                if (current !== null) {
                  words.push({
                    word: current.word,
                    i: current.i,
                    x: current.x * sx,
                    y: current.y * sy,
                    w: current.w * sx,
                    h: current.h * sy,
                    cr: false
                  });
                }
                xAdvance = 0;
                yAdvance = 0;
                lastGlyph = null;
                lastCharCode = 0;
                var prev;
                var offset = 0;
                var crs = [];
                for (i = 0; i < words.length; i++) {
                  var entry = words[i];
                  var left = entry.x;
                  var right = entry.x + entry.w;
                  if (prev) {
                    var diff = left - (prev.x + prev.w);
                    offset = left - (diff + prev.w);
                    prev = null;
                  }
                  var checkLeft = left - offset;
                  var checkRight = right - offset;
                  if (checkLeft > maxWidth || checkRight > maxWidth) {
                    crs.push(entry.i - 1);
                    if (entry.cr) {
                      crs.push(entry.i + entry.word.length);
                      offset = 0;
                      prev = null;
                    } else {
                      prev = entry;
                    }
                  } else if (entry.cr) {
                    crs.push(entry.i + entry.word.length);
                    offset = 0;
                    prev = null;
                  }
                }
                var stringInsert = function(str, index, value) {
                  return str.substr(0, index) + value + str.substr(index + 1);
                };
                for (i = crs.length - 1; i >= 0; i--) {
                  text = stringInsert(text, crs[i], "\n");
                }
                out.wrappedText = text;
                textLength = text.length;
                words = [];
                current = null;
              }
              var charIndex = 0;
              for (i = 0; i < textLength; i++) {
                charCode = text.charCodeAt(i);
                if (charCode === 10) {
                  if (current !== null) {
                    words.push({
                      word: current.word,
                      i: current.i,
                      x: current.x * sx,
                      y: current.y * sy,
                      w: current.w * sx,
                      h: current.h * sy
                    });
                    current = null;
                  }
                  xAdvance = 0;
                  yAdvance += lineHeight + lineSpacing;
                  lastGlyph = null;
                  lineWidths[currentLine] = currentLineWidth;
                  if (currentLineWidth > longestLine) {
                    longestLine = currentLineWidth;
                  }
                  if (currentLineWidth < shortestLine) {
                    shortestLine = currentLineWidth;
                  }
                  currentLine++;
                  currentLineWidth = 0;
                  continue;
                }
                glyph = chars[charCode];
                if (!glyph) {
                  continue;
                }
                x = xAdvance;
                y = yAdvance;
                if (lastGlyph !== null) {
                  var kerningOffset = glyph.kerning[lastCharCode];
                  x += kerningOffset !== void 0 ? kerningOffset : 0;
                }
                if (bx > x) {
                  bx = x;
                }
                if (by > y) {
                  by = y;
                }
                var gw = x + glyph.xAdvance;
                var gh = y + lineHeight;
                if (bw < gw) {
                  bw = gw;
                }
                if (bh < gh) {
                  bh = gh;
                }
                var charWidth = glyph.xOffset + glyph.xAdvance + (kerningOffset !== void 0 ? kerningOffset : 0);
                if (charCode === wordWrapCharCode) {
                  if (current !== null) {
                    words.push({
                      word: current.word,
                      i: current.i,
                      x: current.x * sx,
                      y: current.y * sy,
                      w: current.w * sx,
                      h: current.h * sy
                    });
                    current = null;
                  }
                } else {
                  if (current === null) {
                    current = {word: "", i: charIndex, x: xAdvance, y: yAdvance, w: 0, h: lineHeight};
                  }
                  current.word = current.word.concat(text[i]);
                  current.w += charWidth;
                }
                characters.push({
                  i: charIndex,
                  idx: i,
                  char: text[i],
                  code: charCode,
                  x: (glyph.xOffset + x) * scale,
                  y: (glyph.yOffset + yAdvance) * scale,
                  w: glyph.width * scale,
                  h: glyph.height * scale,
                  t: yAdvance * scale,
                  r: gw * scale,
                  b: lineHeight * scale,
                  line: currentLine,
                  glyph
                });
                xAdvance += glyph.xAdvance + letterSpacing + (kerningOffset !== void 0 ? kerningOffset : 0);
                lastGlyph = glyph;
                lastCharCode = charCode;
                currentLineWidth = gw * scale;
                charIndex++;
              }
              if (current !== null) {
                words.push({
                  word: current.word,
                  i: current.i,
                  x: current.x * sx,
                  y: current.y * sy,
                  w: current.w * sx,
                  h: current.h * sy
                });
              }
              lineWidths[currentLine] = currentLineWidth;
              if (currentLineWidth > longestLine) {
                longestLine = currentLineWidth;
              }
              if (currentLineWidth < shortestLine) {
                shortestLine = currentLineWidth;
              }
              if (align > 0) {
                for (var c = 0; c < characters.length; c++) {
                  var currentChar = characters[c];
                  if (align === 1) {
                    var ax1 = (longestLine - lineWidths[currentChar.line]) / 2;
                    currentChar.x += ax1;
                    currentChar.r += ax1;
                  } else if (align === 2) {
                    var ax2 = longestLine - lineWidths[currentChar.line];
                    currentChar.x += ax2;
                    currentChar.r += ax2;
                  }
                }
              }
              var local = out.local;
              var global = out.global;
              var lines = out.lines;
              local.x = bx * scale;
              local.y = by * scale;
              local.width = bw * scale;
              local.height = bh * scale;
              global.x = src.x - src._displayOriginX + bx * sx;
              global.y = src.y - src._displayOriginY + by * sy;
              global.width = bw * sx;
              global.height = bh * sy;
              lines.shortest = shortestLine;
              lines.longest = longestLine;
              lines.lengths = lineWidths;
              if (round) {
                local.x = Math.ceil(local.x);
                local.y = Math.ceil(local.y);
                local.width = Math.ceil(local.width);
                local.height = Math.ceil(local.height);
                global.x = Math.ceil(global.x);
                global.y = Math.ceil(global.y);
                global.width = Math.ceil(global.width);
                global.height = Math.ceil(global.height);
                lines.shortest = Math.ceil(shortestLine);
                lines.longest = Math.ceil(longestLine);
              }
              if (updateOrigin) {
                src._displayOriginX = src.originX * local.width;
                src._displayOriginY = src.originY * local.height;
                global.x = src.x - src._displayOriginX * src.scaleX;
                global.y = src.y - src._displayOriginY * src.scaleY;
                if (round) {
                  global.x = Math.ceil(global.x);
                  global.y = Math.ceil(global.y);
                }
              }
              out.words = words;
              out.characters = characters;
              out.lines.height = lineHeight;
              out.scale = scale;
              out.scaleX = src.scaleX;
              out.scaleY = src.scaleY;
              return out;
            };
            module2.exports = GetBitmapTextSize;
          },
          68298: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ParseXMLBitmapFont = __webpack_require__2(31476);
            var ParseFromAtlas = function(scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing) {
              var texture = scene.sys.textures.get(textureKey);
              var frame = texture.get(frameKey);
              var xml = scene.sys.cache.xml.get(xmlKey);
              if (frame && xml) {
                var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);
                scene.sys.cache.bitmapFont.add(fontName, {data, texture: textureKey, frame: frameKey, fromAtlas: true});
                return true;
              } else {
                return false;
              }
            };
            module2.exports = ParseFromAtlas;
          },
          39860: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetValue = __webpack_require__2(10850);
            var ParseRetroFont = function(scene, config2) {
              var w = config2.width;
              var h = config2.height;
              var cx = Math.floor(w / 2);
              var cy = Math.floor(h / 2);
              var letters = GetValue(config2, "chars", "");
              if (letters === "") {
                return;
              }
              var key = GetValue(config2, "image", "");
              var frame = scene.sys.textures.getFrame(key);
              var textureX = frame.cutX;
              var textureY = frame.cutY;
              var textureWidth = frame.source.width;
              var textureHeight = frame.source.height;
              var offsetX = GetValue(config2, "offset.x", 0);
              var offsetY = GetValue(config2, "offset.y", 0);
              var spacingX = GetValue(config2, "spacing.x", 0);
              var spacingY = GetValue(config2, "spacing.y", 0);
              var lineSpacing = GetValue(config2, "lineSpacing", 0);
              var charsPerRow = GetValue(config2, "charsPerRow", null);
              if (charsPerRow === null) {
                charsPerRow = textureWidth / w;
                if (charsPerRow > letters.length) {
                  charsPerRow = letters.length;
                }
              }
              var x = offsetX;
              var y = offsetY;
              var data = {
                retroFont: true,
                font: key,
                size: w,
                lineHeight: h + lineSpacing,
                chars: {}
              };
              var r = 0;
              for (var i = 0; i < letters.length; i++) {
                var charCode = letters.charCodeAt(i);
                var u0 = (textureX + x) / textureWidth;
                var v0 = (textureY + y) / textureHeight;
                var u1 = (textureX + x + w) / textureWidth;
                var v1 = (textureY + y + h) / textureHeight;
                data.chars[charCode] = {
                  x,
                  y,
                  width: w,
                  height: h,
                  centerX: cx,
                  centerY: cy,
                  xOffset: 0,
                  yOffset: 0,
                  xAdvance: w,
                  data: {},
                  kerning: {},
                  u0,
                  v0,
                  u1,
                  v1
                };
                r++;
                if (r === charsPerRow) {
                  r = 0;
                  x = offsetX;
                  y += h + spacingY;
                } else {
                  x += w + spacingX;
                }
              }
              var entry = {
                data,
                frame: null,
                texture: key
              };
              return entry;
            };
            module2.exports = ParseRetroFont;
          },
          31476: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            function getValue(node, attribute) {
              return parseInt(node.getAttribute(attribute), 10);
            }
            var ParseXMLBitmapFont = function(xml, frame, xSpacing, ySpacing, texture) {
              if (xSpacing === void 0) {
                xSpacing = 0;
              }
              if (ySpacing === void 0) {
                ySpacing = 0;
              }
              var textureX = frame.cutX;
              var textureY = frame.cutY;
              var textureWidth = frame.source.width;
              var textureHeight = frame.source.height;
              var sourceIndex = frame.sourceIndex;
              var data = {};
              var info = xml.getElementsByTagName("info")[0];
              var common = xml.getElementsByTagName("common")[0];
              data.font = info.getAttribute("face");
              data.size = getValue(info, "size");
              data.lineHeight = getValue(common, "lineHeight") + ySpacing;
              data.chars = {};
              var letters = xml.getElementsByTagName("char");
              var adjustForTrim = frame !== void 0 && frame.trimmed;
              if (adjustForTrim) {
                var top = frame.height;
                var left = frame.width;
              }
              for (var i = 0; i < letters.length; i++) {
                var node = letters[i];
                var charCode = getValue(node, "id");
                var letter = String.fromCharCode(charCode);
                var gx = getValue(node, "x");
                var gy = getValue(node, "y");
                var gw = getValue(node, "width");
                var gh = getValue(node, "height");
                if (adjustForTrim) {
                  if (gx < left) {
                    left = gx;
                  }
                  if (gy < top) {
                    top = gy;
                  }
                }
                if (adjustForTrim && top !== 0 && left !== 0) {
                  gx -= frame.x;
                  gy -= frame.y;
                }
                var u0 = (textureX + gx) / textureWidth;
                var v0 = (textureY + gy) / textureHeight;
                var u1 = (textureX + gx + gw) / textureWidth;
                var v1 = (textureY + gy + gh) / textureHeight;
                data.chars[charCode] = {
                  x: gx,
                  y: gy,
                  width: gw,
                  height: gh,
                  centerX: Math.floor(gw / 2),
                  centerY: Math.floor(gh / 2),
                  xOffset: getValue(node, "xoffset"),
                  yOffset: getValue(node, "yoffset"),
                  xAdvance: getValue(node, "xadvance") + xSpacing,
                  data: {},
                  kerning: {},
                  u0,
                  v0,
                  u1,
                  v1
                };
                if (texture && gw !== 0 && gh !== 0) {
                  var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);
                  if (charFrame) {
                    charFrame.setUVs(gw, gh, u0, v0, u1, v1);
                  }
                }
              }
              var kernings = xml.getElementsByTagName("kerning");
              for (i = 0; i < kernings.length; i++) {
                var kern = kernings[i];
                var first = getValue(kern, "first");
                var second = getValue(kern, "second");
                var amount = getValue(kern, "amount");
                data.chars[second].kerning[first] = amount;
              }
              return data;
            };
            module2.exports = ParseXMLBitmapFont;
          },
          55873: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RETRO_FONT_CONST = __webpack_require__2(66863);
            var Extend = __webpack_require__2(98611);
            var RetroFont = {Parse: __webpack_require__2(39860)};
            RetroFont = Extend(false, RetroFont, RETRO_FONT_CONST);
            module2.exports = RetroFont;
          },
          66863: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RETRO_FONT_CONST = {
              TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
              TEXT_SET2: ` !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ`,
              TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
              TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
              TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
              TEXT_SET6: `ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' `,
              TEXT_SET7: `AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39`,
              TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
              TEXT_SET9: `ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!`,
              TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
              TEXT_SET11: `ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789`
            };
            module2.exports = RETRO_FONT_CONST;
          },
          13468: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BitmapText = __webpack_require__2(44616);
            var Class = __webpack_require__2(56694);
            var Render = __webpack_require__2(88899);
            var DynamicBitmapText = new Class({
              Extends: BitmapText,
              Mixins: [
                Render
              ],
              initialize: function DynamicBitmapText2(scene, x, y, font, text, size, align) {
                BitmapText.call(this, scene, x, y, font, text, size, align);
                this.type = "DynamicBitmapText";
                this.scrollX = 0;
                this.scrollY = 0;
                this.cropWidth = 0;
                this.cropHeight = 0;
                this.displayCallback;
                this.callbackData = {
                  parent: this,
                  color: 0,
                  tint: {
                    topLeft: 0,
                    topRight: 0,
                    bottomLeft: 0,
                    bottomRight: 0
                  },
                  index: 0,
                  charCode: 0,
                  x: 0,
                  y: 0,
                  scale: 0,
                  rotation: 0,
                  data: 0
                };
              },
              setSize: function(width, height) {
                this.cropWidth = width;
                this.cropHeight = height;
                return this;
              },
              setDisplayCallback: function(callback) {
                this.displayCallback = callback;
                return this;
              },
              setScrollX: function(value) {
                this.scrollX = value;
                return this;
              },
              setScrollY: function(value) {
                this.scrollY = value;
                return this;
              }
            });
            module2.exports = DynamicBitmapText;
          },
          93438: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTransform = __webpack_require__2(49584);
            var DynamicBitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              var text = src._text;
              var textLength = text.length;
              var ctx = renderer.currentContext;
              if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                return;
              }
              camera.addToRenderList(src);
              var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
              var displayCallback = src.displayCallback;
              var callbackData = src.callbackData;
              var chars = src.fontData.chars;
              var lineHeight = src.fontData.lineHeight;
              var letterSpacing = src._letterSpacing;
              var xAdvance = 0;
              var yAdvance = 0;
              var charCode = 0;
              var glyph = null;
              var glyphX = 0;
              var glyphY = 0;
              var glyphW = 0;
              var glyphH = 0;
              var x = 0;
              var y = 0;
              var lastGlyph = null;
              var lastCharCode = 0;
              var image = src.frame.source.image;
              var textureX = textureFrame.cutX;
              var textureY = textureFrame.cutY;
              var rotation = 0;
              var scale = 0;
              var baseScale = src._fontSize / src.fontData.size;
              var align = src._align;
              var currentLine = 0;
              var lineOffsetX = 0;
              src.getTextBounds(false);
              var lineData = src._bounds.lines;
              if (align === 1) {
                lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
              } else if (align === 2) {
                lineOffsetX = lineData.longest - lineData.lengths[0];
              }
              ctx.translate(-src.displayOriginX, -src.displayOriginY);
              var roundPixels = camera.roundPixels;
              if (src.cropWidth > 0 && src.cropHeight > 0) {
                ctx.beginPath();
                ctx.rect(0, 0, src.cropWidth, src.cropHeight);
                ctx.clip();
              }
              for (var i = 0; i < textLength; i++) {
                scale = baseScale;
                rotation = 0;
                charCode = text.charCodeAt(i);
                if (charCode === 10) {
                  currentLine++;
                  if (align === 1) {
                    lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                  } else if (align === 2) {
                    lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                  }
                  xAdvance = 0;
                  yAdvance += lineHeight;
                  lastGlyph = null;
                  continue;
                }
                glyph = chars[charCode];
                if (!glyph) {
                  continue;
                }
                glyphX = textureX + glyph.x;
                glyphY = textureY + glyph.y;
                glyphW = glyph.width;
                glyphH = glyph.height;
                x = glyph.xOffset + xAdvance - src.scrollX;
                y = glyph.yOffset + yAdvance - src.scrollY;
                if (lastGlyph !== null) {
                  var kerningOffset = glyph.kerning[lastCharCode];
                  x += kerningOffset !== void 0 ? kerningOffset : 0;
                }
                if (displayCallback) {
                  callbackData.index = i;
                  callbackData.charCode = charCode;
                  callbackData.x = x;
                  callbackData.y = y;
                  callbackData.scale = scale;
                  callbackData.rotation = rotation;
                  callbackData.data = glyph.data;
                  var output = displayCallback(callbackData);
                  x = output.x;
                  y = output.y;
                  scale = output.scale;
                  rotation = output.rotation;
                }
                x *= scale;
                y *= scale;
                x += lineOffsetX;
                xAdvance += glyph.xAdvance + letterSpacing + (kerningOffset !== void 0 ? kerningOffset : 0);
                lastGlyph = glyph;
                lastCharCode = charCode;
                if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                  continue;
                }
                if (roundPixels) {
                  x = Math.round(x);
                  y = Math.round(y);
                }
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);
                ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
                ctx.restore();
              }
              ctx.restore();
            };
            module2.exports = DynamicBitmapTextCanvasRenderer;
          },
          67513: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BitmapText = __webpack_require__2(13468);
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            GameObjectCreator.register("dynamicBitmapText", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var font = GetAdvancedValue(config2, "font", "");
              var text = GetAdvancedValue(config2, "text", "");
              var size = GetAdvancedValue(config2, "size", false);
              var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, bitmapText, config2);
              return bitmapText;
            });
          },
          94145: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DynamicBitmapText = __webpack_require__2(13468);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("dynamicBitmapText", function(x, y, font, text, size) {
              return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));
            });
          },
          88899: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(16873);
            }
            if (true) {
              renderCanvas = __webpack_require__2(93438);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          16873: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var TransformMatrix = __webpack_require__2(69360);
            var Utils = __webpack_require__2(75512);
            var tempMatrix = new TransformMatrix();
            var DynamicBitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              var text = src.text;
              var textLength = text.length;
              if (textLength === 0) {
                return;
              }
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              renderer.pipelines.preBatch(src);
              var spriteMatrix = result.sprite;
              var calcMatrix = result.calc;
              var fontMatrix = tempMatrix;
              var crop = src.cropWidth > 0 || src.cropHeight > 0;
              if (crop) {
                pipeline.flush();
                renderer.pushScissor(calcMatrix.tx, calcMatrix.ty, src.cropWidth * calcMatrix.scaleX, src.cropHeight * calcMatrix.scaleY);
              }
              var frame = src.frame;
              var texture = frame.glTexture;
              var tintEffect = src.tintFill;
              var tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL);
              var tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR);
              var tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL);
              var tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR);
              var textureUnit = pipeline.setGameObject(src);
              var xAdvance = 0;
              var yAdvance = 0;
              var charCode = 0;
              var lastCharCode = 0;
              var letterSpacing = src.letterSpacing;
              var glyph;
              var glyphW = 0;
              var glyphH = 0;
              var lastGlyph;
              var scrollX = src.scrollX;
              var scrollY = src.scrollY;
              var fontData = src.fontData;
              var chars = fontData.chars;
              var lineHeight = fontData.lineHeight;
              var scale = src.fontSize / fontData.size;
              var rotation = 0;
              var align = src._align;
              var currentLine = 0;
              var lineOffsetX = 0;
              var bounds = src.getTextBounds(false);
              if (src.maxWidth > 0) {
                text = bounds.wrappedText;
                textLength = text.length;
              }
              var lineData = src._bounds.lines;
              if (align === 1) {
                lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
              } else if (align === 2) {
                lineOffsetX = lineData.longest - lineData.lengths[0];
              }
              var roundPixels = camera.roundPixels;
              var displayCallback = src.displayCallback;
              var callbackData = src.callbackData;
              for (var i = 0; i < textLength; i++) {
                charCode = text.charCodeAt(i);
                if (charCode === 10) {
                  currentLine++;
                  if (align === 1) {
                    lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                  } else if (align === 2) {
                    lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                  }
                  xAdvance = 0;
                  yAdvance += lineHeight;
                  lastGlyph = null;
                  continue;
                }
                glyph = chars[charCode];
                if (!glyph) {
                  continue;
                }
                glyphW = glyph.width;
                glyphH = glyph.height;
                var x = glyph.xOffset + xAdvance - scrollX;
                var y = glyph.yOffset + yAdvance - scrollY;
                if (lastGlyph !== null) {
                  var kerningOffset = glyph.kerning[lastCharCode];
                  x += kerningOffset !== void 0 ? kerningOffset : 0;
                }
                xAdvance += glyph.xAdvance + letterSpacing;
                lastGlyph = glyph;
                lastCharCode = charCode;
                if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                  continue;
                }
                scale = src.fontSize / src.fontData.size;
                rotation = 0;
                if (displayCallback) {
                  callbackData.color = 0;
                  callbackData.tint.topLeft = tintTL;
                  callbackData.tint.topRight = tintTR;
                  callbackData.tint.bottomLeft = tintBL;
                  callbackData.tint.bottomRight = tintBR;
                  callbackData.index = i;
                  callbackData.charCode = charCode;
                  callbackData.x = x;
                  callbackData.y = y;
                  callbackData.scale = scale;
                  callbackData.rotation = rotation;
                  callbackData.data = glyph.data;
                  var output = displayCallback(callbackData);
                  x = output.x;
                  y = output.y;
                  scale = output.scale;
                  rotation = output.rotation;
                  if (output.color) {
                    tintTL = output.color;
                    tintTR = output.color;
                    tintBL = output.color;
                    tintBR = output.color;
                  } else {
                    tintTL = output.tint.topLeft;
                    tintTR = output.tint.topRight;
                    tintBL = output.tint.bottomLeft;
                    tintBR = output.tint.bottomRight;
                  }
                  tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);
                  tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);
                  tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);
                  tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);
                }
                x *= scale;
                y *= scale;
                x -= src.displayOriginX;
                y -= src.displayOriginY;
                x += lineOffsetX;
                fontMatrix.applyITRS(x, y, rotation, scale, scale);
                calcMatrix.multiply(fontMatrix, spriteMatrix);
                var u0 = glyph.u0;
                var v0 = glyph.v0;
                var u1 = glyph.u1;
                var v1 = glyph.v1;
                var xw = glyphW;
                var yh = glyphH;
                var tx0 = spriteMatrix.e;
                var ty0 = spriteMatrix.f;
                var tx1 = yh * spriteMatrix.c + spriteMatrix.e;
                var ty1 = yh * spriteMatrix.d + spriteMatrix.f;
                var tx2 = xw * spriteMatrix.a + yh * spriteMatrix.c + spriteMatrix.e;
                var ty2 = xw * spriteMatrix.b + yh * spriteMatrix.d + spriteMatrix.f;
                var tx3 = xw * spriteMatrix.a + spriteMatrix.e;
                var ty3 = xw * spriteMatrix.b + spriteMatrix.f;
                if (roundPixels) {
                  tx0 = Math.round(tx0);
                  ty0 = Math.round(ty0);
                  tx1 = Math.round(tx1);
                  ty1 = Math.round(ty1);
                  tx2 = Math.round(tx2);
                  ty2 = Math.round(ty2);
                  tx3 = Math.round(tx3);
                  ty3 = Math.round(ty3);
                }
                if (pipeline.shouldFlush(6)) {
                  pipeline.flush();
                  textureUnit = pipeline.setGameObject(src);
                }
                pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
              }
              if (crop) {
                pipeline.flush();
                renderer.popScissor();
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = DynamicBitmapTextWebGLRenderer;
          },
          44616: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Clamp = __webpack_require__2(82897);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var GetBitmapTextSize = __webpack_require__2(82173);
            var ParseFromAtlas = __webpack_require__2(68298);
            var ParseXMLBitmapFont = __webpack_require__2(31476);
            var Rectangle = __webpack_require__2(74118);
            var Render = __webpack_require__2(84557);
            var BitmapText = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Texture,
                Components.Tint,
                Components.Transform,
                Components.Visible,
                Render
              ],
              initialize: function BitmapText2(scene, x, y, font, text, size, align) {
                if (text === void 0) {
                  text = "";
                }
                if (align === void 0) {
                  align = 0;
                }
                GameObject.call(this, scene, "BitmapText");
                this.font = font;
                var entry = this.scene.sys.cache.bitmapFont.get(font);
                if (!entry) {
                  console.warn("Invalid BitmapText key: " + font);
                }
                this.fontData = entry.data;
                this._text = "";
                this._fontSize = size || this.fontData.size;
                this._letterSpacing = 0;
                this._lineSpacing = 0;
                this._align = align;
                this._bounds = GetBitmapTextSize();
                this._dirty = true;
                this._maxWidth = 0;
                this.wordWrapCharCode = 32;
                this.charColors = [];
                this.dropShadowX = 0;
                this.dropShadowY = 0;
                this.dropShadowColor = 0;
                this.dropShadowAlpha = 0.5;
                this.fromAtlas = entry.fromAtlas;
                this.setTexture(entry.texture, entry.frame);
                this.setPosition(x, y);
                this.setOrigin(0, 0);
                this.initPipeline();
                this.initPostPipeline();
                this.setText(text);
              },
              setLeftAlign: function() {
                this._align = BitmapText.ALIGN_LEFT;
                this._dirty = true;
                return this;
              },
              setCenterAlign: function() {
                this._align = BitmapText.ALIGN_CENTER;
                this._dirty = true;
                return this;
              },
              setRightAlign: function() {
                this._align = BitmapText.ALIGN_RIGHT;
                this._dirty = true;
                return this;
              },
              setFontSize: function(size) {
                this._fontSize = size;
                this._dirty = true;
                return this;
              },
              setLetterSpacing: function(spacing) {
                if (spacing === void 0) {
                  spacing = 0;
                }
                this._letterSpacing = spacing;
                this._dirty = true;
                return this;
              },
              setLineSpacing: function(spacing) {
                if (spacing === void 0) {
                  spacing = 0;
                }
                this.lineSpacing = spacing;
                return this;
              },
              setText: function(value) {
                if (!value && value !== 0) {
                  value = "";
                }
                if (Array.isArray(value)) {
                  value = value.join("\n");
                }
                if (value !== this.text) {
                  this._text = value.toString();
                  this._dirty = true;
                  this.updateDisplayOrigin();
                }
                return this;
              },
              setDropShadow: function(x, y, color, alpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (color === void 0) {
                  color = 0;
                }
                if (alpha === void 0) {
                  alpha = 0.5;
                }
                this.dropShadowX = x;
                this.dropShadowY = y;
                this.dropShadowColor = color;
                this.dropShadowAlpha = alpha;
                return this;
              },
              setCharacterTint: function(start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
                if (start === void 0) {
                  start = 0;
                }
                if (length === void 0) {
                  length = 1;
                }
                if (tintFill === void 0) {
                  tintFill = false;
                }
                if (topLeft === void 0) {
                  topLeft = -1;
                }
                if (topRight === void 0) {
                  topRight = topLeft;
                  bottomLeft = topLeft;
                  bottomRight = topLeft;
                }
                var len = this.text.length;
                if (length === -1) {
                  length = len;
                }
                if (start < 0) {
                  start = len + start;
                }
                start = Clamp(start, 0, len - 1);
                var end = Clamp(start + length, start, len);
                var charColors = this.charColors;
                for (var i = start; i < end; i++) {
                  var color = charColors[i];
                  if (topLeft === -1) {
                    charColors[i] = null;
                  } else {
                    var tintEffect = tintFill ? 1 : 0;
                    if (color) {
                      color.tintEffect = tintEffect;
                      color.tintTL = topLeft;
                      color.tintTR = topRight;
                      color.tintBL = bottomLeft;
                      color.tintBR = bottomRight;
                    } else {
                      charColors[i] = {
                        tintEffect,
                        tintTL: topLeft,
                        tintTR: topRight,
                        tintBL: bottomLeft,
                        tintBR: bottomRight
                      };
                    }
                  }
                }
                return this;
              },
              setWordTint: function(word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
                if (count === void 0) {
                  count = 1;
                }
                var bounds = this.getTextBounds();
                var words = bounds.words;
                var wordIsNumber = typeof word === "number";
                var total = 0;
                for (var i = 0; i < words.length; i++) {
                  var lineword = words[i];
                  if (wordIsNumber && i === word || !wordIsNumber && lineword.word === word) {
                    this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);
                    total++;
                    if (total === count) {
                      return this;
                    }
                  }
                }
                return this;
              },
              getTextBounds: function(round) {
                var bounds = this._bounds;
                if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY) {
                  GetBitmapTextSize(this, round, true, bounds);
                  this._dirty = false;
                }
                return bounds;
              },
              getCharacterAt: function(x, y, camera) {
                var point = this.getLocalPoint(x, y, null, camera);
                var bounds = this.getTextBounds();
                var chars = bounds.characters;
                var tempRect = new Rectangle();
                for (var i = 0; i < chars.length; i++) {
                  var char = chars[i];
                  tempRect.setTo(char.x, char.t, char.r - char.x, char.b);
                  if (tempRect.contains(point.x, point.y)) {
                    return char;
                  }
                }
                return null;
              },
              updateDisplayOrigin: function() {
                this._dirty = true;
                this.getTextBounds(false);
                return this;
              },
              setFont: function(key, size, align) {
                if (size === void 0) {
                  size = this._fontSize;
                }
                if (align === void 0) {
                  align = this._align;
                }
                if (key !== this.font) {
                  var entry = this.scene.sys.cache.bitmapFont.get(key);
                  if (entry) {
                    this.font = key;
                    this.fontData = entry.data;
                    this._fontSize = size;
                    this._align = align;
                    this.fromAtlas = entry.fromAtlas === true;
                    this.setTexture(entry.texture, entry.frame);
                    GetBitmapTextSize(this, false, true, this._bounds);
                  }
                }
                return this;
              },
              setMaxWidth: function(value, wordWrapCharCode) {
                this._maxWidth = value;
                this._dirty = true;
                if (wordWrapCharCode !== void 0) {
                  this.wordWrapCharCode = wordWrapCharCode;
                }
                return this;
              },
              align: {
                set: function(value) {
                  this._align = value;
                  this._dirty = true;
                },
                get: function() {
                  return this._align;
                }
              },
              text: {
                set: function(value) {
                  this.setText(value);
                },
                get: function() {
                  return this._text;
                }
              },
              fontSize: {
                set: function(value) {
                  this._fontSize = value;
                  this._dirty = true;
                },
                get: function() {
                  return this._fontSize;
                }
              },
              letterSpacing: {
                set: function(value) {
                  this._letterSpacing = value;
                  this._dirty = true;
                },
                get: function() {
                  return this._letterSpacing;
                }
              },
              lineSpacing: {
                set: function(value) {
                  this._lineSpacing = value;
                  this._dirty = true;
                },
                get: function() {
                  return this._lineSpacing;
                }
              },
              maxWidth: {
                set: function(value) {
                  this._maxWidth = value;
                  this._dirty = true;
                },
                get: function() {
                  return this._maxWidth;
                }
              },
              width: {
                get: function() {
                  this.getTextBounds(false);
                  return this._bounds.global.width;
                }
              },
              height: {
                get: function() {
                  this.getTextBounds(false);
                  return this._bounds.global.height;
                }
              },
              displayWidth: {
                get: function() {
                  return this.width;
                }
              },
              displayHeight: {
                get: function() {
                  return this.height;
                }
              },
              toJSON: function() {
                var out = Components.ToJSON(this);
                var data = {
                  font: this.font,
                  text: this.text,
                  fontSize: this.fontSize,
                  letterSpacing: this.letterSpacing,
                  lineSpacing: this.lineSpacing,
                  align: this.align
                };
                out.data = data;
                return out;
              },
              preDestroy: function() {
                this.charColors.length = 0;
                this._bounds = null;
                this.fontData = null;
              }
            });
            BitmapText.ALIGN_LEFT = 0;
            BitmapText.ALIGN_CENTER = 1;
            BitmapText.ALIGN_RIGHT = 2;
            BitmapText.ParseFromAtlas = ParseFromAtlas;
            BitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;
            module2.exports = BitmapText;
          },
          97545: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTransform = __webpack_require__2(49584);
            var BitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              var text = src._text;
              var textLength = text.length;
              var ctx = renderer.currentContext;
              if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                return;
              }
              camera.addToRenderList(src);
              var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
              var chars = src.fontData.chars;
              var lineHeight = src.fontData.lineHeight;
              var letterSpacing = src._letterSpacing;
              var lineSpacing = src._lineSpacing;
              var xAdvance = 0;
              var yAdvance = 0;
              var charCode = 0;
              var glyph = null;
              var glyphX = 0;
              var glyphY = 0;
              var glyphW = 0;
              var glyphH = 0;
              var x = 0;
              var y = 0;
              var lastGlyph = null;
              var lastCharCode = 0;
              var image = textureFrame.source.image;
              var textureX = textureFrame.cutX;
              var textureY = textureFrame.cutY;
              var scale = src._fontSize / src.fontData.size;
              var align = src._align;
              var currentLine = 0;
              var lineOffsetX = 0;
              var bounds = src.getTextBounds(false);
              if (src.maxWidth > 0) {
                text = bounds.wrappedText;
                textLength = text.length;
              }
              var lineData = src._bounds.lines;
              if (align === 1) {
                lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
              } else if (align === 2) {
                lineOffsetX = lineData.longest - lineData.lengths[0];
              }
              ctx.translate(-src.displayOriginX, -src.displayOriginY);
              var roundPixels = camera.roundPixels;
              for (var i = 0; i < textLength; i++) {
                charCode = text.charCodeAt(i);
                if (charCode === 10) {
                  currentLine++;
                  if (align === 1) {
                    lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                  } else if (align === 2) {
                    lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                  }
                  xAdvance = 0;
                  yAdvance += lineHeight + lineSpacing;
                  lastGlyph = null;
                  continue;
                }
                glyph = chars[charCode];
                if (!glyph) {
                  continue;
                }
                glyphX = textureX + glyph.x;
                glyphY = textureY + glyph.y;
                glyphW = glyph.width;
                glyphH = glyph.height;
                x = glyph.xOffset + xAdvance;
                y = glyph.yOffset + yAdvance;
                if (lastGlyph !== null) {
                  var kerningOffset = glyph.kerning[lastCharCode];
                  x += kerningOffset !== void 0 ? kerningOffset : 0;
                }
                x *= scale;
                y *= scale;
                x += lineOffsetX;
                xAdvance += glyph.xAdvance + letterSpacing + (kerningOffset !== void 0 ? kerningOffset : 0);
                lastGlyph = glyph;
                lastCharCode = charCode;
                if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                  continue;
                }
                if (roundPixels) {
                  x = Math.round(x);
                  y = Math.round(y);
                }
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(scale, scale);
                ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
                ctx.restore();
              }
              ctx.restore();
            };
            module2.exports = BitmapTextCanvasRenderer;
          },
          95499: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BitmapText = __webpack_require__2(44616);
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetValue = __webpack_require__2(10850);
            GameObjectCreator.register("bitmapText", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var font = GetValue(config2, "font", "");
              var text = GetAdvancedValue(config2, "text", "");
              var size = GetAdvancedValue(config2, "size", false);
              var align = GetValue(config2, "align", 0);
              var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, bitmapText, config2);
              return bitmapText;
            });
          },
          21797: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BitmapText = __webpack_require__2(44616);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("bitmapText", function(x, y, font, text, size, align) {
              return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));
            });
          },
          84557: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(26372);
            }
            if (true) {
              renderCanvas = __webpack_require__2(97545);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          26372: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BatchChar = __webpack_require__2(8810);
            var GetCalcMatrix = __webpack_require__2(73329);
            var Utils = __webpack_require__2(75512);
            var BitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              var text = src._text;
              var textLength = text.length;
              if (textLength === 0) {
                return;
              }
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              renderer.pipelines.preBatch(src);
              var roundPixels = camera.roundPixels;
              var cameraAlpha = camera.alpha;
              var charColors = src.charColors;
              var tintEffect = src.tintFill;
              var getTint = Utils.getTintAppendFloatAlpha;
              var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);
              var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);
              var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);
              var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);
              var texture = src.frame.glTexture;
              var textureUnit = pipeline.setGameObject(src);
              var bounds = src.getTextBounds(false);
              var i;
              var char;
              var glyph;
              var characters = bounds.characters;
              var dropShadowX = src.dropShadowX;
              var dropShadowY = src.dropShadowY;
              var dropShadow = dropShadowX !== 0 || dropShadowY !== 0;
              if (dropShadow) {
                var srcShadowColor = src.dropShadowColor;
                var srcShadowAlpha = src.dropShadowAlpha;
                var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);
                var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);
                var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);
                var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);
                for (i = 0; i < characters.length; i++) {
                  char = characters[i];
                  glyph = char.glyph;
                  if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
                    continue;
                  }
                  BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);
                }
              }
              for (i = 0; i < characters.length; i++) {
                char = characters[i];
                glyph = char.glyph;
                if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
                  continue;
                }
                if (pipeline.shouldFlush(6)) {
                  pipeline.flush();
                  textureUnit = pipeline.setGameObject(src);
                }
                if (charColors[char.i]) {
                  var color = charColors[char.i];
                  var charTintEffect = color.tintEffect;
                  var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);
                  var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);
                  var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);
                  var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);
                  BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);
                } else {
                  BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
                }
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = BitmapTextWebGLRenderer;
          },
          52816: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BlitterRender = __webpack_require__2(92246);
            var Bob = __webpack_require__2(41664);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var Frame = __webpack_require__2(82047);
            var GameObject = __webpack_require__2(89980);
            var List = __webpack_require__2(71207);
            var Blitter = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Size,
                Components.Texture,
                Components.Transform,
                Components.Visible,
                BlitterRender
              ],
              initialize: function Blitter2(scene, x, y, texture, frame) {
                GameObject.call(this, scene, "Blitter");
                this.setTexture(texture, frame);
                this.setPosition(x, y);
                this.initPipeline();
                this.initPostPipeline();
                this.children = new List();
                this.renderList = [];
                this.dirty = false;
              },
              create: function(x, y, frame, visible, index) {
                if (visible === void 0) {
                  visible = true;
                }
                if (index === void 0) {
                  index = this.children.length;
                }
                if (frame === void 0) {
                  frame = this.frame;
                } else if (!(frame instanceof Frame)) {
                  frame = this.texture.get(frame);
                }
                var bob = new Bob(this, x, y, frame, visible);
                this.children.addAt(bob, index, false);
                this.dirty = true;
                return bob;
              },
              createFromCallback: function(callback, quantity, frame, visible) {
                var bobs = this.createMultiple(quantity, frame, visible);
                for (var i = 0; i < bobs.length; i++) {
                  var bob = bobs[i];
                  callback.call(this, bob, i);
                }
                return bobs;
              },
              createMultiple: function(quantity, frame, visible) {
                if (frame === void 0) {
                  frame = this.frame.name;
                }
                if (visible === void 0) {
                  visible = true;
                }
                if (!Array.isArray(frame)) {
                  frame = [frame];
                }
                var bobs = [];
                var _this = this;
                frame.forEach(function(singleFrame) {
                  for (var i = 0; i < quantity; i++) {
                    bobs.push(_this.create(0, 0, singleFrame, visible));
                  }
                });
                return bobs;
              },
              childCanRender: function(child) {
                return child.visible && child.alpha > 0;
              },
              getRenderList: function() {
                if (this.dirty) {
                  this.renderList = this.children.list.filter(this.childCanRender, this);
                  this.dirty = false;
                }
                return this.renderList;
              },
              clear: function() {
                this.children.removeAll();
                this.dirty = true;
              },
              preDestroy: function() {
                this.children.destroy();
                this.renderList = [];
              }
            });
            module2.exports = Blitter;
          },
          33177: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BlitterCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              var list = src.getRenderList();
              if (list.length === 0) {
                return;
              }
              var ctx = renderer.currentContext;
              var alpha = camera.alpha * src.alpha;
              if (alpha === 0) {
                return;
              }
              camera.addToRenderList(src);
              ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
              ctx.imageSmoothingEnabled = !src.frame.source.scaleMode;
              var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX;
              var cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;
              ctx.save();
              if (parentMatrix) {
                parentMatrix.copyToContext(ctx);
              }
              var roundPixels = camera.roundPixels;
              for (var i = 0; i < list.length; i++) {
                var bob = list[i];
                var flip = bob.flipX || bob.flipY;
                var frame = bob.frame;
                var cd = frame.canvasData;
                var dx = frame.x;
                var dy = frame.y;
                var fx = 1;
                var fy = 1;
                var bobAlpha = bob.alpha * alpha;
                if (bobAlpha === 0) {
                  continue;
                }
                ctx.globalAlpha = bobAlpha;
                if (!flip) {
                  if (roundPixels) {
                    dx = Math.round(dx);
                    dy = Math.round(dy);
                  }
                  if (cd.width > 0 && cd.height > 0) {
                    ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx + bob.x + cameraScrollX, dy + bob.y + cameraScrollY, cd.width, cd.height);
                  }
                } else {
                  if (bob.flipX) {
                    fx = -1;
                    dx -= cd.width;
                  }
                  if (bob.flipY) {
                    fy = -1;
                    dy -= cd.height;
                  }
                  if (cd.width > 0 && cd.height > 0) {
                    ctx.save();
                    ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY);
                    ctx.scale(fx, fy);
                    ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx, dy, cd.width, cd.height);
                    ctx.restore();
                  }
                }
              }
              ctx.restore();
            };
            module2.exports = BlitterCanvasRenderer;
          },
          68452: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Blitter = __webpack_require__2(52816);
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            GameObjectCreator.register("blitter", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var frame = GetAdvancedValue(config2, "frame", null);
              var blitter = new Blitter(this.scene, 0, 0, key, frame);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, blitter, config2);
              return blitter;
            });
          },
          38906: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Blitter = __webpack_require__2(52816);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("blitter", function(x, y, texture, frame) {
              return this.displayList.add(new Blitter(this.scene, x, y, texture, frame));
            });
          },
          92246: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(89165);
            }
            if (true) {
              renderCanvas = __webpack_require__2(33177);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          89165: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TransformMatrix = __webpack_require__2(69360);
            var Utils = __webpack_require__2(75512);
            var tempMatrix = new TransformMatrix();
            var BlitterWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              var list = src.getRenderList();
              var alpha = camera.alpha * src.alpha;
              if (list.length === 0 || alpha === 0) {
                return;
              }
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(this.pipeline, src);
              var cameraScrollX = camera.scrollX * src.scrollFactorX;
              var cameraScrollY = camera.scrollY * src.scrollFactorY;
              var calcMatrix = tempMatrix.copyFrom(camera.matrix);
              if (parentMatrix) {
                calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY);
                cameraScrollX = 0;
                cameraScrollY = 0;
              }
              var blitterX = src.x - cameraScrollX;
              var blitterY = src.y - cameraScrollY;
              var prevTextureSourceIndex = -1;
              var tintEffect = false;
              renderer.pipelines.preBatch(src);
              for (var i = 0; i < list.length; i++) {
                var bob = list[i];
                var frame = bob.frame;
                var bobAlpha = bob.alpha * alpha;
                if (bobAlpha === 0) {
                  continue;
                }
                var width = frame.width;
                var height = frame.height;
                var x = blitterX + bob.x + frame.x;
                var y = blitterY + bob.y + frame.y;
                if (bob.flipX) {
                  width *= -1;
                  x += frame.width;
                }
                if (bob.flipY) {
                  height *= -1;
                  y += frame.height;
                }
                var quad = calcMatrix.setQuad(x, y, x + width, y + height);
                var tint = Utils.getTintAppendFloatAlpha(bob.tint, bobAlpha);
                if (frame.sourceIndex !== prevTextureSourceIndex) {
                  var textureUnit = pipeline.setGameObject(src, frame);
                  prevTextureSourceIndex = frame.sourceIndex;
                }
                if (pipeline.batchQuad(src, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, frame.glTexture, textureUnit)) {
                  prevTextureSourceIndex = -1;
                }
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = BlitterWebGLRenderer;
          },
          41664: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Frame = __webpack_require__2(82047);
            var Bob = new Class({
              initialize: function Bob2(blitter, x, y, frame, visible) {
                this.parent = blitter;
                this.x = x;
                this.y = y;
                this.frame = frame;
                this.data = {};
                this.tint = 16777215;
                this._visible = visible;
                this._alpha = 1;
                this.flipX = false;
                this.flipY = false;
                this.hasTransformComponent = true;
              },
              setFrame: function(frame) {
                if (frame === void 0) {
                  this.frame = this.parent.frame;
                } else if (frame instanceof Frame && frame.texture === this.parent.texture) {
                  this.frame = frame;
                } else {
                  this.frame = this.parent.texture.get(frame);
                }
                return this;
              },
              resetFlip: function() {
                this.flipX = false;
                this.flipY = false;
                return this;
              },
              reset: function(x, y, frame) {
                this.x = x;
                this.y = y;
                this.flipX = false;
                this.flipY = false;
                this._alpha = 1;
                this._visible = true;
                this.parent.dirty = true;
                if (frame) {
                  this.setFrame(frame);
                }
                return this;
              },
              setPosition: function(x, y) {
                this.x = x;
                this.y = y;
                return this;
              },
              setFlipX: function(value) {
                this.flipX = value;
                return this;
              },
              setFlipY: function(value) {
                this.flipY = value;
                return this;
              },
              setFlip: function(x, y) {
                this.flipX = x;
                this.flipY = y;
                return this;
              },
              setVisible: function(value) {
                this.visible = value;
                return this;
              },
              setAlpha: function(value) {
                this.alpha = value;
                return this;
              },
              setTint: function(value) {
                this.tint = value;
                return this;
              },
              destroy: function() {
                this.parent.dirty = true;
                this.parent.children.remove(this);
                this.parent = void 0;
                this.frame = void 0;
                this.data = void 0;
              },
              visible: {
                get: function() {
                  return this._visible;
                },
                set: function(value) {
                  this.parent.dirty |= this._visible !== value;
                  this._visible = value;
                }
              },
              alpha: {
                get: function() {
                  return this._alpha;
                },
                set: function(value) {
                  this.parent.dirty |= this._alpha > 0 !== value > 0;
                  this._alpha = value;
                }
              }
            });
            module2.exports = Bob;
          },
          97123: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var _FLAG = 2;
            var Alpha = {
              _alpha: 1,
              _alphaTL: 1,
              _alphaTR: 1,
              _alphaBL: 1,
              _alphaBR: 1,
              clearAlpha: function() {
                return this.setAlpha(1);
              },
              setAlpha: function(topLeft, topRight, bottomLeft, bottomRight) {
                if (topLeft === void 0) {
                  topLeft = 1;
                }
                if (topRight === void 0) {
                  this.alpha = topLeft;
                } else {
                  this._alphaTL = Clamp(topLeft, 0, 1);
                  this._alphaTR = Clamp(topRight, 0, 1);
                  this._alphaBL = Clamp(bottomLeft, 0, 1);
                  this._alphaBR = Clamp(bottomRight, 0, 1);
                }
                return this;
              },
              alpha: {
                get: function() {
                  return this._alpha;
                },
                set: function(value) {
                  var v = Clamp(value, 0, 1);
                  this._alpha = v;
                  this._alphaTL = v;
                  this._alphaTR = v;
                  this._alphaBL = v;
                  this._alphaBR = v;
                  if (v === 0) {
                    this.renderFlags &= ~_FLAG;
                  } else {
                    this.renderFlags |= _FLAG;
                  }
                }
              },
              alphaTopLeft: {
                get: function() {
                  return this._alphaTL;
                },
                set: function(value) {
                  var v = Clamp(value, 0, 1);
                  this._alphaTL = v;
                  if (v !== 0) {
                    this.renderFlags |= _FLAG;
                  }
                }
              },
              alphaTopRight: {
                get: function() {
                  return this._alphaTR;
                },
                set: function(value) {
                  var v = Clamp(value, 0, 1);
                  this._alphaTR = v;
                  if (v !== 0) {
                    this.renderFlags |= _FLAG;
                  }
                }
              },
              alphaBottomLeft: {
                get: function() {
                  return this._alphaBL;
                },
                set: function(value) {
                  var v = Clamp(value, 0, 1);
                  this._alphaBL = v;
                  if (v !== 0) {
                    this.renderFlags |= _FLAG;
                  }
                }
              },
              alphaBottomRight: {
                get: function() {
                  return this._alphaBR;
                },
                set: function(value) {
                  var v = Clamp(value, 0, 1);
                  this._alphaBR = v;
                  if (v !== 0) {
                    this.renderFlags |= _FLAG;
                  }
                }
              }
            };
            module2.exports = Alpha;
          },
          15720: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var _FLAG = 2;
            var AlphaSingle = {
              _alpha: 1,
              clearAlpha: function() {
                return this.setAlpha(1);
              },
              setAlpha: function(value) {
                if (value === void 0) {
                  value = 1;
                }
                this.alpha = value;
                return this;
              },
              alpha: {
                get: function() {
                  return this._alpha;
                },
                set: function(value) {
                  var v = Clamp(value, 0, 1);
                  this._alpha = v;
                  if (v === 0) {
                    this.renderFlags &= ~_FLAG;
                  } else {
                    this.renderFlags |= _FLAG;
                  }
                }
              }
            };
            module2.exports = AlphaSingle;
          },
          69732: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BlendModes = __webpack_require__2(95723);
            var BlendMode = {
              _blendMode: BlendModes.NORMAL,
              blendMode: {
                get: function() {
                  return this._blendMode;
                },
                set: function(value) {
                  if (typeof value === "string") {
                    value = BlendModes[value];
                  }
                  value |= 0;
                  if (value >= -1) {
                    this._blendMode = value;
                  }
                }
              },
              setBlendMode: function(value) {
                this.blendMode = value;
                return this;
              }
            };
            module2.exports = BlendMode;
          },
          28284: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ComputedSize = {
              width: 0,
              height: 0,
              displayWidth: {
                get: function() {
                  return this.scaleX * this.width;
                },
                set: function(value) {
                  this.scaleX = value / this.width;
                }
              },
              displayHeight: {
                get: function() {
                  return this.scaleY * this.height;
                },
                set: function(value) {
                  this.scaleY = value / this.height;
                }
              },
              setSize: function(width, height) {
                this.width = width;
                this.height = height;
                return this;
              },
              setDisplaySize: function(width, height) {
                this.displayWidth = width;
                this.displayHeight = height;
                return this;
              }
            };
            module2.exports = ComputedSize;
          },
          85293: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Crop = {
              texture: null,
              frame: null,
              isCropped: false,
              setCrop: function(x, y, width, height) {
                if (x === void 0) {
                  this.isCropped = false;
                } else if (this.frame) {
                  if (typeof x === "number") {
                    this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
                  } else {
                    var rect = x;
                    this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
                  }
                  this.isCropped = true;
                }
                return this;
              },
              resetCropObject: function() {
                return {u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0};
              }
            };
            module2.exports = Crop;
          },
          14975: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Depth = {
              _depth: 0,
              depth: {
                get: function() {
                  return this._depth;
                },
                set: function(value) {
                  if (this.displayList) {
                    this.displayList.queueDepthSort();
                  }
                  this._depth = value;
                }
              },
              setDepth: function(value) {
                if (value === void 0) {
                  value = 0;
                }
                this.depth = value;
                return this;
              }
            };
            module2.exports = Depth;
          },
          88677: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Effects = __webpack_require__2(96910);
            var SpliceOne = __webpack_require__2(72677);
            var FX = new Class({
              initialize: function FX2(gameObject, isPost) {
                this.gameObject = gameObject;
                this.isPost = isPost;
                this.enabled = false;
                this.list = [];
                this.padding = 0;
              },
              setPadding: function(padding) {
                if (padding === void 0) {
                  padding = 0;
                }
                this.padding = padding;
                return this.gameObject;
              },
              onFXCopy: function() {
              },
              onFX: function() {
              },
              enable: function(padding) {
                if (this.isPost) {
                  return;
                }
                var renderer = this.gameObject.scene.sys.renderer;
                if (renderer && renderer.pipelines) {
                  this.gameObject.pipeline = renderer.pipelines.FX_PIPELINE;
                  if (padding !== void 0) {
                    this.padding = padding;
                  }
                  this.enabled = true;
                } else {
                  this.enabled = false;
                }
              },
              clear: function() {
                if (this.isPost) {
                  this.gameObject.resetPostPipeline(true);
                } else {
                  var list = this.list;
                  for (var i = 0; i < list.length; i++) {
                    list[i].destroy();
                  }
                  this.list = [];
                }
                this.enabled = false;
                return this.gameObject;
              },
              remove: function(fx) {
                var i;
                if (this.isPost) {
                  var pipelines = this.gameObject.getPostPipeline(String(fx.type));
                  if (!Array.isArray(pipelines)) {
                    pipelines = [pipelines];
                  }
                  for (i = 0; i < pipelines.length; i++) {
                    var pipeline = pipelines[i];
                    if (pipeline.controller === fx) {
                      this.gameObject.removePostPipeline(pipeline);
                      fx.destroy();
                      break;
                    }
                  }
                } else {
                  var list = this.list;
                  for (i = 0; i < list.length; i++) {
                    if (list[i] === fx) {
                      SpliceOne(list, i);
                      fx.destroy();
                    }
                  }
                }
                return this.gameObject;
              },
              disable: function(clear) {
                if (clear === void 0) {
                  clear = false;
                }
                if (!this.isPost) {
                  this.gameObject.resetPipeline();
                }
                this.enabled = false;
                if (clear) {
                  this.clear();
                }
                return this.gameObject;
              },
              add: function(fx, config2) {
                if (this.isPost) {
                  var type = String(fx.type);
                  this.gameObject.setPostPipeline(type, config2);
                  var pipeline = this.gameObject.getPostPipeline(type);
                  if (pipeline) {
                    if (Array.isArray(pipeline)) {
                      pipeline = pipeline.pop();
                    }
                    pipeline.controller = fx;
                    return fx;
                  }
                } else {
                  if (!this.enabled) {
                    this.enable();
                  }
                  this.list.push(fx);
                  return fx;
                }
              },
              addGlow: function(color, outerStrength, innerStrength, knockout, quality, distance) {
                return this.add(new Effects.Glow(this.gameObject, color, outerStrength, innerStrength, knockout), {quality, distance});
              },
              addShadow: function(x, y, decay, power, color, samples, intensity) {
                return this.add(new Effects.Shadow(this.gameObject, x, y, decay, power, color, samples, intensity));
              },
              addPixelate: function(amount) {
                return this.add(new Effects.Pixelate(this.gameObject, amount));
              },
              addVignette: function(x, y, radius, strength) {
                return this.add(new Effects.Vignette(this.gameObject, x, y, radius, strength));
              },
              addShine: function(speed, lineWidth, gradient, reveal) {
                return this.add(new Effects.Shine(this.gameObject, speed, lineWidth, gradient, reveal));
              },
              addBlur: function(quality, x, y, strength, color, steps) {
                return this.add(new Effects.Blur(this.gameObject, quality, x, y, strength, color, steps));
              },
              addGradient: function(color1, color2, alpha, fromX, fromY, toX, toY, size) {
                return this.add(new Effects.Gradient(this.gameObject, color1, color2, alpha, fromX, fromY, toX, toY, size));
              },
              addBloom: function(color, offsetX, offsetY, blurStrength, strength, steps) {
                return this.add(new Effects.Bloom(this.gameObject, color, offsetX, offsetY, blurStrength, strength, steps));
              },
              addColorMatrix: function() {
                return this.add(new Effects.ColorMatrix(this.gameObject));
              },
              addCircle: function(thickness, color, backgroundColor, scale, feather) {
                return this.add(new Effects.Circle(this.gameObject, thickness, color, backgroundColor, scale, feather));
              },
              addBarrel: function(amount) {
                return this.add(new Effects.Barrel(this.gameObject, amount));
              },
              addDisplacement: function(texture, x, y) {
                return this.add(new Effects.Displacement(this.gameObject, texture, x, y));
              },
              addWipe: function(wipeWidth, direction, axis) {
                return this.add(new Effects.Wipe(this.gameObject, wipeWidth, direction, axis));
              },
              addReveal: function(wipeWidth, direction, axis) {
                return this.add(new Effects.Wipe(this.gameObject, wipeWidth, direction, axis, true));
              },
              addBokeh: function(radius, amount, contrast) {
                return this.add(new Effects.Bokeh(this.gameObject, radius, amount, contrast));
              },
              addTiltShift: function(radius, amount, contrast, blurX, blurY, strength) {
                return this.add(new Effects.Bokeh(this.gameObject, radius, amount, contrast, true, blurX, blurY, strength));
              },
              destroy: function() {
                this.clear();
                this.gameObject = null;
              }
            });
            module2.exports = FX;
          },
          92972: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Flip = {
              flipX: false,
              flipY: false,
              toggleFlipX: function() {
                this.flipX = !this.flipX;
                return this;
              },
              toggleFlipY: function() {
                this.flipY = !this.flipY;
                return this;
              },
              setFlipX: function(value) {
                this.flipX = value;
                return this;
              },
              setFlipY: function(value) {
                this.flipY = value;
                return this;
              },
              setFlip: function(x, y) {
                this.flipX = x;
                this.flipY = y;
                return this;
              },
              resetFlip: function() {
                this.flipX = false;
                this.flipY = false;
                return this;
              }
            };
            module2.exports = Flip;
          },
          80693: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var RotateAround = __webpack_require__2(2386);
            var Vector2 = __webpack_require__2(93736);
            var GetBounds = {
              prepareBoundsOutput: function(output, includeParent) {
                if (includeParent === void 0) {
                  includeParent = false;
                }
                if (this.rotation !== 0) {
                  RotateAround(output, this.x, this.y, this.rotation);
                }
                if (includeParent && this.parentContainer) {
                  var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                  parentMatrix.transformPoint(output.x, output.y, output);
                }
                return output;
              },
              getCenter: function(output, includeParent) {
                if (output === void 0) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
                output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getTopLeft: function(output, includeParent) {
                if (!output) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX;
                output.y = this.y - this.displayHeight * this.originY;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getTopCenter: function(output, includeParent) {
                if (!output) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
                output.y = this.y - this.displayHeight * this.originY;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getTopRight: function(output, includeParent) {
                if (!output) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
                output.y = this.y - this.displayHeight * this.originY;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getLeftCenter: function(output, includeParent) {
                if (!output) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX;
                output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getRightCenter: function(output, includeParent) {
                if (!output) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
                output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getBottomLeft: function(output, includeParent) {
                if (!output) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX;
                output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getBottomCenter: function(output, includeParent) {
                if (!output) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
                output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getBottomRight: function(output, includeParent) {
                if (!output) {
                  output = new Vector2();
                }
                output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
                output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
                return this.prepareBoundsOutput(output, includeParent);
              },
              getBounds: function(output) {
                if (output === void 0) {
                  output = new Rectangle();
                }
                var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
                if (this.parentContainer) {
                  var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                  this.getTopLeft(output);
                  parentMatrix.transformPoint(output.x, output.y, output);
                  TLx = output.x;
                  TLy = output.y;
                  this.getTopRight(output);
                  parentMatrix.transformPoint(output.x, output.y, output);
                  TRx = output.x;
                  TRy = output.y;
                  this.getBottomLeft(output);
                  parentMatrix.transformPoint(output.x, output.y, output);
                  BLx = output.x;
                  BLy = output.y;
                  this.getBottomRight(output);
                  parentMatrix.transformPoint(output.x, output.y, output);
                  BRx = output.x;
                  BRy = output.y;
                } else {
                  this.getTopLeft(output);
                  TLx = output.x;
                  TLy = output.y;
                  this.getTopRight(output);
                  TRx = output.x;
                  TRy = output.y;
                  this.getBottomLeft(output);
                  BLx = output.x;
                  BLy = output.y;
                  this.getBottomRight(output);
                  BRx = output.x;
                  BRy = output.y;
                }
                output.x = Math.min(TLx, TRx, BLx, BRx);
                output.y = Math.min(TLy, TRy, BLy, BRy);
                output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
                output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
                return output;
              }
            };
            module2.exports = GetBounds;
          },
          39171: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BitmapMask = __webpack_require__2(76756);
            var GeometryMask = __webpack_require__2(63037);
            var Mask = {
              mask: null,
              setMask: function(mask) {
                this.mask = mask;
                return this;
              },
              clearMask: function(destroyMask) {
                if (destroyMask === void 0) {
                  destroyMask = false;
                }
                if (destroyMask && this.mask) {
                  this.mask.destroy();
                }
                this.mask = null;
                return this;
              },
              createBitmapMask: function(maskObject, x, y, texture, frame) {
                if (maskObject === void 0 && (this.texture || this.shader || this.geom)) {
                  maskObject = this;
                }
                return new BitmapMask(this.scene, maskObject, x, y, texture, frame);
              },
              createGeometryMask: function(graphics) {
                if (graphics === void 0 && (this.type === "Graphics" || this.geom)) {
                  graphics = this;
                }
                return new GeometryMask(this.scene, graphics);
              }
            };
            module2.exports = Mask;
          },
          28072: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Origin = {
              _originComponent: true,
              originX: 0.5,
              originY: 0.5,
              _displayOriginX: 0,
              _displayOriginY: 0,
              displayOriginX: {
                get: function() {
                  return this._displayOriginX;
                },
                set: function(value) {
                  this._displayOriginX = value;
                  this.originX = value / this.width;
                }
              },
              displayOriginY: {
                get: function() {
                  return this._displayOriginY;
                },
                set: function(value) {
                  this._displayOriginY = value;
                  this.originY = value / this.height;
                }
              },
              setOrigin: function(x, y) {
                if (x === void 0) {
                  x = 0.5;
                }
                if (y === void 0) {
                  y = x;
                }
                this.originX = x;
                this.originY = y;
                return this.updateDisplayOrigin();
              },
              setOriginFromFrame: function() {
                if (!this.frame || !this.frame.customPivot) {
                  return this.setOrigin();
                } else {
                  this.originX = this.frame.pivotX;
                  this.originY = this.frame.pivotY;
                }
                return this.updateDisplayOrigin();
              },
              setDisplayOrigin: function(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = x;
                }
                this.displayOriginX = x;
                this.displayOriginY = y;
                return this;
              },
              updateDisplayOrigin: function() {
                this._displayOriginX = this.originX * this.width;
                this._displayOriginY = this.originY * this.height;
                return this;
              }
            };
            module2.exports = Origin;
          },
          54211: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DegToRad = __webpack_require__2(75606);
            var GetBoolean = __webpack_require__2(63130);
            var GetValue = __webpack_require__2(10850);
            var TWEEN_CONST = __webpack_require__2(55303);
            var Vector2 = __webpack_require__2(93736);
            var PathFollower = {
              path: null,
              rotateToPath: false,
              pathRotationOffset: 0,
              pathOffset: null,
              pathVector: null,
              pathDelta: null,
              pathTween: null,
              pathConfig: null,
              _prevDirection: TWEEN_CONST.PLAYING_FORWARD,
              setPath: function(path, config2) {
                if (config2 === void 0) {
                  config2 = this.pathConfig;
                }
                var tween = this.pathTween;
                if (tween && tween.isPlaying()) {
                  tween.stop();
                }
                this.path = path;
                if (config2) {
                  this.startFollow(config2);
                }
                return this;
              },
              setRotateToPath: function(value, offset) {
                if (offset === void 0) {
                  offset = 0;
                }
                this.rotateToPath = value;
                this.pathRotationOffset = offset;
                return this;
              },
              isFollowing: function() {
                var tween = this.pathTween;
                return tween && tween.isPlaying();
              },
              startFollow: function(config2, startAt) {
                if (config2 === void 0) {
                  config2 = {};
                }
                if (startAt === void 0) {
                  startAt = 0;
                }
                var tween = this.pathTween;
                if (tween && tween.isPlaying()) {
                  tween.stop();
                }
                if (typeof config2 === "number") {
                  config2 = {duration: config2};
                }
                config2.from = GetValue(config2, "from", 0);
                config2.to = GetValue(config2, "to", 1);
                var positionOnPath = GetBoolean(config2, "positionOnPath", false);
                this.rotateToPath = GetBoolean(config2, "rotateToPath", false);
                this.pathRotationOffset = GetValue(config2, "rotationOffset", 0);
                var seek = GetValue(config2, "startAt", startAt);
                if (seek) {
                  config2.onStart = function(tween2) {
                    var tweenData = tween2.data[0];
                    tweenData.progress = seek;
                    tweenData.elapsed = tweenData.duration * seek;
                    var v = tweenData.ease(tweenData.progress);
                    tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;
                    tweenData.setTargetValue();
                  };
                }
                if (!this.pathOffset) {
                  this.pathOffset = new Vector2(this.x, this.y);
                }
                if (!this.pathVector) {
                  this.pathVector = new Vector2();
                }
                if (!this.pathDelta) {
                  this.pathDelta = new Vector2();
                }
                this.pathDelta.reset();
                config2.persist = true;
                this.pathTween = this.scene.sys.tweens.addCounter(config2);
                this.path.getStartPoint(this.pathOffset);
                if (positionOnPath) {
                  this.x = this.pathOffset.x;
                  this.y = this.pathOffset.y;
                }
                this.pathOffset.x = this.x - this.pathOffset.x;
                this.pathOffset.y = this.y - this.pathOffset.y;
                this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;
                if (this.rotateToPath) {
                  var nextPoint = this.path.getPoint(0.1);
                  this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);
                }
                this.pathConfig = config2;
                return this;
              },
              pauseFollow: function() {
                var tween = this.pathTween;
                if (tween && tween.isPlaying()) {
                  tween.pause();
                }
                return this;
              },
              resumeFollow: function() {
                var tween = this.pathTween;
                if (tween && tween.isPaused()) {
                  tween.resume();
                }
                return this;
              },
              stopFollow: function() {
                var tween = this.pathTween;
                if (tween && tween.isPlaying()) {
                  tween.stop();
                }
                return this;
              },
              pathUpdate: function() {
                var tween = this.pathTween;
                if (tween && tween.data) {
                  var tweenData = tween.data[0];
                  var pathDelta = this.pathDelta;
                  var pathVector = this.pathVector;
                  pathDelta.copy(pathVector).negate();
                  if (tweenData.state === TWEEN_CONST.COMPLETE) {
                    this.path.getPoint(tweenData.end, pathVector);
                    pathDelta.add(pathVector);
                    pathVector.add(this.pathOffset);
                    this.setPosition(pathVector.x, pathVector.y);
                    return;
                  } else if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD) {
                    return;
                  }
                  this.path.getPoint(tween.getValue(), pathVector);
                  pathDelta.add(pathVector);
                  pathVector.add(this.pathOffset);
                  var oldX = this.x;
                  var oldY = this.y;
                  this.setPosition(pathVector.x, pathVector.y);
                  var speedX = this.x - oldX;
                  var speedY = this.y - oldY;
                  if (speedX === 0 && speedY === 0) {
                    return;
                  }
                  if (tweenData.state !== this._prevDirection) {
                    this._prevDirection = tweenData.state;
                    return;
                  }
                  if (this.rotateToPath) {
                    this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);
                  }
                }
              }
            };
            module2.exports = PathFollower;
          },
          58210: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DeepCopy = __webpack_require__2(28699);
            var Pipeline = {
              defaultPipeline: null,
              pipeline: null,
              pipelineData: null,
              initPipeline: function(pipeline) {
                this.pipelineData = {};
                var renderer = this.scene.sys.renderer;
                if (!renderer) {
                  return false;
                }
                var pipelines = renderer.pipelines;
                if (pipelines) {
                  if (pipeline === void 0) {
                    pipeline = pipelines.default;
                  }
                  var instance = pipelines.get(pipeline);
                  if (instance) {
                    this.defaultPipeline = instance;
                    this.pipeline = instance;
                    return true;
                  }
                }
                return false;
              },
              setPipeline: function(pipeline, pipelineData, copyData) {
                var renderer = this.scene.sys.renderer;
                if (!renderer) {
                  return this;
                }
                var pipelines = renderer.pipelines;
                if (pipelines) {
                  var instance = pipelines.get(pipeline);
                  if (instance) {
                    this.pipeline = instance;
                  }
                  if (pipelineData) {
                    this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
                  }
                }
                return this;
              },
              setPipelineData: function(key, value) {
                var data = this.pipelineData;
                if (value === void 0) {
                  delete data[key];
                } else {
                  data[key] = value;
                }
                return this;
              },
              resetPipeline: function(resetData) {
                if (resetData === void 0) {
                  resetData = false;
                }
                this.pipeline = this.defaultPipeline;
                if (resetData) {
                  this.pipelineData = {};
                }
                return this.pipeline !== null;
              },
              getPipelineName: function() {
                return this.pipeline.name;
              }
            };
            module2.exports = Pipeline;
          },
          44086: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DeepCopy = __webpack_require__2(28699);
            var FX = __webpack_require__2(88677);
            var SpliceOne = __webpack_require__2(72677);
            var PostPipeline = {
              hasPostPipeline: false,
              postPipelines: null,
              postPipelineData: null,
              preFX: null,
              postFX: null,
              initPostPipeline: function(preFX) {
                this.postPipelines = [];
                this.postPipelineData = {};
                this.postFX = new FX(this, true);
                if (preFX) {
                  this.preFX = new FX(this, false);
                }
              },
              setPostPipeline: function(pipelines, pipelineData, copyData) {
                var renderer = this.scene.sys.renderer;
                if (!renderer) {
                  return this;
                }
                var pipelineManager = renderer.pipelines;
                if (pipelineManager) {
                  if (!Array.isArray(pipelines)) {
                    pipelines = [pipelines];
                  }
                  for (var i = 0; i < pipelines.length; i++) {
                    var instance = pipelineManager.getPostPipeline(pipelines[i], this, pipelineData);
                    if (instance) {
                      this.postPipelines.push(instance);
                    }
                  }
                  if (pipelineData) {
                    this.postPipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
                  }
                }
                this.hasPostPipeline = this.postPipelines.length > 0;
                return this;
              },
              setPostPipelineData: function(key, value) {
                var data = this.postPipelineData;
                if (value === void 0) {
                  delete data[key];
                } else {
                  data[key] = value;
                }
                return this;
              },
              getPostPipeline: function(pipeline) {
                var isString = typeof pipeline === "string";
                var pipelines = this.postPipelines;
                var results = [];
                for (var i = 0; i < pipelines.length; i++) {
                  var instance = pipelines[i];
                  if (isString && instance.name === pipeline || !isString && instance instanceof pipeline) {
                    results.push(instance);
                  }
                }
                return results.length === 1 ? results[0] : results;
              },
              resetPostPipeline: function(resetData) {
                if (resetData === void 0) {
                  resetData = false;
                }
                var pipelines = this.postPipelines;
                for (var i = 0; i < pipelines.length; i++) {
                  pipelines[i].destroy();
                }
                this.postPipelines = [];
                this.hasPostPipeline = false;
                if (resetData) {
                  this.postPipelineData = {};
                }
              },
              removePostPipeline: function(pipeline) {
                var isString = typeof pipeline === "string";
                var pipelines = this.postPipelines;
                for (var i = pipelines.length - 1; i >= 0; i--) {
                  var instance = pipelines[i];
                  if (isString && instance.name === pipeline || !isString && instance === pipeline) {
                    instance.destroy();
                    SpliceOne(pipelines, i);
                  }
                }
                this.hasPostPipeline = this.postPipelines.length > 0;
                return this;
              },
              clearFX: function() {
                if (this.preFX) {
                  this.preFX.clear();
                }
                if (this.postFX) {
                  this.postFX.clear();
                }
                return this;
              }
            };
            module2.exports = PostPipeline;
          },
          45900: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ScrollFactor = {
              scrollFactorX: 1,
              scrollFactorY: 1,
              setScrollFactor: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.scrollFactorX = x;
                this.scrollFactorY = y;
                return this;
              }
            };
            module2.exports = ScrollFactor;
          },
          31654: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Size = {
              _sizeComponent: true,
              width: 0,
              height: 0,
              displayWidth: {
                get: function() {
                  return Math.abs(this.scaleX * this.frame.realWidth);
                },
                set: function(value) {
                  this.scaleX = value / this.frame.realWidth;
                }
              },
              displayHeight: {
                get: function() {
                  return Math.abs(this.scaleY * this.frame.realHeight);
                },
                set: function(value) {
                  this.scaleY = value / this.frame.realHeight;
                }
              },
              setSizeToFrame: function(frame) {
                if (!frame) {
                  frame = this.frame;
                }
                this.width = frame.realWidth;
                this.height = frame.realHeight;
                var input = this.input;
                if (input && !input.customHitArea) {
                  input.hitArea.width = this.width;
                  input.hitArea.height = this.height;
                }
                return this;
              },
              setSize: function(width, height) {
                this.width = width;
                this.height = height;
                return this;
              },
              setDisplaySize: function(width, height) {
                this.displayWidth = width;
                this.displayHeight = height;
                return this;
              }
            };
            module2.exports = Size;
          },
          82081: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Frame = __webpack_require__2(82047);
            var _FLAG = 8;
            var Texture = {
              texture: null,
              frame: null,
              isCropped: false,
              setTexture: function(key, frame, updateSize, updateOrigin) {
                this.texture = this.scene.sys.textures.get(key);
                return this.setFrame(frame, updateSize, updateOrigin);
              },
              setFrame: function(frame, updateSize, updateOrigin) {
                if (updateSize === void 0) {
                  updateSize = true;
                }
                if (updateOrigin === void 0) {
                  updateOrigin = true;
                }
                if (frame instanceof Frame) {
                  this.texture = this.scene.sys.textures.get(frame.texture.key);
                  this.frame = frame;
                } else {
                  this.frame = this.texture.get(frame);
                }
                if (!this.frame.cutWidth || !this.frame.cutHeight) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
                if (this._sizeComponent && updateSize) {
                  this.setSizeToFrame();
                }
                if (this._originComponent && updateOrigin) {
                  if (this.frame.customPivot) {
                    this.setOrigin(this.frame.pivotX, this.frame.pivotY);
                  } else {
                    this.updateDisplayOrigin();
                  }
                }
                return this;
              }
            };
            module2.exports = Texture;
          },
          21850: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Frame = __webpack_require__2(82047);
            var _FLAG = 8;
            var TextureCrop = {
              texture: null,
              frame: null,
              isCropped: false,
              setCrop: function(x, y, width, height) {
                if (x === void 0) {
                  this.isCropped = false;
                } else if (this.frame) {
                  if (typeof x === "number") {
                    this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
                  } else {
                    var rect = x;
                    this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
                  }
                  this.isCropped = true;
                }
                return this;
              },
              setTexture: function(key, frame) {
                this.texture = this.scene.sys.textures.get(key);
                return this.setFrame(frame);
              },
              setFrame: function(frame, updateSize, updateOrigin) {
                if (updateSize === void 0) {
                  updateSize = true;
                }
                if (updateOrigin === void 0) {
                  updateOrigin = true;
                }
                if (frame instanceof Frame) {
                  this.texture = this.scene.sys.textures.get(frame.texture.key);
                  this.frame = frame;
                } else {
                  this.frame = this.texture.get(frame);
                }
                if (!this.frame.cutWidth || !this.frame.cutHeight) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
                if (this._sizeComponent && updateSize) {
                  this.setSizeToFrame();
                }
                if (this._originComponent && updateOrigin) {
                  if (this.frame.customPivot) {
                    this.setOrigin(this.frame.pivotX, this.frame.pivotY);
                  } else {
                    this.updateDisplayOrigin();
                  }
                }
                if (this.isCropped) {
                  this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
                }
                return this;
              },
              resetCropObject: function() {
                return {u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0};
              }
            };
            module2.exports = TextureCrop;
          },
          58072: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Tint = {
              tintTopLeft: 16777215,
              tintTopRight: 16777215,
              tintBottomLeft: 16777215,
              tintBottomRight: 16777215,
              tintFill: false,
              clearTint: function() {
                this.setTint(16777215);
                return this;
              },
              setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
                if (topLeft === void 0) {
                  topLeft = 16777215;
                }
                if (topRight === void 0) {
                  topRight = topLeft;
                  bottomLeft = topLeft;
                  bottomRight = topLeft;
                }
                this.tintTopLeft = topLeft;
                this.tintTopRight = topRight;
                this.tintBottomLeft = bottomLeft;
                this.tintBottomRight = bottomRight;
                this.tintFill = false;
                return this;
              },
              setTintFill: function(topLeft, topRight, bottomLeft, bottomRight) {
                this.setTint(topLeft, topRight, bottomLeft, bottomRight);
                this.tintFill = true;
                return this;
              },
              tint: {
                get: function() {
                  return this.tintTopLeft;
                },
                set: function(value) {
                  this.setTint(value, value, value, value);
                }
              },
              isTinted: {
                get: function() {
                  var white = 16777215;
                  return this.tintFill || this.tintTopLeft !== white || this.tintTopRight !== white || this.tintBottomLeft !== white || this.tintBottomRight !== white;
                }
              }
            };
            module2.exports = Tint;
          },
          48129: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ToJSON = function(gameObject) {
              var out = {
                name: gameObject.name,
                type: gameObject.type,
                x: gameObject.x,
                y: gameObject.y,
                depth: gameObject.depth,
                scale: {
                  x: gameObject.scaleX,
                  y: gameObject.scaleY
                },
                origin: {
                  x: gameObject.originX,
                  y: gameObject.originY
                },
                flipX: gameObject.flipX,
                flipY: gameObject.flipY,
                rotation: gameObject.rotation,
                alpha: gameObject.alpha,
                visible: gameObject.visible,
                blendMode: gameObject.blendMode,
                textureKey: "",
                frameKey: "",
                data: {}
              };
              if (gameObject.texture) {
                out.textureKey = gameObject.texture.key;
                out.frameKey = gameObject.frame.name;
              }
              return out;
            };
            module2.exports = ToJSON;
          },
          56584: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MATH_CONST = __webpack_require__2(83392);
            var TransformMatrix = __webpack_require__2(69360);
            var TransformXY = __webpack_require__2(64462);
            var WrapAngle = __webpack_require__2(35786);
            var WrapAngleDegrees = __webpack_require__2(62138);
            var Vector2 = __webpack_require__2(93736);
            var _FLAG = 4;
            var Transform = {
              hasTransformComponent: true,
              _scaleX: 1,
              _scaleY: 1,
              _rotation: 0,
              x: 0,
              y: 0,
              z: 0,
              w: 0,
              scale: {
                get: function() {
                  return (this._scaleX + this._scaleY) / 2;
                },
                set: function(value) {
                  this._scaleX = value;
                  this._scaleY = value;
                  if (value === 0) {
                    this.renderFlags &= ~_FLAG;
                  } else {
                    this.renderFlags |= _FLAG;
                  }
                }
              },
              scaleX: {
                get: function() {
                  return this._scaleX;
                },
                set: function(value) {
                  this._scaleX = value;
                  if (value === 0) {
                    this.renderFlags &= ~_FLAG;
                  } else if (this._scaleY !== 0) {
                    this.renderFlags |= _FLAG;
                  }
                }
              },
              scaleY: {
                get: function() {
                  return this._scaleY;
                },
                set: function(value) {
                  this._scaleY = value;
                  if (value === 0) {
                    this.renderFlags &= ~_FLAG;
                  } else if (this._scaleX !== 0) {
                    this.renderFlags |= _FLAG;
                  }
                }
              },
              angle: {
                get: function() {
                  return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
                },
                set: function(value) {
                  this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
                }
              },
              rotation: {
                get: function() {
                  return this._rotation;
                },
                set: function(value) {
                  this._rotation = WrapAngle(value);
                }
              },
              setPosition: function(x, y, z, w) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = x;
                }
                if (z === void 0) {
                  z = 0;
                }
                if (w === void 0) {
                  w = 0;
                }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
                return this;
              },
              copyPosition: function(source) {
                if (source.x !== void 0) {
                  this.x = source.x;
                }
                if (source.y !== void 0) {
                  this.y = source.y;
                }
                if (source.z !== void 0) {
                  this.z = source.z;
                }
                if (source.w !== void 0) {
                  this.w = source.w;
                }
                return this;
              },
              setRandomPosition: function(x, y, width, height) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = this.scene.sys.scale.width;
                }
                if (height === void 0) {
                  height = this.scene.sys.scale.height;
                }
                this.x = x + Math.random() * width;
                this.y = y + Math.random() * height;
                return this;
              },
              setRotation: function(radians) {
                if (radians === void 0) {
                  radians = 0;
                }
                this.rotation = radians;
                return this;
              },
              setAngle: function(degrees) {
                if (degrees === void 0) {
                  degrees = 0;
                }
                this.angle = degrees;
                return this;
              },
              setScale: function(x, y) {
                if (x === void 0) {
                  x = 1;
                }
                if (y === void 0) {
                  y = x;
                }
                this.scaleX = x;
                this.scaleY = y;
                return this;
              },
              setX: function(value) {
                if (value === void 0) {
                  value = 0;
                }
                this.x = value;
                return this;
              },
              setY: function(value) {
                if (value === void 0) {
                  value = 0;
                }
                this.y = value;
                return this;
              },
              setZ: function(value) {
                if (value === void 0) {
                  value = 0;
                }
                this.z = value;
                return this;
              },
              setW: function(value) {
                if (value === void 0) {
                  value = 0;
                }
                this.w = value;
                return this;
              },
              getLocalTransformMatrix: function(tempMatrix) {
                if (tempMatrix === void 0) {
                  tempMatrix = new TransformMatrix();
                }
                return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
              },
              getWorldTransformMatrix: function(tempMatrix, parentMatrix) {
                if (tempMatrix === void 0) {
                  tempMatrix = new TransformMatrix();
                }
                var parent = this.parentContainer;
                if (!parent) {
                  return this.getLocalTransformMatrix(tempMatrix);
                }
                if (!parentMatrix) {
                  parentMatrix = new TransformMatrix();
                }
                tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
                while (parent) {
                  parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);
                  parentMatrix.multiply(tempMatrix, tempMatrix);
                  parent = parent.parentContainer;
                }
                return tempMatrix;
              },
              getLocalPoint: function(x, y, point, camera) {
                if (!point) {
                  point = new Vector2();
                }
                if (!camera) {
                  camera = this.scene.sys.cameras.main;
                }
                var csx = camera.scrollX;
                var csy = camera.scrollY;
                var px = x + csx * this.scrollFactorX - csx;
                var py = y + csy * this.scrollFactorY - csy;
                if (this.parentContainer) {
                  this.getWorldTransformMatrix().applyInverse(px, py, point);
                } else {
                  TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point);
                }
                if (this._originComponent) {
                  point.x += this._displayOriginX;
                  point.y += this._displayOriginY;
                }
                return point;
              },
              getParentRotation: function() {
                var rotation = 0;
                var parent = this.parentContainer;
                while (parent) {
                  rotation += parent.rotation;
                  parent = parent.parentContainer;
                }
                return rotation;
              }
            };
            module2.exports = Transform;
          },
          69360: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var MATH_CONST = __webpack_require__2(83392);
            var Vector2 = __webpack_require__2(93736);
            var TransformMatrix = new Class({
              initialize: function TransformMatrix2(a, b, c, d, tx, ty) {
                if (a === void 0) {
                  a = 1;
                }
                if (b === void 0) {
                  b = 0;
                }
                if (c === void 0) {
                  c = 0;
                }
                if (d === void 0) {
                  d = 1;
                }
                if (tx === void 0) {
                  tx = 0;
                }
                if (ty === void 0) {
                  ty = 0;
                }
                this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]);
                this.decomposedMatrix = {
                  translateX: 0,
                  translateY: 0,
                  scaleX: 1,
                  scaleY: 1,
                  rotation: 0
                };
                this.quad = new Float32Array(8);
              },
              a: {
                get: function() {
                  return this.matrix[0];
                },
                set: function(value) {
                  this.matrix[0] = value;
                }
              },
              b: {
                get: function() {
                  return this.matrix[1];
                },
                set: function(value) {
                  this.matrix[1] = value;
                }
              },
              c: {
                get: function() {
                  return this.matrix[2];
                },
                set: function(value) {
                  this.matrix[2] = value;
                }
              },
              d: {
                get: function() {
                  return this.matrix[3];
                },
                set: function(value) {
                  this.matrix[3] = value;
                }
              },
              e: {
                get: function() {
                  return this.matrix[4];
                },
                set: function(value) {
                  this.matrix[4] = value;
                }
              },
              f: {
                get: function() {
                  return this.matrix[5];
                },
                set: function(value) {
                  this.matrix[5] = value;
                }
              },
              tx: {
                get: function() {
                  return this.matrix[4];
                },
                set: function(value) {
                  this.matrix[4] = value;
                }
              },
              ty: {
                get: function() {
                  return this.matrix[5];
                },
                set: function(value) {
                  this.matrix[5] = value;
                }
              },
              rotation: {
                get: function() {
                  return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
                }
              },
              rotationNormalized: {
                get: function() {
                  var matrix = this.matrix;
                  var a = matrix[0];
                  var b = matrix[1];
                  var c = matrix[2];
                  var d = matrix[3];
                  if (a || b) {
                    return b > 0 ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);
                  } else if (c || d) {
                    return MATH_CONST.TAU - (d > 0 ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));
                  } else {
                    return 0;
                  }
                }
              },
              scaleX: {
                get: function() {
                  return Math.sqrt(this.a * this.a + this.b * this.b);
                }
              },
              scaleY: {
                get: function() {
                  return Math.sqrt(this.c * this.c + this.d * this.d);
                }
              },
              loadIdentity: function() {
                var matrix = this.matrix;
                matrix[0] = 1;
                matrix[1] = 0;
                matrix[2] = 0;
                matrix[3] = 1;
                matrix[4] = 0;
                matrix[5] = 0;
                return this;
              },
              translate: function(x, y) {
                var matrix = this.matrix;
                matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
                matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];
                return this;
              },
              scale: function(x, y) {
                var matrix = this.matrix;
                matrix[0] *= x;
                matrix[1] *= x;
                matrix[2] *= y;
                matrix[3] *= y;
                return this;
              },
              rotate: function(angle) {
                var sin = Math.sin(angle);
                var cos = Math.cos(angle);
                var matrix = this.matrix;
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[2];
                var d = matrix[3];
                matrix[0] = a * cos + c * sin;
                matrix[1] = b * cos + d * sin;
                matrix[2] = a * -sin + c * cos;
                matrix[3] = b * -sin + d * cos;
                return this;
              },
              multiply: function(rhs, out) {
                var matrix = this.matrix;
                var source = rhs.matrix;
                var localA = matrix[0];
                var localB = matrix[1];
                var localC = matrix[2];
                var localD = matrix[3];
                var localE = matrix[4];
                var localF = matrix[5];
                var sourceA = source[0];
                var sourceB = source[1];
                var sourceC = source[2];
                var sourceD = source[3];
                var sourceE = source[4];
                var sourceF = source[5];
                var destinationMatrix = out === void 0 ? matrix : out.matrix;
                destinationMatrix[0] = sourceA * localA + sourceB * localC;
                destinationMatrix[1] = sourceA * localB + sourceB * localD;
                destinationMatrix[2] = sourceC * localA + sourceD * localC;
                destinationMatrix[3] = sourceC * localB + sourceD * localD;
                destinationMatrix[4] = sourceE * localA + sourceF * localC + localE;
                destinationMatrix[5] = sourceE * localB + sourceF * localD + localF;
                return destinationMatrix;
              },
              multiplyWithOffset: function(src, offsetX, offsetY) {
                var matrix = this.matrix;
                var otherMatrix = src.matrix;
                var a0 = matrix[0];
                var b0 = matrix[1];
                var c0 = matrix[2];
                var d0 = matrix[3];
                var tx0 = matrix[4];
                var ty0 = matrix[5];
                var pse = offsetX * a0 + offsetY * c0 + tx0;
                var psf = offsetX * b0 + offsetY * d0 + ty0;
                var a1 = otherMatrix[0];
                var b1 = otherMatrix[1];
                var c1 = otherMatrix[2];
                var d1 = otherMatrix[3];
                var tx1 = otherMatrix[4];
                var ty1 = otherMatrix[5];
                matrix[0] = a1 * a0 + b1 * c0;
                matrix[1] = a1 * b0 + b1 * d0;
                matrix[2] = c1 * a0 + d1 * c0;
                matrix[3] = c1 * b0 + d1 * d0;
                matrix[4] = tx1 * a0 + ty1 * c0 + pse;
                matrix[5] = tx1 * b0 + ty1 * d0 + psf;
                return this;
              },
              transform: function(a, b, c, d, tx, ty) {
                var matrix = this.matrix;
                var a0 = matrix[0];
                var b0 = matrix[1];
                var c0 = matrix[2];
                var d0 = matrix[3];
                var tx0 = matrix[4];
                var ty0 = matrix[5];
                matrix[0] = a * a0 + b * c0;
                matrix[1] = a * b0 + b * d0;
                matrix[2] = c * a0 + d * c0;
                matrix[3] = c * b0 + d * d0;
                matrix[4] = tx * a0 + ty * c0 + tx0;
                matrix[5] = tx * b0 + ty * d0 + ty0;
                return this;
              },
              transformPoint: function(x, y, point) {
                if (point === void 0) {
                  point = {x: 0, y: 0};
                }
                var matrix = this.matrix;
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[2];
                var d = matrix[3];
                var tx = matrix[4];
                var ty = matrix[5];
                point.x = x * a + y * c + tx;
                point.y = x * b + y * d + ty;
                return point;
              },
              invert: function() {
                var matrix = this.matrix;
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[2];
                var d = matrix[3];
                var tx = matrix[4];
                var ty = matrix[5];
                var n = a * d - b * c;
                matrix[0] = d / n;
                matrix[1] = -b / n;
                matrix[2] = -c / n;
                matrix[3] = a / n;
                matrix[4] = (c * ty - d * tx) / n;
                matrix[5] = -(a * ty - b * tx) / n;
                return this;
              },
              copyFrom: function(src) {
                var matrix = this.matrix;
                matrix[0] = src.a;
                matrix[1] = src.b;
                matrix[2] = src.c;
                matrix[3] = src.d;
                matrix[4] = src.e;
                matrix[5] = src.f;
                return this;
              },
              copyFromArray: function(src) {
                var matrix = this.matrix;
                matrix[0] = src[0];
                matrix[1] = src[1];
                matrix[2] = src[2];
                matrix[3] = src[3];
                matrix[4] = src[4];
                matrix[5] = src[5];
                return this;
              },
              copyToContext: function(ctx) {
                var matrix = this.matrix;
                ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                return ctx;
              },
              setToContext: function(ctx) {
                ctx.setTransform(this);
                return ctx;
              },
              copyToArray: function(out) {
                var matrix = this.matrix;
                if (out === void 0) {
                  out = [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]];
                } else {
                  out[0] = matrix[0];
                  out[1] = matrix[1];
                  out[2] = matrix[2];
                  out[3] = matrix[3];
                  out[4] = matrix[4];
                  out[5] = matrix[5];
                }
                return out;
              },
              setTransform: function(a, b, c, d, tx, ty) {
                var matrix = this.matrix;
                matrix[0] = a;
                matrix[1] = b;
                matrix[2] = c;
                matrix[3] = d;
                matrix[4] = tx;
                matrix[5] = ty;
                return this;
              },
              decomposeMatrix: function() {
                var decomposedMatrix = this.decomposedMatrix;
                var matrix = this.matrix;
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[2];
                var d = matrix[3];
                var determ = a * d - b * c;
                decomposedMatrix.translateX = matrix[4];
                decomposedMatrix.translateY = matrix[5];
                if (a || b) {
                  var r = Math.sqrt(a * a + b * b);
                  decomposedMatrix.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
                  decomposedMatrix.scaleX = r;
                  decomposedMatrix.scaleY = determ / r;
                } else if (c || d) {
                  var s = Math.sqrt(c * c + d * d);
                  decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
                  decomposedMatrix.scaleX = determ / s;
                  decomposedMatrix.scaleY = s;
                } else {
                  decomposedMatrix.rotation = 0;
                  decomposedMatrix.scaleX = 0;
                  decomposedMatrix.scaleY = 0;
                }
                return decomposedMatrix;
              },
              applyITRS: function(x, y, rotation, scaleX, scaleY) {
                var matrix = this.matrix;
                var radianSin = Math.sin(rotation);
                var radianCos = Math.cos(rotation);
                matrix[4] = x;
                matrix[5] = y;
                matrix[0] = radianCos * scaleX;
                matrix[1] = radianSin * scaleX;
                matrix[2] = -radianSin * scaleY;
                matrix[3] = radianCos * scaleY;
                return this;
              },
              applyInverse: function(x, y, output) {
                if (output === void 0) {
                  output = new Vector2();
                }
                var matrix = this.matrix;
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[2];
                var d = matrix[3];
                var tx = matrix[4];
                var ty = matrix[5];
                var id = 1 / (a * d + c * -b);
                output.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
                output.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
                return output;
              },
              setQuad: function(x, y, xw, yh, roundPixels, quad) {
                if (roundPixels === void 0) {
                  roundPixels = false;
                }
                if (quad === void 0) {
                  quad = this.quad;
                }
                var matrix = this.matrix;
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[2];
                var d = matrix[3];
                var e = matrix[4];
                var f = matrix[5];
                if (roundPixels) {
                  quad[0] = Math.round(x * a + y * c + e);
                  quad[1] = Math.round(x * b + y * d + f);
                  quad[2] = Math.round(x * a + yh * c + e);
                  quad[3] = Math.round(x * b + yh * d + f);
                  quad[4] = Math.round(xw * a + yh * c + e);
                  quad[5] = Math.round(xw * b + yh * d + f);
                  quad[6] = Math.round(xw * a + y * c + e);
                  quad[7] = Math.round(xw * b + y * d + f);
                } else {
                  quad[0] = x * a + y * c + e;
                  quad[1] = x * b + y * d + f;
                  quad[2] = x * a + yh * c + e;
                  quad[3] = x * b + yh * d + f;
                  quad[4] = xw * a + yh * c + e;
                  quad[5] = xw * b + yh * d + f;
                  quad[6] = xw * a + y * c + e;
                  quad[7] = xw * b + y * d + f;
                }
                return quad;
              },
              getX: function(x, y) {
                return x * this.a + y * this.c + this.e;
              },
              getY: function(x, y) {
                return x * this.b + y * this.d + this.f;
              },
              getXRound: function(x, y, round) {
                var v = this.getX(x, y);
                if (round) {
                  v = Math.round(v);
                }
                return v;
              },
              getYRound: function(x, y, round) {
                var v = this.getY(x, y);
                if (round) {
                  v = Math.round(v);
                }
                return v;
              },
              getCSSMatrix: function() {
                var m = this.matrix;
                return "matrix(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4] + "," + m[5] + ")";
              },
              destroy: function() {
                this.matrix = null;
                this.quad = null;
                this.decomposedMatrix = null;
              }
            });
            module2.exports = TransformMatrix;
          },
          59694: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var _FLAG = 1;
            var Visible = {
              _visible: true,
              visible: {
                get: function() {
                  return this._visible;
                },
                set: function(value) {
                  if (value) {
                    this._visible = true;
                    this.renderFlags |= _FLAG;
                  } else {
                    this._visible = false;
                    this.renderFlags &= ~_FLAG;
                  }
                }
              },
              setVisible: function(value) {
                this.visible = value;
                return this;
              }
            };
            module2.exports = Visible;
          },
          64937: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Alpha: __webpack_require__2(97123),
              AlphaSingle: __webpack_require__2(15720),
              BlendMode: __webpack_require__2(69732),
              ComputedSize: __webpack_require__2(28284),
              Crop: __webpack_require__2(85293),
              Depth: __webpack_require__2(14975),
              Flip: __webpack_require__2(92972),
              FX: __webpack_require__2(88677),
              GetBounds: __webpack_require__2(80693),
              Mask: __webpack_require__2(39171),
              Origin: __webpack_require__2(28072),
              PathFollower: __webpack_require__2(54211),
              Pipeline: __webpack_require__2(58210),
              PostPipeline: __webpack_require__2(44086),
              ScrollFactor: __webpack_require__2(45900),
              Size: __webpack_require__2(31654),
              Texture: __webpack_require__2(82081),
              TextureCrop: __webpack_require__2(21850),
              Tint: __webpack_require__2(58072),
              ToJSON: __webpack_require__2(48129),
              Transform: __webpack_require__2(56584),
              TransformMatrix: __webpack_require__2(69360),
              Visible: __webpack_require__2(59694)
            };
          },
          70339: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArrayUtils = __webpack_require__2(59959);
            var BlendModes = __webpack_require__2(95723);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var Events = __webpack_require__2(56631);
            var GameObject = __webpack_require__2(89980);
            var Rectangle = __webpack_require__2(74118);
            var Render = __webpack_require__2(98524);
            var Union = __webpack_require__2(58795);
            var Vector2 = __webpack_require__2(93736);
            var Container = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Depth,
                Components.Mask,
                Components.PostPipeline,
                Components.Transform,
                Components.Visible,
                Render
              ],
              initialize: function Container2(scene, x, y, children) {
                GameObject.call(this, scene, "Container");
                this.list = [];
                this.exclusive = true;
                this.maxSize = -1;
                this.position = 0;
                this.localTransform = new Components.TransformMatrix();
                this.tempTransformMatrix = new Components.TransformMatrix();
                this._sortKey = "";
                this._sysEvents = scene.sys.events;
                this.scrollFactorX = 1;
                this.scrollFactorY = 1;
                this.initPostPipeline();
                this.setPosition(x, y);
                this.setBlendMode(BlendModes.SKIP_CHECK);
                if (children) {
                  this.add(children);
                }
              },
              originX: {
                get: function() {
                  return 0.5;
                }
              },
              originY: {
                get: function() {
                  return 0.5;
                }
              },
              displayOriginX: {
                get: function() {
                  return this.width * 0.5;
                }
              },
              displayOriginY: {
                get: function() {
                  return this.height * 0.5;
                }
              },
              setExclusive: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.exclusive = value;
                return this;
              },
              getBounds: function(output) {
                if (output === void 0) {
                  output = new Rectangle();
                }
                output.setTo(this.x, this.y, 0, 0);
                if (this.parentContainer) {
                  var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                  var transformedPosition = parentMatrix.transformPoint(this.x, this.y);
                  output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);
                }
                if (this.list.length > 0) {
                  var children = this.list;
                  var tempRect = new Rectangle();
                  var hasSetFirst = false;
                  output.setEmpty();
                  for (var i = 0; i < children.length; i++) {
                    var entry = children[i];
                    if (entry.getBounds) {
                      entry.getBounds(tempRect);
                      if (!hasSetFirst) {
                        output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);
                        hasSetFirst = true;
                      } else {
                        Union(tempRect, output, output);
                      }
                    }
                  }
                }
                return output;
              },
              addHandler: function(gameObject) {
                gameObject.once(Events.DESTROY, this.remove, this);
                if (this.exclusive) {
                  if (gameObject.parentContainer) {
                    gameObject.parentContainer.remove(gameObject);
                  }
                  gameObject.parentContainer = this;
                  gameObject.removeFromDisplayList();
                  gameObject.addedToScene();
                }
              },
              removeHandler: function(gameObject) {
                gameObject.off(Events.DESTROY, this.remove, this);
                if (this.exclusive) {
                  gameObject.parentContainer = null;
                  gameObject.removedFromScene();
                  gameObject.addToDisplayList();
                }
              },
              pointToContainer: function(source, output) {
                if (output === void 0) {
                  output = new Vector2();
                }
                if (this.parentContainer) {
                  this.parentContainer.pointToContainer(source, output);
                } else {
                  output.x = source.x;
                  output.y = source.y;
                }
                var tempMatrix = this.tempTransformMatrix;
                tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
                tempMatrix.invert();
                tempMatrix.transformPoint(source.x, source.y, output);
                return output;
              },
              getBoundsTransformMatrix: function() {
                return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);
              },
              add: function(child) {
                ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);
                return this;
              },
              addAt: function(child, index) {
                ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);
                return this;
              },
              getAt: function(index) {
                return this.list[index];
              },
              getIndex: function(child) {
                return this.list.indexOf(child);
              },
              sort: function(property, handler) {
                if (!property) {
                  return this;
                }
                if (handler === void 0) {
                  handler = function(childA, childB) {
                    return childA[property] - childB[property];
                  };
                }
                ArrayUtils.StableSort(this.list, handler);
                return this;
              },
              getByName: function(name) {
                return ArrayUtils.GetFirst(this.list, "name", name);
              },
              getRandom: function(startIndex, length) {
                return ArrayUtils.GetRandom(this.list, startIndex, length);
              },
              getFirst: function(property, value, startIndex, endIndex) {
                return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
              },
              getAll: function(property, value, startIndex, endIndex) {
                return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
              },
              count: function(property, value, startIndex, endIndex) {
                return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
              },
              swap: function(child1, child2) {
                ArrayUtils.Swap(this.list, child1, child2);
                return this;
              },
              moveTo: function(child, index) {
                ArrayUtils.MoveTo(this.list, child, index);
                return this;
              },
              moveAbove: function(child1, child2) {
                ArrayUtils.MoveAbove(this.list, child1, child2);
                return this;
              },
              moveBelow: function(child1, child2) {
                ArrayUtils.MoveBelow(this.list, child1, child2);
                return this;
              },
              remove: function(child, destroyChild) {
                var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);
                if (destroyChild && removed) {
                  if (!Array.isArray(removed)) {
                    removed = [removed];
                  }
                  for (var i = 0; i < removed.length; i++) {
                    removed[i].destroy();
                  }
                }
                return this;
              },
              removeAt: function(index, destroyChild) {
                var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);
                if (destroyChild && removed) {
                  removed.destroy();
                }
                return this;
              },
              removeBetween: function(startIndex, endIndex, destroyChild) {
                var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);
                if (destroyChild) {
                  for (var i = 0; i < removed.length; i++) {
                    removed[i].destroy();
                  }
                }
                return this;
              },
              removeAll: function(destroyChild) {
                var list = this.list;
                if (destroyChild) {
                  for (var i = 0; i < list.length; i++) {
                    if (list[i] && list[i].scene) {
                      list[i].off(Events.DESTROY, this.remove, this);
                      list[i].destroy();
                    }
                  }
                  this.list = [];
                } else {
                  ArrayUtils.RemoveBetween(list, 0, list.length, this.removeHandler, this);
                }
                return this;
              },
              bringToTop: function(child) {
                ArrayUtils.BringToTop(this.list, child);
                return this;
              },
              sendToBack: function(child) {
                ArrayUtils.SendToBack(this.list, child);
                return this;
              },
              moveUp: function(child) {
                ArrayUtils.MoveUp(this.list, child);
                return this;
              },
              moveDown: function(child) {
                ArrayUtils.MoveDown(this.list, child);
                return this;
              },
              reverse: function() {
                this.list.reverse();
                return this;
              },
              shuffle: function() {
                ArrayUtils.Shuffle(this.list);
                return this;
              },
              replace: function(oldChild, newChild, destroyChild) {
                var moved = ArrayUtils.Replace(this.list, oldChild, newChild);
                if (moved) {
                  this.addHandler(newChild);
                  this.removeHandler(oldChild);
                  if (destroyChild) {
                    oldChild.destroy();
                  }
                }
                return this;
              },
              exists: function(child) {
                return this.list.indexOf(child) > -1;
              },
              setAll: function(property, value, startIndex, endIndex) {
                ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
                return this;
              },
              each: function(callback, context) {
                var args = [null];
                var i;
                var temp = this.list.slice();
                var len = temp.length;
                for (i = 2; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                for (i = 0; i < len; i++) {
                  args[0] = temp[i];
                  callback.apply(context, args);
                }
                return this;
              },
              iterate: function(callback, context) {
                var args = [null];
                var i;
                for (i = 2; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                for (i = 0; i < this.list.length; i++) {
                  args[0] = this.list[i];
                  callback.apply(context, args);
                }
                return this;
              },
              setScrollFactor: function(x, y, updateChildren) {
                if (y === void 0) {
                  y = x;
                }
                if (updateChildren === void 0) {
                  updateChildren = false;
                }
                this.scrollFactorX = x;
                this.scrollFactorY = y;
                if (updateChildren) {
                  ArrayUtils.SetAll(this.list, "scrollFactorX", x);
                  ArrayUtils.SetAll(this.list, "scrollFactorY", y);
                }
                return this;
              },
              length: {
                get: function() {
                  return this.list.length;
                }
              },
              first: {
                get: function() {
                  this.position = 0;
                  if (this.list.length > 0) {
                    return this.list[0];
                  } else {
                    return null;
                  }
                }
              },
              last: {
                get: function() {
                  if (this.list.length > 0) {
                    this.position = this.list.length - 1;
                    return this.list[this.position];
                  } else {
                    return null;
                  }
                }
              },
              next: {
                get: function() {
                  if (this.position < this.list.length) {
                    this.position++;
                    return this.list[this.position];
                  } else {
                    return null;
                  }
                }
              },
              previous: {
                get: function() {
                  if (this.position > 0) {
                    this.position--;
                    return this.list[this.position];
                  } else {
                    return null;
                  }
                }
              },
              preDestroy: function() {
                this.removeAll(!!this.exclusive);
                this.localTransform.destroy();
                this.tempTransformMatrix.destroy();
                this.list = [];
              }
            });
            module2.exports = Container;
          },
          13916: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ContainerCanvasRenderer = function(renderer, container, camera, parentMatrix) {
              camera.addToRenderList(container);
              var children = container.list;
              if (children.length === 0) {
                return;
              }
              var transformMatrix = container.localTransform;
              if (parentMatrix) {
                transformMatrix.loadIdentity();
                transformMatrix.multiply(parentMatrix);
                transformMatrix.translate(container.x, container.y);
                transformMatrix.rotate(container.rotation);
                transformMatrix.scale(container.scaleX, container.scaleY);
              } else {
                transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
              }
              var containerHasBlendMode = container.blendMode !== -1;
              if (!containerHasBlendMode) {
                renderer.setBlendMode(0);
              }
              var alpha = container._alpha;
              var scrollFactorX = container.scrollFactorX;
              var scrollFactorY = container.scrollFactorY;
              if (container.mask) {
                container.mask.preRenderCanvas(renderer, null, camera);
              }
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (!child.willRender(camera)) {
                  continue;
                }
                var childAlpha = child.alpha;
                var childScrollFactorX = child.scrollFactorX;
                var childScrollFactorY = child.scrollFactorY;
                if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                  renderer.setBlendMode(child.blendMode);
                }
                child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
                child.setAlpha(childAlpha * alpha);
                child.renderCanvas(renderer, child, camera, transformMatrix);
                child.setAlpha(childAlpha);
                child.setScrollFactor(childScrollFactorX, childScrollFactorY);
              }
              if (container.mask) {
                container.mask.postRenderCanvas(renderer);
              }
            };
            module2.exports = ContainerCanvasRenderer;
          },
          44516: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var Container = __webpack_require__2(70339);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            GameObjectCreator.register("container", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var x = GetAdvancedValue(config2, "x", 0);
              var y = GetAdvancedValue(config2, "y", 0);
              var children = GetAdvancedValue(config2, "children", null);
              var container = new Container(this.scene, x, y, children);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, container, config2);
              return container;
            });
          },
          23400: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Container = __webpack_require__2(70339);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("container", function(x, y, children) {
              return this.displayList.add(new Container(this.scene, x, y, children));
            });
          },
          98524: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(36934);
            }
            if (true) {
              renderCanvas = __webpack_require__2(13916);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          36934: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ContainerWebGLRenderer = function(renderer, container, camera, parentMatrix) {
              camera.addToRenderList(container);
              var children = container.list;
              var childCount = children.length;
              if (childCount === 0) {
                return;
              }
              var transformMatrix = container.localTransform;
              if (parentMatrix) {
                transformMatrix.loadIdentity();
                transformMatrix.multiply(parentMatrix);
                transformMatrix.translate(container.x, container.y);
                transformMatrix.rotate(container.rotation);
                transformMatrix.scale(container.scaleX, container.scaleY);
              } else {
                transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
              }
              renderer.pipelines.preBatch(container);
              var containerHasBlendMode = container.blendMode !== -1;
              if (!containerHasBlendMode) {
                renderer.setBlendMode(0);
              }
              var alpha = container.alpha;
              var scrollFactorX = container.scrollFactorX;
              var scrollFactorY = container.scrollFactorY;
              for (var i = 0; i < childCount; i++) {
                var child = children[i];
                if (!child.willRender(camera)) {
                  continue;
                }
                var childAlphaTopLeft;
                var childAlphaTopRight;
                var childAlphaBottomLeft;
                var childAlphaBottomRight;
                if (child.alphaTopLeft !== void 0) {
                  childAlphaTopLeft = child.alphaTopLeft;
                  childAlphaTopRight = child.alphaTopRight;
                  childAlphaBottomLeft = child.alphaBottomLeft;
                  childAlphaBottomRight = child.alphaBottomRight;
                } else {
                  var childAlpha = child.alpha;
                  childAlphaTopLeft = childAlpha;
                  childAlphaTopRight = childAlpha;
                  childAlphaBottomLeft = childAlpha;
                  childAlphaBottomRight = childAlpha;
                }
                var childScrollFactorX = child.scrollFactorX;
                var childScrollFactorY = child.scrollFactorY;
                if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                  renderer.setBlendMode(child.blendMode);
                }
                var mask = child.mask;
                if (mask) {
                  mask.preRenderWebGL(renderer, child, camera);
                }
                var type = child.type;
                if (type !== renderer.currentType) {
                  renderer.newType = true;
                  renderer.currentType = type;
                }
                renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
                child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
                child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
                child.renderWebGL(renderer, child, camera, transformMatrix, container);
                child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
                child.setScrollFactor(childScrollFactorX, childScrollFactorY);
                if (mask) {
                  mask.postRenderWebGL(renderer, camera);
                }
                renderer.newType = false;
              }
              renderer.pipelines.postBatch(container);
            };
            module2.exports = ContainerWebGLRenderer;
          },
          2452: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = [
              "normal",
              "multiply",
              "multiply",
              "screen",
              "overlay",
              "darken",
              "lighten",
              "color-dodge",
              "color-burn",
              "hard-light",
              "soft-light",
              "difference",
              "exclusion",
              "hue",
              "saturation",
              "color",
              "luminosity"
            ];
          },
          38943: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var DOMElementRender = __webpack_require__2(11603);
            var GameObject = __webpack_require__2(89980);
            var IsPlainObject = __webpack_require__2(42911);
            var RemoveFromDOM = __webpack_require__2(55638);
            var SCENE_EVENTS = __webpack_require__2(7599);
            var Vector4 = __webpack_require__2(51729);
            var DOMElement = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.Origin,
                Components.ScrollFactor,
                Components.Transform,
                Components.Visible,
                DOMElementRender
              ],
              initialize: function DOMElement2(scene, x, y, element, style, innerText) {
                GameObject.call(this, scene, "DOMElement");
                this.parent = scene.sys.game.domContainer;
                this.cache = scene.sys.cache.html;
                this.node;
                this.transformOnly = false;
                this.skewX = 0;
                this.skewY = 0;
                this.rotate3d = new Vector4();
                this.rotate3dAngle = "deg";
                this.pointerEvents = "auto";
                this.width = 0;
                this.height = 0;
                this.displayWidth = 0;
                this.displayHeight = 0;
                this.handler = this.dispatchNativeEvent.bind(this);
                this.setPosition(x, y);
                if (typeof element === "string") {
                  if (element[0] === "#") {
                    this.setElement(element.substr(1), style, innerText);
                  } else {
                    this.createElement(element, style, innerText);
                  }
                } else if (element) {
                  this.setElement(element, style, innerText);
                }
                scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
                scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
                scene.sys.events.on(SCENE_EVENTS.PRE_RENDER, this.preRender, this);
              },
              handleSceneEvent: function(sys) {
                var node = this.node;
                var style = node.style;
                if (node) {
                  style.display = sys.settings.visible ? "block" : "none";
                }
              },
              setSkew: function(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = x;
                }
                this.skewX = x;
                this.skewY = y;
                return this;
              },
              setPerspective: function(value) {
                this.parent.style.perspective = value + "px";
                return this;
              },
              perspective: {
                get: function() {
                  return parseFloat(this.parent.style.perspective);
                },
                set: function(value) {
                  this.parent.style.perspective = value + "px";
                }
              },
              addListener: function(events) {
                if (this.node) {
                  events = events.split(" ");
                  for (var i = 0; i < events.length; i++) {
                    this.node.addEventListener(events[i], this.handler, false);
                  }
                }
                return this;
              },
              removeListener: function(events) {
                if (this.node) {
                  events = events.split(" ");
                  for (var i = 0; i < events.length; i++) {
                    this.node.removeEventListener(events[i], this.handler);
                  }
                }
                return this;
              },
              dispatchNativeEvent: function(event) {
                this.emit(event.type, event);
              },
              createElement: function(tagName, style, innerText) {
                return this.setElement(document.createElement(tagName), style, innerText);
              },
              setElement: function(element, style, innerText) {
                this.removeElement();
                var target;
                if (typeof element === "string") {
                  if (element[0] === "#") {
                    element = element.substr(1);
                  }
                  target = document.getElementById(element);
                } else if (typeof element === "object" && element.nodeType === 1) {
                  target = element;
                }
                if (!target) {
                  return this;
                }
                this.node = target;
                if (style && IsPlainObject(style)) {
                  for (var key in style) {
                    target.style[key] = style[key];
                  }
                } else if (typeof style === "string") {
                  target.style = style;
                }
                target.style.zIndex = "0";
                target.style.display = "inline";
                target.style.position = "absolute";
                target.phaser = this;
                if (this.parent) {
                  this.parent.appendChild(target);
                }
                if (innerText) {
                  target.innerText = innerText;
                }
                return this.updateSize();
              },
              createFromCache: function(key, tagName) {
                var html = this.cache.get(key);
                if (html) {
                  this.createFromHTML(html, tagName);
                }
                return this;
              },
              createFromHTML: function(html, tagName) {
                if (tagName === void 0) {
                  tagName = "div";
                }
                this.removeElement();
                var element = document.createElement(tagName);
                this.node = element;
                element.style.zIndex = "0";
                element.style.display = "inline";
                element.style.position = "absolute";
                element.phaser = this;
                if (this.parent) {
                  this.parent.appendChild(element);
                }
                element.innerHTML = html;
                return this.updateSize();
              },
              removeElement: function() {
                if (this.node) {
                  RemoveFromDOM(this.node);
                  this.node = null;
                }
                return this;
              },
              updateSize: function() {
                var node = this.node;
                var nodeBounds = node.getBoundingClientRect();
                this.width = node.clientWidth;
                this.height = node.clientHeight;
                this.displayWidth = nodeBounds.width || 0;
                this.displayHeight = nodeBounds.height || 0;
                return this;
              },
              getChildByProperty: function(property, value) {
                if (this.node) {
                  var children = this.node.querySelectorAll("*");
                  for (var i = 0; i < children.length; i++) {
                    if (children[i][property] === value) {
                      return children[i];
                    }
                  }
                }
                return null;
              },
              getChildByID: function(id) {
                return this.getChildByProperty("id", id);
              },
              getChildByName: function(name) {
                return this.getChildByProperty("name", name);
              },
              setClassName: function(className) {
                if (this.node) {
                  this.node.className = className;
                  this.updateSize();
                }
                return this;
              },
              setText: function(text) {
                if (this.node) {
                  this.node.innerText = text;
                  this.updateSize();
                }
                return this;
              },
              setHTML: function(html) {
                if (this.node) {
                  this.node.innerHTML = html;
                  this.updateSize();
                }
                return this;
              },
              preRender: function() {
                var parent = this.parentContainer;
                var node = this.node;
                if (node && parent && !parent.willRender()) {
                  node.style.display = "none";
                }
              },
              willRender: function() {
                return true;
              },
              preDestroy: function() {
                this.removeElement();
                this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
                this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
                this.scene.sys.events.off(SCENE_EVENTS.PRE_RENDER, this.preRender, this);
              }
            });
            module2.exports = DOMElement;
          },
          66070: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CSSBlendModes = __webpack_require__2(2452);
            var GameObject = __webpack_require__2(89980);
            var TransformMatrix = __webpack_require__2(69360);
            var tempMatrix1 = new TransformMatrix();
            var tempMatrix2 = new TransformMatrix();
            var tempMatrix3 = new TransformMatrix();
            var DOMElementCSSRenderer = function(renderer, src, camera, parentMatrix) {
              if (!src.node) {
                return;
              }
              var style = src.node.style;
              var settings = src.scene.sys.settings;
              if (!style || !settings.visible || GameObject.RENDER_MASK !== src.renderFlags || src.cameraFilter !== 0 && src.cameraFilter & camera.id || src.parentContainer && !src.parentContainer.willRender()) {
                style.display = "none";
                return;
              }
              var parent = src.parentContainer;
              var alpha = camera.alpha * src.alpha;
              if (parent) {
                alpha *= parent.alpha;
              }
              var camMatrix = tempMatrix1;
              var srcMatrix = tempMatrix2;
              var calcMatrix = tempMatrix3;
              var dx = 0;
              var dy = 0;
              var tx = "0%";
              var ty = "0%";
              if (parentMatrix) {
                dx = src.width * src.scaleX * src.originX;
                dy = src.height * src.scaleY * src.originY;
                srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
                camMatrix.copyFrom(camera.matrix);
                camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
                srcMatrix.e = src.x - dx;
                srcMatrix.f = src.y - dy;
                camMatrix.multiply(srcMatrix, calcMatrix);
              } else {
                dx = src.width * src.originX;
                dy = src.height * src.originY;
                srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
                camMatrix.copyFrom(camera.matrix);
                tx = 100 * src.originX + "%";
                ty = 100 * src.originY + "%";
                srcMatrix.e -= camera.scrollX * src.scrollFactorX;
                srcMatrix.f -= camera.scrollY * src.scrollFactorY;
                camMatrix.multiply(srcMatrix, calcMatrix);
              }
              if (!src.transformOnly) {
                style.display = "block";
                style.opacity = alpha;
                style.zIndex = src._depth;
                style.pointerEvents = src.pointerEvents;
                style.mixBlendMode = CSSBlendModes[src._blendMode];
              }
              style.transform = calcMatrix.getCSSMatrix() + " skew(" + src.skewX + "rad, " + src.skewY + "rad) rotate3d(" + src.rotate3d.x + "," + src.rotate3d.y + "," + src.rotate3d.z + "," + src.rotate3d.w + src.rotate3dAngle + ")";
              style.transformOrigin = tx + " " + ty;
            };
            module2.exports = DOMElementCSSRenderer;
          },
          66788: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DOMElement = __webpack_require__2(38943);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("dom", function(x, y, element, style, innerText) {
              var gameObject = new DOMElement(this.scene, x, y, element, style, innerText);
              this.displayList.add(gameObject);
              return gameObject;
            });
          },
          11603: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(66070);
            }
            if (true) {
              renderCanvas = __webpack_require__2(66070);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          65492: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "addedtoscene";
          },
          98398: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "destroy";
          },
          40239: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "removedfromscene";
          },
          17286: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "complete";
          },
          31496: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "created";
          },
          89587: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "error";
          },
          59792: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "locked";
          },
          96342: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "loop";
          },
          6017: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "playing";
          },
          49614: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "play";
          },
          24418: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "seeked";
          },
          87318: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "seeking";
          },
          50009: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "stalled";
          },
          61922: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "stop";
          },
          79501: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "textureready";
          },
          4052: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "unlocked";
          },
          54857: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "unsupported";
          },
          56631: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ADDED_TO_SCENE: __webpack_require__2(65492),
              DESTROY: __webpack_require__2(98398),
              REMOVED_FROM_SCENE: __webpack_require__2(40239),
              VIDEO_COMPLETE: __webpack_require__2(17286),
              VIDEO_CREATED: __webpack_require__2(31496),
              VIDEO_ERROR: __webpack_require__2(89587),
              VIDEO_LOCKED: __webpack_require__2(59792),
              VIDEO_LOOP: __webpack_require__2(96342),
              VIDEO_PLAY: __webpack_require__2(49614),
              VIDEO_PLAYING: __webpack_require__2(6017),
              VIDEO_SEEKED: __webpack_require__2(24418),
              VIDEO_SEEKING: __webpack_require__2(87318),
              VIDEO_STALLED: __webpack_require__2(50009),
              VIDEO_STOP: __webpack_require__2(61922),
              VIDEO_TEXTURE: __webpack_require__2(79501),
              VIDEO_UNLOCKED: __webpack_require__2(4052),
              VIDEO_UNSUPPORTED: __webpack_require__2(54857)
            };
          },
          39419: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var ExternRender = __webpack_require__2(79394);
            var Extern = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Flip,
                Components.Origin,
                Components.ScrollFactor,
                Components.Size,
                Components.Texture,
                Components.Tint,
                Components.Transform,
                Components.Visible,
                ExternRender
              ],
              initialize: function Extern2(scene) {
                GameObject.call(this, scene, "Extern");
              },
              addedToScene: function() {
                this.scene.sys.updateList.add(this);
              },
              removedFromScene: function() {
                this.scene.sys.updateList.remove(this);
              },
              preUpdate: function() {
              },
              render: function() {
              }
            });
            module2.exports = Extern;
          },
          96699: () => {
          },
          41155: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Extern = __webpack_require__2(39419);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("extern", function() {
              var extern = new Extern(this.scene);
              this.displayList.add(extern);
              return extern;
            });
          },
          79394: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(81410);
            }
            if (true) {
              renderCanvas = __webpack_require__2(96699);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          81410: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var ExternWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              renderer.pipelines.clear();
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              src.render.call(src, renderer, camera, calcMatrix);
              renderer.pipelines.rebind();
            };
            module2.exports = ExternWebGLRenderer;
          },
          36266: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ARC: 0,
              BEGIN_PATH: 1,
              CLOSE_PATH: 2,
              FILL_RECT: 3,
              LINE_TO: 4,
              MOVE_TO: 5,
              LINE_STYLE: 6,
              FILL_STYLE: 7,
              FILL_PATH: 8,
              STROKE_PATH: 9,
              FILL_TRIANGLE: 10,
              STROKE_TRIANGLE: 11,
              SAVE: 14,
              RESTORE: 15,
              TRANSLATE: 16,
              SCALE: 17,
              ROTATE: 18,
              GRADIENT_FILL_STYLE: 21,
              GRADIENT_LINE_STYLE: 22
            };
          },
          33182: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseCamera = __webpack_require__2(51052);
            var Class = __webpack_require__2(56694);
            var Commands = __webpack_require__2(36266);
            var Components = __webpack_require__2(64937);
            var Ellipse = __webpack_require__2(95669);
            var GameObject = __webpack_require__2(89980);
            var GetFastValue = __webpack_require__2(72632);
            var GetValue = __webpack_require__2(10850);
            var MATH_CONST = __webpack_require__2(83392);
            var Render = __webpack_require__2(60898);
            var Graphics = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.Pipeline,
                Components.PostPipeline,
                Components.Transform,
                Components.Visible,
                Components.ScrollFactor,
                Render
              ],
              initialize: function Graphics2(scene, options) {
                var x = GetValue(options, "x", 0);
                var y = GetValue(options, "y", 0);
                GameObject.call(this, scene, "Graphics");
                this.setPosition(x, y);
                this.initPipeline();
                this.initPostPipeline();
                this.displayOriginX = 0;
                this.displayOriginY = 0;
                this.commandBuffer = [];
                this.defaultFillColor = -1;
                this.defaultFillAlpha = 1;
                this.defaultStrokeWidth = 1;
                this.defaultStrokeColor = -1;
                this.defaultStrokeAlpha = 1;
                this._lineWidth = 1;
                this.lineStyle(1, 0, 0);
                this.fillStyle(0, 0);
                this.setDefaultStyles(options);
              },
              setDefaultStyles: function(options) {
                if (GetValue(options, "lineStyle", null)) {
                  this.defaultStrokeWidth = GetValue(options, "lineStyle.width", 1);
                  this.defaultStrokeColor = GetValue(options, "lineStyle.color", 16777215);
                  this.defaultStrokeAlpha = GetValue(options, "lineStyle.alpha", 1);
                  this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
                }
                if (GetValue(options, "fillStyle", null)) {
                  this.defaultFillColor = GetValue(options, "fillStyle.color", 16777215);
                  this.defaultFillAlpha = GetValue(options, "fillStyle.alpha", 1);
                  this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
                }
                return this;
              },
              lineStyle: function(lineWidth, color, alpha) {
                if (alpha === void 0) {
                  alpha = 1;
                }
                this.commandBuffer.push(Commands.LINE_STYLE, lineWidth, color, alpha);
                this._lineWidth = lineWidth;
                return this;
              },
              fillStyle: function(color, alpha) {
                if (alpha === void 0) {
                  alpha = 1;
                }
                this.commandBuffer.push(Commands.FILL_STYLE, color, alpha);
                return this;
              },
              fillGradientStyle: function(topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight) {
                if (alphaTopLeft === void 0) {
                  alphaTopLeft = 1;
                }
                if (alphaTopRight === void 0) {
                  alphaTopRight = alphaTopLeft;
                }
                if (alphaBottomLeft === void 0) {
                  alphaBottomLeft = alphaTopLeft;
                }
                if (alphaBottomRight === void 0) {
                  alphaBottomRight = alphaTopLeft;
                }
                this.commandBuffer.push(Commands.GRADIENT_FILL_STYLE, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight, topLeft, topRight, bottomLeft, bottomRight);
                return this;
              },
              lineGradientStyle: function(lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha) {
                if (alpha === void 0) {
                  alpha = 1;
                }
                this.commandBuffer.push(Commands.GRADIENT_LINE_STYLE, lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight);
                return this;
              },
              beginPath: function() {
                this.commandBuffer.push(Commands.BEGIN_PATH);
                return this;
              },
              closePath: function() {
                this.commandBuffer.push(Commands.CLOSE_PATH);
                return this;
              },
              fillPath: function() {
                this.commandBuffer.push(Commands.FILL_PATH);
                return this;
              },
              fill: function() {
                this.commandBuffer.push(Commands.FILL_PATH);
                return this;
              },
              strokePath: function() {
                this.commandBuffer.push(Commands.STROKE_PATH);
                return this;
              },
              stroke: function() {
                this.commandBuffer.push(Commands.STROKE_PATH);
                return this;
              },
              fillCircleShape: function(circle) {
                return this.fillCircle(circle.x, circle.y, circle.radius);
              },
              strokeCircleShape: function(circle) {
                return this.strokeCircle(circle.x, circle.y, circle.radius);
              },
              fillCircle: function(x, y, radius) {
                this.beginPath();
                this.arc(x, y, radius, 0, MATH_CONST.PI2);
                this.fillPath();
                return this;
              },
              strokeCircle: function(x, y, radius) {
                this.beginPath();
                this.arc(x, y, radius, 0, MATH_CONST.PI2);
                this.strokePath();
                return this;
              },
              fillRectShape: function(rect) {
                return this.fillRect(rect.x, rect.y, rect.width, rect.height);
              },
              strokeRectShape: function(rect) {
                return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
              },
              fillRect: function(x, y, width, height) {
                this.commandBuffer.push(Commands.FILL_RECT, x, y, width, height);
                return this;
              },
              strokeRect: function(x, y, width, height) {
                var lineWidthHalf = this._lineWidth / 2;
                var minx = x - lineWidthHalf;
                var maxx = x + lineWidthHalf;
                this.beginPath();
                this.moveTo(x, y);
                this.lineTo(x, y + height);
                this.strokePath();
                this.beginPath();
                this.moveTo(x + width, y);
                this.lineTo(x + width, y + height);
                this.strokePath();
                this.beginPath();
                this.moveTo(minx, y);
                this.lineTo(maxx + width, y);
                this.strokePath();
                this.beginPath();
                this.moveTo(minx, y + height);
                this.lineTo(maxx + width, y + height);
                this.strokePath();
                return this;
              },
              fillRoundedRect: function(x, y, width, height, radius) {
                if (radius === void 0) {
                  radius = 20;
                }
                var tl = radius;
                var tr = radius;
                var bl = radius;
                var br = radius;
                if (typeof radius !== "number") {
                  tl = GetFastValue(radius, "tl", 20);
                  tr = GetFastValue(radius, "tr", 20);
                  bl = GetFastValue(radius, "bl", 20);
                  br = GetFastValue(radius, "br", 20);
                }
                var convexTL = tl >= 0;
                var convexTR = tr >= 0;
                var convexBL = bl >= 0;
                var convexBR = br >= 0;
                tl = Math.abs(tl);
                tr = Math.abs(tr);
                bl = Math.abs(bl);
                br = Math.abs(br);
                this.beginPath();
                this.moveTo(x + tl, y);
                this.lineTo(x + width - tr, y);
                if (convexTR) {
                  this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
                } else {
                  this.arc(x + width, y, tr, Math.PI, MATH_CONST.TAU, true);
                }
                this.lineTo(x + width, y + height - br);
                if (convexBR) {
                  this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
                } else {
                  this.arc(x + width, y + height, br, -MATH_CONST.TAU, Math.PI, true);
                }
                this.lineTo(x + bl, y + height);
                if (convexBL) {
                  this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
                } else {
                  this.arc(x, y + height, bl, 0, -MATH_CONST.TAU, true);
                }
                this.lineTo(x, y + tl);
                if (convexTL) {
                  this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
                } else {
                  this.arc(x, y, tl, MATH_CONST.TAU, 0, true);
                }
                this.fillPath();
                return this;
              },
              strokeRoundedRect: function(x, y, width, height, radius) {
                if (radius === void 0) {
                  radius = 20;
                }
                var tl = radius;
                var tr = radius;
                var bl = radius;
                var br = radius;
                var maxRadius = Math.min(width, height) / 2;
                if (typeof radius !== "number") {
                  tl = GetFastValue(radius, "tl", 20);
                  tr = GetFastValue(radius, "tr", 20);
                  bl = GetFastValue(radius, "bl", 20);
                  br = GetFastValue(radius, "br", 20);
                }
                var convexTL = tl >= 0;
                var convexTR = tr >= 0;
                var convexBL = bl >= 0;
                var convexBR = br >= 0;
                tl = Math.min(Math.abs(tl), maxRadius);
                tr = Math.min(Math.abs(tr), maxRadius);
                bl = Math.min(Math.abs(bl), maxRadius);
                br = Math.min(Math.abs(br), maxRadius);
                this.beginPath();
                this.moveTo(x + tl, y);
                this.lineTo(x + width - tr, y);
                this.moveTo(x + width - tr, y);
                if (convexTR) {
                  this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
                } else {
                  this.arc(x + width, y, tr, Math.PI, MATH_CONST.TAU, true);
                }
                this.lineTo(x + width, y + height - br);
                this.moveTo(x + width, y + height - br);
                if (convexBR) {
                  this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
                } else {
                  this.arc(x + width, y + height, br, -MATH_CONST.TAU, Math.PI, true);
                }
                this.lineTo(x + bl, y + height);
                this.moveTo(x + bl, y + height);
                if (convexBL) {
                  this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
                } else {
                  this.arc(x, y + height, bl, 0, -MATH_CONST.TAU, true);
                }
                this.lineTo(x, y + tl);
                this.moveTo(x, y + tl);
                if (convexTL) {
                  this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
                } else {
                  this.arc(x, y, tl, MATH_CONST.TAU, 0, true);
                }
                this.strokePath();
                return this;
              },
              fillPointShape: function(point, size) {
                return this.fillPoint(point.x, point.y, size);
              },
              fillPoint: function(x, y, size) {
                if (!size || size < 1) {
                  size = 1;
                } else {
                  x -= size / 2;
                  y -= size / 2;
                }
                this.commandBuffer.push(Commands.FILL_RECT, x, y, size, size);
                return this;
              },
              fillTriangleShape: function(triangle) {
                return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
              },
              strokeTriangleShape: function(triangle) {
                return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
              },
              fillTriangle: function(x0, y0, x1, y1, x2, y2) {
                this.commandBuffer.push(Commands.FILL_TRIANGLE, x0, y0, x1, y1, x2, y2);
                return this;
              },
              strokeTriangle: function(x0, y0, x1, y1, x2, y2) {
                this.commandBuffer.push(Commands.STROKE_TRIANGLE, x0, y0, x1, y1, x2, y2);
                return this;
              },
              strokeLineShape: function(line) {
                return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
              },
              lineBetween: function(x1, y1, x2, y2) {
                this.beginPath();
                this.moveTo(x1, y1);
                this.lineTo(x2, y2);
                this.strokePath();
                return this;
              },
              lineTo: function(x, y) {
                this.commandBuffer.push(Commands.LINE_TO, x, y);
                return this;
              },
              moveTo: function(x, y) {
                this.commandBuffer.push(Commands.MOVE_TO, x, y);
                return this;
              },
              strokePoints: function(points, closeShape, closePath, endIndex) {
                if (closeShape === void 0) {
                  closeShape = false;
                }
                if (closePath === void 0) {
                  closePath = false;
                }
                if (endIndex === void 0) {
                  endIndex = points.length;
                }
                this.beginPath();
                this.moveTo(points[0].x, points[0].y);
                for (var i = 1; i < endIndex; i++) {
                  this.lineTo(points[i].x, points[i].y);
                }
                if (closeShape) {
                  this.lineTo(points[0].x, points[0].y);
                }
                if (closePath) {
                  this.closePath();
                }
                this.strokePath();
                return this;
              },
              fillPoints: function(points, closeShape, closePath, endIndex) {
                if (closeShape === void 0) {
                  closeShape = false;
                }
                if (closePath === void 0) {
                  closePath = false;
                }
                if (endIndex === void 0) {
                  endIndex = points.length;
                }
                this.beginPath();
                this.moveTo(points[0].x, points[0].y);
                for (var i = 1; i < endIndex; i++) {
                  this.lineTo(points[i].x, points[i].y);
                }
                if (closeShape) {
                  this.lineTo(points[0].x, points[0].y);
                }
                if (closePath) {
                  this.closePath();
                }
                this.fillPath();
                return this;
              },
              strokeEllipseShape: function(ellipse, smoothness) {
                if (smoothness === void 0) {
                  smoothness = 32;
                }
                var points = ellipse.getPoints(smoothness);
                return this.strokePoints(points, true);
              },
              strokeEllipse: function(x, y, width, height, smoothness) {
                if (smoothness === void 0) {
                  smoothness = 32;
                }
                var ellipse = new Ellipse(x, y, width, height);
                var points = ellipse.getPoints(smoothness);
                return this.strokePoints(points, true);
              },
              fillEllipseShape: function(ellipse, smoothness) {
                if (smoothness === void 0) {
                  smoothness = 32;
                }
                var points = ellipse.getPoints(smoothness);
                return this.fillPoints(points, true);
              },
              fillEllipse: function(x, y, width, height, smoothness) {
                if (smoothness === void 0) {
                  smoothness = 32;
                }
                var ellipse = new Ellipse(x, y, width, height);
                var points = ellipse.getPoints(smoothness);
                return this.fillPoints(points, true);
              },
              arc: function(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
                if (anticlockwise === void 0) {
                  anticlockwise = false;
                }
                if (overshoot === void 0) {
                  overshoot = 0;
                }
                this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
                return this;
              },
              slice: function(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
                if (anticlockwise === void 0) {
                  anticlockwise = false;
                }
                if (overshoot === void 0) {
                  overshoot = 0;
                }
                this.commandBuffer.push(Commands.BEGIN_PATH);
                this.commandBuffer.push(Commands.MOVE_TO, x, y);
                this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
                this.commandBuffer.push(Commands.CLOSE_PATH);
                return this;
              },
              save: function() {
                this.commandBuffer.push(Commands.SAVE);
                return this;
              },
              restore: function() {
                this.commandBuffer.push(Commands.RESTORE);
                return this;
              },
              translateCanvas: function(x, y) {
                this.commandBuffer.push(Commands.TRANSLATE, x, y);
                return this;
              },
              scaleCanvas: function(x, y) {
                this.commandBuffer.push(Commands.SCALE, x, y);
                return this;
              },
              rotateCanvas: function(radians) {
                this.commandBuffer.push(Commands.ROTATE, radians);
                return this;
              },
              clear: function() {
                this.commandBuffer.length = 0;
                if (this.defaultFillColor > -1) {
                  this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
                }
                if (this.defaultStrokeColor > -1) {
                  this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
                }
                return this;
              },
              generateTexture: function(key, width, height) {
                var sys = this.scene.sys;
                var renderer = sys.game.renderer;
                if (width === void 0) {
                  width = sys.scale.width;
                }
                if (height === void 0) {
                  height = sys.scale.height;
                }
                Graphics.TargetCamera.setScene(this.scene);
                Graphics.TargetCamera.setViewport(0, 0, width, height);
                Graphics.TargetCamera.scrollX = this.x;
                Graphics.TargetCamera.scrollY = this.y;
                var texture;
                var ctx;
                var willRead = {willReadFrequently: true};
                if (typeof key === "string") {
                  if (sys.textures.exists(key)) {
                    texture = sys.textures.get(key);
                    var src = texture.getSourceImage();
                    if (src instanceof HTMLCanvasElement) {
                      ctx = src.getContext("2d", willRead);
                    }
                  } else {
                    texture = sys.textures.createCanvas(key, width, height);
                    ctx = texture.getSourceImage().getContext("2d", willRead);
                  }
                } else if (key instanceof HTMLCanvasElement) {
                  ctx = key.getContext("2d", willRead);
                }
                if (ctx) {
                  this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);
                  if (texture) {
                    texture.refresh();
                  }
                }
                return this;
              },
              preDestroy: function() {
                this.commandBuffer = [];
              }
            });
            Graphics.TargetCamera = new BaseCamera();
            module2.exports = Graphics;
          },
          91543: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Commands = __webpack_require__2(36266);
            var SetTransform = __webpack_require__2(49584);
            var GraphicsCanvasRenderer = function(renderer, src, camera, parentMatrix, renderTargetCtx, allowClip) {
              var commandBuffer = src.commandBuffer;
              var commandBufferLength = commandBuffer.length;
              var ctx = renderTargetCtx || renderer.currentContext;
              if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                return;
              }
              camera.addToRenderList(src);
              var lineAlpha = 1;
              var fillAlpha = 1;
              var lineColor = 0;
              var fillColor = 0;
              var lineWidth = 1;
              var red = 0;
              var green = 0;
              var blue = 0;
              ctx.beginPath();
              for (var index = 0; index < commandBufferLength; ++index) {
                var commandID = commandBuffer[index];
                switch (commandID) {
                  case Commands.ARC:
                    ctx.arc(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4], commandBuffer[index + 5], commandBuffer[index + 6]);
                    index += 7;
                    break;
                  case Commands.LINE_STYLE:
                    lineWidth = commandBuffer[index + 1];
                    lineColor = commandBuffer[index + 2];
                    lineAlpha = commandBuffer[index + 3];
                    red = (lineColor & 16711680) >>> 16;
                    green = (lineColor & 65280) >>> 8;
                    blue = lineColor & 255;
                    ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + lineAlpha + ")";
                    ctx.lineWidth = lineWidth;
                    index += 3;
                    break;
                  case Commands.FILL_STYLE:
                    fillColor = commandBuffer[index + 1];
                    fillAlpha = commandBuffer[index + 2];
                    red = (fillColor & 16711680) >>> 16;
                    green = (fillColor & 65280) >>> 8;
                    blue = fillColor & 255;
                    ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
                    index += 2;
                    break;
                  case Commands.BEGIN_PATH:
                    ctx.beginPath();
                    break;
                  case Commands.CLOSE_PATH:
                    ctx.closePath();
                    break;
                  case Commands.FILL_PATH:
                    if (!allowClip) {
                      ctx.fill();
                    }
                    break;
                  case Commands.STROKE_PATH:
                    if (!allowClip) {
                      ctx.stroke();
                    }
                    break;
                  case Commands.FILL_RECT:
                    if (!allowClip) {
                      ctx.fillRect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
                    } else {
                      ctx.rect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
                    }
                    index += 4;
                    break;
                  case Commands.FILL_TRIANGLE:
                    ctx.beginPath();
                    ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                    ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                    ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                    ctx.closePath();
                    if (!allowClip) {
                      ctx.fill();
                    }
                    index += 6;
                    break;
                  case Commands.STROKE_TRIANGLE:
                    ctx.beginPath();
                    ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                    ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                    ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                    ctx.closePath();
                    if (!allowClip) {
                      ctx.stroke();
                    }
                    index += 6;
                    break;
                  case Commands.LINE_TO:
                    ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                    index += 2;
                    break;
                  case Commands.MOVE_TO:
                    ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                    index += 2;
                    break;
                  case Commands.LINE_FX_TO:
                    ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                    index += 5;
                    break;
                  case Commands.MOVE_FX_TO:
                    ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                    index += 5;
                    break;
                  case Commands.SAVE:
                    ctx.save();
                    break;
                  case Commands.RESTORE:
                    ctx.restore();
                    break;
                  case Commands.TRANSLATE:
                    ctx.translate(commandBuffer[index + 1], commandBuffer[index + 2]);
                    index += 2;
                    break;
                  case Commands.SCALE:
                    ctx.scale(commandBuffer[index + 1], commandBuffer[index + 2]);
                    index += 2;
                    break;
                  case Commands.ROTATE:
                    ctx.rotate(commandBuffer[index + 1]);
                    index += 1;
                    break;
                  case Commands.GRADIENT_FILL_STYLE:
                    index += 5;
                    break;
                  case Commands.GRADIENT_LINE_STYLE:
                    index += 6;
                    break;
                }
              }
              ctx.restore();
            };
            module2.exports = GraphicsCanvasRenderer;
          },
          41286: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectCreator = __webpack_require__2(99325);
            var Graphics = __webpack_require__2(33182);
            GameObjectCreator.register("graphics", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              var graphics = new Graphics(this.scene, config2);
              if (config2.add) {
                this.scene.sys.displayList.add(graphics);
              }
              return graphics;
            });
          },
          13122: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Graphics = __webpack_require__2(33182);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("graphics", function(config2) {
              return this.displayList.add(new Graphics(this.scene, config2));
            });
          },
          60898: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(34429);
              renderCanvas = __webpack_require__2(91543);
            }
            if (true) {
              renderCanvas = __webpack_require__2(91543);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          34429: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Commands = __webpack_require__2(36266);
            var GetCalcMatrix = __webpack_require__2(73329);
            var TransformMatrix = __webpack_require__2(69360);
            var Utils = __webpack_require__2(75512);
            var Point = function(x, y, width) {
              this.x = x;
              this.y = y;
              this.width = width;
            };
            var Path = function(x, y, width) {
              this.points = [];
              this.pointsLength = 1;
              this.points[0] = new Point(x, y, width);
            };
            var matrixStack = [];
            var tempMatrix = new TransformMatrix();
            var GraphicsWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              if (src.commandBuffer.length === 0) {
                return;
              }
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              renderer.pipelines.preBatch(src);
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              var currentMatrix = tempMatrix.loadIdentity();
              var commands = src.commandBuffer;
              var alpha = camera.alpha * src.alpha;
              var lineWidth = 1;
              var fillTint = pipeline.fillTint;
              var strokeTint = pipeline.strokeTint;
              var tx = 0;
              var ty = 0;
              var ta = 0;
              var iterStep = 0.01;
              var PI2 = Math.PI * 2;
              var cmd;
              var path = [];
              var pathIndex = 0;
              var pathOpen = true;
              var lastPath = null;
              var getTint = Utils.getTintAppendFloatAlpha;
              for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {
                cmd = commands[cmdIndex];
                switch (cmd) {
                  case Commands.BEGIN_PATH: {
                    path.length = 0;
                    lastPath = null;
                    pathOpen = true;
                    break;
                  }
                  case Commands.CLOSE_PATH: {
                    pathOpen = false;
                    if (lastPath && lastPath.points.length) {
                      lastPath.points.push(lastPath.points[0]);
                    }
                    break;
                  }
                  case Commands.FILL_PATH: {
                    for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                      pipeline.batchFillPath(path[pathIndex].points, currentMatrix, calcMatrix);
                    }
                    break;
                  }
                  case Commands.STROKE_PATH: {
                    for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                      pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, calcMatrix);
                    }
                    break;
                  }
                  case Commands.LINE_STYLE: {
                    lineWidth = commands[++cmdIndex];
                    var strokeColor = commands[++cmdIndex];
                    var strokeAlpha = commands[++cmdIndex] * alpha;
                    var strokeTintColor = getTint(strokeColor, strokeAlpha);
                    strokeTint.TL = strokeTintColor;
                    strokeTint.TR = strokeTintColor;
                    strokeTint.BL = strokeTintColor;
                    strokeTint.BR = strokeTintColor;
                    break;
                  }
                  case Commands.FILL_STYLE: {
                    var fillColor = commands[++cmdIndex];
                    var fillAlpha = commands[++cmdIndex] * alpha;
                    var fillTintColor = getTint(fillColor, fillAlpha);
                    fillTint.TL = fillTintColor;
                    fillTint.TR = fillTintColor;
                    fillTint.BL = fillTintColor;
                    fillTint.BR = fillTintColor;
                    break;
                  }
                  case Commands.GRADIENT_FILL_STYLE: {
                    var alphaTL = commands[++cmdIndex] * alpha;
                    var alphaTR = commands[++cmdIndex] * alpha;
                    var alphaBL = commands[++cmdIndex] * alpha;
                    var alphaBR = commands[++cmdIndex] * alpha;
                    fillTint.TL = getTint(commands[++cmdIndex], alphaTL);
                    fillTint.TR = getTint(commands[++cmdIndex], alphaTR);
                    fillTint.BL = getTint(commands[++cmdIndex], alphaBL);
                    fillTint.BR = getTint(commands[++cmdIndex], alphaBR);
                    break;
                  }
                  case Commands.GRADIENT_LINE_STYLE: {
                    lineWidth = commands[++cmdIndex];
                    var gradientLineAlpha = commands[++cmdIndex] * alpha;
                    strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);
                    strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);
                    strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);
                    strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);
                    break;
                  }
                  case Commands.ARC: {
                    var iteration = 0;
                    var x = commands[++cmdIndex];
                    var y = commands[++cmdIndex];
                    var radius = commands[++cmdIndex];
                    var startAngle = commands[++cmdIndex];
                    var endAngle = commands[++cmdIndex];
                    var anticlockwise = commands[++cmdIndex];
                    var overshoot = commands[++cmdIndex];
                    endAngle -= startAngle;
                    if (anticlockwise) {
                      if (endAngle < -PI2) {
                        endAngle = -PI2;
                      } else if (endAngle > 0) {
                        endAngle = -PI2 + endAngle % PI2;
                      }
                    } else if (endAngle > PI2) {
                      endAngle = PI2;
                    } else if (endAngle < 0) {
                      endAngle = PI2 + endAngle % PI2;
                    }
                    if (lastPath === null) {
                      lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);
                      path.push(lastPath);
                      iteration += iterStep;
                    }
                    while (iteration < 1 + overshoot) {
                      ta = endAngle * iteration + startAngle;
                      tx = x + Math.cos(ta) * radius;
                      ty = y + Math.sin(ta) * radius;
                      lastPath.points.push(new Point(tx, ty, lineWidth));
                      iteration += iterStep;
                    }
                    ta = endAngle + startAngle;
                    tx = x + Math.cos(ta) * radius;
                    ty = y + Math.sin(ta) * radius;
                    lastPath.points.push(new Point(tx, ty, lineWidth));
                    break;
                  }
                  case Commands.FILL_RECT: {
                    pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
                    break;
                  }
                  case Commands.FILL_TRIANGLE: {
                    pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
                    break;
                  }
                  case Commands.STROKE_TRIANGLE: {
                    pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, calcMatrix);
                    break;
                  }
                  case Commands.LINE_TO: {
                    if (lastPath !== null) {
                      lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));
                    } else {
                      lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                      path.push(lastPath);
                    }
                    break;
                  }
                  case Commands.MOVE_TO: {
                    lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                    path.push(lastPath);
                    break;
                  }
                  case Commands.SAVE: {
                    matrixStack.push(currentMatrix.copyToArray());
                    break;
                  }
                  case Commands.RESTORE: {
                    currentMatrix.copyFromArray(matrixStack.pop());
                    break;
                  }
                  case Commands.TRANSLATE: {
                    x = commands[++cmdIndex];
                    y = commands[++cmdIndex];
                    currentMatrix.translate(x, y);
                    break;
                  }
                  case Commands.SCALE: {
                    x = commands[++cmdIndex];
                    y = commands[++cmdIndex];
                    currentMatrix.scale(x, y);
                    break;
                  }
                  case Commands.ROTATE: {
                    currentMatrix.rotate(commands[++cmdIndex]);
                    break;
                  }
                }
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = GraphicsWebGLRenderer;
          },
          59192: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Actions = __webpack_require__2(83979);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(56631);
            var EventEmitter = __webpack_require__2(6659);
            var GetAll = __webpack_require__2(71608);
            var GetFastValue = __webpack_require__2(72632);
            var GetValue = __webpack_require__2(10850);
            var HasValue = __webpack_require__2(19256);
            var IsPlainObject = __webpack_require__2(42911);
            var Range = __webpack_require__2(75757);
            var Set = __webpack_require__2(58403);
            var Sprite = __webpack_require__2(13747);
            var Group = new Class({
              Extends: EventEmitter,
              initialize: function Group2(scene, children, config2) {
                EventEmitter.call(this);
                if (config2) {
                  if (children && !Array.isArray(children)) {
                    children = [children];
                  }
                } else if (Array.isArray(children)) {
                  if (IsPlainObject(children[0])) {
                    config2 = children;
                    children = null;
                  }
                } else if (IsPlainObject(children)) {
                  config2 = children;
                  children = null;
                }
                this.scene = scene;
                this.children = new Set();
                this.isParent = true;
                this.type = "Group";
                this.classType = GetFastValue(config2, "classType", Sprite);
                this.name = GetFastValue(config2, "name", "");
                this.active = GetFastValue(config2, "active", true);
                this.maxSize = GetFastValue(config2, "maxSize", -1);
                this.defaultKey = GetFastValue(config2, "defaultKey", null);
                this.defaultFrame = GetFastValue(config2, "defaultFrame", null);
                this.runChildUpdate = GetFastValue(config2, "runChildUpdate", false);
                this.createCallback = GetFastValue(config2, "createCallback", null);
                this.removeCallback = GetFastValue(config2, "removeCallback", null);
                this.createMultipleCallback = GetFastValue(config2, "createMultipleCallback", null);
                this.internalCreateCallback = GetFastValue(config2, "internalCreateCallback", null);
                this.internalRemoveCallback = GetFastValue(config2, "internalRemoveCallback", null);
                if (children) {
                  this.addMultiple(children);
                }
                if (config2) {
                  this.createMultiple(config2);
                }
                this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
                this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
              },
              addedToScene: function() {
                this.scene.sys.updateList.add(this);
              },
              removedFromScene: function() {
                this.scene.sys.updateList.remove(this);
              },
              create: function(x, y, key, frame, visible, active) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (key === void 0) {
                  key = this.defaultKey;
                }
                if (frame === void 0) {
                  frame = this.defaultFrame;
                }
                if (visible === void 0) {
                  visible = true;
                }
                if (active === void 0) {
                  active = true;
                }
                if (this.isFull()) {
                  return null;
                }
                var child = new this.classType(this.scene, x, y, key, frame);
                child.addToDisplayList(this.scene.sys.displayList);
                child.addToUpdateList();
                child.visible = visible;
                child.setActive(active);
                this.add(child);
                return child;
              },
              createMultiple: function(config2) {
                if (this.isFull()) {
                  return [];
                }
                if (!Array.isArray(config2)) {
                  config2 = [config2];
                }
                var output = [];
                if (config2[0].key) {
                  for (var i = 0; i < config2.length; i++) {
                    var entries = this.createFromConfig(config2[i]);
                    output = output.concat(entries);
                  }
                }
                return output;
              },
              createFromConfig: function(options) {
                if (this.isFull()) {
                  return [];
                }
                this.classType = GetFastValue(options, "classType", this.classType);
                var key = GetFastValue(options, "key", void 0);
                var frame = GetFastValue(options, "frame", null);
                var visible = GetFastValue(options, "visible", true);
                var active = GetFastValue(options, "active", true);
                var entries = [];
                if (key === void 0) {
                  return entries;
                } else {
                  if (!Array.isArray(key)) {
                    key = [key];
                  }
                  if (!Array.isArray(frame)) {
                    frame = [frame];
                  }
                }
                var repeat = GetFastValue(options, "repeat", 0);
                var randomKey = GetFastValue(options, "randomKey", false);
                var randomFrame = GetFastValue(options, "randomFrame", false);
                var yoyo = GetFastValue(options, "yoyo", false);
                var quantity = GetFastValue(options, "quantity", false);
                var frameQuantity = GetFastValue(options, "frameQuantity", 1);
                var max = GetFastValue(options, "max", 0);
                var range = Range(key, frame, {
                  max,
                  qty: quantity ? quantity : frameQuantity,
                  random: randomKey,
                  randomB: randomFrame,
                  repeat,
                  yoyo
                });
                if (options.createCallback) {
                  this.createCallback = options.createCallback;
                }
                if (options.removeCallback) {
                  this.removeCallback = options.removeCallback;
                }
                if (options.internalCreateCallback) {
                  this.internalCreateCallback = options.internalCreateCallback;
                }
                if (options.internalRemoveCallback) {
                  this.internalRemoveCallback = options.internalRemoveCallback;
                }
                for (var c = 0; c < range.length; c++) {
                  var created = this.create(0, 0, range[c].a, range[c].b, visible, active);
                  if (!created) {
                    break;
                  }
                  entries.push(created);
                }
                if (HasValue(options, "setXY")) {
                  var x = GetValue(options, "setXY.x", 0);
                  var y = GetValue(options, "setXY.y", 0);
                  var stepX = GetValue(options, "setXY.stepX", 0);
                  var stepY = GetValue(options, "setXY.stepY", 0);
                  Actions.SetXY(entries, x, y, stepX, stepY);
                }
                if (HasValue(options, "setRotation")) {
                  var rotation = GetValue(options, "setRotation.value", 0);
                  var stepRotation = GetValue(options, "setRotation.step", 0);
                  Actions.SetRotation(entries, rotation, stepRotation);
                }
                if (HasValue(options, "setScale")) {
                  var scaleX = GetValue(options, "setScale.x", 1);
                  var scaleY = GetValue(options, "setScale.y", scaleX);
                  var stepScaleX = GetValue(options, "setScale.stepX", 0);
                  var stepScaleY = GetValue(options, "setScale.stepY", 0);
                  Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);
                }
                if (HasValue(options, "setOrigin")) {
                  var originX = GetValue(options, "setOrigin.x", 0.5);
                  var originY = GetValue(options, "setOrigin.y", originX);
                  var stepOriginX = GetValue(options, "setOrigin.stepX", 0);
                  var stepOriginY = GetValue(options, "setOrigin.stepY", 0);
                  Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);
                }
                if (HasValue(options, "setAlpha")) {
                  var alpha = GetValue(options, "setAlpha.value", 1);
                  var stepAlpha = GetValue(options, "setAlpha.step", 0);
                  Actions.SetAlpha(entries, alpha, stepAlpha);
                }
                if (HasValue(options, "setDepth")) {
                  var depth = GetValue(options, "setDepth.value", 0);
                  var stepDepth = GetValue(options, "setDepth.step", 0);
                  Actions.SetDepth(entries, depth, stepDepth);
                }
                if (HasValue(options, "setScrollFactor")) {
                  var scrollFactorX = GetValue(options, "setScrollFactor.x", 1);
                  var scrollFactorY = GetValue(options, "setScrollFactor.y", scrollFactorX);
                  var stepScrollFactorX = GetValue(options, "setScrollFactor.stepX", 0);
                  var stepScrollFactorY = GetValue(options, "setScrollFactor.stepY", 0);
                  Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);
                }
                var hitArea = GetFastValue(options, "hitArea", null);
                var hitAreaCallback = GetFastValue(options, "hitAreaCallback", null);
                if (hitArea) {
                  Actions.SetHitArea(entries, hitArea, hitAreaCallback);
                }
                var grid = GetFastValue(options, "gridAlign", false);
                if (grid) {
                  Actions.GridAlign(entries, grid);
                }
                if (this.createMultipleCallback) {
                  this.createMultipleCallback.call(this, entries);
                }
                return entries;
              },
              preUpdate: function(time, delta) {
                if (!this.runChildUpdate || this.children.size === 0) {
                  return;
                }
                var temp = this.children.entries.slice();
                for (var i = 0; i < temp.length; i++) {
                  var item = temp[i];
                  if (item.active) {
                    item.update(time, delta);
                  }
                }
              },
              add: function(child, addToScene) {
                if (addToScene === void 0) {
                  addToScene = false;
                }
                if (this.isFull()) {
                  return this;
                }
                this.children.set(child);
                if (this.internalCreateCallback) {
                  this.internalCreateCallback.call(this, child);
                }
                if (this.createCallback) {
                  this.createCallback.call(this, child);
                }
                if (addToScene) {
                  child.addToDisplayList(this.scene.sys.displayList);
                  child.addToUpdateList();
                }
                child.on(Events.DESTROY, this.remove, this);
                return this;
              },
              addMultiple: function(children, addToScene) {
                if (addToScene === void 0) {
                  addToScene = false;
                }
                if (Array.isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    this.add(children[i], addToScene);
                  }
                }
                return this;
              },
              remove: function(child, removeFromScene, destroyChild) {
                if (removeFromScene === void 0) {
                  removeFromScene = false;
                }
                if (destroyChild === void 0) {
                  destroyChild = false;
                }
                if (!this.children.contains(child)) {
                  return this;
                }
                this.children.delete(child);
                if (this.internalRemoveCallback) {
                  this.internalRemoveCallback.call(this, child);
                }
                if (this.removeCallback) {
                  this.removeCallback.call(this, child);
                }
                child.off(Events.DESTROY, this.remove, this);
                if (destroyChild) {
                  child.destroy();
                } else if (removeFromScene) {
                  child.removeFromDisplayList();
                  child.removeFromUpdateList();
                }
                return this;
              },
              clear: function(removeFromScene, destroyChild) {
                if (removeFromScene === void 0) {
                  removeFromScene = false;
                }
                if (destroyChild === void 0) {
                  destroyChild = false;
                }
                var children = this.children;
                for (var i = 0; i < children.size; i++) {
                  var gameObject = children.entries[i];
                  gameObject.off(Events.DESTROY, this.remove, this);
                  if (destroyChild) {
                    gameObject.destroy();
                  } else if (removeFromScene) {
                    gameObject.removeFromDisplayList();
                    gameObject.removeFromUpdateList();
                  }
                }
                this.children.clear();
                return this;
              },
              contains: function(child) {
                return this.children.contains(child);
              },
              getChildren: function() {
                return this.children.entries;
              },
              getLength: function() {
                return this.children.size;
              },
              getMatching: function(property, value, startIndex, endIndex) {
                return GetAll(this.children.entries, property, value, startIndex, endIndex);
              },
              getFirst: function(state, createIfNull, x, y, key, frame, visible) {
                return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);
              },
              getFirstNth: function(nth, state, createIfNull, x, y, key, frame, visible) {
                return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);
              },
              getLast: function(state, createIfNull, x, y, key, frame, visible) {
                return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);
              },
              getLastNth: function(nth, state, createIfNull, x, y, key, frame, visible) {
                return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);
              },
              getHandler: function(forwards, nth, state, createIfNull, x, y, key, frame, visible) {
                if (state === void 0) {
                  state = false;
                }
                if (createIfNull === void 0) {
                  createIfNull = false;
                }
                var gameObject;
                var i;
                var total = 0;
                var children = this.children.entries;
                if (forwards) {
                  for (i = 0; i < children.length; i++) {
                    gameObject = children[i];
                    if (gameObject.active === state) {
                      total++;
                      if (total === nth) {
                        break;
                      }
                    } else {
                      gameObject = null;
                    }
                  }
                } else {
                  for (i = children.length - 1; i >= 0; i--) {
                    gameObject = children[i];
                    if (gameObject.active === state) {
                      total++;
                      if (total === nth) {
                        break;
                      }
                    } else {
                      gameObject = null;
                    }
                  }
                }
                if (gameObject) {
                  if (typeof x === "number") {
                    gameObject.x = x;
                  }
                  if (typeof y === "number") {
                    gameObject.y = y;
                  }
                  return gameObject;
                }
                if (createIfNull) {
                  return this.create(x, y, key, frame, visible);
                } else {
                  return null;
                }
              },
              get: function(x, y, key, frame, visible) {
                return this.getFirst(false, true, x, y, key, frame, visible);
              },
              getFirstAlive: function(createIfNull, x, y, key, frame, visible) {
                return this.getFirst(true, createIfNull, x, y, key, frame, visible);
              },
              getFirstDead: function(createIfNull, x, y, key, frame, visible) {
                return this.getFirst(false, createIfNull, x, y, key, frame, visible);
              },
              playAnimation: function(key, startFrame) {
                Actions.PlayAnimation(this.children.entries, key, startFrame);
                return this;
              },
              isFull: function() {
                if (this.maxSize === -1) {
                  return false;
                } else {
                  return this.children.size >= this.maxSize;
                }
              },
              countActive: function(value) {
                if (value === void 0) {
                  value = true;
                }
                var total = 0;
                for (var i = 0; i < this.children.size; i++) {
                  if (this.children.entries[i].active === value) {
                    total++;
                  }
                }
                return total;
              },
              getTotalUsed: function() {
                return this.countActive();
              },
              getTotalFree: function() {
                var used = this.getTotalUsed();
                var capacity = this.maxSize === -1 ? 999999999999 : this.maxSize;
                return capacity - used;
              },
              setActive: function(value) {
                this.active = value;
                return this;
              },
              setName: function(value) {
                this.name = value;
                return this;
              },
              propertyValueSet: function(key, value, step, index, direction) {
                Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);
                return this;
              },
              propertyValueInc: function(key, value, step, index, direction) {
                Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);
                return this;
              },
              setX: function(value, step) {
                Actions.SetX(this.children.entries, value, step);
                return this;
              },
              setY: function(value, step) {
                Actions.SetY(this.children.entries, value, step);
                return this;
              },
              setXY: function(x, y, stepX, stepY) {
                Actions.SetXY(this.children.entries, x, y, stepX, stepY);
                return this;
              },
              incX: function(value, step) {
                Actions.IncX(this.children.entries, value, step);
                return this;
              },
              incY: function(value, step) {
                Actions.IncY(this.children.entries, value, step);
                return this;
              },
              incXY: function(x, y, stepX, stepY) {
                Actions.IncXY(this.children.entries, x, y, stepX, stepY);
                return this;
              },
              shiftPosition: function(x, y, direction) {
                Actions.ShiftPosition(this.children.entries, x, y, direction);
                return this;
              },
              angle: function(value, step) {
                Actions.Angle(this.children.entries, value, step);
                return this;
              },
              rotate: function(value, step) {
                Actions.Rotate(this.children.entries, value, step);
                return this;
              },
              rotateAround: function(point, angle) {
                Actions.RotateAround(this.children.entries, point, angle);
                return this;
              },
              rotateAroundDistance: function(point, angle, distance) {
                Actions.RotateAroundDistance(this.children.entries, point, angle, distance);
                return this;
              },
              setAlpha: function(value, step) {
                Actions.SetAlpha(this.children.entries, value, step);
                return this;
              },
              setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
                Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);
                return this;
              },
              setOrigin: function(originX, originY, stepX, stepY) {
                Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);
                return this;
              },
              scaleX: function(value, step) {
                Actions.ScaleX(this.children.entries, value, step);
                return this;
              },
              scaleY: function(value, step) {
                Actions.ScaleY(this.children.entries, value, step);
                return this;
              },
              scaleXY: function(scaleX, scaleY, stepX, stepY) {
                Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);
                return this;
              },
              setDepth: function(value, step) {
                Actions.SetDepth(this.children.entries, value, step);
                return this;
              },
              setBlendMode: function(value) {
                Actions.SetBlendMode(this.children.entries, value);
                return this;
              },
              setHitArea: function(hitArea, hitAreaCallback) {
                Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);
                return this;
              },
              shuffle: function() {
                Actions.Shuffle(this.children.entries);
                return this;
              },
              kill: function(gameObject) {
                if (this.children.contains(gameObject)) {
                  gameObject.setActive(false);
                }
              },
              killAndHide: function(gameObject) {
                if (this.children.contains(gameObject)) {
                  gameObject.setActive(false);
                  gameObject.setVisible(false);
                }
              },
              setVisible: function(value, index, direction) {
                Actions.SetVisible(this.children.entries, value, index, direction);
                return this;
              },
              toggleVisible: function() {
                Actions.ToggleVisible(this.children.entries);
                return this;
              },
              destroy: function(destroyChildren, removeFromScene) {
                if (destroyChildren === void 0) {
                  destroyChildren = false;
                }
                if (removeFromScene === void 0) {
                  removeFromScene = false;
                }
                if (!this.scene || this.ignoreDestroy) {
                  return;
                }
                this.emit(Events.DESTROY, this);
                this.removeAllListeners();
                this.scene.sys.updateList.remove(this);
                this.clear(removeFromScene, destroyChildren);
                this.scene = void 0;
                this.children = void 0;
              }
            });
            module2.exports = Group;
          },
          61295: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectCreator = __webpack_require__2(99325);
            var Group = __webpack_require__2(59192);
            GameObjectCreator.register("group", function(config2) {
              return new Group(this.scene, null, config2);
            });
          },
          62598: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Group = __webpack_require__2(59192);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("group", function(children, config2) {
              return this.updateList.add(new Group(this.scene, children, config2));
            });
          },
          1539: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var ImageRender = __webpack_require__2(57322);
            var Image2 = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Size,
                Components.TextureCrop,
                Components.Tint,
                Components.Transform,
                Components.Visible,
                ImageRender
              ],
              initialize: function Image3(scene, x, y, texture, frame) {
                GameObject.call(this, scene, "Image");
                this._crop = this.resetCropObject();
                this.setTexture(texture, frame);
                this.setPosition(x, y);
                this.setSizeToFrame();
                this.setOriginFromFrame();
                this.initPipeline();
                this.initPostPipeline(true);
              }
            });
            module2.exports = Image2;
          },
          57786: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ImageCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              renderer.batchSprite(src, src.frame, camera, parentMatrix);
            };
            module2.exports = ImageCanvasRenderer;
          },
          83556: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var Image2 = __webpack_require__2(1539);
            GameObjectCreator.register("image", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var frame = GetAdvancedValue(config2, "frame", null);
              var image = new Image2(this.scene, 0, 0, key, frame);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, image, config2);
              return image;
            });
          },
          20927: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Image2 = __webpack_require__2(1539);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("image", function(x, y, texture, frame) {
              return this.displayList.add(new Image2(this.scene, x, y, texture, frame));
            });
          },
          57322: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(59390);
            }
            if (true) {
              renderCanvas = __webpack_require__2(57786);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          59390: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ImageWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              this.pipeline.batchSprite(src, camera, parentMatrix);
            };
            module2.exports = ImageWebGLRenderer;
          },
          48013: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjects = {
              Events: __webpack_require__2(56631),
              DisplayList: __webpack_require__2(91713),
              GameObjectCreator: __webpack_require__2(99325),
              GameObjectFactory: __webpack_require__2(61286),
              UpdateList: __webpack_require__2(92034),
              Components: __webpack_require__2(64937),
              GetCalcMatrix: __webpack_require__2(73329),
              BuildGameObject: __webpack_require__2(88933),
              BuildGameObjectAnimation: __webpack_require__2(32291),
              GameObject: __webpack_require__2(89980),
              BitmapText: __webpack_require__2(44616),
              Blitter: __webpack_require__2(52816),
              Bob: __webpack_require__2(41664),
              Container: __webpack_require__2(70339),
              DOMElement: __webpack_require__2(38943),
              DynamicBitmapText: __webpack_require__2(13468),
              Extern: __webpack_require__2(39419),
              Graphics: __webpack_require__2(33182),
              Group: __webpack_require__2(59192),
              Image: __webpack_require__2(1539),
              Layer: __webpack_require__2(85305),
              Particles: __webpack_require__2(27684),
              PathFollower: __webpack_require__2(29598),
              RenderTexture: __webpack_require__2(15996),
              RetroFont: __webpack_require__2(55873),
              Rope: __webpack_require__2(79968),
              Sprite: __webpack_require__2(13747),
              Text: __webpack_require__2(76555),
              GetTextSize: __webpack_require__2(32979),
              MeasureText: __webpack_require__2(27030),
              TextStyle: __webpack_require__2(74744),
              TileSprite: __webpack_require__2(35856),
              Zone: __webpack_require__2(71030),
              Video: __webpack_require__2(8630),
              Shape: __webpack_require__2(91461),
              Arc: __webpack_require__2(28593),
              Curve: __webpack_require__2(15220),
              Ellipse: __webpack_require__2(28591),
              Grid: __webpack_require__2(39169),
              IsoBox: __webpack_require__2(4415),
              IsoTriangle: __webpack_require__2(65159),
              Line: __webpack_require__2(579),
              Polygon: __webpack_require__2(91249),
              Rectangle: __webpack_require__2(517),
              Star: __webpack_require__2(77843),
              Triangle: __webpack_require__2(21873),
              Factories: {
                Blitter: __webpack_require__2(38906),
                Container: __webpack_require__2(23400),
                DOMElement: __webpack_require__2(66788),
                DynamicBitmapText: __webpack_require__2(94145),
                Extern: __webpack_require__2(41155),
                Graphics: __webpack_require__2(13122),
                Group: __webpack_require__2(62598),
                Image: __webpack_require__2(20927),
                Layer: __webpack_require__2(17676),
                Particles: __webpack_require__2(81212),
                PathFollower: __webpack_require__2(19626),
                RenderTexture: __webpack_require__2(29599),
                Rope: __webpack_require__2(31982),
                Sprite: __webpack_require__2(66135),
                StaticBitmapText: __webpack_require__2(21797),
                Text: __webpack_require__2(94627),
                TileSprite: __webpack_require__2(20509),
                Zone: __webpack_require__2(34546),
                Video: __webpack_require__2(215),
                Arc: __webpack_require__2(10369),
                Curve: __webpack_require__2(10147),
                Ellipse: __webpack_require__2(99869),
                Grid: __webpack_require__2(9326),
                IsoBox: __webpack_require__2(88154),
                IsoTriangle: __webpack_require__2(67765),
                Line: __webpack_require__2(85665),
                Polygon: __webpack_require__2(88203),
                Rectangle: __webpack_require__2(94355),
                Star: __webpack_require__2(23962),
                Triangle: __webpack_require__2(79296)
              },
              Creators: {
                Blitter: __webpack_require__2(68452),
                Container: __webpack_require__2(44516),
                DynamicBitmapText: __webpack_require__2(67513),
                Graphics: __webpack_require__2(41286),
                Group: __webpack_require__2(61295),
                Image: __webpack_require__2(83556),
                Layer: __webpack_require__2(56378),
                Particles: __webpack_require__2(765),
                RenderTexture: __webpack_require__2(85692),
                Rope: __webpack_require__2(96027),
                Sprite: __webpack_require__2(89219),
                StaticBitmapText: __webpack_require__2(95499),
                Text: __webpack_require__2(75397),
                TileSprite: __webpack_require__2(63950),
                Zone: __webpack_require__2(24067),
                Video: __webpack_require__2(65601)
              }
            };
            if (true) {
              GameObjects.Shader = __webpack_require__2(27902);
              GameObjects.Mesh = __webpack_require__2(83321);
              GameObjects.NineSlice = __webpack_require__2(44139);
              GameObjects.PointLight = __webpack_require__2(13171);
              GameObjects.Plane = __webpack_require__2(33412);
              GameObjects.Factories.Shader = __webpack_require__2(51979);
              GameObjects.Factories.Mesh = __webpack_require__2(8767);
              GameObjects.Factories.NineSlice = __webpack_require__2(53778);
              GameObjects.Factories.PointLight = __webpack_require__2(91201);
              GameObjects.Factories.Plane = __webpack_require__2(58322);
              GameObjects.Creators.Shader = __webpack_require__2(13908);
              GameObjects.Creators.Mesh = __webpack_require__2(41839);
              GameObjects.Creators.NineSlice = __webpack_require__2(40964);
              GameObjects.Creators.PointLight = __webpack_require__2(162);
              GameObjects.Creators.Plane = __webpack_require__2(10912);
              GameObjects.Light = __webpack_require__2(14455);
              GameObjects.LightsManager = __webpack_require__2(26193);
              GameObjects.LightsPlugin = __webpack_require__2(50296);
            }
            module2.exports = GameObjects;
          },
          85305: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BlendModes = __webpack_require__2(95723);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var ComponentsToJSON = __webpack_require__2(48129);
            var DataManager = __webpack_require__2(81078);
            var EventEmitter = __webpack_require__2(6659);
            var GameObjectEvents = __webpack_require__2(56631);
            var List = __webpack_require__2(71207);
            var RemoveBetween = __webpack_require__2(47427);
            var Render = __webpack_require__2(58010);
            var SceneEvents = __webpack_require__2(7599);
            var StableSort = __webpack_require__2(17922);
            var Layer = new Class({
              Extends: List,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.PostPipeline,
                Components.Visible,
                EventEmitter,
                Render
              ],
              initialize: function Layer2(scene, children) {
                List.call(this, scene);
                EventEmitter.call(this);
                this.scene = scene;
                this.displayList = null;
                this.type = "Layer";
                this.state = 0;
                this.parentContainer = null;
                this.name = "";
                this.active = true;
                this.tabIndex = -1;
                this.data = null;
                this.renderFlags = 15;
                this.cameraFilter = 0;
                this.input = null;
                this.body = null;
                this.ignoreDestroy = false;
                this.systems = scene.sys;
                this.events = scene.sys.events;
                this.sortChildrenFlag = false;
                this.addCallback = this.addChildCallback;
                this.removeCallback = this.removeChildCallback;
                this.initPostPipeline();
                this.clearAlpha();
                this.setBlendMode(BlendModes.SKIP_CHECK);
                if (children) {
                  this.add(children);
                }
                scene.sys.queueDepthSort();
              },
              setActive: function(value) {
                this.active = value;
                return this;
              },
              setName: function(value) {
                this.name = value;
                return this;
              },
              setState: function(value) {
                this.state = value;
                return this;
              },
              setDataEnabled: function() {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                return this;
              },
              setData: function(key, value) {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                this.data.set(key, value);
                return this;
              },
              incData: function(key, value) {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                this.data.inc(key, value);
                return this;
              },
              toggleData: function(key) {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                this.data.toggle(key);
                return this;
              },
              getData: function(key) {
                if (!this.data) {
                  this.data = new DataManager(this);
                }
                return this.data.get(key);
              },
              setInteractive: function() {
                return this;
              },
              disableInteractive: function() {
                return this;
              },
              removeInteractive: function() {
                return this;
              },
              add: function(child) {
                List.prototype.add.call(this, child);
                return this;
              },
              remove: function(child, destroyChild) {
                var removed = List.prototype.remove.call(this, child);
                if (destroyChild && removed) {
                  if (!Array.isArray(removed)) {
                    removed = [removed];
                  }
                  for (var i = 0; i < removed.length; i++) {
                    removed[i].destroy();
                  }
                }
                return this;
              },
              removeAll: function(destroyChild) {
                var list = this.list;
                if (destroyChild) {
                  for (var i = 0; i < list.length; i++) {
                    if (list[i] && list[i].scene) {
                      list[i].off(GameObjectEvents.DESTROY, this.remove, this);
                      list[i].destroy();
                    }
                  }
                  this.list = [];
                } else {
                  RemoveBetween(list, 0, list.length, this.removeChildCallback, this);
                }
                return this;
              },
              addedToScene: function() {
              },
              removedFromScene: function() {
              },
              update: function() {
              },
              toJSON: function() {
                return ComponentsToJSON(this);
              },
              willRender: function(camera) {
                return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
              },
              getIndexList: function() {
                var child = this;
                var parent = this.parentContainer;
                var indexes = [];
                while (parent) {
                  indexes.unshift(parent.getIndex(child));
                  child = parent;
                  if (!parent.parentContainer) {
                    break;
                  } else {
                    parent = parent.parentContainer;
                  }
                }
                indexes.unshift(this.displayList.getIndex(child));
                return indexes;
              },
              addChildCallback: function(gameObject) {
                gameObject.once(GameObjectEvents.DESTROY, this.remove, this);
                if (gameObject.displayList && gameObject.displayList !== this) {
                  gameObject.removeFromDisplayList();
                }
                if (!gameObject.displayList) {
                  this.queueDepthSort();
                  gameObject.displayList = this;
                  gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
                  this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
                }
              },
              removeChildCallback: function(gameObject) {
                gameObject.off(GameObjectEvents.DESTROY, this.remove, this);
                this.queueDepthSort();
                gameObject.displayList = null;
                gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
                this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
              },
              queueDepthSort: function() {
                this.sortChildrenFlag = true;
              },
              depthSort: function() {
                if (this.sortChildrenFlag) {
                  StableSort(this.list, this.sortByDepth);
                  this.sortChildrenFlag = false;
                }
              },
              sortByDepth: function(childA, childB) {
                return childA._depth - childB._depth;
              },
              getChildren: function() {
                return this.list;
              },
              addToDisplayList: function(displayList) {
                if (displayList === void 0) {
                  displayList = this.scene.sys.displayList;
                }
                if (this.displayList && this.displayList !== displayList) {
                  this.removeFromDisplayList();
                }
                if (!displayList.exists(this)) {
                  this.displayList = displayList;
                  displayList.add(this, true);
                  displayList.queueDepthSort();
                  this.emit(GameObjectEvents.ADDED_TO_SCENE, this, this.scene);
                  displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);
                }
                return this;
              },
              removeFromDisplayList: function() {
                var displayList = this.displayList || this.scene.sys.displayList;
                if (displayList.exists(this)) {
                  displayList.remove(this, true);
                  displayList.queueDepthSort();
                  this.displayList = null;
                  this.emit(GameObjectEvents.REMOVED_FROM_SCENE, this, this.scene);
                  displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);
                }
                return this;
              },
              destroy: function(fromScene) {
                if (!this.scene || this.ignoreDestroy) {
                  return;
                }
                this.emit(GameObjectEvents.DESTROY, this);
                var list = this.list;
                while (list.length) {
                  list[0].destroy(fromScene);
                }
                this.removeAllListeners();
                this.resetPostPipeline(true);
                if (this.displayList) {
                  this.displayList.remove(this, true);
                  this.displayList.queueDepthSort();
                }
                if (this.data) {
                  this.data.destroy();
                  this.data = void 0;
                }
                this.active = false;
                this.visible = false;
                this.list = void 0;
                this.scene = void 0;
                this.displayList = void 0;
                this.systems = void 0;
                this.events = void 0;
              }
            });
            module2.exports = Layer;
          },
          834: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LayerCanvasRenderer = function(renderer, layer, camera) {
              var children = layer.list;
              if (children.length === 0) {
                return;
              }
              layer.depthSort();
              var layerHasBlendMode = layer.blendMode !== -1;
              if (!layerHasBlendMode) {
                renderer.setBlendMode(0);
              }
              var alpha = layer._alpha;
              if (layer.mask) {
                layer.mask.preRenderCanvas(renderer, null, camera);
              }
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (!child.willRender(camera)) {
                  continue;
                }
                var childAlpha = child.alpha;
                if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                  renderer.setBlendMode(child.blendMode);
                }
                child.setAlpha(childAlpha * alpha);
                child.renderCanvas(renderer, child, camera);
                child.setAlpha(childAlpha);
              }
              if (layer.mask) {
                layer.mask.postRenderCanvas(renderer);
              }
            };
            module2.exports = LayerCanvasRenderer;
          },
          56378: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var Layer = __webpack_require__2(85305);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            GameObjectCreator.register("layer", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var children = GetAdvancedValue(config2, "children", null);
              var layer = new Layer(this.scene, children);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, layer, config2);
              return layer;
            });
          },
          17676: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Layer = __webpack_require__2(85305);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("layer", function(children) {
              return this.displayList.add(new Layer(this.scene, children));
            });
          },
          58010: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(17576);
            }
            if (true) {
              renderCanvas = __webpack_require__2(834);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          17576: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LayerWebGLRenderer = function(renderer, layer, camera) {
              var children = layer.list;
              var childCount = children.length;
              if (childCount === 0) {
                return;
              }
              layer.depthSort();
              renderer.pipelines.preBatch(layer);
              var layerHasBlendMode = layer.blendMode !== -1;
              if (!layerHasBlendMode) {
                renderer.setBlendMode(0);
              }
              var alpha = layer.alpha;
              for (var i = 0; i < childCount; i++) {
                var child = children[i];
                if (!child.willRender(camera)) {
                  continue;
                }
                var childAlphaTopLeft;
                var childAlphaTopRight;
                var childAlphaBottomLeft;
                var childAlphaBottomRight;
                if (child.alphaTopLeft !== void 0) {
                  childAlphaTopLeft = child.alphaTopLeft;
                  childAlphaTopRight = child.alphaTopRight;
                  childAlphaBottomLeft = child.alphaBottomLeft;
                  childAlphaBottomRight = child.alphaBottomRight;
                } else {
                  var childAlpha = child.alpha;
                  childAlphaTopLeft = childAlpha;
                  childAlphaTopRight = childAlpha;
                  childAlphaBottomLeft = childAlpha;
                  childAlphaBottomRight = childAlpha;
                }
                if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                  renderer.setBlendMode(child.blendMode);
                }
                var mask = child.mask;
                if (mask) {
                  mask.preRenderWebGL(renderer, child, camera);
                }
                var type = child.type;
                if (type !== renderer.currentType) {
                  renderer.newType = true;
                  renderer.currentType = type;
                }
                renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
                child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
                child.renderWebGL(renderer, child, camera);
                child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
                if (mask) {
                  mask.postRenderWebGL(renderer, camera);
                }
                renderer.newType = false;
              }
              renderer.pipelines.postBatch(layer);
            };
            module2.exports = LayerWebGLRenderer;
          },
          14455: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circle = __webpack_require__2(26673);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var RGB = __webpack_require__2(39298);
            var Utils = __webpack_require__2(75512);
            var Light = new Class({
              Extends: Circle,
              Mixins: [
                Components.Origin,
                Components.ScrollFactor,
                Components.Transform,
                Components.Visible
              ],
              initialize: function Light2(x, y, radius, r, g, b, intensity) {
                Circle.call(this, x, y, radius);
                this.color = new RGB(r, g, b);
                this.intensity = intensity;
                this.renderFlags = 15;
                this.cameraFilter = 0;
                this.setScrollFactor(1, 1);
                this.setOrigin();
                this.setDisplayOrigin(radius);
              },
              displayWidth: {
                get: function() {
                  return this.diameter;
                },
                set: function(value) {
                  this.diameter = value;
                }
              },
              displayHeight: {
                get: function() {
                  return this.diameter;
                },
                set: function(value) {
                  this.diameter = value;
                }
              },
              width: {
                get: function() {
                  return this.diameter;
                },
                set: function(value) {
                  this.diameter = value;
                }
              },
              height: {
                get: function() {
                  return this.diameter;
                },
                set: function(value) {
                  this.diameter = value;
                }
              },
              willRender: function(camera) {
                return !(Light.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
              },
              setColor: function(rgb) {
                var color = Utils.getFloatsFromUintRGB(rgb);
                this.color.set(color[0], color[1], color[2]);
                return this;
              },
              setIntensity: function(intensity) {
                this.intensity = intensity;
                return this;
              },
              setRadius: function(radius) {
                this.radius = radius;
                return this;
              }
            });
            Light.RENDER_MASK = 15;
            module2.exports = Light;
          },
          26193: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CircleToRectangle = __webpack_require__2(26535);
            var Class = __webpack_require__2(56694);
            var DistanceBetween = __webpack_require__2(53996);
            var Light = __webpack_require__2(14455);
            var PointLight = __webpack_require__2(13171);
            var RGB = __webpack_require__2(39298);
            var SpliceOne = __webpack_require__2(72677);
            var StableSort = __webpack_require__2(17922);
            var Utils = __webpack_require__2(75512);
            var LightsManager = new Class({
              initialize: function LightsManager2() {
                this.lights = [];
                this.ambientColor = new RGB(0.1, 0.1, 0.1);
                this.active = false;
                this.maxLights = -1;
                this.visibleLights = 0;
              },
              addPointLight: function(x, y, color, radius, intensity, attenuation) {
                return this.systems.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
              },
              enable: function() {
                if (this.maxLights === -1) {
                  this.maxLights = this.systems.renderer.config.maxLights;
                }
                this.active = true;
                return this;
              },
              disable: function() {
                this.active = false;
                return this;
              },
              getLights: function(camera) {
                var lights = this.lights;
                var worldView = camera.worldView;
                var visibleLights = [];
                for (var i = 0; i < lights.length; i++) {
                  var light = lights[i];
                  if (light.willRender(camera) && CircleToRectangle(light, worldView)) {
                    visibleLights.push({
                      light,
                      distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)
                    });
                  }
                }
                if (visibleLights.length > this.maxLights) {
                  StableSort(visibleLights, this.sortByDistance);
                  visibleLights = visibleLights.slice(0, this.maxLights);
                }
                this.visibleLights = visibleLights.length;
                return visibleLights;
              },
              sortByDistance: function(a, b) {
                return a.distance >= b.distance;
              },
              setAmbientColor: function(rgb) {
                var color = Utils.getFloatsFromUintRGB(rgb);
                this.ambientColor.set(color[0], color[1], color[2]);
                return this;
              },
              getMaxVisibleLights: function() {
                return this.maxLights;
              },
              getLightCount: function() {
                return this.lights.length;
              },
              addLight: function(x, y, radius, rgb, intensity) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (radius === void 0) {
                  radius = 128;
                }
                if (rgb === void 0) {
                  rgb = 16777215;
                }
                if (intensity === void 0) {
                  intensity = 1;
                }
                var color = Utils.getFloatsFromUintRGB(rgb);
                var light = new Light(x, y, radius, color[0], color[1], color[2], intensity);
                this.lights.push(light);
                return light;
              },
              removeLight: function(light) {
                var index = this.lights.indexOf(light);
                if (index >= 0) {
                  SpliceOne(this.lights, index);
                }
                return this;
              },
              shutdown: function() {
                this.lights.length = 0;
              },
              destroy: function() {
                this.shutdown();
              }
            });
            module2.exports = LightsManager;
          },
          50296: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var LightsManager = __webpack_require__2(26193);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var LightsPlugin = new Class({
              Extends: LightsManager,
              initialize: function LightsPlugin2(scene) {
                this.scene = scene;
                this.systems = scene.sys;
                if (!scene.sys.settings.isBooted) {
                  scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                }
                LightsManager.call(this);
              },
              boot: function() {
                var eventEmitter = this.systems.events;
                eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this);
                eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);
              },
              destroy: function() {
                this.shutdown();
                this.scene = void 0;
                this.systems = void 0;
              }
            });
            PluginCache.register("LightsPlugin", LightsPlugin, "lights");
            module2.exports = LightsPlugin;
          },
          83321: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var DegToRad = __webpack_require__2(75606);
            var Face = __webpack_require__2(18693);
            var GameObject = __webpack_require__2(89980);
            var GenerateObjVerts = __webpack_require__2(53267);
            var GenerateVerts = __webpack_require__2(67623);
            var GetCalcMatrix = __webpack_require__2(73329);
            var Matrix4 = __webpack_require__2(16650);
            var MeshRender = __webpack_require__2(23464);
            var RadToDeg = __webpack_require__2(23701);
            var StableSort = __webpack_require__2(17922);
            var Vector3 = __webpack_require__2(70015);
            var Vertex = __webpack_require__2(85769);
            var Mesh = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Size,
                Components.Texture,
                Components.Transform,
                Components.Visible,
                MeshRender
              ],
              initialize: function Mesh2(scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (texture === void 0) {
                  texture = "__WHITE";
                }
                GameObject.call(this, scene, "Mesh");
                this.faces = [];
                this.vertices = [];
                this.tintFill = false;
                this.debugCallback = null;
                this.debugGraphic = null;
                this.hideCCW = true;
                this.modelPosition = new Vector3();
                this.modelScale = new Vector3(1, 1, 1);
                this.modelRotation = new Vector3();
                this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                this.transformMatrix = new Matrix4();
                this.viewPosition = new Vector3();
                this.viewMatrix = new Matrix4();
                this.projectionMatrix = new Matrix4();
                this.totalRendered = 0;
                this.totalFrame = 0;
                this.ignoreDirtyCache = false;
                this.fov;
                this.displayOriginX = 0;
                this.displayOriginY = 0;
                var renderer = scene.sys.renderer;
                this.setPosition(x, y);
                this.setTexture(texture, frame);
                this.setSize(renderer.width, renderer.height);
                this.initPipeline();
                this.initPostPipeline();
                this.setPerspective(renderer.width, renderer.height);
                if (vertices) {
                  this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);
                }
              },
              addedToScene: function() {
                this.scene.sys.updateList.add(this);
              },
              removedFromScene: function() {
                this.scene.sys.updateList.remove(this);
              },
              panX: function(v) {
                this.viewPosition.addScale(Vector3.LEFT, v);
                this.dirtyCache[10] = 1;
                return this;
              },
              panY: function(v) {
                this.viewPosition.y += Vector3.DOWN.y * v;
                this.dirtyCache[10] = 1;
                return this;
              },
              panZ: function(amount) {
                this.viewPosition.z += amount;
                this.dirtyCache[10] = 1;
                return this;
              },
              setPerspective: function(width, height, fov, near, far) {
                if (fov === void 0) {
                  fov = 45;
                }
                if (near === void 0) {
                  near = 0.01;
                }
                if (far === void 0) {
                  far = 1e3;
                }
                this.fov = fov;
                this.projectionMatrix.perspective(DegToRad(fov), width / height, near, far);
                this.dirtyCache[10] = 1;
                this.dirtyCache[11] = 0;
                return this;
              },
              setOrtho: function(scaleX, scaleY, near, far) {
                if (scaleX === void 0) {
                  scaleX = this.scene.sys.renderer.getAspectRatio();
                }
                if (scaleY === void 0) {
                  scaleY = 1;
                }
                if (near === void 0) {
                  near = -1e3;
                }
                if (far === void 0) {
                  far = 1e3;
                }
                this.fov = 0;
                this.projectionMatrix.ortho(-scaleX, scaleX, -scaleY, scaleY, near, far);
                this.dirtyCache[10] = 1;
                this.dirtyCache[11] = 1;
                return this;
              },
              clear: function() {
                this.faces.forEach(function(face) {
                  face.destroy();
                });
                this.faces = [];
                this.vertices = [];
                return this;
              },
              addVerticesFromObj: function(key, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
                var data = this.scene.sys.cache.obj.get(key);
                var parsedData;
                if (data) {
                  parsedData = GenerateObjVerts(data, this, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp);
                }
                if (!parsedData || parsedData.verts.length === 0) {
                  console.warn("Mesh.addVerticesFromObj data empty:", key);
                }
                return this;
              },
              sortByDepth: function(faceA, faceB) {
                return faceA.depth - faceB.depth;
              },
              depthSort: function() {
                StableSort(this.faces, this.sortByDepth);
                return this;
              },
              addVertex: function(x, y, z, u, v, color, alpha) {
                var vert = new Vertex(x, y, z, u, v, color, alpha);
                this.vertices.push(vert);
                return vert;
              },
              addFace: function(vertex1, vertex2, vertex3) {
                var face = new Face(vertex1, vertex2, vertex3);
                this.faces.push(face);
                this.dirtyCache[9] = -1;
                return face;
              },
              addVertices: function(vertices, uvs, indicies, containsZ, normals, colors, alphas) {
                var result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, alphas);
                if (result) {
                  this.faces = this.faces.concat(result.faces);
                  this.vertices = this.vertices.concat(result.vertices);
                } else {
                  console.warn("Mesh.addVertices data empty or invalid");
                }
                this.dirtyCache[9] = -1;
                return this;
              },
              getFaceCount: function() {
                return this.faces.length;
              },
              getVertexCount: function() {
                return this.vertices.length;
              },
              getFace: function(index) {
                return this.faces[index];
              },
              hasFaceAt: function(x, y, camera) {
                if (camera === void 0) {
                  camera = this.scene.sys.cameras.main;
                }
                var calcMatrix = GetCalcMatrix(this, camera).calc;
                var faces = this.faces;
                for (var i = 0; i < faces.length; i++) {
                  var face = faces[i];
                  if (face.contains(x, y, calcMatrix)) {
                    return true;
                  }
                }
                return false;
              },
              getFaceAt: function(x, y, camera) {
                if (camera === void 0) {
                  camera = this.scene.sys.cameras.main;
                }
                var calcMatrix = GetCalcMatrix(this, camera).calc;
                var faces = this.faces;
                var results = [];
                for (var i = 0; i < faces.length; i++) {
                  var face = faces[i];
                  if (face.contains(x, y, calcMatrix)) {
                    results.push(face);
                  }
                }
                return StableSort(results, this.sortByDepth);
              },
              setDebug: function(graphic, callback) {
                this.debugGraphic = graphic;
                if (!graphic && !callback) {
                  this.debugCallback = null;
                } else if (!callback) {
                  this.debugCallback = this.renderDebug;
                } else {
                  this.debugCallback = callback;
                }
                return this;
              },
              isDirty: function() {
                var position = this.modelPosition;
                var rotation = this.modelRotation;
                var scale = this.modelScale;
                var dirtyCache = this.dirtyCache;
                var px = position.x;
                var py = position.y;
                var pz = position.z;
                var rx = rotation.x;
                var ry = rotation.y;
                var rz = rotation.z;
                var sx = scale.x;
                var sy = scale.y;
                var sz = scale.z;
                var faces = this.getFaceCount();
                var pxCached = dirtyCache[0];
                var pyCached = dirtyCache[1];
                var pzCached = dirtyCache[2];
                var rxCached = dirtyCache[3];
                var ryCached = dirtyCache[4];
                var rzCached = dirtyCache[5];
                var sxCached = dirtyCache[6];
                var syCached = dirtyCache[7];
                var szCached = dirtyCache[8];
                var fCached = dirtyCache[9];
                dirtyCache[0] = px;
                dirtyCache[1] = py;
                dirtyCache[2] = pz;
                dirtyCache[3] = rx;
                dirtyCache[4] = ry;
                dirtyCache[5] = rz;
                dirtyCache[6] = sx;
                dirtyCache[7] = sy;
                dirtyCache[8] = sz;
                dirtyCache[9] = faces;
                return pxCached !== px || pyCached !== py || pzCached !== pz || rxCached !== rx || ryCached !== ry || rzCached !== rz || sxCached !== sx || syCached !== sy || szCached !== sz || fCached !== faces;
              },
              preUpdate: function() {
                this.totalRendered = this.totalFrame;
                this.totalFrame = 0;
                var dirty = this.dirtyCache;
                if (!this.ignoreDirtyCache && !dirty[10] && !this.isDirty()) {
                  return;
                }
                var width = this.width;
                var height = this.height;
                var viewMatrix = this.viewMatrix;
                var viewPosition = this.viewPosition;
                if (dirty[10]) {
                  viewMatrix.identity();
                  viewMatrix.translate(viewPosition);
                  viewMatrix.invert();
                  dirty[10] = 0;
                }
                var transformMatrix = this.transformMatrix;
                transformMatrix.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix);
                var z = viewPosition.z;
                var faces = this.faces;
                for (var i = 0; i < faces.length; i++) {
                  faces[i].transformCoordinatesLocal(transformMatrix, width, height, z);
                }
                this.depthSort();
              },
              renderDebug: function(src, faces) {
                var graphic = src.debugGraphic;
                for (var i = 0; i < faces.length; i++) {
                  var face = faces[i];
                  var x0 = face.vertex1.tx;
                  var y0 = face.vertex1.ty;
                  var x1 = face.vertex2.tx;
                  var y1 = face.vertex2.ty;
                  var x2 = face.vertex3.tx;
                  var y2 = face.vertex3.ty;
                  graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);
                }
              },
              preDestroy: function() {
                this.clear();
                this.debugCallback = null;
                this.debugGraphic = null;
              },
              clearTint: function() {
                return this.setTint();
              },
              setInteractive: function() {
                var hitAreaCallback = function(area, x, y) {
                  var faces = this.faces;
                  for (var i = 0; i < faces.length; i++) {
                    var face = faces[i];
                    if (face.contains(x, y)) {
                      return true;
                    }
                  }
                  return false;
                }.bind(this);
                this.scene.sys.input.enable(this, hitAreaCallback);
                return this;
              },
              setTint: function(tint) {
                if (tint === void 0) {
                  tint = 16777215;
                }
                var vertices = this.vertices;
                for (var i = 0; i < vertices.length; i++) {
                  vertices[i].color = tint;
                }
                return this;
              },
              uvScroll: function(x, y) {
                var faces = this.faces;
                for (var i = 0; i < faces.length; i++) {
                  faces[i].scrollUV(x, y);
                }
                return this;
              },
              uvScale: function(x, y) {
                var faces = this.faces;
                for (var i = 0; i < faces.length; i++) {
                  faces[i].scaleUV(x, y);
                }
                return this;
              },
              tint: {
                set: function(value) {
                  this.setTint(value);
                }
              },
              rotateX: {
                get: function() {
                  return RadToDeg(this.modelRotation.x);
                },
                set: function(value) {
                  this.modelRotation.x = DegToRad(value);
                }
              },
              rotateY: {
                get: function() {
                  return RadToDeg(this.modelRotation.y);
                },
                set: function(value) {
                  this.modelRotation.y = DegToRad(value);
                }
              },
              rotateZ: {
                get: function() {
                  return RadToDeg(this.modelRotation.z);
                },
                set: function(value) {
                  this.modelRotation.z = DegToRad(value);
                }
              }
            });
            module2.exports = Mesh;
          },
          6317: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MeshCanvasRenderer = function() {
            };
            module2.exports = MeshCanvasRenderer;
          },
          41839: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetValue = __webpack_require__2(10850);
            var Mesh = __webpack_require__2(83321);
            GameObjectCreator.register("mesh", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var frame = GetAdvancedValue(config2, "frame", null);
              var vertices = GetValue(config2, "vertices", []);
              var uvs = GetValue(config2, "uvs", []);
              var indicies = GetValue(config2, "indicies", []);
              var containsZ = GetValue(config2, "containsZ", false);
              var normals = GetValue(config2, "normals", []);
              var colors = GetValue(config2, "colors", 16777215);
              var alphas = GetValue(config2, "alphas", 1);
              var mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, mesh, config2);
              return mesh;
            });
          },
          8767: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Mesh = __webpack_require__2(83321);
            var GameObjectFactory = __webpack_require__2(61286);
            if (true) {
              GameObjectFactory.register("mesh", function(x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
                return this.displayList.add(new Mesh(this.scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));
              });
            }
          },
          23464: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(57410);
            }
            if (true) {
              renderCanvas = __webpack_require__2(6317);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          57410: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var MeshWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              var faces = src.faces;
              var totalFaces = faces.length;
              if (totalFaces === 0) {
                return;
              }
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              renderer.pipelines.preBatch(src);
              var textureUnit = pipeline.setGameObject(src);
              var F32 = pipeline.vertexViewF32;
              var U32 = pipeline.vertexViewU32;
              var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
              var tintEffect = src.tintFill;
              var debugFaces = [];
              var debugCallback = src.debugCallback;
              var a = calcMatrix.a;
              var b = calcMatrix.b;
              var c = calcMatrix.c;
              var d = calcMatrix.d;
              var e = calcMatrix.e;
              var f = calcMatrix.f;
              var z = src.viewPosition.z;
              var hideCCW = src.hideCCW;
              var roundPixels = camera.roundPixels;
              var alpha = camera.alpha * src.alpha;
              var totalFacesRendered = 0;
              for (var i = 0; i < totalFaces; i++) {
                var face = faces[i];
                if (!face.isInView(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels)) {
                  continue;
                }
                if (pipeline.shouldFlush(3)) {
                  pipeline.flush();
                  textureUnit = pipeline.setGameObject(src);
                  vertexOffset = 0;
                }
                vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect);
                totalFacesRendered++;
                pipeline.vertexCount += 3;
                pipeline.currentBatch.count = pipeline.vertexCount - pipeline.currentBatch.start;
                if (debugCallback) {
                  debugFaces.push(face);
                }
              }
              src.totalFrame += totalFacesRendered;
              if (debugCallback) {
                debugCallback.call(src, src, debugFaces);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = MeshWebGLRenderer;
          },
          44139: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var NineSliceRender = __webpack_require__2(94456);
            var Vertex = __webpack_require__2(85769);
            var NineSlice = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Texture,
                Components.Transform,
                Components.Visible,
                NineSliceRender
              ],
              initialize: function NineSlice2(scene, x, y, texture, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight) {
                GameObject.call(this, scene, "NineSlice");
                this._width;
                this._height;
                this._originX = 0.5;
                this._originY = 0.5;
                this._sizeComponent = true;
                this.vertices = [];
                this.leftWidth;
                this.rightWidth;
                this.topHeight;
                this.bottomHeight;
                this.tint = 16777215;
                this.tintFill = false;
                var textureFrame = scene.textures.getFrame(texture, frame);
                this.is3Slice = !topHeight && !bottomHeight;
                if (textureFrame.scale9) {
                  this.is3Slice = textureFrame.is3Slice;
                }
                var size = this.is3Slice ? 18 : 54;
                for (var i = 0; i < size; i++) {
                  this.vertices.push(new Vertex());
                }
                this.setPosition(x, y);
                this.setTexture(texture, frame);
                this.setSlices(width, height, leftWidth, rightWidth, topHeight, bottomHeight, false);
                this.setOrigin(0.5, 0.5);
                this.initPipeline();
                this.initPostPipeline();
              },
              setSlices: function(width, height, leftWidth, rightWidth, topHeight, bottomHeight, skipScale9) {
                if (leftWidth === void 0) {
                  leftWidth = 10;
                }
                if (rightWidth === void 0) {
                  rightWidth = 10;
                }
                if (topHeight === void 0) {
                  topHeight = 0;
                }
                if (bottomHeight === void 0) {
                  bottomHeight = 0;
                }
                if (skipScale9 === void 0) {
                  skipScale9 = false;
                }
                var frame = this.frame;
                var sliceChange = false;
                if (this.is3Slice && skipScale9 && topHeight !== 0 && bottomHeight !== 0) {
                  sliceChange = true;
                }
                if (sliceChange) {
                  console.warn("Cannot change 9 slice to 3 slice");
                } else {
                  if (frame.scale9 && !skipScale9) {
                    var data = frame.data.scale9Borders;
                    var x = data.x;
                    var y = data.y;
                    leftWidth = x;
                    rightWidth = frame.width - data.w - x;
                    topHeight = y;
                    bottomHeight = frame.height - data.h - y;
                    if (width === void 0) {
                      width = frame.width;
                    }
                    if (height === void 0) {
                      height = frame.height;
                    }
                  } else {
                    if (width === void 0) {
                      width = 256;
                    }
                    if (height === void 0) {
                      height = 256;
                    }
                  }
                  this._width = width;
                  this._height = height;
                  this.leftWidth = leftWidth;
                  this.rightWidth = rightWidth;
                  this.topHeight = topHeight;
                  this.bottomHeight = bottomHeight;
                  if (this.is3Slice) {
                    height = frame.height;
                    this._height = height;
                    this.topHeight = height;
                    this.bottomHeight = 0;
                  }
                  this.updateVertices();
                  this.updateUVs();
                }
                return this;
              },
              updateUVs: function() {
                var left = this.leftWidth;
                var right = this.rightWidth;
                var top = this.topHeight;
                var bot = this.bottomHeight;
                var width = this.frame.width;
                var height = this.frame.height;
                this.updateQuadUVs(0, 0, 0, left / width, top / height);
                this.updateQuadUVs(6, left / width, 0, 1 - right / width, top / height);
                this.updateQuadUVs(12, 1 - right / width, 0, 1, top / height);
                if (!this.is3Slice) {
                  this.updateQuadUVs(18, 0, top / height, left / width, 1 - bot / height);
                  this.updateQuadUVs(24, left / width, top / height, 1 - right / width, 1 - bot / height);
                  this.updateQuadUVs(30, 1 - right / width, top / height, 1, 1 - bot / height);
                  this.updateQuadUVs(36, 0, 1 - bot / height, left / width, 1);
                  this.updateQuadUVs(42, left / width, 1 - bot / height, 1 - right / width, 1);
                  this.updateQuadUVs(48, 1 - right / width, 1 - bot / height, 1, 1);
                }
              },
              updateVertices: function() {
                var left = this.leftWidth;
                var right = this.rightWidth;
                var top = this.topHeight;
                var bot = this.bottomHeight;
                var width = this.width;
                var height = this.height;
                this.updateQuad(0, -0.5, 0.5, -0.5 + left / width, 0.5 - top / height);
                this.updateQuad(6, -0.5 + left / width, 0.5, 0.5 - right / width, 0.5 - top / height);
                this.updateQuad(12, 0.5 - right / width, 0.5, 0.5, 0.5 - top / height);
                if (!this.is3Slice) {
                  this.updateQuad(18, -0.5, 0.5 - top / height, -0.5 + left / width, -0.5 + bot / height);
                  this.updateQuad(24, -0.5 + left / width, 0.5 - top / height, 0.5 - right / width, -0.5 + bot / height);
                  this.updateQuad(30, 0.5 - right / width, 0.5 - top / height, 0.5, -0.5 + bot / height);
                  this.updateQuad(36, -0.5, -0.5 + bot / height, -0.5 + left / width, -0.5);
                  this.updateQuad(42, -0.5 + left / width, -0.5 + bot / height, 0.5 - right / width, -0.5);
                  this.updateQuad(48, 0.5 - right / width, -0.5 + bot / height, 0.5, -0.5);
                }
              },
              updateQuad: function(offset, x1, y1, x2, y2) {
                var width = this.width;
                var height = this.height;
                var originX = this.originX;
                var originY = this.originY;
                var verts = this.vertices;
                verts[offset + 0].resize(x1, y1, width, height, originX, originY);
                verts[offset + 1].resize(x1, y2, width, height, originX, originY);
                verts[offset + 2].resize(x2, y1, width, height, originX, originY);
                verts[offset + 3].resize(x1, y2, width, height, originX, originY);
                verts[offset + 4].resize(x2, y2, width, height, originX, originY);
                verts[offset + 5].resize(x2, y1, width, height, originX, originY);
              },
              updateQuadUVs: function(offset, u1, v1, u2, v2) {
                var verts = this.vertices;
                var frame = this.frame;
                var fu1 = frame.u0;
                var fv1 = frame.v0;
                var fu2 = frame.u1;
                var fv2 = frame.v1;
                if (fu1 !== 0 || fu2 !== 1) {
                  var udiff = fu2 - fu1;
                  u1 = fu1 + u1 * udiff;
                  u2 = fu1 + u2 * udiff;
                }
                if (fv1 !== 0 || fv2 !== 1) {
                  var vdiff = fv2 - fv1;
                  v1 = fv1 + v1 * vdiff;
                  v2 = fv1 + v2 * vdiff;
                }
                verts[offset + 0].setUVs(u1, v1);
                verts[offset + 1].setUVs(u1, v2);
                verts[offset + 2].setUVs(u2, v1);
                verts[offset + 3].setUVs(u1, v2);
                verts[offset + 4].setUVs(u2, v2);
                verts[offset + 5].setUVs(u2, v1);
              },
              clearTint: function() {
                this.setTint(16777215);
                return this;
              },
              setTint: function(color) {
                if (color === void 0) {
                  color = 16777215;
                }
                this.tint = color;
                this.tintFill = false;
                return this;
              },
              setTintFill: function(color) {
                this.setTint(color);
                this.tintFill = true;
                return this;
              },
              isTinted: {
                get: function() {
                  return this.tint !== 16777215;
                }
              },
              width: {
                get: function() {
                  return this._width;
                },
                set: function(value) {
                  this._width = Math.max(value, this.leftWidth + this.rightWidth);
                  this.updateVertices();
                }
              },
              height: {
                get: function() {
                  return this._height;
                },
                set: function(value) {
                  if (!this.is3Slice) {
                    this._height = Math.max(value, this.topHeight + this.bottomHeight);
                    this.updateVertices();
                  }
                }
              },
              displayWidth: {
                get: function() {
                  return this.scaleX * this.width;
                },
                set: function(value) {
                  this.scaleX = value / this.width;
                }
              },
              displayHeight: {
                get: function() {
                  return this.scaleY * this.height;
                },
                set: function(value) {
                  this.scaleY = value / this.height;
                }
              },
              setSize: function(width, height) {
                this.width = width;
                this.height = height;
                var input = this.input;
                if (input && !input.customHitArea) {
                  input.hitArea.width = this.width;
                  input.hitArea.height = this.height;
                }
                return this;
              },
              setDisplaySize: function(width, height) {
                this.displayWidth = width;
                this.displayHeight = height;
                return this;
              },
              originX: {
                get: function() {
                  return this._originX;
                },
                set: function(value) {
                  this._originX = value;
                  this.updateVertices();
                }
              },
              originY: {
                get: function() {
                  return this._originY;
                },
                set: function(value) {
                  this._originY = value;
                  this.updateVertices();
                }
              },
              setOrigin: function(x, y) {
                if (x === void 0) {
                  x = 0.5;
                }
                if (y === void 0) {
                  y = x;
                }
                this._originX = x;
                this._originY = y;
                this.updateVertices();
                return this.updateDisplayOrigin();
              },
              setSizeToFrame: function() {
                if (this.is3Slice) {
                  var height = this.frame.height;
                  this._height = height;
                  this.topHeight = height;
                  this.bottomHeight = 0;
                }
                this.updateUVs();
                return this;
              },
              preDestroy: function() {
                this.vertices = [];
              }
            });
            module2.exports = NineSlice;
          },
          40964: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetValue = __webpack_require__2(10850);
            var NineSlice = __webpack_require__2(44139);
            GameObjectCreator.register("nineslice", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var frame = GetAdvancedValue(config2, "frame", null);
              var width = GetValue(config2, "width", 256);
              var height = GetValue(config2, "height", 256);
              var leftWidth = GetValue(config2, "leftWidth", 10);
              var rightWidth = GetValue(config2, "rightWidth", 10);
              var topHeight = GetValue(config2, "topHeight", 0);
              var bottomHeight = GetValue(config2, "bottomHeight", 0);
              var nineslice = new NineSlice(this.scene, 0, 0, key, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, nineslice, config2);
              return nineslice;
            });
          },
          53778: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NineSlice = __webpack_require__2(44139);
            var GameObjectFactory = __webpack_require__2(61286);
            if (true) {
              GameObjectFactory.register("nineslice", function(x, y, texture, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight) {
                return this.displayList.add(new NineSlice(this.scene, x, y, texture, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight));
              });
            }
          },
          94456: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(27420);
            }
            if (true) {
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          27420: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var Utils = __webpack_require__2(75512);
            var NineSliceWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              var verts = src.vertices;
              var totalVerts = verts.length;
              if (totalVerts === 0) {
                return;
              }
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix, false).calc;
              renderer.pipelines.preBatch(src);
              var textureUnit = pipeline.setGameObject(src);
              var F32 = pipeline.vertexViewF32;
              var U32 = pipeline.vertexViewU32;
              var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
              var roundPixels = camera.roundPixels;
              var tintEffect = src.tintFill;
              var alpha = camera.alpha * src.alpha;
              var color = Utils.getTintAppendFloatAlpha(src.tint, alpha);
              var available = pipeline.vertexAvailable();
              var flushCount = -1;
              if (available < totalVerts) {
                flushCount = available;
              }
              for (var i = 0; i < totalVerts; i++) {
                var vert = verts[i];
                if (i === flushCount) {
                  pipeline.flush();
                  textureUnit = pipeline.setGameObject(src);
                  vertexOffset = 0;
                }
                F32[++vertexOffset] = calcMatrix.getXRound(vert.vx, vert.vy, roundPixels);
                F32[++vertexOffset] = calcMatrix.getYRound(vert.vx, vert.vy, roundPixels);
                F32[++vertexOffset] = vert.u;
                F32[++vertexOffset] = vert.v;
                F32[++vertexOffset] = textureUnit;
                F32[++vertexOffset] = tintEffect;
                U32[++vertexOffset] = color;
                pipeline.vertexCount++;
                pipeline.currentBatch.count = pipeline.vertexCount - pipeline.currentBatch.start;
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = NineSliceWebGLRenderer;
          },
          19737: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EmitterOp = __webpack_require__2(93025);
            var GetColor = __webpack_require__2(22946);
            var GetEaseFunction = __webpack_require__2(21902);
            var GetInterpolationFunction = __webpack_require__2(4840);
            var IntegerToRGB = __webpack_require__2(15978);
            var EmitterColorOp = new Class({
              Extends: EmitterOp,
              initialize: function EmitterColorOp2(key) {
                EmitterOp.call(this, key, null, false);
                this.active = false;
                this.easeName = "Linear";
                this.r = [];
                this.g = [];
                this.b = [];
              },
              getMethod: function() {
                return this.propertyValue === null ? 0 : 9;
              },
              setMethods: function() {
                var value = this.propertyValue;
                var current = value;
                var onEmit = this.defaultEmit;
                var onUpdate = this.defaultUpdate;
                if (this.method === 9) {
                  this.start = value[0];
                  this.ease = GetEaseFunction("Linear");
                  this.interpolation = GetInterpolationFunction("linear");
                  onEmit = this.easedValueEmit;
                  onUpdate = this.easeValueUpdate;
                  current = value[0];
                  this.active = true;
                  for (var i = 0; i < value.length; i++) {
                    var color = IntegerToRGB(value[i]);
                    this.r.push(color.r);
                    this.g.push(color.g);
                    this.b.push(color.b);
                  }
                }
                this.onEmit = onEmit;
                this.onUpdate = onUpdate;
                this.current = current;
                return this;
              },
              setEase: function(value) {
                this.easeName = value;
                this.ease = GetEaseFunction(value);
              },
              easedValueEmit: function() {
                this.current = this.start;
                return this.start;
              },
              easeValueUpdate: function(particle, key, t) {
                var v = this.ease(t);
                var r = this.interpolation(this.r, v);
                var g = this.interpolation(this.g, v);
                var b = this.interpolation(this.b, v);
                var current = GetColor(r, g, b);
                this.current = current;
                return current;
              }
            });
            module2.exports = EmitterColorOp;
          },
          93025: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Between = __webpack_require__2(17489);
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var FloatBetween = __webpack_require__2(61616);
            var GetEaseFunction = __webpack_require__2(21902);
            var GetFastValue = __webpack_require__2(72632);
            var GetInterpolationFunction = __webpack_require__2(4840);
            var SnapTo = __webpack_require__2(88462);
            var Wrap = __webpack_require__2(1071);
            var EmitterOp = new Class({
              initialize: function EmitterOp2(key, defaultValue, emitOnly) {
                if (emitOnly === void 0) {
                  emitOnly = false;
                }
                this.propertyKey = key;
                this.propertyValue = defaultValue;
                this.defaultValue = defaultValue;
                this.steps = 0;
                this.counter = 0;
                this.yoyo = false;
                this.direction = 0;
                this.start = 0;
                this.current = 0;
                this.end = 0;
                this.ease = null;
                this.interpolation = null;
                this.emitOnly = emitOnly;
                this.onEmit = this.defaultEmit;
                this.onUpdate = this.defaultUpdate;
                this.active = true;
                this.method = 0;
                this._onEmit;
                this._onUpdate;
              },
              loadConfig: function(config2, newKey) {
                if (config2 === void 0) {
                  config2 = {};
                }
                if (newKey) {
                  this.propertyKey = newKey;
                }
                this.propertyValue = GetFastValue(config2, this.propertyKey, this.defaultValue);
                this.method = this.getMethod();
                this.setMethods();
                if (this.emitOnly) {
                  this.onUpdate = this.defaultUpdate;
                }
              },
              toJSON: function() {
                return JSON.stringify(this.propertyValue);
              },
              onChange: function(value) {
                var current;
                switch (this.method) {
                  case 1:
                  case 3:
                  case 8:
                    current = value;
                    break;
                  case 2:
                    if (this.propertyValue.indexOf(value) >= 0) {
                      current = value;
                    }
                    break;
                  case 4:
                    var step = (this.end - this.start) / this.steps;
                    current = SnapTo(value, step);
                    this.counter = current;
                    break;
                  case 5:
                  case 6:
                  case 7:
                    current = Clamp(value, this.start, this.end);
                    break;
                  case 9:
                    current = this.start[0];
                    break;
                }
                this.current = current;
                return this;
              },
              getMethod: function() {
                var value = this.propertyValue;
                if (value === null) {
                  return 0;
                }
                var t = typeof value;
                if (t === "number") {
                  return 1;
                } else if (Array.isArray(value)) {
                  return 2;
                } else if (t === "function") {
                  return 3;
                } else if (t === "object") {
                  if (this.hasBoth(value, "start", "end")) {
                    if (this.has(value, "steps")) {
                      return 4;
                    } else {
                      return 5;
                    }
                  } else if (this.hasBoth(value, "min", "max")) {
                    return 6;
                  } else if (this.has(value, "random")) {
                    return 7;
                  } else if (this.hasEither(value, "onEmit", "onUpdate")) {
                    return 8;
                  } else if (this.hasEither(value, "values", "interpolation")) {
                    return 9;
                  }
                }
                return 0;
              },
              setMethods: function() {
                var value = this.propertyValue;
                var current = value;
                var onEmit = this.defaultEmit;
                var onUpdate = this.defaultUpdate;
                switch (this.method) {
                  case 1:
                    onEmit = this.staticValueEmit;
                    break;
                  case 2:
                    onEmit = this.randomStaticValueEmit;
                    current = value[0];
                    break;
                  case 3:
                    this._onEmit = value;
                    onEmit = this.proxyEmit;
                    break;
                  case 4:
                    this.start = value.start;
                    this.end = value.end;
                    this.steps = value.steps;
                    this.counter = this.start;
                    this.yoyo = this.has(value, "yoyo") ? value.yoyo : false;
                    this.direction = 0;
                    onEmit = this.steppedEmit;
                    current = this.start;
                    break;
                  case 5:
                    this.start = value.start;
                    this.end = value.end;
                    var easeType = this.has(value, "ease") ? value.ease : "Linear";
                    this.ease = GetEaseFunction(easeType, value.easeParams);
                    onEmit = this.has(value, "random") && value.random ? this.randomRangedValueEmit : this.easedValueEmit;
                    onUpdate = this.easeValueUpdate;
                    current = this.start;
                    break;
                  case 6:
                    this.start = value.min;
                    this.end = value.max;
                    onEmit = this.has(value, "int") && value.int ? this.randomRangedIntEmit : this.randomRangedValueEmit;
                    current = this.start;
                    break;
                  case 7:
                    var rnd = value.random;
                    if (Array.isArray(rnd)) {
                      this.start = rnd[0];
                      this.end = rnd[1];
                    }
                    onEmit = this.randomRangedIntEmit;
                    current = this.start;
                    break;
                  case 8:
                    this._onEmit = this.has(value, "onEmit") ? value.onEmit : this.defaultEmit;
                    this._onUpdate = this.has(value, "onUpdate") ? value.onUpdate : this.defaultUpdate;
                    onEmit = this.proxyEmit;
                    onUpdate = this.proxyUpdate;
                    break;
                  case 9:
                    this.start = value.values;
                    var easeTypeI = this.has(value, "ease") ? value.ease : "Linear";
                    this.ease = GetEaseFunction(easeTypeI, value.easeParams);
                    this.interpolation = GetInterpolationFunction(value.interpolation);
                    onEmit = this.easedValueEmit;
                    onUpdate = this.easeValueUpdate;
                    current = this.start[0];
                    break;
                }
                this.onEmit = onEmit;
                this.onUpdate = onUpdate;
                this.current = current;
                return this;
              },
              has: function(object, key) {
                return object.hasOwnProperty(key);
              },
              hasBoth: function(object, key1, key2) {
                return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);
              },
              hasEither: function(object, key1, key2) {
                return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);
              },
              defaultEmit: function(particle, key, value) {
                return value;
              },
              defaultUpdate: function(particle, key, t, value) {
                return value;
              },
              proxyEmit: function(particle, key, value) {
                var result = this._onEmit(particle, key, value);
                this.current = result;
                return result;
              },
              proxyUpdate: function(particle, key, t, value) {
                var result = this._onUpdate(particle, key, t, value);
                this.current = result;
                return result;
              },
              staticValueEmit: function() {
                return this.current;
              },
              staticValueUpdate: function() {
                return this.current;
              },
              randomStaticValueEmit: function() {
                var randomIndex = Math.floor(Math.random() * this.propertyValue.length);
                this.current = this.propertyValue[randomIndex];
                return this.current;
              },
              randomRangedValueEmit: function(particle, key) {
                var value = FloatBetween(this.start, this.end);
                if (particle && particle.data[key]) {
                  particle.data[key].min = value;
                  particle.data[key].max = this.end;
                }
                this.current = value;
                return value;
              },
              randomRangedIntEmit: function(particle, key) {
                var value = Between(this.start, this.end);
                if (particle && particle.data[key]) {
                  particle.data[key].min = value;
                  particle.data[key].max = this.end;
                }
                this.current = value;
                return value;
              },
              steppedEmit: function() {
                var current = this.counter;
                var next = current;
                var step = (this.end - this.start) / this.steps;
                if (this.yoyo) {
                  var over;
                  if (this.direction === 0) {
                    next += step;
                    if (next >= this.end) {
                      over = next - this.end;
                      next = this.end - over;
                      this.direction = 1;
                    }
                  } else {
                    next -= step;
                    if (next <= this.start) {
                      over = this.start - next;
                      next = this.start + over;
                      this.direction = 0;
                    }
                  }
                  this.counter = next;
                } else {
                  this.counter = Wrap(next + step, this.start, this.end);
                }
                this.current = current;
                return current;
              },
              easedValueEmit: function(particle, key) {
                if (particle && particle.data[key]) {
                  var data = particle.data[key];
                  data.min = this.start;
                  data.max = this.end;
                }
                this.current = this.start;
                return this.start;
              },
              easeValueUpdate: function(particle, key, t) {
                var data = particle.data[key];
                var current;
                var v = this.ease(t);
                if (this.interpolation) {
                  current = this.interpolation(this.start, v);
                } else {
                  current = (data.max - data.min) * v + data.min;
                }
                this.current = current;
                return current;
              },
              destroy: function() {
                this.propertyValue = null;
                this.defaultValue = null;
                this.ease = null;
                this.interpolation = null;
                this._onEmit = null;
                this._onUpdate = null;
              }
            });
            module2.exports = EmitterOp;
          },
          87811: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var ParticleProcessor = __webpack_require__2(30891);
            var GravityWell = new Class({
              Extends: ParticleProcessor,
              initialize: function GravityWell2(x, y, power, epsilon, gravity) {
                if (typeof x === "object") {
                  var config2 = x;
                  x = GetFastValue(config2, "x", 0);
                  y = GetFastValue(config2, "y", 0);
                  power = GetFastValue(config2, "power", 0);
                  epsilon = GetFastValue(config2, "epsilon", 100);
                  gravity = GetFastValue(config2, "gravity", 50);
                } else {
                  if (x === void 0) {
                    x = 0;
                  }
                  if (y === void 0) {
                    y = 0;
                  }
                  if (power === void 0) {
                    power = 0;
                  }
                  if (epsilon === void 0) {
                    epsilon = 100;
                  }
                  if (gravity === void 0) {
                    gravity = 50;
                  }
                }
                ParticleProcessor.call(this, x, y, true);
                this._gravity = gravity;
                this._power = power * gravity;
                this._epsilon = epsilon * epsilon;
              },
              update: function(particle, delta) {
                var x = this.x - particle.x;
                var y = this.y - particle.y;
                var dSq = x * x + y * y;
                if (dSq === 0) {
                  return;
                }
                var d = Math.sqrt(dSq);
                if (dSq < this._epsilon) {
                  dSq = this._epsilon;
                }
                var factor = this._power * delta / (dSq * d) * 100;
                particle.velocityX += x * factor;
                particle.velocityY += y * factor;
              },
              epsilon: {
                get: function() {
                  return Math.sqrt(this._epsilon);
                },
                set: function(value) {
                  this._epsilon = value * value;
                }
              },
              power: {
                get: function() {
                  return this._power / this._gravity;
                },
                set: function(value) {
                  this._power = value * this._gravity;
                }
              },
              gravity: {
                get: function() {
                  return this._gravity;
                },
                set: function(value) {
                  var pwr = this.power;
                  this._gravity = value;
                  this.power = pwr;
                }
              }
            });
            module2.exports = GravityWell;
          },
          14909: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AnimationState = __webpack_require__2(16569);
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var DegToRad = __webpack_require__2(75606);
            var Rectangle = __webpack_require__2(74118);
            var RotateAround = __webpack_require__2(2386);
            var Vector2 = __webpack_require__2(93736);
            var Particle = new Class({
              initialize: function Particle2(emitter) {
                this.emitter = emitter;
                this.texture = null;
                this.frame = null;
                this.x = 0;
                this.y = 0;
                this.worldPosition = new Vector2();
                this.velocityX = 0;
                this.velocityY = 0;
                this.accelerationX = 0;
                this.accelerationY = 0;
                this.maxVelocityX = 1e4;
                this.maxVelocityY = 1e4;
                this.bounce = 0;
                this.scaleX = 1;
                this.scaleY = 1;
                this.alpha = 1;
                this.angle = 0;
                this.rotation = 0;
                this.tint = 16777215;
                this.life = 1e3;
                this.lifeCurrent = 1e3;
                this.delayCurrent = 0;
                this.holdCurrent = 0;
                this.lifeT = 0;
                this.data = {
                  tint: {min: 16777215, max: 16777215},
                  alpha: {min: 1, max: 1},
                  rotate: {min: 0, max: 0},
                  scaleX: {min: 1, max: 1},
                  scaleY: {min: 1, max: 1},
                  x: {min: 0, max: 0},
                  y: {min: 0, max: 0},
                  accelerationX: {min: 0, max: 0},
                  accelerationY: {min: 0, max: 0},
                  maxVelocityX: {min: 0, max: 0},
                  maxVelocityY: {min: 0, max: 0},
                  moveToX: {min: 0, max: 0},
                  moveToY: {min: 0, max: 0},
                  bounce: {min: 0, max: 0}
                };
                this.isCropped = false;
                this.scene = emitter.scene;
                this.anims = new AnimationState(this);
                this.bounds = new Rectangle();
              },
              emit: function(event, a1, a2, a3, a4, a5) {
                return this.emitter.emit(event, a1, a2, a3, a4, a5);
              },
              isAlive: function() {
                return this.lifeCurrent > 0;
              },
              kill: function() {
                this.lifeCurrent = 0;
              },
              setPosition: function(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                this.x = x;
                this.y = y;
              },
              fire: function(x, y) {
                var emitter = this.emitter;
                var ops = emitter.ops;
                var anim = emitter.getAnim();
                if (anim) {
                  this.anims.play(anim);
                } else {
                  this.frame = emitter.getFrame();
                  this.texture = this.frame.texture;
                }
                if (!this.frame) {
                  throw new Error("Particle has no texture frame");
                }
                emitter.getEmitZone(this);
                if (x === void 0) {
                  this.x += ops.x.onEmit(this, "x");
                } else if (ops.x.steps > 0) {
                  this.x += x + ops.x.onEmit(this, "x");
                } else {
                  this.x += x;
                }
                if (y === void 0) {
                  this.y += ops.y.onEmit(this, "y");
                } else if (ops.y.steps > 0) {
                  this.y += y + ops.y.onEmit(this, "y");
                } else {
                  this.y += y;
                }
                this.life = ops.lifespan.onEmit(this, "lifespan");
                this.lifeCurrent = this.life;
                this.lifeT = 0;
                this.delayCurrent = ops.delay.onEmit(this, "delay");
                this.holdCurrent = ops.hold.onEmit(this, "hold");
                this.scaleX = ops.scaleX.onEmit(this, "scaleX");
                this.scaleY = ops.scaleY.active ? ops.scaleY.onEmit(this, "scaleY") : this.scaleX;
                this.angle = ops.rotate.onEmit(this, "rotate");
                this.rotation = DegToRad(this.angle);
                emitter.worldMatrix.transformPoint(this.x, this.y, this.worldPosition);
                if (this.delayCurrent === 0 && emitter.getDeathZone(this)) {
                  this.lifeCurrent = 0;
                  return false;
                }
                var sx = ops.speedX.onEmit(this, "speedX");
                var sy = ops.speedY.active ? ops.speedY.onEmit(this, "speedY") : sx;
                if (emitter.radial) {
                  var rad = DegToRad(ops.angle.onEmit(this, "angle"));
                  this.velocityX = Math.cos(rad) * Math.abs(sx);
                  this.velocityY = Math.sin(rad) * Math.abs(sy);
                } else if (emitter.moveTo) {
                  var mx = ops.moveToX.onEmit(this, "moveToX");
                  var my = ops.moveToY.onEmit(this, "moveToY");
                  var lifeS = this.life / 1e3;
                  this.velocityX = (mx - this.x) / lifeS;
                  this.velocityY = (my - this.y) / lifeS;
                } else {
                  this.velocityX = sx;
                  this.velocityY = sy;
                }
                if (emitter.acceleration) {
                  this.accelerationX = ops.accelerationX.onEmit(this, "accelerationX");
                  this.accelerationY = ops.accelerationY.onEmit(this, "accelerationY");
                }
                this.maxVelocityX = ops.maxVelocityX.onEmit(this, "maxVelocityX");
                this.maxVelocityY = ops.maxVelocityY.onEmit(this, "maxVelocityY");
                this.bounce = ops.bounce.onEmit(this, "bounce");
                this.alpha = ops.alpha.onEmit(this, "alpha");
                if (ops.color.active) {
                  this.tint = ops.color.onEmit(this, "tint");
                } else {
                  this.tint = ops.tint.onEmit(this, "tint");
                }
                return true;
              },
              update: function(delta, step, processors) {
                if (this.lifeCurrent <= 0) {
                  if (this.holdCurrent > 0) {
                    this.holdCurrent -= delta;
                    return this.holdCurrent <= 0;
                  } else {
                    return true;
                  }
                }
                if (this.delayCurrent > 0) {
                  this.delayCurrent -= delta;
                  return false;
                }
                this.anims.update(0, delta);
                var emitter = this.emitter;
                var ops = emitter.ops;
                var t = 1 - this.lifeCurrent / this.life;
                this.lifeT = t;
                this.x = ops.x.onUpdate(this, "x", t, this.x);
                this.y = ops.y.onUpdate(this, "y", t, this.y);
                if (emitter.moveTo) {
                  var mx = ops.moveToX.onUpdate(this, "moveToX", t, emitter.moveToX);
                  var my = ops.moveToY.onUpdate(this, "moveToY", t, emitter.moveToY);
                  var lifeS = this.lifeCurrent / 1e3;
                  this.velocityX = (mx - this.x) / lifeS;
                  this.velocityY = (my - this.y) / lifeS;
                }
                this.computeVelocity(emitter, delta, step, processors, t);
                this.scaleX = ops.scaleX.onUpdate(this, "scaleX", t, this.scaleX);
                if (ops.scaleY.active) {
                  this.scaleY = ops.scaleY.onUpdate(this, "scaleY", t, this.scaleY);
                } else {
                  this.scaleY = this.scaleX;
                }
                this.angle = ops.rotate.onUpdate(this, "rotate", t, this.angle);
                this.rotation = DegToRad(this.angle);
                if (emitter.getDeathZone(this)) {
                  this.lifeCurrent = 0;
                  return true;
                }
                this.alpha = Clamp(ops.alpha.onUpdate(this, "alpha", t, this.alpha), 0, 1);
                if (ops.color.active) {
                  this.tint = ops.color.onUpdate(this, "color", t, this.tint);
                } else {
                  this.tint = ops.tint.onUpdate(this, "tint", t, this.tint);
                }
                this.lifeCurrent -= delta;
                return this.lifeCurrent <= 0 && this.holdCurrent <= 0;
              },
              computeVelocity: function(emitter, delta, step, processors, t) {
                var ops = emitter.ops;
                var vx = this.velocityX;
                var vy = this.velocityY;
                var ax = ops.accelerationX.onUpdate(this, "accelerationX", t, this.accelerationX);
                var ay = ops.accelerationY.onUpdate(this, "accelerationY", t, this.accelerationY);
                var mx = ops.maxVelocityX.onUpdate(this, "maxVelocityX", t, this.maxVelocityX);
                var my = ops.maxVelocityY.onUpdate(this, "maxVelocityY", t, this.maxVelocityY);
                this.bounce = ops.bounce.onUpdate(this, "bounce", t, this.bounce);
                vx += emitter.gravityX * step + ax * step;
                vy += emitter.gravityY * step + ay * step;
                vx = Clamp(vx, -mx, mx);
                vy = Clamp(vy, -my, my);
                this.velocityX = vx;
                this.velocityY = vy;
                this.x += vx * step;
                this.y += vy * step;
                emitter.worldMatrix.transformPoint(this.x, this.y, this.worldPosition);
                for (var i = 0; i < processors.length; i++) {
                  var processor = processors[i];
                  if (processor.active) {
                    processor.update(this, delta, step, t);
                  }
                }
              },
              setSizeToFrame: function() {
              },
              getBounds: function(matrix) {
                if (matrix === void 0) {
                  matrix = this.emitter.getWorldTransformMatrix();
                }
                var sx = Math.abs(matrix.scaleX) * this.scaleX;
                var sy = Math.abs(matrix.scaleY) * this.scaleY;
                var x = this.x;
                var y = this.y;
                var rotation = this.rotation;
                var width = this.frame.width * sx / 2;
                var height = this.frame.height * sy / 2;
                var bounds = this.bounds;
                var topLeft = new Vector2(x - width, y - height);
                var topRight = new Vector2(x + width, y - height);
                var bottomLeft = new Vector2(x - width, y + height);
                var bottomRight = new Vector2(x + width, y + height);
                if (rotation !== 0) {
                  RotateAround(topLeft, x, y, rotation);
                  RotateAround(topRight, x, y, rotation);
                  RotateAround(bottomLeft, x, y, rotation);
                  RotateAround(bottomRight, x, y, rotation);
                }
                matrix.transformPoint(topLeft.x, topLeft.y, topLeft);
                matrix.transformPoint(topRight.x, topRight.y, topRight);
                matrix.transformPoint(bottomLeft.x, bottomLeft.y, bottomLeft);
                matrix.transformPoint(bottomRight.x, bottomRight.y, bottomRight);
                bounds.x = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
                bounds.y = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
                bounds.width = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x) - bounds.x;
                bounds.height = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y) - bounds.y;
                return bounds;
              },
              destroy: function() {
                this.anims.destroy();
                this.anims = null;
                this.emitter = null;
                this.texture = null;
                this.frame = null;
                this.scene = null;
              }
            });
            module2.exports = Particle;
          },
          73106: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ParticleProcessor = __webpack_require__2(30891);
            var Rectangle = __webpack_require__2(74118);
            var ParticleBounds = new Class({
              Extends: ParticleProcessor,
              initialize: function ParticleBounds2(x, y, width, height, collideLeft, collideRight, collideTop, collideBottom) {
                if (collideLeft === void 0) {
                  collideLeft = true;
                }
                if (collideRight === void 0) {
                  collideRight = true;
                }
                if (collideTop === void 0) {
                  collideTop = true;
                }
                if (collideBottom === void 0) {
                  collideBottom = true;
                }
                ParticleProcessor.call(this, x, y, true);
                this.bounds = new Rectangle(x, y, width, height);
                this.collideLeft = collideLeft;
                this.collideRight = collideRight;
                this.collideTop = collideTop;
                this.collideBottom = collideBottom;
              },
              update: function(particle) {
                var bounds = this.bounds;
                var bounce = -particle.bounce;
                var pos = particle.worldPosition;
                if (pos.x < bounds.x && this.collideLeft) {
                  particle.x += bounds.x - pos.x;
                  particle.velocityX *= bounce;
                } else if (pos.x > bounds.right && this.collideRight) {
                  particle.x -= pos.x - bounds.right;
                  particle.velocityX *= bounce;
                }
                if (pos.y < bounds.y && this.collideTop) {
                  particle.y += bounds.y - pos.y;
                  particle.velocityY *= bounce;
                } else if (pos.y > bounds.bottom && this.collideBottom) {
                  particle.y -= pos.y - bounds.bottom;
                  particle.velocityY *= bounce;
                }
              }
            });
            module2.exports = ParticleBounds;
          },
          9216: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var ComponentsToJSON = __webpack_require__2(48129);
            var CopyFrom = __webpack_require__2(29538);
            var DeathZone = __webpack_require__2(69361);
            var EdgeZone = __webpack_require__2(54213);
            var EmitterColorOp = __webpack_require__2(19737);
            var EmitterOp = __webpack_require__2(93025);
            var Events = __webpack_require__2(40629);
            var GameObject = __webpack_require__2(89980);
            var GetFastValue = __webpack_require__2(72632);
            var GetRandom = __webpack_require__2(72861);
            var GravityWell = __webpack_require__2(87811);
            var HasAny = __webpack_require__2(53523);
            var HasValue = __webpack_require__2(19256);
            var Inflate = __webpack_require__2(7782);
            var List = __webpack_require__2(71207);
            var MergeRect = __webpack_require__2(14655);
            var Particle = __webpack_require__2(14909);
            var RandomZone = __webpack_require__2(68433);
            var Rectangle = __webpack_require__2(74118);
            var RectangleToRectangle = __webpack_require__2(90205);
            var Remove = __webpack_require__2(66458);
            var Render = __webpack_require__2(69116);
            var StableSort = __webpack_require__2(17922);
            var TransformMatrix = __webpack_require__2(69360);
            var Vector2 = __webpack_require__2(93736);
            var Wrap = __webpack_require__2(1071);
            var ParticleBounds = __webpack_require__2(73106);
            var configFastMap = [
              "active",
              "advance",
              "blendMode",
              "colorEase",
              "deathCallback",
              "deathCallbackScope",
              "duration",
              "emitCallback",
              "emitCallbackScope",
              "follow",
              "frequency",
              "gravityX",
              "gravityY",
              "maxAliveParticles",
              "maxParticles",
              "name",
              "emitting",
              "particleBringToTop",
              "particleClass",
              "radial",
              "sortCallback",
              "sortOrderAsc",
              "sortProperty",
              "stopAfter",
              "tintFill",
              "timeScale",
              "trackVisible",
              "visible"
            ];
            var configOpMap = [
              "accelerationX",
              "accelerationY",
              "alpha",
              "angle",
              "bounce",
              "color",
              "delay",
              "hold",
              "lifespan",
              "maxVelocityX",
              "maxVelocityY",
              "moveToX",
              "moveToY",
              "quantity",
              "rotate",
              "scaleX",
              "scaleY",
              "speedX",
              "speedY",
              "tint",
              "x",
              "y"
            ];
            var ParticleEmitter = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Texture,
                Components.Transform,
                Components.Visible,
                Render
              ],
              initialize: function ParticleEmitter2(scene, x, y, texture, config2) {
                GameObject.call(this, scene, "ParticleEmitter");
                this.particleClass = Particle;
                this.ops = {
                  accelerationX: new EmitterOp("accelerationX", 0),
                  accelerationY: new EmitterOp("accelerationY", 0),
                  alpha: new EmitterOp("alpha", 1),
                  angle: new EmitterOp("angle", {min: 0, max: 360}, true),
                  bounce: new EmitterOp("bounce", 0),
                  color: new EmitterColorOp("color"),
                  delay: new EmitterOp("delay", 0, true),
                  hold: new EmitterOp("hold", 0, true),
                  lifespan: new EmitterOp("lifespan", 1e3, true),
                  maxVelocityX: new EmitterOp("maxVelocityX", 1e4),
                  maxVelocityY: new EmitterOp("maxVelocityY", 1e4),
                  moveToX: new EmitterOp("moveToX", 0),
                  moveToY: new EmitterOp("moveToY", 0),
                  quantity: new EmitterOp("quantity", 1, true),
                  rotate: new EmitterOp("rotate", 0),
                  scaleX: new EmitterOp("scaleX", 1),
                  scaleY: new EmitterOp("scaleY", 1),
                  speedX: new EmitterOp("speedX", 0, true),
                  speedY: new EmitterOp("speedY", 0, true),
                  tint: new EmitterOp("tint", 16777215),
                  x: new EmitterOp("x", 0),
                  y: new EmitterOp("y", 0)
                };
                this.radial = true;
                this.gravityX = 0;
                this.gravityY = 0;
                this.acceleration = false;
                this.moveTo = false;
                this.emitCallback = null;
                this.emitCallbackScope = null;
                this.deathCallback = null;
                this.deathCallbackScope = null;
                this.maxParticles = 0;
                this.maxAliveParticles = 0;
                this.stopAfter = 0;
                this.duration = 0;
                this.frequency = 0;
                this.emitting = true;
                this.particleBringToTop = true;
                this.timeScale = 1;
                this.emitZones = [];
                this.deathZones = [];
                this.viewBounds = null;
                this.follow = null;
                this.followOffset = new Vector2();
                this.trackVisible = false;
                this.frames = [];
                this.randomFrame = true;
                this.frameQuantity = 1;
                this.anims = [];
                this.randomAnim = true;
                this.animQuantity = 1;
                this.dead = [];
                this.alive = [];
                this.counters = new Float32Array(10);
                this.skipping = false;
                this.worldMatrix = new TransformMatrix();
                this.sortProperty = "";
                this.sortOrderAsc = true;
                this.sortCallback = this.depthSortCallback;
                this.processors = new List(this);
                this.tintFill = false;
                this.initPipeline();
                this.initPostPipeline();
                this.setPosition(x, y);
                this.setTexture(texture);
                if (config2) {
                  this.setConfig(config2);
                }
              },
              addedToScene: function() {
                this.scene.sys.updateList.add(this);
              },
              removedFromScene: function() {
                this.scene.sys.updateList.remove(this);
              },
              setConfig: function(config2) {
                if (!config2) {
                  return this;
                }
                var i = 0;
                var key = "";
                var ops = this.ops;
                for (i = 0; i < configOpMap.length; i++) {
                  key = configOpMap[i];
                  ops[key].loadConfig(config2);
                }
                for (i = 0; i < configFastMap.length; i++) {
                  key = configFastMap[i];
                  if (HasValue(config2, key)) {
                    this[key] = GetFastValue(config2, key);
                  }
                }
                this.acceleration = this.accelerationX !== 0 || this.accelerationY !== 0;
                this.moveTo = this.moveToX !== 0 && this.moveToY !== 0;
                if (HasValue(config2, "speed")) {
                  ops.speedX.loadConfig(config2, "speed");
                  ops.speedY.active = false;
                }
                if (HasAny(config2, ["speedX", "speedY"]) || this.moveTo) {
                  this.radial = false;
                }
                if (HasValue(config2, "scale")) {
                  ops.scaleX.loadConfig(config2, "scale");
                  ops.scaleY.active = false;
                }
                if (HasValue(config2, "callbackScope")) {
                  var callbackScope = GetFastValue(config2, "callbackScope", null);
                  this.emitCallbackScope = callbackScope;
                  this.deathCallbackScope = callbackScope;
                }
                if (HasValue(config2, "emitZone")) {
                  this.addEmitZone(config2.emitZone);
                }
                if (HasValue(config2, "deathZone")) {
                  this.addDeathZone(config2.deathZone);
                }
                if (HasValue(config2, "bounds")) {
                  var bounds = this.addParticleBounds(config2.bounds);
                  bounds.collideLeft = GetFastValue(config2, "collideLeft", true);
                  bounds.collideRight = GetFastValue(config2, "collideRight", true);
                  bounds.collideTop = GetFastValue(config2, "collideTop", true);
                  bounds.collideBottom = GetFastValue(config2, "collideBottom", true);
                }
                if (HasValue(config2, "followOffset")) {
                  this.followOffset.setFromObject(GetFastValue(config2, "followOffset", 0));
                }
                if (HasValue(config2, "texture")) {
                  this.setTexture(config2.texture);
                }
                if (HasValue(config2, "frame")) {
                  this.setEmitterFrame(config2.frame);
                } else if (HasValue(config2, "anim")) {
                  this.setAnim(config2.anim);
                }
                if (HasValue(config2, "reserve")) {
                  this.reserve(config2.reserve);
                }
                if (HasValue(config2, "advance")) {
                  this.fastForward(config2.advance);
                }
                this.resetCounters(this.frequency, this.emitting);
                if (this.emitting) {
                  this.emit(Events.START, this);
                }
                return this;
              },
              toJSON: function() {
                var output = ComponentsToJSON(this);
                var i = 0;
                var key = "";
                for (i = 0; i < configFastMap.length; i++) {
                  key = configFastMap[i];
                  output[key] = this[key];
                }
                var ops = this.ops;
                for (i = 0; i < configOpMap.length; i++) {
                  key = configOpMap[i];
                  if (ops[key]) {
                    output[key] = ops[key].toJSON();
                  }
                }
                if (!ops.speedY.active) {
                  delete output.speedX;
                  output.speed = ops.speedX.toJSON();
                }
                if (this.scaleX === this.scaleY) {
                  delete output.scaleX;
                  delete output.scaleY;
                  output.scale = ops.scaleX.toJSON();
                }
                return output;
              },
              resetCounters: function(frequency, on) {
                var counters = this.counters;
                counters.fill(0);
                counters[0] = frequency;
                if (on) {
                  counters[5] = 1;
                }
              },
              startFollow: function(target, offsetX, offsetY, trackVisible) {
                if (offsetX === void 0) {
                  offsetX = 0;
                }
                if (offsetY === void 0) {
                  offsetY = 0;
                }
                if (trackVisible === void 0) {
                  trackVisible = false;
                }
                this.follow = target;
                this.followOffset.set(offsetX, offsetY);
                this.trackVisible = trackVisible;
                return this;
              },
              stopFollow: function() {
                this.follow = null;
                this.followOffset.set(0, 0);
                this.trackVisible = false;
                return this;
              },
              getFrame: function() {
                var frames = this.frames;
                var len = frames.length;
                var current;
                if (len === 1) {
                  current = frames[0];
                } else if (this.randomFrame) {
                  current = GetRandom(frames);
                } else {
                  current = frames[this.currentFrame];
                  this.frameCounter++;
                  if (this.frameCounter === this.frameQuantity) {
                    this.frameCounter = 0;
                    this.currentFrame++;
                    if (this.currentFrame === len) {
                      this.currentFrame = 0;
                    }
                  }
                }
                return this.texture.get(current);
              },
              setEmitterFrame: function(frames, pickRandom, quantity) {
                if (pickRandom === void 0) {
                  pickRandom = true;
                }
                if (quantity === void 0) {
                  quantity = 1;
                }
                this.randomFrame = pickRandom;
                this.frameQuantity = quantity;
                this.currentFrame = 0;
                var t = typeof frames;
                this.frames.length = 0;
                if (Array.isArray(frames)) {
                  this.frames = this.frames.concat(frames);
                } else if (t === "string" || t === "number") {
                  this.frames.push(frames);
                } else if (t === "object") {
                  var frameConfig = frames;
                  frames = GetFastValue(frameConfig, "frames", null);
                  if (frames) {
                    this.frames = this.frames.concat(frames);
                  }
                  var isCycle = GetFastValue(frameConfig, "cycle", false);
                  this.randomFrame = isCycle ? false : true;
                  this.frameQuantity = GetFastValue(frameConfig, "quantity", quantity);
                }
                if (this.frames.length === 1) {
                  this.frameQuantity = 1;
                  this.randomFrame = false;
                }
                return this;
              },
              getAnim: function() {
                var anims = this.anims;
                var len = anims.length;
                if (len === 0) {
                  return null;
                } else if (len === 1) {
                  return anims[0];
                } else if (this.randomAnim) {
                  return GetRandom(anims);
                } else {
                  var anim = anims[this.currentAnim];
                  this.animCounter++;
                  if (this.animCounter >= this.animQuantity) {
                    this.animCounter = 0;
                    this.currentAnim = Wrap(this.currentAnim + 1, 0, len);
                  }
                  return anim;
                }
              },
              setAnim: function(anims, pickRandom, quantity) {
                if (pickRandom === void 0) {
                  pickRandom = true;
                }
                if (quantity === void 0) {
                  quantity = 1;
                }
                this.randomAnim = pickRandom;
                this.animQuantity = quantity;
                this.currentAnim = 0;
                var t = typeof anims;
                this.anims.length = 0;
                if (Array.isArray(anims)) {
                  this.anims = this.anims.concat(anims);
                } else if (t === "string") {
                  this.anims.push(anims);
                } else if (t === "object") {
                  var animConfig = anims;
                  anims = GetFastValue(animConfig, "anims", null);
                  if (anims) {
                    this.anims = this.anims.concat(anims);
                  }
                  var isCycle = GetFastValue(animConfig, "cycle", false);
                  this.randomAnim = isCycle ? false : true;
                  this.animQuantity = GetFastValue(animConfig, "quantity", quantity);
                }
                if (this.anims.length === 1) {
                  this.animQuantity = 1;
                  this.randomAnim = false;
                }
                return this;
              },
              setRadial: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.radial = value;
                return this;
              },
              addParticleBounds: function(x, y, width, height, collideLeft, collideRight, collideTop, collideBottom) {
                if (typeof x === "object") {
                  var obj = x;
                  x = obj.x;
                  y = obj.y;
                  width = HasValue(obj, "w") ? obj.w : obj.width;
                  height = HasValue(obj, "h") ? obj.h : obj.height;
                }
                return this.addParticleProcessor(new ParticleBounds(x, y, width, height, collideLeft, collideRight, collideTop, collideBottom));
              },
              setParticleSpeed: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.ops.speedX.onChange(x);
                if (x === y) {
                  this.ops.speedY.active = false;
                } else {
                  this.ops.speedY.onChange(y);
                }
                this.radial = true;
                return this;
              },
              setParticleScale: function(x, y) {
                if (x === void 0) {
                  x = 1;
                }
                if (y === void 0) {
                  y = x;
                }
                this.ops.scaleX.onChange(x);
                this.ops.scaleY.onChange(y);
                return this;
              },
              setParticleGravity: function(x, y) {
                this.gravityX = x;
                this.gravityY = y;
                return this;
              },
              setParticleAlpha: function(value) {
                this.ops.alpha.onChange(value);
                return this;
              },
              setParticleTint: function(value) {
                this.ops.tint.onChange(value);
                return this;
              },
              setEmitterAngle: function(value) {
                this.ops.angle.onChange(value);
                return this;
              },
              setParticleLifespan: function(value) {
                this.ops.lifespan.onChange(value);
                return this;
              },
              setQuantity: function(quantity) {
                this.quantity = quantity;
                return this;
              },
              setFrequency: function(frequency, quantity) {
                this.frequency = frequency;
                this.flowCounter = frequency > 0 ? frequency : 0;
                if (quantity) {
                  this.quantity = quantity;
                }
                return this;
              },
              addDeathZone: function(config2) {
                if (!Array.isArray(config2)) {
                  config2 = [config2];
                }
                var zone;
                var output = [];
                for (var i = 0; i < config2.length; i++) {
                  zone = config2[i];
                  if (zone instanceof DeathZone) {
                    output.push(zone);
                  } else if (typeof zone.contains === "function") {
                    zone = new DeathZone(zone, true);
                    output.push(zone);
                  } else {
                    var type = GetFastValue(zone, "type", "onEnter");
                    var source = GetFastValue(zone, "source", null);
                    if (source && typeof source.contains === "function") {
                      var killOnEnter = type === "onEnter" ? true : false;
                      zone = new DeathZone(source, killOnEnter);
                      output.push(zone);
                    }
                  }
                }
                this.deathZones = this.deathZones.concat(output);
                return output;
              },
              removeDeathZone: function(zone) {
                Remove(this.deathZones, zone);
                return this;
              },
              clearDeathZones: function() {
                this.deathZones.length = 0;
                return this;
              },
              addEmitZone: function(config2) {
                if (!Array.isArray(config2)) {
                  config2 = [config2];
                }
                var zone;
                var output = [];
                for (var i = 0; i < config2.length; i++) {
                  zone = config2[i];
                  if (zone instanceof RandomZone || zone instanceof EdgeZone) {
                    output.push(zone);
                  } else {
                    var source = GetFastValue(zone, "source", null);
                    if (source) {
                      var type = GetFastValue(zone, "type", "random");
                      if (type === "random" && typeof source.getRandomPoint === "function") {
                        zone = new RandomZone(source);
                        output.push(zone);
                      } else if (type === "edge" && typeof source.getPoints === "function") {
                        var quantity = GetFastValue(zone, "quantity", 1);
                        var stepRate = GetFastValue(zone, "stepRate", 0);
                        var yoyo = GetFastValue(zone, "yoyo", false);
                        var seamless = GetFastValue(zone, "seamless", true);
                        var total = GetFastValue(zone, "total", -1);
                        zone = new EdgeZone(source, quantity, stepRate, yoyo, seamless, total);
                        output.push(zone);
                      }
                    }
                  }
                }
                this.emitZones = this.emitZones.concat(output);
                return output;
              },
              removeEmitZone: function(zone) {
                Remove(this.emitZones, zone);
                this.zoneIndex = 0;
                return this;
              },
              clearEmitZones: function() {
                this.emitZones.length = 0;
                this.zoneIndex = 0;
                return this;
              },
              getEmitZone: function(particle) {
                var zones = this.emitZones;
                var len = zones.length;
                if (len === 0) {
                  return;
                } else {
                  var zone = zones[this.zoneIndex];
                  zone.getPoint(particle);
                  if (zone.total > -1) {
                    this.zoneTotal++;
                    if (this.zoneTotal === zone.total) {
                      this.zoneTotal = 0;
                      this.zoneIndex++;
                      if (this.zoneIndex === len) {
                        this.zoneIndex = 0;
                      }
                    }
                  }
                }
              },
              getDeathZone: function(particle) {
                var zones = this.deathZones;
                for (var i = 0; i < zones.length; i++) {
                  var zone = zones[i];
                  if (zone.willKill(particle)) {
                    this.emit(Events.DEATH_ZONE, this, particle, zone);
                    return true;
                  }
                }
                return false;
              },
              setEmitZone: function(zone) {
                var index;
                if (isFinite(zone)) {
                  index = zone;
                } else {
                  index = this.emitZones.indexOf(zone);
                }
                if (index >= 0) {
                  this.zoneIndex = index;
                }
                return this;
              },
              addParticleProcessor: function(processor) {
                if (!this.processors.exists(processor)) {
                  if (processor.emitter) {
                    processor.emitter.removeParticleProcessor(processor);
                  }
                  this.processors.add(processor);
                  processor.emitter = this;
                }
                return processor;
              },
              removeParticleProcessor: function(processor) {
                if (this.processors.exists(processor)) {
                  this.processors.remove(processor, true);
                  processor.emitter = null;
                }
                return processor;
              },
              getProcessors: function() {
                return this.processors.getAll("active", true);
              },
              createGravityWell: function(config2) {
                return this.addParticleProcessor(new GravityWell(config2));
              },
              reserve: function(count) {
                var dead = this.dead;
                if (this.maxParticles > 0) {
                  var total = this.getParticleCount();
                  if (total + count > this.maxParticles) {
                    count = this.maxParticles - (total + count);
                  }
                }
                for (var i = 0; i < count; i++) {
                  dead.push(new this.particleClass(this));
                }
                return this;
              },
              getAliveParticleCount: function() {
                return this.alive.length;
              },
              getDeadParticleCount: function() {
                return this.dead.length;
              },
              getParticleCount: function() {
                return this.getAliveParticleCount() + this.getDeadParticleCount();
              },
              atLimit: function() {
                if (this.maxParticles > 0 && this.getParticleCount() >= this.maxParticles) {
                  return true;
                }
                return this.maxAliveParticles > 0 && this.getAliveParticleCount() >= this.maxAliveParticles;
              },
              onParticleEmit: function(callback, context) {
                if (callback === void 0) {
                  this.emitCallback = null;
                  this.emitCallbackScope = null;
                } else if (typeof callback === "function") {
                  this.emitCallback = callback;
                  if (context) {
                    this.emitCallbackScope = context;
                  }
                }
                return this;
              },
              onParticleDeath: function(callback, context) {
                if (callback === void 0) {
                  this.deathCallback = null;
                  this.deathCallbackScope = null;
                } else if (typeof callback === "function") {
                  this.deathCallback = callback;
                  if (context) {
                    this.deathCallbackScope = context;
                  }
                }
                return this;
              },
              killAll: function() {
                var dead = this.dead;
                var alive = this.alive;
                while (alive.length > 0) {
                  dead.push(alive.pop());
                }
                return this;
              },
              forEachAlive: function(callback, context) {
                var alive = this.alive;
                var length = alive.length;
                for (var i = 0; i < length; i++) {
                  callback.call(context, alive[i], this);
                }
                return this;
              },
              forEachDead: function(callback, context) {
                var dead = this.dead;
                var length = dead.length;
                for (var i = 0; i < length; i++) {
                  callback.call(context, dead[i], this);
                }
                return this;
              },
              start: function(advance, duration) {
                if (advance === void 0) {
                  advance = 0;
                }
                if (!this.emitting) {
                  if (advance > 0) {
                    this.fastForward(advance);
                  }
                  this.emitting = true;
                  this.resetCounters(this.frequency, true);
                  if (duration !== void 0) {
                    this.duration = Math.abs(duration);
                  }
                  this.emit(Events.START, this);
                }
                return this;
              },
              stop: function(kill) {
                if (kill === void 0) {
                  kill = false;
                }
                if (this.emitting) {
                  this.emitting = false;
                  if (kill) {
                    this.killAll();
                  }
                  this.emit(Events.STOP, this);
                }
                return this;
              },
              pause: function() {
                this.active = false;
                return this;
              },
              resume: function() {
                this.active = true;
                return this;
              },
              setSortProperty: function(property, ascending) {
                if (property === void 0) {
                  property = "";
                }
                if (ascending === void 0) {
                  ascending = this.true;
                }
                this.sortProperty = property;
                this.sortOrderAsc = ascending;
                this.sortCallback = this.depthSortCallback;
                return this;
              },
              setSortCallback: function(callback) {
                if (this.sortProperty !== "") {
                  callback = this.depthSortCallback;
                } else {
                  callback = null;
                }
                this.sortCallback = callback;
                return this;
              },
              depthSort: function() {
                StableSort(this.alive, this.sortCallback.bind(this));
                return this;
              },
              depthSortCallback: function(a, b) {
                var key = this.sortProperty;
                if (this.sortOrderAsc) {
                  return a[key] - b[key];
                } else {
                  return b[key] - a[key];
                }
              },
              flow: function(frequency, count, stopAfter) {
                if (count === void 0) {
                  count = 1;
                }
                this.emitting = false;
                this.frequency = frequency;
                this.quantity = count;
                if (stopAfter !== void 0) {
                  this.stopAfter = stopAfter;
                }
                return this.start();
              },
              explode: function(count, x, y) {
                this.frequency = -1;
                this.resetCounters(-1, true);
                var particle = this.emitParticle(count, x, y);
                this.emit(Events.EXPLODE, this, particle);
                return particle;
              },
              emitParticleAt: function(x, y, count) {
                return this.emitParticle(count, x, y);
              },
              emitParticle: function(count, x, y) {
                if (this.atLimit()) {
                  return;
                }
                if (count === void 0) {
                  count = this.ops.quantity.onEmit();
                }
                var dead = this.dead;
                var stopAfter = this.stopAfter;
                var followX = this.follow ? this.follow.x + this.followOffset.x : x;
                var followY = this.follow ? this.follow.y + this.followOffset.y : y;
                for (var i = 0; i < count; i++) {
                  var particle = dead.pop();
                  if (!particle) {
                    particle = new this.particleClass(this);
                  }
                  if (particle.fire(followX, followY)) {
                    if (this.particleBringToTop) {
                      this.alive.push(particle);
                    } else {
                      this.alive.unshift(particle);
                    }
                    if (this.emitCallback) {
                      this.emitCallback.call(this.emitCallbackScope, particle, this);
                    }
                  } else {
                    this.dead.push(particle);
                  }
                  if (stopAfter > 0) {
                    this.stopCounter++;
                    if (this.stopCounter >= stopAfter) {
                      break;
                    }
                  }
                  if (this.atLimit()) {
                    break;
                  }
                }
                return particle;
              },
              fastForward: function(time, delta) {
                if (delta === void 0) {
                  delta = 1e3 / 60;
                }
                var total = 0;
                this.skipping = true;
                while (total < Math.abs(time)) {
                  this.preUpdate(0, delta);
                  total += delta;
                }
                this.skipping = false;
                return this;
              },
              preUpdate: function(time, delta) {
                delta *= this.timeScale;
                var step = delta / 1e3;
                if (this.trackVisible) {
                  this.visible = this.follow.visible;
                }
                this.getWorldTransformMatrix(this.worldMatrix);
                var processors = this.getProcessors();
                var particles = this.alive;
                var dead = this.dead;
                var i = 0;
                var rip = [];
                var length = particles.length;
                for (i = 0; i < length; i++) {
                  var particle = particles[i];
                  if (particle.update(delta, step, processors)) {
                    rip.push({index: i, particle});
                  }
                }
                length = rip.length;
                if (length > 0) {
                  var deathCallback = this.deathCallback;
                  var deathCallbackScope = this.deathCallbackScope;
                  for (i = length - 1; i >= 0; i--) {
                    var entry = rip[i];
                    particles.splice(entry.index, 1);
                    dead.push(entry.particle);
                    if (deathCallback) {
                      deathCallback.call(deathCallbackScope, entry.particle);
                    }
                    entry.particle.setPosition();
                  }
                }
                if (!this.emitting && !this.skipping) {
                  if (this.completeFlag === 1 && particles.length === 0) {
                    this.completeFlag = 0;
                    this.emit(Events.COMPLETE, this);
                  }
                  return;
                }
                if (this.frequency === 0) {
                  this.emitParticle();
                } else if (this.frequency > 0) {
                  this.flowCounter -= delta;
                  while (this.flowCounter <= 0) {
                    this.emitParticle();
                    this.flowCounter += this.frequency;
                  }
                }
                if (!this.skipping) {
                  if (this.duration > 0) {
                    this.elapsed += delta;
                    if (this.elapsed >= this.duration) {
                      this.stop();
                    }
                  }
                  if (this.stopAfter > 0 && this.stopCounter >= this.stopAfter) {
                    this.stop();
                  }
                }
              },
              overlap: function(target) {
                var matrix = this.getWorldTransformMatrix();
                var alive = this.alive;
                var length = alive.length;
                var output = [];
                for (var i = 0; i < length; i++) {
                  var particle = alive[i];
                  if (RectangleToRectangle(target, particle.getBounds(matrix))) {
                    output.push(particle);
                  }
                }
                return output;
              },
              getBounds: function(padding, advance, delta, output) {
                if (padding === void 0) {
                  padding = 0;
                }
                if (advance === void 0) {
                  advance = 0;
                }
                if (delta === void 0) {
                  delta = 1e3 / 60;
                }
                if (output === void 0) {
                  output = new Rectangle();
                }
                var matrix = this.getWorldTransformMatrix();
                var i;
                var bounds;
                var alive = this.alive;
                var setFirst = false;
                output.setTo(0, 0, 0, 0);
                if (advance > 0) {
                  var total = 0;
                  this.skipping = true;
                  while (total < Math.abs(advance)) {
                    this.preUpdate(0, delta);
                    for (i = 0; i < alive.length; i++) {
                      bounds = alive[i].getBounds(matrix);
                      if (!setFirst) {
                        setFirst = true;
                        CopyFrom(bounds, output);
                      } else {
                        MergeRect(output, bounds);
                      }
                    }
                    total += delta;
                  }
                  this.skipping = false;
                } else {
                  for (i = 0; i < alive.length; i++) {
                    bounds = alive[i].getBounds(matrix);
                    if (!setFirst) {
                      setFirst = true;
                      CopyFrom(bounds, output);
                    } else {
                      MergeRect(output, bounds);
                    }
                  }
                }
                if (padding > 0) {
                  Inflate(output, padding, padding);
                }
                return output;
              },
              createEmitter: function() {
                throw new Error("createEmitter removed. See ParticleEmitter docs for info");
              },
              particleX: {
                get: function() {
                  return this.ops.x.current;
                },
                set: function(value) {
                  this.ops.x.onChange(value);
                }
              },
              particleY: {
                get: function() {
                  return this.ops.y.current;
                },
                set: function(value) {
                  this.ops.y.onChange(value);
                }
              },
              accelerationX: {
                get: function() {
                  return this.ops.accelerationX.current;
                },
                set: function(value) {
                  this.ops.accelerationX.onChange(value);
                }
              },
              accelerationY: {
                get: function() {
                  return this.ops.accelerationY.current;
                },
                set: function(value) {
                  this.ops.accelerationY.onChange(value);
                }
              },
              maxVelocityX: {
                get: function() {
                  return this.ops.maxVelocityX.current;
                },
                set: function(value) {
                  this.ops.maxVelocityX.onChange(value);
                }
              },
              maxVelocityY: {
                get: function() {
                  return this.ops.maxVelocityY.current;
                },
                set: function(value) {
                  this.ops.maxVelocityY.onChange(value);
                }
              },
              speed: {
                get: function() {
                  return this.ops.speedX.current;
                },
                set: function(value) {
                  this.ops.speedX.onChange(value);
                  this.ops.speedY.onChange(value);
                }
              },
              speedX: {
                get: function() {
                  return this.ops.speedX.current;
                },
                set: function(value) {
                  this.ops.speedX.onChange(value);
                }
              },
              speedY: {
                get: function() {
                  return this.ops.speedY.current;
                },
                set: function(value) {
                  this.ops.speedY.onChange(value);
                }
              },
              moveToX: {
                get: function() {
                  return this.ops.moveToX.current;
                },
                set: function(value) {
                  this.ops.moveToX.onChange(value);
                }
              },
              moveToY: {
                get: function() {
                  return this.ops.moveToY.current;
                },
                set: function(value) {
                  this.ops.moveToY.onChange(value);
                }
              },
              bounce: {
                get: function() {
                  return this.ops.bounce.current;
                },
                set: function(value) {
                  this.ops.bounce.onChange(value);
                }
              },
              particleScaleX: {
                get: function() {
                  return this.ops.scaleX.current;
                },
                set: function(value) {
                  this.ops.scaleX.onChange(value);
                }
              },
              particleScaleY: {
                get: function() {
                  return this.ops.scaleY.current;
                },
                set: function(value) {
                  this.ops.scaleY.onChange(value);
                }
              },
              particleColor: {
                get: function() {
                  return this.ops.color.current;
                },
                set: function(value) {
                  this.ops.color.onChange(value);
                }
              },
              colorEase: {
                get: function() {
                  return this.ops.color.easeName;
                },
                set: function(value) {
                  this.ops.color.setEase(value);
                }
              },
              particleTint: {
                get: function() {
                  return this.ops.tint.current;
                },
                set: function(value) {
                  this.ops.tint.onChange(value);
                }
              },
              particleAlpha: {
                get: function() {
                  return this.ops.alpha.current;
                },
                set: function(value) {
                  this.ops.alpha.onChange(value);
                }
              },
              lifespan: {
                get: function() {
                  return this.ops.lifespan.current;
                },
                set: function(value) {
                  this.ops.lifespan.onChange(value);
                }
              },
              particleAngle: {
                get: function() {
                  return this.ops.angle.current;
                },
                set: function(value) {
                  this.ops.angle.onChange(value);
                }
              },
              particleRotate: {
                get: function() {
                  return this.ops.rotate.current;
                },
                set: function(value) {
                  this.ops.rotate.onChange(value);
                }
              },
              quantity: {
                get: function() {
                  return this.ops.quantity.current;
                },
                set: function(value) {
                  this.ops.quantity.onChange(value);
                }
              },
              delay: {
                get: function() {
                  return this.ops.delay.current;
                },
                set: function(value) {
                  this.ops.delay.onChange(value);
                }
              },
              hold: {
                get: function() {
                  return this.ops.hold.current;
                },
                set: function(value) {
                  this.ops.hold.onChange(value);
                }
              },
              flowCounter: {
                get: function() {
                  return this.counters[0];
                },
                set: function(value) {
                  this.counters[0] = value;
                }
              },
              frameCounter: {
                get: function() {
                  return this.counters[1];
                },
                set: function(value) {
                  this.counters[1] = value;
                }
              },
              animCounter: {
                get: function() {
                  return this.counters[2];
                },
                set: function(value) {
                  this.counters[2] = value;
                }
              },
              elapsed: {
                get: function() {
                  return this.counters[3];
                },
                set: function(value) {
                  this.counters[3] = value;
                }
              },
              stopCounter: {
                get: function() {
                  return this.counters[4];
                },
                set: function(value) {
                  this.counters[4] = value;
                }
              },
              completeFlag: {
                get: function() {
                  return this.counters[5];
                },
                set: function(value) {
                  this.counters[5] = value;
                }
              },
              zoneIndex: {
                get: function() {
                  return this.counters[6];
                },
                set: function(value) {
                  this.counters[6] = value;
                }
              },
              zoneTotal: {
                get: function() {
                  return this.counters[7];
                },
                set: function(value) {
                  this.counters[7] = value;
                }
              },
              currentFrame: {
                get: function() {
                  return this.counters[8];
                },
                set: function(value) {
                  this.counters[8] = value;
                }
              },
              currentAnim: {
                get: function() {
                  return this.counters[9];
                },
                set: function(value) {
                  this.counters[9] = value;
                }
              },
              preDestroy: function() {
                this.texture = null;
                this.frames = null;
                this.anims = null;
                this.emitCallback = null;
                this.emitCallbackScope = null;
                this.deathCallback = null;
                this.deathCallbackScope = null;
                this.emitZones = null;
                this.deathZones = null;
                this.bounds = null;
                this.follow = null;
                this.counters = null;
                var i;
                var ops = this.ops;
                for (i = 0; i < configOpMap.length; i++) {
                  var key = configOpMap[i];
                  ops[key].destroy();
                }
                for (i = 0; i < this.alive.length; i++) {
                  this.alive[i].destroy();
                }
                for (i = 0; i < this.dead.length; i++) {
                  this.dead[i].destroy();
                }
                this.ops = null;
                this.alive = [];
                this.dead = [];
                this.worldMatrix.destroy();
              }
            });
            module2.exports = ParticleEmitter;
          },
          10456: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RectangleToRectangle = __webpack_require__2(90205);
            var TransformMatrix = __webpack_require__2(69360);
            var tempMatrix1 = new TransformMatrix();
            var tempMatrix2 = new TransformMatrix();
            var tempMatrix3 = new TransformMatrix();
            var tempMatrix4 = new TransformMatrix();
            var ParticleEmitterCanvasRenderer = function(renderer, emitter, camera, parentMatrix) {
              var camMatrix = tempMatrix1;
              var calcMatrix = tempMatrix2;
              var particleMatrix = tempMatrix3;
              var managerMatrix = tempMatrix4;
              if (parentMatrix) {
                managerMatrix.loadIdentity();
                managerMatrix.multiply(parentMatrix);
                managerMatrix.translate(emitter.x, emitter.y);
                managerMatrix.rotate(emitter.rotation);
                managerMatrix.scale(emitter.scaleX, emitter.scaleY);
              } else {
                managerMatrix.applyITRS(emitter.x, emitter.y, emitter.rotation, emitter.scaleX, emitter.scaleY);
              }
              var ctx = renderer.currentContext;
              var roundPixels = camera.roundPixels;
              var camerAlpha = camera.alpha;
              var emitterAlpha = emitter.alpha;
              var particles = emitter.alive;
              var particleCount = particles.length;
              var viewBounds = emitter.viewBounds;
              if (!emitter.visible || particleCount === 0 || viewBounds && !RectangleToRectangle(viewBounds, camera.worldView)) {
                return;
              }
              if (emitter.sortCallback) {
                emitter.depthSort();
              }
              camera.addToRenderList(emitter);
              var scrollFactorX = emitter.scrollFactorX;
              var scrollFactorY = emitter.scrollFactorY;
              ctx.save();
              ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];
              for (var i = 0; i < particleCount; i++) {
                var particle = particles[i];
                var alpha = particle.alpha * emitterAlpha * camerAlpha;
                if (alpha <= 0 || particle.scaleX === 0 || particle.scaleY === 0) {
                  continue;
                }
                particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
                camMatrix.copyFrom(camera.matrix);
                camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
                particleMatrix.e = particle.x;
                particleMatrix.f = particle.y;
                camMatrix.multiply(particleMatrix, calcMatrix);
                var frame = particle.frame;
                var cd = frame.canvasData;
                if (cd.width > 0 && cd.height > 0) {
                  var x = -frame.halfWidth;
                  var y = -frame.halfHeight;
                  ctx.globalAlpha = alpha;
                  ctx.save();
                  calcMatrix.setToContext(ctx);
                  if (roundPixels) {
                    x = Math.round(x);
                    y = Math.round(y);
                  }
                  ctx.imageSmoothingEnabled = !frame.source.scaleMode;
                  ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
                  ctx.restore();
                }
              }
              ctx.restore();
            };
            module2.exports = ParticleEmitterCanvasRenderer;
          },
          765: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetFastValue = __webpack_require__2(72632);
            var ParticleEmitter = __webpack_require__2(9216);
            GameObjectCreator.register("particles", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var emitterConfig = GetFastValue(config2, "config", null);
              var emitter = new ParticleEmitter(this.scene, 0, 0, key);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, emitter, config2);
              if (emitterConfig) {
                emitter.setConfig(emitterConfig);
              }
              return emitter;
            });
          },
          81212: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var ParticleEmitter = __webpack_require__2(9216);
            GameObjectFactory.register("particles", function(x, y, texture, config2) {
              if (x !== void 0 && typeof x === "string") {
                console.warn("ParticleEmitterManager was removed in Phaser 3.60. See documentation for details");
              }
              return this.displayList.add(new ParticleEmitter(this.scene, x, y, texture, config2));
            });
          },
          69116: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(10275);
            }
            if (true) {
              renderCanvas = __webpack_require__2(10456);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          10275: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RectangleToRectangle = __webpack_require__2(90205);
            var TransformMatrix = __webpack_require__2(69360);
            var Utils = __webpack_require__2(75512);
            var tempMatrix1 = new TransformMatrix();
            var tempMatrix2 = new TransformMatrix();
            var tempMatrix3 = new TransformMatrix();
            var tempMatrix4 = new TransformMatrix();
            var ParticleEmitterWebGLRenderer = function(renderer, emitter, camera, parentMatrix) {
              var pipeline = renderer.pipelines.set(emitter.pipeline);
              var camMatrix = tempMatrix1;
              var calcMatrix = tempMatrix2;
              var particleMatrix = tempMatrix3;
              var managerMatrix = tempMatrix4;
              if (parentMatrix) {
                managerMatrix.loadIdentity();
                managerMatrix.multiply(parentMatrix);
                managerMatrix.translate(emitter.x, emitter.y);
                managerMatrix.rotate(emitter.rotation);
                managerMatrix.scale(emitter.scaleX, emitter.scaleY);
              } else {
                managerMatrix.applyITRS(emitter.x, emitter.y, emitter.rotation, emitter.scaleX, emitter.scaleY);
              }
              var getTint = Utils.getTintAppendFloatAlpha;
              var camerAlpha = camera.alpha;
              var emitterAlpha = emitter.alpha;
              renderer.pipelines.preBatch(emitter);
              var particles = emitter.alive;
              var particleCount = particles.length;
              var viewBounds = emitter.viewBounds;
              if (particleCount === 0 || viewBounds && !RectangleToRectangle(viewBounds, camera.worldView)) {
                return;
              }
              if (emitter.sortCallback) {
                emitter.depthSort();
              }
              camera.addToRenderList(emitter);
              camMatrix.copyFrom(camera.matrix);
              camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * emitter.scrollFactorX, -camera.scrollY * emitter.scrollFactorY);
              renderer.setBlendMode(emitter.blendMode);
              if (emitter.mask) {
                emitter.mask.preRenderWebGL(renderer, emitter, camera);
                renderer.pipelines.set(emitter.pipeline);
              }
              var tintEffect = emitter.tintFill;
              var textureUnit;
              var glTexture;
              for (var i = 0; i < particleCount; i++) {
                var particle = particles[i];
                var alpha = particle.alpha * emitterAlpha * camerAlpha;
                if (alpha <= 0 || particle.scaleX === 0 || particle.scaleY === 0) {
                  continue;
                }
                particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
                particleMatrix.e = particle.x;
                particleMatrix.f = particle.y;
                camMatrix.multiply(particleMatrix, calcMatrix);
                var frame = particle.frame;
                if (frame.glTexture !== glTexture) {
                  glTexture = frame.glTexture;
                  textureUnit = pipeline.setGameObject(emitter, frame);
                }
                var x = -frame.halfWidth;
                var y = -frame.halfHeight;
                var quad = calcMatrix.setQuad(x, y, x + frame.width, y + frame.height);
                var tint = getTint(particle.tint, alpha);
                if (pipeline.shouldFlush(6)) {
                  pipeline.flush();
                  textureUnit = pipeline.setGameObject(emitter, frame);
                }
                pipeline.batchQuad(emitter, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, glTexture, textureUnit);
              }
              if (emitter.mask) {
                emitter.mask.postRenderWebGL(renderer, camera);
              }
              renderer.pipelines.postBatch(emitter);
            };
            module2.exports = ParticleEmitterWebGLRenderer;
          },
          30891: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ParticleProcessor = new Class({
              initialize: function ParticleProcessor2(x, y, active) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (active === void 0) {
                  active = true;
                }
                this.emitter;
                this.x = x;
                this.y = y;
                this.active = active;
              },
              update: function() {
              },
              destroy: function() {
                this.emitter = null;
              }
            });
            module2.exports = ParticleProcessor;
          },
          76100: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "complete";
          },
          26677: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "deathzone";
          },
          62736: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "explode";
          },
          56490: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "start";
          },
          85715: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "stop";
          },
          40629: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              COMPLETE: __webpack_require__2(76100),
              DEATH_ZONE: __webpack_require__2(26677),
              EXPLODE: __webpack_require__2(62736),
              START: __webpack_require__2(56490),
              STOP: __webpack_require__2(85715)
            };
          },
          27684: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              EmitterColorOp: __webpack_require__2(19737),
              EmitterOp: __webpack_require__2(93025),
              Events: __webpack_require__2(40629),
              GravityWell: __webpack_require__2(87811),
              Particle: __webpack_require__2(14909),
              ParticleBounds: __webpack_require__2(73106),
              ParticleEmitter: __webpack_require__2(9216),
              ParticleProcessor: __webpack_require__2(30891),
              Zones: __webpack_require__2(25962)
            };
          },
          69361: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var DeathZone = new Class({
              initialize: function DeathZone2(source, killOnEnter) {
                this.source = source;
                this.killOnEnter = killOnEnter;
              },
              willKill: function(particle) {
                var pos = particle.worldPosition;
                var withinZone = this.source.contains(pos.x, pos.y);
                return withinZone && this.killOnEnter || !withinZone && !this.killOnEnter;
              }
            });
            module2.exports = DeathZone;
          },
          54213: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EdgeZone = new Class({
              initialize: function EdgeZone2(source, quantity, stepRate, yoyo, seamless, total) {
                if (yoyo === void 0) {
                  yoyo = false;
                }
                if (seamless === void 0) {
                  seamless = true;
                }
                if (total === void 0) {
                  total = -1;
                }
                this.source = source;
                this.points = [];
                this.quantity = quantity;
                this.stepRate = stepRate;
                this.yoyo = yoyo;
                this.counter = -1;
                this.seamless = seamless;
                this._length = 0;
                this._direction = 0;
                this.total = total;
                this.updateSource();
              },
              updateSource: function() {
                this.points = this.source.getPoints(this.quantity, this.stepRate);
                if (this.seamless) {
                  var a = this.points[0];
                  var b = this.points[this.points.length - 1];
                  if (a.x === b.x && a.y === b.y) {
                    this.points.pop();
                  }
                }
                var oldLength = this._length;
                this._length = this.points.length;
                if (this._length < oldLength && this.counter > this._length) {
                  this.counter = this._length - 1;
                }
                return this;
              },
              changeSource: function(source) {
                this.source = source;
                return this.updateSource();
              },
              getPoint: function(particle) {
                if (this._direction === 0) {
                  this.counter++;
                  if (this.counter >= this._length) {
                    if (this.yoyo) {
                      this._direction = 1;
                      this.counter = this._length - 1;
                    } else {
                      this.counter = 0;
                    }
                  }
                } else {
                  this.counter--;
                  if (this.counter === -1) {
                    if (this.yoyo) {
                      this._direction = 0;
                      this.counter = 0;
                    } else {
                      this.counter = this._length - 1;
                    }
                  }
                }
                var point = this.points[this.counter];
                if (point) {
                  particle.x = point.x;
                  particle.y = point.y;
                }
              }
            });
            module2.exports = EdgeZone;
          },
          68433: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Vector2 = __webpack_require__2(93736);
            var RandomZone = new Class({
              initialize: function RandomZone2(source) {
                this.source = source;
                this._tempVec = new Vector2();
                this.total = -1;
              },
              getPoint: function(particle) {
                var vec = this._tempVec;
                this.source.getRandomPoint(vec);
                particle.x = vec.x;
                particle.y = vec.y;
              }
            });
            module2.exports = RandomZone;
          },
          25962: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              DeathZone: __webpack_require__2(69361),
              EdgeZone: __webpack_require__2(54213),
              RandomZone: __webpack_require__2(68433)
            };
          },
          29598: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var Sprite = __webpack_require__2(13747);
            var PathFollower = new Class({
              Extends: Sprite,
              Mixins: [
                Components.PathFollower
              ],
              initialize: function PathFollower2(scene, path, x, y, texture, frame) {
                Sprite.call(this, scene, x, y, texture, frame);
                this.path = path;
              },
              preUpdate: function(time, delta) {
                this.anims.update(time, delta);
                this.pathUpdate(time);
              }
            });
            module2.exports = PathFollower;
          },
          19626: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var PathFollower = __webpack_require__2(29598);
            GameObjectFactory.register("follower", function(path, x, y, key, frame) {
              var sprite = new PathFollower(this.scene, path, x, y, key, frame);
              this.displayList.add(sprite);
              this.updateList.add(sprite);
              return sprite;
            });
          },
          33412: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AnimationState = __webpack_require__2(16569);
            var Class = __webpack_require__2(56694);
            var GenerateGridVerts = __webpack_require__2(99425);
            var IntegerToRGB = __webpack_require__2(15978);
            var Mesh = __webpack_require__2(83321);
            var UUID = __webpack_require__2(76583);
            var Plane = new Class({
              Extends: Mesh,
              initialize: function Plane2(scene, x, y, texture, frame, width, height, tile) {
                if (!texture) {
                  texture = "__DEFAULT";
                }
                Mesh.call(this, scene, x, y, texture, frame);
                this.type = "Plane";
                this.anims = new AnimationState(this);
                this.gridWidth;
                this.gridHeight;
                this.isTiled;
                this._checkerboard = null;
                this.hideCCW = false;
                this.setGridSize(width, height, tile);
                this.setSizeToFrame(false);
                this.setViewHeight();
              },
              originX: {
                get: function() {
                  return 0.5;
                }
              },
              originY: {
                get: function() {
                  return 0.5;
                }
              },
              setGridSize: function(width, height, tile) {
                if (width === void 0) {
                  width = 8;
                }
                if (height === void 0) {
                  height = 8;
                }
                if (tile === void 0) {
                  tile = false;
                }
                var flipY = false;
                if (tile) {
                  flipY = true;
                }
                this.gridWidth = width;
                this.gridHeight = height;
                this.isTiled = tile;
                this.clear();
                GenerateGridVerts({
                  mesh: this,
                  widthSegments: width,
                  heightSegments: height,
                  isOrtho: false,
                  tile,
                  flipY
                });
                return this;
              },
              setSizeToFrame: function(resetUV) {
                if (resetUV === void 0) {
                  resetUV = true;
                }
                var frame = this.frame;
                this.setPerspective(this.width / frame.width, this.height / frame.height);
                if (this._checkerboard && this._checkerboard !== this.texture) {
                  this.removeCheckerboard();
                }
                if (!resetUV) {
                  return this;
                }
                var gridX = this.gridWidth;
                var gridY = this.gridHeight;
                var verts = this.vertices;
                var frameU0 = frame.u0;
                var frameU1 = frame.u1;
                var frameV0 = frame.v0;
                var frameV1 = frame.v1;
                var x;
                var y;
                var i = 0;
                if (this.isTiled) {
                  frameV0 = frame.v1;
                  frameV1 = frame.v0;
                  for (y = 0; y < gridY; y++) {
                    for (x = 0; x < gridX; x++) {
                      verts[i++].setUVs(frameU0, frameV1);
                      verts[i++].setUVs(frameU0, frameV0);
                      verts[i++].setUVs(frameU1, frameV1);
                      verts[i++].setUVs(frameU0, frameV0);
                      verts[i++].setUVs(frameU1, frameV0);
                      verts[i++].setUVs(frameU1, frameV1);
                    }
                  }
                } else {
                  var gridX1 = gridX + 1;
                  var gridY1 = gridY + 1;
                  var frameU = frameU1 - frameU0;
                  var frameV = frameV1 - frameV0;
                  var uvs = [];
                  for (y = 0; y < gridY1; y++) {
                    for (x = 0; x < gridX1; x++) {
                      var tu = frameU0 + frameU * (x / gridX);
                      var tv = frameV0 + frameV * (y / gridY);
                      uvs.push(tu, tv);
                    }
                  }
                  for (y = 0; y < gridY; y++) {
                    for (x = 0; x < gridX; x++) {
                      var a = (x + gridX1 * y) * 2;
                      var b = (x + gridX1 * (y + 1)) * 2;
                      var c = (x + 1 + gridX1 * (y + 1)) * 2;
                      var d = (x + 1 + gridX1 * y) * 2;
                      verts[i++].setUVs(uvs[a], uvs[a + 1]);
                      verts[i++].setUVs(uvs[b], uvs[b + 1]);
                      verts[i++].setUVs(uvs[d], uvs[d + 1]);
                      verts[i++].setUVs(uvs[b], uvs[b + 1]);
                      verts[i++].setUVs(uvs[c], uvs[c + 1]);
                      verts[i++].setUVs(uvs[d], uvs[d + 1]);
                    }
                  }
                }
                return this;
              },
              setViewHeight: function(value) {
                if (value === void 0) {
                  value = this.frame.height;
                }
                var vFOV = this.fov * (Math.PI / 180);
                this.viewPosition.z = this.height / value / Math.tan(vFOV / 2);
                this.dirtyCache[10] = 1;
              },
              createCheckerboard: function(color1, color2, alpha1, alpha2, height) {
                if (color1 === void 0) {
                  color1 = 16777215;
                }
                if (color2 === void 0) {
                  color2 = 255;
                }
                if (alpha1 === void 0) {
                  alpha1 = 255;
                }
                if (alpha2 === void 0) {
                  alpha2 = 255;
                }
                if (height === void 0) {
                  height = 128;
                }
                var gl = this.scene.sys.renderer.gl;
                var glTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                var c1 = IntegerToRGB(color1);
                var c2 = IntegerToRGB(color2);
                var colors = [];
                for (var h = 0; h < 16; h++) {
                  for (var w = 0; w < 16; w++) {
                    if (h < 8 && w < 8 || h > 7 && w > 7) {
                      colors.push(c1.r, c1.g, c1.b, alpha1);
                    } else {
                      colors.push(c2.r, c2.g, c2.b, alpha2);
                    }
                  }
                }
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(colors));
                glTexture.isAlphaPremultiplied = true;
                glTexture.isRenderTexture = false;
                glTexture.width = 16;
                glTexture.height = 16;
                var texture = this.scene.sys.textures.addGLTexture(UUID(), glTexture, 16, 16);
                this.removeCheckerboard();
                this._checkerboard = texture;
                gl.bindTexture(gl.TEXTURE_2D, null);
                this.setTexture(texture);
                this.setSizeToFrame();
                this.setViewHeight(height);
                return this;
              },
              removeCheckerboard: function() {
                if (this._checkerboard) {
                  this._checkerboard.destroy();
                  this._checkerboard = null;
                }
              },
              play: function(key, ignoreIfPlaying) {
                return this.anims.play(key, ignoreIfPlaying);
              },
              playReverse: function(key, ignoreIfPlaying) {
                return this.anims.playReverse(key, ignoreIfPlaying);
              },
              playAfterDelay: function(key, delay) {
                return this.anims.playAfterDelay(key, delay);
              },
              playAfterRepeat: function(key, repeatCount) {
                return this.anims.playAfterRepeat(key, repeatCount);
              },
              stop: function() {
                return this.anims.stop();
              },
              stopAfterDelay: function(delay) {
                return this.anims.stopAfterDelay(delay);
              },
              stopAfterRepeat: function(repeatCount) {
                return this.anims.stopAfterRepeat(repeatCount);
              },
              stopOnFrame: function(frame) {
                return this.anims.stopOnFrame(frame);
              },
              preUpdate: function(time, delta) {
                Mesh.prototype.preUpdate.call(this, time, delta);
                this.anims.update(time, delta);
              },
              preDestroy: function() {
                this.clear();
                this.removeCheckerboard();
                this.anims.destroy();
                this.anims = void 0;
                this.debugCallback = null;
                this.debugGraphic = null;
              }
            });
            module2.exports = Plane;
          },
          10912: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var BuildGameObjectAnimation = __webpack_require__2(32291);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetValue = __webpack_require__2(10850);
            var Plane = __webpack_require__2(33412);
            GameObjectCreator.register("plane", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var frame = GetAdvancedValue(config2, "frame", null);
              var width = GetValue(config2, "width", 8);
              var height = GetValue(config2, "height", 8);
              var tile = GetValue(config2, "tile", false);
              var plane = new Plane(this.scene, 0, 0, key, frame, width, height, tile);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              var checkerboard = GetValue(config2, "checkerboard", null);
              if (checkerboard) {
                var color1 = GetValue(checkerboard, "color1", 16777215);
                var color2 = GetValue(checkerboard, "color2", 255);
                var alpha1 = GetValue(checkerboard, "alpha1", 255);
                var alpha2 = GetValue(checkerboard, "alpha2", 255);
                var checkheight = GetValue(checkerboard, "height", 128);
                plane.createCheckerboard(color1, color2, alpha1, alpha2, checkheight);
              }
              BuildGameObject(this.scene, plane, config2);
              BuildGameObjectAnimation(plane, config2);
              return plane;
            });
          },
          58322: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Plane = __webpack_require__2(33412);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("plane", function(x, y, texture, frame, width, height, tile) {
              return this.displayList.add(new Plane(this.scene, x, y, texture, frame, width, height, tile));
            });
          },
          13171: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var IntegerToColor = __webpack_require__2(74853);
            var PIPELINES_CONST = __webpack_require__2(65641);
            var Render = __webpack_require__2(71606);
            var PointLight = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Transform,
                Components.Visible,
                Render
              ],
              initialize: function PointLight2(scene, x, y, color, radius, intensity, attenuation) {
                if (color === void 0) {
                  color = 16777215;
                }
                if (radius === void 0) {
                  radius = 128;
                }
                if (intensity === void 0) {
                  intensity = 1;
                }
                if (attenuation === void 0) {
                  attenuation = 0.1;
                }
                GameObject.call(this, scene, "PointLight");
                this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE);
                this.initPostPipeline();
                this.setPosition(x, y);
                this.color = IntegerToColor(color);
                this.intensity = intensity;
                this.attenuation = attenuation;
                this.width = radius * 2;
                this.height = radius * 2;
                this._radius = radius;
              },
              radius: {
                get: function() {
                  return this._radius;
                },
                set: function(value) {
                  this._radius = value;
                  this.width = value * 2;
                  this.height = value * 2;
                }
              },
              originX: {
                get: function() {
                  return 0.5;
                }
              },
              originY: {
                get: function() {
                  return 0.5;
                }
              },
              displayOriginX: {
                get: function() {
                  return this._radius;
                }
              },
              displayOriginY: {
                get: function() {
                  return this._radius;
                }
              }
            });
            module2.exports = PointLight;
          },
          162: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var PointLight = __webpack_require__2(13171);
            GameObjectCreator.register("pointlight", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var color = GetAdvancedValue(config2, "color", 16777215);
              var radius = GetAdvancedValue(config2, "radius", 128);
              var intensity = GetAdvancedValue(config2, "intensity", 1);
              var attenuation = GetAdvancedValue(config2, "attenuation", 0.1);
              var layer = new PointLight(this.scene, 0, 0, color, radius, intensity, attenuation);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, layer, config2);
              return layer;
            });
          },
          91201: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var PointLight = __webpack_require__2(13171);
            GameObjectFactory.register("pointlight", function(x, y, color, radius, intensity, attenuation) {
              return this.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
            });
          },
          71606: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(80590);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          80590: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var PointLightWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              var width = src.width;
              var height = src.height;
              var x = -src._radius;
              var y = -src._radius;
              var xw = x + width;
              var yh = y + height;
              var lightX = calcMatrix.getX(0, 0);
              var lightY = calcMatrix.getY(0, 0);
              var tx0 = calcMatrix.getX(x, y);
              var ty0 = calcMatrix.getY(x, y);
              var tx1 = calcMatrix.getX(x, yh);
              var ty1 = calcMatrix.getY(x, yh);
              var tx2 = calcMatrix.getX(xw, yh);
              var ty2 = calcMatrix.getY(xw, yh);
              var tx3 = calcMatrix.getX(xw, y);
              var ty3 = calcMatrix.getY(xw, y);
              renderer.pipelines.preBatch(src);
              pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY);
              renderer.pipelines.postBatch(src);
            };
            module2.exports = PointLightWebGLRenderer;
          },
          15996: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var DynamicTexture = __webpack_require__2(845);
            var Image2 = __webpack_require__2(1539);
            var RenderTexture = new Class({
              Extends: Image2,
              initialize: function RenderTexture2(scene, x, y, width, height) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = 32;
                }
                if (height === void 0) {
                  height = 32;
                }
                var dynamicTexture = new DynamicTexture(scene.sys.textures, "", width, height);
                Image2.call(this, scene, x, y, dynamicTexture);
                this.type = "RenderTexture";
                this.camera = this.texture.camera;
                this._saved = false;
              },
              setSize: function(width, height) {
                this.width = width;
                this.height = height;
                this.texture.setSize(width, height);
                this.updateDisplayOrigin();
                var input = this.input;
                if (input && !input.customHitArea) {
                  input.hitArea.width = width;
                  input.hitArea.height = height;
                }
                return this;
              },
              resize: function(width, height) {
                this.setSize(width, height);
                return this;
              },
              saveTexture: function(key) {
                var texture = this.texture;
                texture.key = key;
                if (texture.manager.addDynamicTexture(texture)) {
                  this._saved = true;
                }
                return texture;
              },
              fill: function(rgb, alpha, x, y, width, height) {
                this.texture.fill(rgb, alpha, x, y, width, height);
                return this;
              },
              clear: function() {
                this.texture.clear();
                return this;
              },
              stamp: function(key, frame, x, y, config2) {
                this.texture.stamp(key, frame, x, y, config2);
                return this;
              },
              erase: function(entries, x, y) {
                this.texture.erase(entries, x, y);
                return this;
              },
              draw: function(entries, x, y, alpha, tint) {
                this.texture.draw(entries, x, y, alpha, tint);
                return this;
              },
              drawFrame: function(key, frame, x, y, alpha, tint) {
                this.texture.drawFrame(key, frame, x, y, alpha, tint);
                return this;
              },
              repeat: function(key, frame, x, y, width, height, alpha, tint, skipBatch) {
                this.texture.repeat(key, frame, x, y, width, height, alpha, tint, skipBatch);
                return this;
              },
              beginDraw: function() {
                this.texture.beginDraw();
                return this;
              },
              batchDraw: function(entries, x, y, alpha, tint) {
                this.texture.batchDraw(entries, x, y, alpha, tint);
                return this;
              },
              batchDrawFrame: function(key, frame, x, y, alpha, tint) {
                this.texture.batchDrawFrame(key, frame, x, y, alpha, tint);
                return this;
              },
              endDraw: function(erase) {
                this.texture.endDraw(erase);
                return this;
              },
              snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
                this.texture.snapshotArea(x, y, width, height, callback, type, encoderOptions);
                return this;
              },
              snapshot: function(callback, type, encoderOptions) {
                return this.snapshotArea(0, 0, this.width, this.height, callback, type, encoderOptions);
              },
              snapshotPixel: function(x, y, callback) {
                return this.snapshotArea(x, y, 1, 1, callback, "pixel");
              },
              preDestroy: function() {
                this.camera = null;
                if (!this._saved) {
                  this.texture.destroy();
                }
              }
            });
            module2.exports = RenderTexture;
          },
          85692: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var RenderTexture = __webpack_require__2(15996);
            GameObjectCreator.register("renderTexture", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var x = GetAdvancedValue(config2, "x", 0);
              var y = GetAdvancedValue(config2, "y", 0);
              var width = GetAdvancedValue(config2, "width", 32);
              var height = GetAdvancedValue(config2, "height", 32);
              var renderTexture = new RenderTexture(this.scene, x, y, width, height);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, renderTexture, config2);
              return renderTexture;
            });
          },
          29599: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var RenderTexture = __webpack_require__2(15996);
            GameObjectFactory.register("renderTexture", function(x, y, width, height) {
              return this.displayList.add(new RenderTexture(this.scene, x, y, width, height));
            });
          },
          79968: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AnimationState = __webpack_require__2(16569);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var PIPELINE_CONST = __webpack_require__2(65641);
            var RopeRender = __webpack_require__2(58912);
            var Vector2 = __webpack_require__2(93736);
            var Rope = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.Flip,
                Components.Mask,
                Components.Pipeline,
                Components.PostPipeline,
                Components.Size,
                Components.Texture,
                Components.Transform,
                Components.Visible,
                Components.ScrollFactor,
                RopeRender
              ],
              initialize: function Rope2(scene, x, y, texture, frame, points, horizontal, colors, alphas) {
                if (texture === void 0) {
                  texture = "__DEFAULT";
                }
                if (points === void 0) {
                  points = 2;
                }
                if (horizontal === void 0) {
                  horizontal = true;
                }
                GameObject.call(this, scene, "Rope");
                this.anims = new AnimationState(this);
                this.points = points;
                this.vertices;
                this.uv;
                this.colors;
                this.alphas;
                this.tintFill = texture === "__DEFAULT" ? true : false;
                this.dirty = false;
                this.horizontal = horizontal;
                this._flipX = false;
                this._flipY = false;
                this._perp = new Vector2();
                this.debugCallback = null;
                this.debugGraphic = null;
                this.setTexture(texture, frame);
                this.setPosition(x, y);
                this.setSizeToFrame();
                this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE);
                this.initPostPipeline();
                if (Array.isArray(points)) {
                  this.resizeArrays(points.length);
                }
                this.setPoints(points, colors, alphas);
                this.updateVertices();
              },
              addedToScene: function() {
                this.scene.sys.updateList.add(this);
              },
              removedFromScene: function() {
                this.scene.sys.updateList.remove(this);
              },
              preUpdate: function(time, delta) {
                var prevFrame = this.anims.currentFrame;
                this.anims.update(time, delta);
                if (this.anims.currentFrame !== prevFrame) {
                  this.updateUVs();
                  this.updateVertices();
                }
              },
              play: function(key, ignoreIfPlaying, startFrame) {
                this.anims.play(key, ignoreIfPlaying, startFrame);
                return this;
              },
              setDirty: function() {
                this.dirty = true;
                return this;
              },
              setHorizontal: function(points, colors, alphas) {
                if (points === void 0) {
                  points = this.points.length;
                }
                if (this.horizontal) {
                  return this;
                }
                this.horizontal = true;
                return this.setPoints(points, colors, alphas);
              },
              setVertical: function(points, colors, alphas) {
                if (points === void 0) {
                  points = this.points.length;
                }
                if (!this.horizontal) {
                  return this;
                }
                this.horizontal = false;
                return this.setPoints(points, colors, alphas);
              },
              setTintFill: function(value) {
                if (value === void 0) {
                  value = false;
                }
                this.tintFill = value;
                return this;
              },
              setAlphas: function(alphas, bottomAlpha) {
                var total = this.points.length;
                if (total < 1) {
                  return this;
                }
                var currentAlphas = this.alphas;
                if (alphas === void 0) {
                  alphas = [1];
                } else if (!Array.isArray(alphas) && bottomAlpha === void 0) {
                  alphas = [alphas];
                }
                var i;
                var index = 0;
                if (bottomAlpha !== void 0) {
                  for (i = 0; i < total; i++) {
                    index = i * 2;
                    currentAlphas[index] = alphas;
                    currentAlphas[index + 1] = bottomAlpha;
                  }
                } else if (alphas.length === total) {
                  for (i = 0; i < total; i++) {
                    index = i * 2;
                    currentAlphas[index] = alphas[i];
                    currentAlphas[index + 1] = alphas[i];
                  }
                } else {
                  var prevAlpha = alphas[0];
                  for (i = 0; i < total; i++) {
                    index = i * 2;
                    if (alphas.length > index) {
                      prevAlpha = alphas[index];
                    }
                    currentAlphas[index] = prevAlpha;
                    if (alphas.length > index + 1) {
                      prevAlpha = alphas[index + 1];
                    }
                    currentAlphas[index + 1] = prevAlpha;
                  }
                }
                return this;
              },
              setColors: function(colors) {
                var total = this.points.length;
                if (total < 1) {
                  return this;
                }
                var currentColors = this.colors;
                if (colors === void 0) {
                  colors = [16777215];
                } else if (!Array.isArray(colors)) {
                  colors = [colors];
                }
                var i;
                var index = 0;
                if (colors.length === total) {
                  for (i = 0; i < total; i++) {
                    index = i * 2;
                    currentColors[index] = colors[i];
                    currentColors[index + 1] = colors[i];
                  }
                } else {
                  var prevColor = colors[0];
                  for (i = 0; i < total; i++) {
                    index = i * 2;
                    if (colors.length > index) {
                      prevColor = colors[index];
                    }
                    currentColors[index] = prevColor;
                    if (colors.length > index + 1) {
                      prevColor = colors[index + 1];
                    }
                    currentColors[index + 1] = prevColor;
                  }
                }
                return this;
              },
              setPoints: function(points, colors, alphas) {
                if (points === void 0) {
                  points = 2;
                }
                if (typeof points === "number") {
                  var segments = points;
                  if (segments < 2) {
                    segments = 2;
                  }
                  points = [];
                  var s;
                  var frameSegment;
                  var offset;
                  if (this.horizontal) {
                    offset = -this.frame.halfWidth;
                    frameSegment = this.frame.width / (segments - 1);
                    for (s = 0; s < segments; s++) {
                      points.push({x: offset + s * frameSegment, y: 0});
                    }
                  } else {
                    offset = -this.frame.halfHeight;
                    frameSegment = this.frame.height / (segments - 1);
                    for (s = 0; s < segments; s++) {
                      points.push({x: 0, y: offset + s * frameSegment});
                    }
                  }
                }
                var total = points.length;
                var currentTotal = this.points.length;
                if (total < 1) {
                  console.warn("Rope: Not enough points given");
                  return this;
                } else if (total === 1) {
                  points.unshift({x: 0, y: 0});
                  total++;
                }
                if (currentTotal !== total) {
                  this.resizeArrays(total);
                }
                this.dirty = true;
                this.points = points;
                this.updateUVs();
                if (colors !== void 0 && colors !== null) {
                  this.setColors(colors);
                }
                if (alphas !== void 0 && alphas !== null) {
                  this.setAlphas(alphas);
                }
                return this;
              },
              updateUVs: function() {
                var currentUVs = this.uv;
                var total = this.points.length;
                var u0 = this.frame.u0;
                var v0 = this.frame.v0;
                var u1 = this.frame.u1;
                var v1 = this.frame.v1;
                var partH = (u1 - u0) / (total - 1);
                var partV = (v1 - v0) / (total - 1);
                for (var i = 0; i < total; i++) {
                  var index = i * 4;
                  var uv0;
                  var uv1;
                  var uv2;
                  var uv3;
                  if (this.horizontal) {
                    if (this._flipX) {
                      uv0 = u1 - i * partH;
                      uv2 = u1 - i * partH;
                    } else {
                      uv0 = u0 + i * partH;
                      uv2 = u0 + i * partH;
                    }
                    if (this._flipY) {
                      uv1 = v1;
                      uv3 = v0;
                    } else {
                      uv1 = v0;
                      uv3 = v1;
                    }
                  } else {
                    if (this._flipX) {
                      uv0 = u0;
                      uv2 = u1;
                    } else {
                      uv0 = u1;
                      uv2 = u0;
                    }
                    if (this._flipY) {
                      uv1 = v1 - i * partV;
                      uv3 = v1 - i * partV;
                    } else {
                      uv1 = v0 + i * partV;
                      uv3 = v0 + i * partV;
                    }
                  }
                  currentUVs[index + 0] = uv0;
                  currentUVs[index + 1] = uv1;
                  currentUVs[index + 2] = uv2;
                  currentUVs[index + 3] = uv3;
                }
                return this;
              },
              resizeArrays: function(newSize) {
                var colors = this.colors;
                var alphas = this.alphas;
                this.vertices = new Float32Array(newSize * 4);
                this.uv = new Float32Array(newSize * 4);
                colors = new Uint32Array(newSize * 2);
                alphas = new Float32Array(newSize * 2);
                for (var i = 0; i < newSize * 2; i++) {
                  colors[i] = 16777215;
                  alphas[i] = 1;
                }
                this.colors = colors;
                this.alphas = alphas;
                this.dirty = true;
                return this;
              },
              updateVertices: function() {
                var perp = this._perp;
                var points = this.points;
                var vertices = this.vertices;
                var total = points.length;
                this.dirty = false;
                if (total < 1) {
                  return;
                }
                var nextPoint;
                var lastPoint = points[0];
                var frameSize = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth;
                for (var i = 0; i < total; i++) {
                  var point = points[i];
                  var index = i * 4;
                  if (i < total - 1) {
                    nextPoint = points[i + 1];
                  } else {
                    nextPoint = point;
                  }
                  perp.x = nextPoint.y - lastPoint.y;
                  perp.y = -(nextPoint.x - lastPoint.x);
                  var perpLength = perp.length();
                  perp.x /= perpLength;
                  perp.y /= perpLength;
                  perp.x *= frameSize;
                  perp.y *= frameSize;
                  vertices[index] = point.x + perp.x;
                  vertices[index + 1] = point.y + perp.y;
                  vertices[index + 2] = point.x - perp.x;
                  vertices[index + 3] = point.y - perp.y;
                  lastPoint = point;
                }
                return this;
              },
              setDebug: function(graphic, callback) {
                this.debugGraphic = graphic;
                if (!graphic && !callback) {
                  this.debugCallback = null;
                } else if (!callback) {
                  this.debugCallback = this.renderDebugVerts;
                } else {
                  this.debugCallback = callback;
                }
                return this;
              },
              renderDebugVerts: function(src, meshLength, verts) {
                var graphic = src.debugGraphic;
                var px0 = verts[0];
                var py0 = verts[1];
                var px1 = verts[2];
                var py1 = verts[3];
                graphic.lineBetween(px0, py0, px1, py1);
                for (var i = 4; i < meshLength; i += 4) {
                  var x0 = verts[i + 0];
                  var y0 = verts[i + 1];
                  var x1 = verts[i + 2];
                  var y1 = verts[i + 3];
                  graphic.lineBetween(px0, py0, x0, y0);
                  graphic.lineBetween(px1, py1, x1, y1);
                  graphic.lineBetween(px1, py1, x0, y0);
                  graphic.lineBetween(x0, y0, x1, y1);
                  px0 = x0;
                  py0 = y0;
                  px1 = x1;
                  py1 = y1;
                }
              },
              preDestroy: function() {
                this.anims.destroy();
                this.anims = void 0;
                this.points = null;
                this.vertices = null;
                this.uv = null;
                this.colors = null;
                this.alphas = null;
                this.debugCallback = null;
                this.debugGraphic = null;
              },
              flipX: {
                get: function() {
                  return this._flipX;
                },
                set: function(value) {
                  this._flipX = value;
                  return this.updateUVs();
                }
              },
              flipY: {
                get: function() {
                  return this._flipY;
                },
                set: function(value) {
                  this._flipY = value;
                  return this.updateUVs();
                }
              }
            });
            module2.exports = Rope;
          },
          44598: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RopeCanvasRenderer = function() {
            };
            module2.exports = RopeCanvasRenderer;
          },
          96027: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetValue = __webpack_require__2(10850);
            var Rope = __webpack_require__2(79968);
            GameObjectCreator.register("rope", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var frame = GetAdvancedValue(config2, "frame", null);
              var horizontal = GetAdvancedValue(config2, "horizontal", true);
              var points = GetValue(config2, "points", void 0);
              var colors = GetValue(config2, "colors", void 0);
              var alphas = GetValue(config2, "alphas", void 0);
              var rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, alphas);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, rope, config2);
              return rope;
            });
          },
          31982: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rope = __webpack_require__2(79968);
            var GameObjectFactory = __webpack_require__2(61286);
            if (true) {
              GameObjectFactory.register("rope", function(x, y, texture, frame, points, horizontal, colors, alphas) {
                return this.displayList.add(new Rope(this.scene, x, y, texture, frame, points, horizontal, colors, alphas));
              });
            }
          },
          58912: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(49489);
            }
            if (true) {
              renderCanvas = __webpack_require__2(44598);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          49489: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var Utils = __webpack_require__2(75512);
            var RopeWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              var vertices = src.vertices;
              var uvs = src.uv;
              var colors = src.colors;
              var alphas = src.alphas;
              var alpha = src.alpha;
              var getTint = Utils.getTintAppendFloatAlpha;
              var roundPixels = camera.roundPixels;
              var meshVerticesLength = vertices.length;
              var vertexCount = Math.floor(meshVerticesLength * 0.5);
              pipeline.flush();
              renderer.pipelines.preBatch(src);
              var textureUnit = pipeline.setGameObject(src);
              var vertexViewF32 = pipeline.vertexViewF32;
              var vertexViewU32 = pipeline.vertexViewU32;
              var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
              var colorIndex = 0;
              var tintEffect = src.tintFill;
              if (src.dirty) {
                src.updateVertices();
              }
              var debugCallback = src.debugCallback;
              var debugVerts = [];
              for (var i = 0; i < meshVerticesLength; i += 2) {
                var x = vertices[i + 0];
                var y = vertices[i + 1];
                var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;
                var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;
                if (roundPixels) {
                  tx = Math.round(tx);
                  ty = Math.round(ty);
                }
                vertexViewF32[++vertexOffset] = tx;
                vertexViewF32[++vertexOffset] = ty;
                vertexViewF32[++vertexOffset] = uvs[i + 0];
                vertexViewF32[++vertexOffset] = uvs[i + 1];
                vertexViewF32[++vertexOffset] = textureUnit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha));
                colorIndex++;
                if (debugCallback) {
                  debugVerts[i + 0] = tx;
                  debugVerts[i + 1] = ty;
                }
              }
              if (debugCallback) {
                debugCallback.call(src, src, meshVerticesLength, debugVerts);
              }
              pipeline.vertexCount += vertexCount;
              pipeline.currentBatch.count = pipeline.vertexCount - pipeline.currentBatch.start;
              renderer.pipelines.postBatch(src);
            };
            module2.exports = RopeWebGLRenderer;
          },
          27902: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var GetFastValue = __webpack_require__2(72632);
            var Extend = __webpack_require__2(98611);
            var SetValue = __webpack_require__2(22440);
            var ShaderRender = __webpack_require__2(24252);
            var TransformMatrix = __webpack_require__2(69360);
            var Shader = new Class({
              Extends: GameObject,
              Mixins: [
                Components.ComputedSize,
                Components.Depth,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.ScrollFactor,
                Components.Transform,
                Components.Visible,
                ShaderRender
              ],
              initialize: function Shader2(scene, key, x, y, width, height, textures, textureData) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = 128;
                }
                if (height === void 0) {
                  height = 128;
                }
                GameObject.call(this, scene, "Shader");
                this.blendMode = -1;
                this.shader;
                var renderer = scene.sys.renderer;
                this.renderer = renderer;
                this.gl = renderer.gl;
                this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));
                this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);
                this.program = null;
                this.bytes = new Uint8Array(this.vertexData);
                this.vertexViewF32 = new Float32Array(this.vertexData);
                this._tempMatrix1 = new TransformMatrix();
                this._tempMatrix2 = new TransformMatrix();
                this._tempMatrix3 = new TransformMatrix();
                this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                this.uniforms = {};
                this.pointer = null;
                this._rendererWidth = renderer.width;
                this._rendererHeight = renderer.height;
                this._textureCount = 0;
                this.framebuffer = null;
                this.glTexture = null;
                this.renderToTexture = false;
                this.texture = null;
                this.setPosition(x, y);
                this.setSize(width, height);
                this.setOrigin(0.5, 0.5);
                this.setShader(key, textures, textureData);
              },
              willRender: function(camera) {
                if (this.renderToTexture) {
                  return true;
                } else {
                  return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
                }
              },
              setRenderToTexture: function(key, flipY) {
                if (flipY === void 0) {
                  flipY = false;
                }
                if (!this.renderToTexture) {
                  var width = this.width;
                  var height = this.height;
                  var renderer = this.renderer;
                  this.glTexture = renderer.createTextureFromSource(null, width, height, 0);
                  this.glTexture.flipY = flipY;
                  this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);
                  this._rendererWidth = width;
                  this._rendererHeight = height;
                  this.renderToTexture = true;
                  this.projOrtho(0, this.width, this.height, 0);
                  if (key) {
                    this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);
                  }
                }
                if (this.shader) {
                  renderer.pipelines.clear();
                  this.load();
                  this.flush();
                  renderer.pipelines.rebind();
                }
                return this;
              },
              setShader: function(key, textures, textureData) {
                if (textures === void 0) {
                  textures = [];
                }
                if (typeof key === "string") {
                  var cache = this.scene.sys.cache.shader;
                  if (!cache.has(key)) {
                    console.warn("Shader missing: " + key);
                    return this;
                  }
                  this.shader = cache.get(key);
                } else {
                  this.shader = key;
                }
                var gl = this.gl;
                var renderer = this.renderer;
                if (this.program) {
                  gl.deleteProgram(this.program);
                }
                var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
                gl.uniformMatrix4fv(gl.getUniformLocation(program, "uViewMatrix"), false, this.viewMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
                gl.uniform2f(gl.getUniformLocation(program, "uResolution"), this.width, this.height);
                this.program = program;
                var d = new Date();
                var defaultUniforms = {
                  resolution: {type: "2f", value: {x: this.width, y: this.height}},
                  time: {type: "1f", value: 0},
                  mouse: {type: "2f", value: {x: this.width / 2, y: this.height / 2}},
                  date: {type: "4fv", value: [d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds()]},
                  sampleRate: {type: "1f", value: 44100},
                  iChannel0: {type: "sampler2D", value: null, textureData: {repeat: true}},
                  iChannel1: {type: "sampler2D", value: null, textureData: {repeat: true}},
                  iChannel2: {type: "sampler2D", value: null, textureData: {repeat: true}},
                  iChannel3: {type: "sampler2D", value: null, textureData: {repeat: true}}
                };
                if (this.shader.uniforms) {
                  this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);
                } else {
                  this.uniforms = defaultUniforms;
                }
                for (var i = 0; i < 4; i++) {
                  if (textures[i]) {
                    this.setSampler2D("iChannel" + i, textures[i], i, textureData);
                  }
                }
                this.initUniforms();
                this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);
                return this;
              },
              setPointer: function(pointer) {
                this.pointer = pointer;
                return this;
              },
              projOrtho: function(left, right, bottom, top) {
                var near = -1e3;
                var far = 1e3;
                var leftRight = 1 / (left - right);
                var bottomTop = 1 / (bottom - top);
                var nearFar = 1 / (near - far);
                var pm = this.projectionMatrix;
                pm[0] = -2 * leftRight;
                pm[5] = -2 * bottomTop;
                pm[10] = 2 * nearFar;
                pm[12] = (left + right) * leftRight;
                pm[13] = (top + bottom) * bottomTop;
                pm[14] = (far + near) * nearFar;
                var program = this.program;
                var gl = this.gl;
                var renderer = this.renderer;
                renderer.setProgram(program);
                gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
                this._rendererWidth = right;
                this._rendererHeight = bottom;
              },
              initUniforms: function() {
                var gl = this.gl;
                var map = this.renderer.glFuncMap;
                var program = this.program;
                this._textureCount = 0;
                for (var key in this.uniforms) {
                  var uniform = this.uniforms[key];
                  var type = uniform.type;
                  var data = map[type];
                  uniform.uniformLocation = gl.getUniformLocation(program, key);
                  if (type !== "sampler2D") {
                    uniform.glMatrix = data.matrix;
                    uniform.glValueLength = data.length;
                    uniform.glFunc = data.func;
                  }
                }
              },
              setSampler2DBuffer: function(uniformKey, texture, width, height, textureIndex, textureData) {
                if (textureIndex === void 0) {
                  textureIndex = 0;
                }
                if (textureData === void 0) {
                  textureData = {};
                }
                var uniform = this.uniforms[uniformKey];
                uniform.value = texture;
                textureData.width = width;
                textureData.height = height;
                uniform.textureData = textureData;
                this._textureCount = textureIndex;
                this.initSampler2D(uniform);
                return this;
              },
              setSampler2D: function(uniformKey, textureKey, textureIndex, textureData) {
                if (textureIndex === void 0) {
                  textureIndex = 0;
                }
                var textureManager = this.scene.sys.textures;
                if (textureManager.exists(textureKey)) {
                  var frame = textureManager.getFrame(textureKey);
                  if (frame.glTexture && frame.glTexture.isRenderTexture) {
                    return this.setSampler2DBuffer(uniformKey, frame.glTexture, frame.width, frame.height, textureIndex, textureData);
                  }
                  var uniform = this.uniforms[uniformKey];
                  var source = frame.source;
                  uniform.textureKey = textureKey;
                  uniform.source = source.image;
                  uniform.value = frame.glTexture;
                  if (source.isGLTexture) {
                    if (!textureData) {
                      textureData = {};
                    }
                    textureData.width = source.width;
                    textureData.height = source.height;
                  }
                  if (textureData) {
                    uniform.textureData = textureData;
                  }
                  this._textureCount = textureIndex;
                  this.initSampler2D(uniform);
                }
                return this;
              },
              setUniform: function(key, value) {
                SetValue(this.uniforms, key, value);
                return this;
              },
              getUniform: function(key) {
                return GetFastValue(this.uniforms, key, null);
              },
              setChannel0: function(textureKey, textureData) {
                return this.setSampler2D("iChannel0", textureKey, 0, textureData);
              },
              setChannel1: function(textureKey, textureData) {
                return this.setSampler2D("iChannel1", textureKey, 1, textureData);
              },
              setChannel2: function(textureKey, textureData) {
                return this.setSampler2D("iChannel2", textureKey, 2, textureData);
              },
              setChannel3: function(textureKey, textureData) {
                return this.setSampler2D("iChannel3", textureKey, 3, textureData);
              },
              initSampler2D: function(uniform) {
                if (!uniform.value) {
                  return;
                }
                var gl = this.gl;
                gl.activeTexture(gl.TEXTURE0 + this._textureCount);
                gl.bindTexture(gl.TEXTURE_2D, uniform.value);
                var data = uniform.textureData;
                if (data && !uniform.value.isRenderTexture) {
                  var magFilter = gl[GetFastValue(data, "magFilter", "linear").toUpperCase()];
                  var minFilter = gl[GetFastValue(data, "minFilter", "linear").toUpperCase()];
                  var wrapS = gl[GetFastValue(data, "wrapS", "repeat").toUpperCase()];
                  var wrapT = gl[GetFastValue(data, "wrapT", "repeat").toUpperCase()];
                  var format = gl[GetFastValue(data, "format", "rgba").toUpperCase()];
                  if (data.repeat) {
                    wrapS = gl.REPEAT;
                    wrapT = gl.REPEAT;
                  }
                  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
                  if (data.width) {
                    var width = GetFastValue(data, "width", 512);
                    var height = GetFastValue(data, "height", 2);
                    var border = GetFastValue(data, "border", 0);
                    gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
                  } else {
                    gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);
                  }
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
                }
                this.renderer.setProgram(this.program);
                gl.uniform1i(uniform.uniformLocation, this._textureCount);
                this._textureCount++;
              },
              syncUniforms: function() {
                var gl = this.gl;
                var uniforms = this.uniforms;
                var uniform;
                var length;
                var glFunc;
                var location;
                var value;
                var textureCount = 0;
                for (var key in uniforms) {
                  uniform = uniforms[key];
                  glFunc = uniform.glFunc;
                  length = uniform.glValueLength;
                  location = uniform.uniformLocation;
                  value = uniform.value;
                  if (value === null) {
                    continue;
                  }
                  if (length === 1) {
                    if (uniform.glMatrix) {
                      glFunc.call(gl, location, uniform.transpose, value);
                    } else {
                      glFunc.call(gl, location, value);
                    }
                  } else if (length === 2) {
                    glFunc.call(gl, location, value.x, value.y);
                  } else if (length === 3) {
                    glFunc.call(gl, location, value.x, value.y, value.z);
                  } else if (length === 4) {
                    glFunc.call(gl, location, value.x, value.y, value.z, value.w);
                  } else if (uniform.type === "sampler2D") {
                    gl.activeTexture(gl.TEXTURE0 + textureCount);
                    gl.bindTexture(gl.TEXTURE_2D, value);
                    gl.uniform1i(location, textureCount);
                    textureCount++;
                  }
                }
              },
              load: function(matrix2D) {
                var gl = this.gl;
                var width = this.width;
                var height = this.height;
                var renderer = this.renderer;
                var program = this.program;
                var vm = this.viewMatrix;
                if (!this.renderToTexture) {
                  var x = -this._displayOriginX;
                  var y = -this._displayOriginY;
                  vm[0] = matrix2D[0];
                  vm[1] = matrix2D[1];
                  vm[4] = matrix2D[2];
                  vm[5] = matrix2D[3];
                  vm[8] = matrix2D[4];
                  vm[9] = matrix2D[5];
                  vm[12] = vm[0] * x + vm[4] * y;
                  vm[13] = vm[1] * x + vm[5] * y;
                }
                gl.useProgram(program);
                gl.uniformMatrix4fv(gl.getUniformLocation(program, "uViewMatrix"), false, vm);
                gl.uniform2f(gl.getUniformLocation(program, "uResolution"), this.width, this.height);
                var uniforms = this.uniforms;
                var res = uniforms.resolution;
                res.value.x = width;
                res.value.y = height;
                uniforms.time.value = renderer.game.loop.getDuration();
                var pointer = this.pointer;
                if (pointer) {
                  var mouse = uniforms.mouse;
                  var px = pointer.x / width;
                  var py = 1 - pointer.y / height;
                  mouse.value.x = px.toFixed(2);
                  mouse.value.y = py.toFixed(2);
                }
                this.syncUniforms();
              },
              flush: function() {
                var width = this.width;
                var height = this.height;
                var program = this.program;
                var gl = this.gl;
                var vertexBuffer = this.vertexBuffer;
                var renderer = this.renderer;
                var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;
                if (this.renderToTexture) {
                  renderer.setFramebuffer(this.framebuffer);
                  gl.clearColor(0, 0, 0, 0);
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                var location = gl.getAttribLocation(program, "inPosition");
                if (location !== -1) {
                  gl.enableVertexAttribArray(location);
                  gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);
                }
                var vf = this.vertexViewF32;
                vf[3] = height;
                vf[4] = width;
                vf[5] = height;
                vf[8] = width;
                vf[9] = height;
                vf[10] = width;
                var vertexCount = 6;
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
                gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
                if (this.renderToTexture) {
                  renderer.setFramebuffer(null, false);
                }
              },
              setAlpha: function() {
              },
              setBlendMode: function() {
              },
              preDestroy: function() {
                var gl = this.gl;
                gl.deleteProgram(this.program);
                gl.deleteBuffer(this.vertexBuffer);
                if (this.renderToTexture) {
                  this.renderer.deleteFramebuffer(this.framebuffer);
                  this.texture.destroy();
                  this.framebuffer = null;
                  this.glTexture = null;
                  this.texture = null;
                }
              }
            });
            module2.exports = Shader;
          },
          10612: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ShaderCanvasRenderer = function() {
            };
            module2.exports = ShaderCanvasRenderer;
          },
          13908: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var Shader = __webpack_require__2(27902);
            GameObjectCreator.register("shader", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var x = GetAdvancedValue(config2, "x", 0);
              var y = GetAdvancedValue(config2, "y", 0);
              var width = GetAdvancedValue(config2, "width", 128);
              var height = GetAdvancedValue(config2, "height", 128);
              var shader = new Shader(this.scene, key, x, y, width, height);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, shader, config2);
              return shader;
            });
          },
          51979: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Shader = __webpack_require__2(27902);
            var GameObjectFactory = __webpack_require__2(61286);
            if (true) {
              GameObjectFactory.register("shader", function(key, x, y, width, height, textures, textureData) {
                return this.displayList.add(new Shader(this.scene, key, x, y, width, height, textures, textureData));
              });
            }
          },
          24252: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(19782);
            }
            if (true) {
              renderCanvas = __webpack_require__2(10612);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          19782: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var ShaderWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              if (!src.shader) {
                return;
              }
              camera.addToRenderList(src);
              renderer.pipelines.clear();
              if (src.renderToTexture) {
                src.load();
                src.flush();
              } else {
                var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
                if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight) {
                  src.projOrtho(0, renderer.width, renderer.height, 0);
                }
                src.load(calcMatrix.matrix);
                src.flush();
              }
              renderer.pipelines.rebind();
            };
            module2.exports = ShaderWebGLRenderer;
          },
          19543: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Utils = __webpack_require__2(75512);
            var FillPathWebGL = function(pipeline, calcMatrix, src, alpha, dx, dy) {
              var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
              var path = src.pathData;
              var pathIndexes = src.pathIndexes;
              for (var i = 0; i < pathIndexes.length; i += 3) {
                var p0 = pathIndexes[i] * 2;
                var p1 = pathIndexes[i + 1] * 2;
                var p2 = pathIndexes[i + 2] * 2;
                var x0 = path[p0 + 0] - dx;
                var y0 = path[p0 + 1] - dy;
                var x1 = path[p1 + 0] - dx;
                var y1 = path[p1 + 1] - dy;
                var x2 = path[p2 + 0] - dx;
                var y2 = path[p2 + 1] - dy;
                var tx0 = calcMatrix.getX(x0, y0);
                var ty0 = calcMatrix.getY(x0, y0);
                var tx1 = calcMatrix.getX(x1, y1);
                var ty1 = calcMatrix.getY(x1, y1);
                var tx2 = calcMatrix.getX(x2, y2);
                var ty2 = calcMatrix.getY(x2, y2);
                pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
              }
            };
            module2.exports = FillPathWebGL;
          },
          15608: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = function(ctx, src, altColor, altAlpha) {
              var fillColor = altColor ? altColor : src.fillColor;
              var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
              var red = (fillColor & 16711680) >>> 16;
              var green = (fillColor & 65280) >>> 8;
              var blue = fillColor & 255;
              ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
            };
            module2.exports = FillStyleCanvas;
          },
          17876: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LineStyleCanvas = function(ctx, src, altColor, altAlpha) {
              var strokeColor = altColor ? altColor : src.strokeColor;
              var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
              var red = (strokeColor & 16711680) >>> 16;
              var green = (strokeColor & 65280) >>> 8;
              var blue = strokeColor & 255;
              ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + strokeAlpha + ")";
              ctx.lineWidth = src.lineWidth;
            };
            module2.exports = LineStyleCanvas;
          },
          91461: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var Line = __webpack_require__2(88829);
            var Shape = new Class({
              Extends: GameObject,
              Mixins: [
                Components.AlphaSingle,
                Components.BlendMode,
                Components.Depth,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Transform,
                Components.Visible
              ],
              initialize: function Shape2(scene, type, data) {
                if (type === void 0) {
                  type = "Shape";
                }
                GameObject.call(this, scene, type);
                this.geom = data;
                this.pathData = [];
                this.pathIndexes = [];
                this.fillColor = 16777215;
                this.fillAlpha = 1;
                this.strokeColor = 16777215;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.isFilled = false;
                this.isStroked = false;
                this.closePath = true;
                this._tempLine = new Line();
                this.width = 0;
                this.height = 0;
                this.initPipeline();
                this.initPostPipeline();
              },
              setFillStyle: function(color, alpha) {
                if (alpha === void 0) {
                  alpha = 1;
                }
                if (color === void 0) {
                  this.isFilled = false;
                } else {
                  this.fillColor = color;
                  this.fillAlpha = alpha;
                  this.isFilled = true;
                }
                return this;
              },
              setStrokeStyle: function(lineWidth, color, alpha) {
                if (alpha === void 0) {
                  alpha = 1;
                }
                if (lineWidth === void 0) {
                  this.isStroked = false;
                } else {
                  this.lineWidth = lineWidth;
                  this.strokeColor = color;
                  this.strokeAlpha = alpha;
                  this.isStroked = true;
                }
                return this;
              },
              setClosePath: function(value) {
                this.closePath = value;
                return this;
              },
              setSize: function(width, height) {
                this.width = width;
                this.height = height;
                return this;
              },
              setDisplaySize: function(width, height) {
                this.displayWidth = width;
                this.displayHeight = height;
                return this;
              },
              preDestroy: function() {
                this.geom = null;
                this._tempLine = null;
                this.pathData = [];
                this.pathIndexes = [];
              },
              displayWidth: {
                get: function() {
                  return this.scaleX * this.width;
                },
                set: function(value) {
                  this.scaleX = value / this.width;
                }
              },
              displayHeight: {
                get: function() {
                  return this.scaleY * this.height;
                },
                set: function(value) {
                  this.scaleY = value / this.height;
                }
              }
            });
            module2.exports = Shape;
          },
          50262: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Utils = __webpack_require__2(75512);
            var StrokePathWebGL = function(pipeline, src, alpha, dx, dy) {
              var strokeTint = pipeline.strokeTint;
              var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
              strokeTint.TL = strokeTintColor;
              strokeTint.TR = strokeTintColor;
              strokeTint.BL = strokeTintColor;
              strokeTint.BR = strokeTintColor;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var lineWidth = src.lineWidth;
              var halfLineWidth = lineWidth / 2;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, src.closePath ? i === pathLength - 1 : false);
                px1 = px2;
                py1 = py2;
              }
            };
            module2.exports = StrokePathWebGL;
          },
          28593: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArcRender = __webpack_require__2(2213);
            var Class = __webpack_require__2(56694);
            var DegToRad = __webpack_require__2(75606);
            var Earcut = __webpack_require__2(11117);
            var GeomCircle = __webpack_require__2(26673);
            var MATH_CONST = __webpack_require__2(83392);
            var Shape = __webpack_require__2(91461);
            var Arc = new Class({
              Extends: Shape,
              Mixins: [
                ArcRender
              ],
              initialize: function Arc2(scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (radius === void 0) {
                  radius = 128;
                }
                if (startAngle === void 0) {
                  startAngle = 0;
                }
                if (endAngle === void 0) {
                  endAngle = 360;
                }
                if (anticlockwise === void 0) {
                  anticlockwise = false;
                }
                Shape.call(this, scene, "Arc", new GeomCircle(0, 0, radius));
                this._startAngle = startAngle;
                this._endAngle = endAngle;
                this._anticlockwise = anticlockwise;
                this._iterations = 0.01;
                this.setPosition(x, y);
                var diameter = this.geom.radius * 2;
                this.setSize(diameter, diameter);
                if (fillColor !== void 0) {
                  this.setFillStyle(fillColor, fillAlpha);
                }
                this.updateDisplayOrigin();
                this.updateData();
              },
              iterations: {
                get: function() {
                  return this._iterations;
                },
                set: function(value) {
                  this._iterations = value;
                  this.updateData();
                }
              },
              radius: {
                get: function() {
                  return this.geom.radius;
                },
                set: function(value) {
                  this.geom.radius = value;
                  var diameter = value * 2;
                  this.setSize(diameter, diameter);
                  this.updateDisplayOrigin();
                  this.updateData();
                }
              },
              startAngle: {
                get: function() {
                  return this._startAngle;
                },
                set: function(value) {
                  this._startAngle = value;
                  this.updateData();
                }
              },
              endAngle: {
                get: function() {
                  return this._endAngle;
                },
                set: function(value) {
                  this._endAngle = value;
                  this.updateData();
                }
              },
              anticlockwise: {
                get: function() {
                  return this._anticlockwise;
                },
                set: function(value) {
                  this._anticlockwise = value;
                  this.updateData();
                }
              },
              setRadius: function(value) {
                this.radius = value;
                return this;
              },
              setIterations: function(value) {
                if (value === void 0) {
                  value = 0.01;
                }
                this.iterations = value;
                return this;
              },
              setStartAngle: function(angle, anticlockwise) {
                this._startAngle = angle;
                if (anticlockwise !== void 0) {
                  this._anticlockwise = anticlockwise;
                }
                return this.updateData();
              },
              setEndAngle: function(angle, anticlockwise) {
                this._endAngle = angle;
                if (anticlockwise !== void 0) {
                  this._anticlockwise = anticlockwise;
                }
                return this.updateData();
              },
              updateData: function() {
                var step = this._iterations;
                var iteration = step;
                var radius = this.geom.radius;
                var startAngle = DegToRad(this._startAngle);
                var endAngle = DegToRad(this._endAngle);
                var anticlockwise = this._anticlockwise;
                var x = radius;
                var y = radius;
                endAngle -= startAngle;
                if (anticlockwise) {
                  if (endAngle < -MATH_CONST.PI2) {
                    endAngle = -MATH_CONST.PI2;
                  } else if (endAngle > 0) {
                    endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
                  }
                } else if (endAngle > MATH_CONST.PI2) {
                  endAngle = MATH_CONST.PI2;
                } else if (endAngle < 0) {
                  endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
                }
                var path = [x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius];
                var ta;
                while (iteration < 1) {
                  ta = endAngle * iteration + startAngle;
                  path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);
                  iteration += step;
                }
                ta = endAngle + startAngle;
                path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);
                path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);
                this.pathIndexes = Earcut(path);
                this.pathData = path;
                return this;
              }
            });
            module2.exports = Arc;
          },
          23560: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DegToRad = __webpack_require__2(75606);
            var FillStyleCanvas = __webpack_require__2(15608);
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var ArcCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var radius = src.radius;
                ctx.beginPath();
                ctx.arc(radius - src.originX * (radius * 2), radius - src.originY * (radius * 2), radius, DegToRad(src._startAngle), DegToRad(src._endAngle), src.anticlockwise);
                if (src.closePath) {
                  ctx.closePath();
                }
                if (src.isFilled) {
                  FillStyleCanvas(ctx, src);
                  ctx.fill();
                }
                if (src.isStroked) {
                  LineStyleCanvas(ctx, src);
                  ctx.stroke();
                }
                ctx.restore();
              }
            };
            module2.exports = ArcCanvasRenderer;
          },
          10369: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Arc = __webpack_require__2(28593);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("arc", function(x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
              return this.displayList.add(new Arc(this.scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));
            });
            GameObjectFactory.register("circle", function(x, y, radius, fillColor, fillAlpha) {
              return this.displayList.add(new Arc(this.scene, x, y, radius, 0, 360, false, fillColor, fillAlpha));
            });
          },
          2213: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(58356);
            }
            if (true) {
              renderCanvas = __webpack_require__2(23560);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          58356: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var FillPathWebGL = __webpack_require__2(19543);
            var StrokePathWebGL = __webpack_require__2(50262);
            var ArcWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              renderer.pipelines.preBatch(src);
              if (src.isFilled) {
                FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
              }
              if (src.isStroked) {
                StrokePathWebGL(pipeline, src, alpha, dx, dy);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = ArcWebGLRenderer;
          },
          15220: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CurveRender = __webpack_require__2(87203);
            var Earcut = __webpack_require__2(11117);
            var Rectangle = __webpack_require__2(74118);
            var Shape = __webpack_require__2(91461);
            var Curve = new Class({
              Extends: Shape,
              Mixins: [
                CurveRender
              ],
              initialize: function Curve2(scene, x, y, curve, fillColor, fillAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                Shape.call(this, scene, "Curve", curve);
                this._smoothness = 32;
                this._curveBounds = new Rectangle();
                this.closePath = false;
                this.setPosition(x, y);
                if (fillColor !== void 0) {
                  this.setFillStyle(fillColor, fillAlpha);
                }
                this.updateData();
              },
              smoothness: {
                get: function() {
                  return this._smoothness;
                },
                set: function(value) {
                  this._smoothness = value;
                  this.updateData();
                }
              },
              setSmoothness: function(value) {
                this._smoothness = value;
                return this.updateData();
              },
              updateData: function() {
                var bounds = this._curveBounds;
                var smoothness = this._smoothness;
                this.geom.getBounds(bounds, smoothness);
                this.setSize(bounds.width, bounds.height);
                this.updateDisplayOrigin();
                var path = [];
                var points = this.geom.getPoints(smoothness);
                for (var i = 0; i < points.length; i++) {
                  path.push(points[i].x, points[i].y);
                }
                path.push(points[0].x, points[0].y);
                this.pathIndexes = Earcut(path);
                this.pathData = path;
                return this;
              }
            });
            module2.exports = Curve;
          },
          4024: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var CurveCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var dx = src._displayOriginX + src._curveBounds.x;
                var dy = src._displayOriginY + src._curveBounds.y;
                var path = src.pathData;
                var pathLength = path.length - 1;
                var px1 = path[0] - dx;
                var py1 = path[1] - dy;
                ctx.beginPath();
                ctx.moveTo(px1, py1);
                if (!src.closePath) {
                  pathLength -= 2;
                }
                for (var i = 2; i < pathLength; i += 2) {
                  var px2 = path[i] - dx;
                  var py2 = path[i + 1] - dy;
                  ctx.lineTo(px2, py2);
                }
                if (src.closePath) {
                  ctx.closePath();
                }
                if (src.isFilled) {
                  FillStyleCanvas(ctx, src);
                  ctx.fill();
                }
                if (src.isStroked) {
                  LineStyleCanvas(ctx, src);
                  ctx.stroke();
                }
                ctx.restore();
              }
            };
            module2.exports = CurveCanvasRenderer;
          },
          10147: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var Curve = __webpack_require__2(15220);
            GameObjectFactory.register("curve", function(x, y, curve, fillColor, fillAlpha) {
              return this.displayList.add(new Curve(this.scene, x, y, curve, fillColor, fillAlpha));
            });
          },
          87203: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(82958);
            }
            if (true) {
              renderCanvas = __webpack_require__2(4024);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          82958: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillPathWebGL = __webpack_require__2(19543);
            var GetCalcMatrix = __webpack_require__2(73329);
            var StrokePathWebGL = __webpack_require__2(50262);
            var CurveWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
              var dx = src._displayOriginX + src._curveBounds.x;
              var dy = src._displayOriginY + src._curveBounds.y;
              var alpha = camera.alpha * src.alpha;
              renderer.pipelines.preBatch(src);
              if (src.isFilled) {
                FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
              }
              if (src.isStroked) {
                StrokePathWebGL(pipeline, src, alpha, dx, dy);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = CurveWebGLRenderer;
          },
          28591: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Earcut = __webpack_require__2(11117);
            var EllipseRender = __webpack_require__2(84171);
            var GeomEllipse = __webpack_require__2(95669);
            var Shape = __webpack_require__2(91461);
            var Ellipse = new Class({
              Extends: Shape,
              Mixins: [
                EllipseRender
              ],
              initialize: function Ellipse2(scene, x, y, width, height, fillColor, fillAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = 128;
                }
                if (height === void 0) {
                  height = 128;
                }
                Shape.call(this, scene, "Ellipse", new GeomEllipse(width / 2, height / 2, width, height));
                this._smoothness = 64;
                this.setPosition(x, y);
                this.width = width;
                this.height = height;
                if (fillColor !== void 0) {
                  this.setFillStyle(fillColor, fillAlpha);
                }
                this.updateDisplayOrigin();
                this.updateData();
              },
              smoothness: {
                get: function() {
                  return this._smoothness;
                },
                set: function(value) {
                  this._smoothness = value;
                  this.updateData();
                }
              },
              setSize: function(width, height) {
                this.width = width;
                this.height = height;
                this.geom.setPosition(width / 2, height / 2);
                this.geom.setSize(width, height);
                return this.updateData();
              },
              setSmoothness: function(value) {
                this._smoothness = value;
                return this.updateData();
              },
              updateData: function() {
                var path = [];
                var points = this.geom.getPoints(this._smoothness);
                for (var i = 0; i < points.length; i++) {
                  path.push(points[i].x, points[i].y);
                }
                path.push(points[0].x, points[0].y);
                this.pathIndexes = Earcut(path);
                this.pathData = path;
                return this;
              }
            });
            module2.exports = Ellipse;
          },
          55881: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var EllipseCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var dx = src._displayOriginX;
                var dy = src._displayOriginY;
                var path = src.pathData;
                var pathLength = path.length - 1;
                var px1 = path[0] - dx;
                var py1 = path[1] - dy;
                ctx.beginPath();
                ctx.moveTo(px1, py1);
                if (!src.closePath) {
                  pathLength -= 2;
                }
                for (var i = 2; i < pathLength; i += 2) {
                  var px2 = path[i] - dx;
                  var py2 = path[i + 1] - dy;
                  ctx.lineTo(px2, py2);
                }
                ctx.closePath();
                if (src.isFilled) {
                  FillStyleCanvas(ctx, src);
                  ctx.fill();
                }
                if (src.isStroked) {
                  LineStyleCanvas(ctx, src);
                  ctx.stroke();
                }
                ctx.restore();
              }
            };
            module2.exports = EllipseCanvasRenderer;
          },
          99869: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Ellipse = __webpack_require__2(28591);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("ellipse", function(x, y, width, height, fillColor, fillAlpha) {
              return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));
            });
          },
          84171: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(17554);
            }
            if (true) {
              renderCanvas = __webpack_require__2(55881);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          17554: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillPathWebGL = __webpack_require__2(19543);
            var GetCalcMatrix = __webpack_require__2(73329);
            var StrokePathWebGL = __webpack_require__2(50262);
            var EllipseWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              renderer.pipelines.preBatch(src);
              if (src.isFilled) {
                FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
              }
              if (src.isStroked) {
                StrokePathWebGL(pipeline, src, alpha, dx, dy);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = EllipseWebGLRenderer;
          },
          39169: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Shape = __webpack_require__2(91461);
            var GridRender = __webpack_require__2(88059);
            var Grid = new Class({
              Extends: Shape,
              Mixins: [
                GridRender
              ],
              initialize: function Grid2(scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = 128;
                }
                if (height === void 0) {
                  height = 128;
                }
                if (cellWidth === void 0) {
                  cellWidth = 32;
                }
                if (cellHeight === void 0) {
                  cellHeight = 32;
                }
                Shape.call(this, scene, "Grid", null);
                this.cellWidth = cellWidth;
                this.cellHeight = cellHeight;
                this.showCells = true;
                this.outlineFillColor = 0;
                this.outlineFillAlpha = 0;
                this.showOutline = true;
                this.showAltCells = false;
                this.altFillColor;
                this.altFillAlpha;
                this.setPosition(x, y);
                this.setSize(width, height);
                this.setFillStyle(fillColor, fillAlpha);
                if (outlineFillColor !== void 0) {
                  this.setOutlineStyle(outlineFillColor, outlineFillAlpha);
                }
                this.updateDisplayOrigin();
              },
              setFillStyle: function(fillColor, fillAlpha) {
                if (fillAlpha === void 0) {
                  fillAlpha = 1;
                }
                if (fillColor === void 0) {
                  this.showCells = false;
                } else {
                  this.fillColor = fillColor;
                  this.fillAlpha = fillAlpha;
                  this.showCells = true;
                }
                return this;
              },
              setAltFillStyle: function(fillColor, fillAlpha) {
                if (fillAlpha === void 0) {
                  fillAlpha = 1;
                }
                if (fillColor === void 0) {
                  this.showAltCells = false;
                } else {
                  this.altFillColor = fillColor;
                  this.altFillAlpha = fillAlpha;
                  this.showAltCells = true;
                }
                return this;
              },
              setOutlineStyle: function(fillColor, fillAlpha) {
                if (fillAlpha === void 0) {
                  fillAlpha = 1;
                }
                if (fillColor === void 0) {
                  this.showOutline = false;
                } else {
                  this.outlineFillColor = fillColor;
                  this.outlineFillAlpha = fillAlpha;
                  this.showOutline = true;
                }
                return this;
              }
            });
            module2.exports = Grid;
          },
          95525: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var GridCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var dx = -src._displayOriginX;
                var dy = -src._displayOriginY;
                var alpha = camera.alpha * src.alpha;
                var width = src.width;
                var height = src.height;
                var cellWidth = src.cellWidth;
                var cellHeight = src.cellHeight;
                var gridWidth = Math.ceil(width / cellWidth);
                var gridHeight = Math.ceil(height / cellHeight);
                var cellWidthA = cellWidth;
                var cellHeightA = cellHeight;
                var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
                var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
                var showCells = src.showCells;
                var showAltCells = src.showAltCells;
                var showOutline = src.showOutline;
                var x = 0;
                var y = 0;
                var r = 0;
                var cw = 0;
                var ch = 0;
                if (showOutline) {
                  cellWidthA--;
                  cellHeightA--;
                  if (cellWidthB === cellWidth) {
                    cellWidthB--;
                  }
                  if (cellHeightB === cellHeight) {
                    cellHeightB--;
                  }
                }
                if (showCells && src.fillAlpha > 0) {
                  FillStyleCanvas(ctx, src);
                  for (y = 0; y < gridHeight; y++) {
                    if (showAltCells) {
                      r = y % 2;
                    }
                    for (x = 0; x < gridWidth; x++) {
                      if (showAltCells && r) {
                        r = 0;
                        continue;
                      }
                      r++;
                      cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                      ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                      ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, cw, ch);
                    }
                  }
                }
                if (showAltCells && src.altFillAlpha > 0) {
                  FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha);
                  for (y = 0; y < gridHeight; y++) {
                    if (showAltCells) {
                      r = y % 2;
                    }
                    for (x = 0; x < gridWidth; x++) {
                      if (showAltCells && !r) {
                        r = 1;
                        continue;
                      }
                      r = 0;
                      cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                      ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                      ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, cw, ch);
                    }
                  }
                }
                if (showOutline && src.outlineFillAlpha > 0) {
                  LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha);
                  for (x = 1; x < gridWidth; x++) {
                    var x1 = x * cellWidth;
                    ctx.beginPath();
                    ctx.moveTo(x1 + dx, dy);
                    ctx.lineTo(x1 + dx, height + dy);
                    ctx.stroke();
                  }
                  for (y = 1; y < gridHeight; y++) {
                    var y1 = y * cellHeight;
                    ctx.beginPath();
                    ctx.moveTo(dx, y1 + dy);
                    ctx.lineTo(dx + width, y1 + dy);
                    ctx.stroke();
                  }
                }
                ctx.restore();
              }
            };
            module2.exports = GridCanvasRenderer;
          },
          9326: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var Grid = __webpack_require__2(39169);
            GameObjectFactory.register("grid", function(x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
              return this.displayList.add(new Grid(this.scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));
            });
          },
          88059: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(50639);
            }
            if (true) {
              renderCanvas = __webpack_require__2(95525);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          50639: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var Utils = __webpack_require__2(75512);
            var GridWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
              calcMatrix.translate(-src._displayOriginX, -src._displayOriginY);
              var alpha = camera.alpha * src.alpha;
              var width = src.width;
              var height = src.height;
              var cellWidth = src.cellWidth;
              var cellHeight = src.cellHeight;
              var gridWidth = Math.ceil(width / cellWidth);
              var gridHeight = Math.ceil(height / cellHeight);
              var cellWidthA = cellWidth;
              var cellHeightA = cellHeight;
              var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
              var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
              var fillTint;
              var fillTintColor;
              var showCells = src.showCells;
              var showAltCells = src.showAltCells;
              var showOutline = src.showOutline;
              var x = 0;
              var y = 0;
              var r = 0;
              var cw = 0;
              var ch = 0;
              if (showOutline) {
                cellWidthA--;
                cellHeightA--;
                if (cellWidthB === cellWidth) {
                  cellWidthB--;
                }
                if (cellHeightB === cellHeight) {
                  cellHeightB--;
                }
              }
              renderer.pipelines.preBatch(src);
              if (showCells && src.fillAlpha > 0) {
                fillTint = pipeline.fillTint;
                fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
                fillTint.TL = fillTintColor;
                fillTint.TR = fillTintColor;
                fillTint.BL = fillTintColor;
                fillTint.BR = fillTintColor;
                for (y = 0; y < gridHeight; y++) {
                  if (showAltCells) {
                    r = y % 2;
                  }
                  for (x = 0; x < gridWidth; x++) {
                    if (showAltCells && r) {
                      r = 0;
                      continue;
                    }
                    r++;
                    cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                    ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                    pipeline.batchFillRect(x * cellWidth, y * cellHeight, cw, ch);
                  }
                }
              }
              if (showAltCells && src.altFillAlpha > 0) {
                fillTint = pipeline.fillTint;
                fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * alpha);
                fillTint.TL = fillTintColor;
                fillTint.TR = fillTintColor;
                fillTint.BL = fillTintColor;
                fillTint.BR = fillTintColor;
                for (y = 0; y < gridHeight; y++) {
                  if (showAltCells) {
                    r = y % 2;
                  }
                  for (x = 0; x < gridWidth; x++) {
                    if (showAltCells && !r) {
                      r = 1;
                      continue;
                    }
                    r = 0;
                    cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                    ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                    pipeline.batchFillRect(x * cellWidth, y * cellHeight, cw, ch);
                  }
                }
              }
              if (showOutline && src.outlineFillAlpha > 0) {
                var strokeTint = pipeline.strokeTint;
                var color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * alpha);
                strokeTint.TL = color;
                strokeTint.TR = color;
                strokeTint.BL = color;
                strokeTint.BR = color;
                for (x = 1; x < gridWidth; x++) {
                  var x1 = x * cellWidth;
                  pipeline.batchLine(x1, 0, x1, height, 1, 1, 1, 0, false);
                }
                for (y = 1; y < gridHeight; y++) {
                  var y1 = y * cellHeight;
                  pipeline.batchLine(0, y1, width, y1, 1, 1, 1, 0, false);
                }
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = GridWebGLRenderer;
          },
          4415: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsoBoxRender = __webpack_require__2(72296);
            var Class = __webpack_require__2(56694);
            var Shape = __webpack_require__2(91461);
            var IsoBox = new Class({
              Extends: Shape,
              Mixins: [
                IsoBoxRender
              ],
              initialize: function IsoBox2(scene, x, y, size, height, fillTop, fillLeft, fillRight) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (size === void 0) {
                  size = 48;
                }
                if (height === void 0) {
                  height = 32;
                }
                if (fillTop === void 0) {
                  fillTop = 15658734;
                }
                if (fillLeft === void 0) {
                  fillLeft = 10066329;
                }
                if (fillRight === void 0) {
                  fillRight = 13421772;
                }
                Shape.call(this, scene, "IsoBox", null);
                this.projection = 4;
                this.fillTop = fillTop;
                this.fillLeft = fillLeft;
                this.fillRight = fillRight;
                this.showTop = true;
                this.showLeft = true;
                this.showRight = true;
                this.isFilled = true;
                this.setPosition(x, y);
                this.setSize(size, height);
                this.updateDisplayOrigin();
              },
              setProjection: function(value) {
                this.projection = value;
                return this;
              },
              setFaces: function(showTop, showLeft, showRight) {
                if (showTop === void 0) {
                  showTop = true;
                }
                if (showLeft === void 0) {
                  showLeft = true;
                }
                if (showRight === void 0) {
                  showRight = true;
                }
                this.showTop = showTop;
                this.showLeft = showLeft;
                this.showRight = showRight;
                return this;
              },
              setFillStyle: function(fillTop, fillLeft, fillRight) {
                this.fillTop = fillTop;
                this.fillLeft = fillLeft;
                this.fillRight = fillRight;
                this.isFilled = true;
                return this;
              }
            });
            module2.exports = IsoBox;
          },
          32884: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var SetTransform = __webpack_require__2(49584);
            var IsoBoxCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
                var size = src.width;
                var height = src.height;
                var sizeA = size / 2;
                var sizeB = size / src.projection;
                if (src.showTop) {
                  FillStyleCanvas(ctx, src, src.fillTop);
                  ctx.beginPath();
                  ctx.moveTo(-sizeA, -height);
                  ctx.lineTo(0, -sizeB - height);
                  ctx.lineTo(sizeA, -height);
                  ctx.lineTo(sizeA, -1);
                  ctx.lineTo(0, sizeB - 1);
                  ctx.lineTo(-sizeA, -1);
                  ctx.lineTo(-sizeA, -height);
                  ctx.fill();
                }
                if (src.showLeft) {
                  FillStyleCanvas(ctx, src, src.fillLeft);
                  ctx.beginPath();
                  ctx.moveTo(-sizeA, 0);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                  ctx.lineTo(-sizeA, -height);
                  ctx.lineTo(-sizeA, 0);
                  ctx.fill();
                }
                if (src.showRight) {
                  FillStyleCanvas(ctx, src, src.fillRight);
                  ctx.beginPath();
                  ctx.moveTo(sizeA, 0);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                  ctx.lineTo(sizeA, -height);
                  ctx.lineTo(sizeA, 0);
                  ctx.fill();
                }
                ctx.restore();
              }
            };
            module2.exports = IsoBoxCanvasRenderer;
          },
          88154: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var IsoBox = __webpack_require__2(4415);
            GameObjectFactory.register("isobox", function(x, y, size, height, fillTop, fillLeft, fillRight) {
              return this.displayList.add(new IsoBox(this.scene, x, y, size, height, fillTop, fillLeft, fillRight));
            });
          },
          72296: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(33101);
            }
            if (true) {
              renderCanvas = __webpack_require__2(32884);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          33101: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var Utils = __webpack_require__2(75512);
            var IsoBoxWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
              var size = src.width;
              var height = src.height;
              var sizeA = size / 2;
              var sizeB = size / src.projection;
              var alpha = camera.alpha * src.alpha;
              if (!src.isFilled) {
                return;
              }
              var tint;
              var x0;
              var y0;
              var x1;
              var y1;
              var x2;
              var y2;
              var x3;
              var y3;
              renderer.pipelines.preBatch(src);
              if (src.showTop) {
                tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
                x0 = calcMatrix.getX(-sizeA, -height);
                y0 = calcMatrix.getY(-sizeA, -height);
                x1 = calcMatrix.getX(0, -sizeB - height);
                y1 = calcMatrix.getY(0, -sizeB - height);
                x2 = calcMatrix.getX(sizeA, -height);
                y2 = calcMatrix.getY(sizeA, -height);
                x3 = calcMatrix.getX(0, sizeB - height);
                y3 = calcMatrix.getY(0, sizeB - height);
                pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
              }
              if (src.showLeft) {
                tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
                x0 = calcMatrix.getX(-sizeA, 0);
                y0 = calcMatrix.getY(-sizeA, 0);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
                x3 = calcMatrix.getX(-sizeA, -height);
                y3 = calcMatrix.getY(-sizeA, -height);
                pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
              }
              if (src.showRight) {
                tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
                x0 = calcMatrix.getX(sizeA, 0);
                y0 = calcMatrix.getY(sizeA, 0);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
                x3 = calcMatrix.getX(sizeA, -height);
                y3 = calcMatrix.getY(sizeA, -height);
                pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = IsoBoxWebGLRenderer;
          },
          65159: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var IsoTriangleRender = __webpack_require__2(93387);
            var Shape = __webpack_require__2(91461);
            var IsoTriangle = new Class({
              Extends: Shape,
              Mixins: [
                IsoTriangleRender
              ],
              initialize: function IsoTriangle2(scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (size === void 0) {
                  size = 48;
                }
                if (height === void 0) {
                  height = 32;
                }
                if (reversed === void 0) {
                  reversed = false;
                }
                if (fillTop === void 0) {
                  fillTop = 15658734;
                }
                if (fillLeft === void 0) {
                  fillLeft = 10066329;
                }
                if (fillRight === void 0) {
                  fillRight = 13421772;
                }
                Shape.call(this, scene, "IsoTriangle", null);
                this.projection = 4;
                this.fillTop = fillTop;
                this.fillLeft = fillLeft;
                this.fillRight = fillRight;
                this.showTop = true;
                this.showLeft = true;
                this.showRight = true;
                this.isReversed = reversed;
                this.isFilled = true;
                this.setPosition(x, y);
                this.setSize(size, height);
                this.updateDisplayOrigin();
              },
              setProjection: function(value) {
                this.projection = value;
                return this;
              },
              setReversed: function(reversed) {
                this.isReversed = reversed;
                return this;
              },
              setFaces: function(showTop, showLeft, showRight) {
                if (showTop === void 0) {
                  showTop = true;
                }
                if (showLeft === void 0) {
                  showLeft = true;
                }
                if (showRight === void 0) {
                  showRight = true;
                }
                this.showTop = showTop;
                this.showLeft = showLeft;
                this.showRight = showRight;
                return this;
              },
              setFillStyle: function(fillTop, fillLeft, fillRight) {
                this.fillTop = fillTop;
                this.fillLeft = fillLeft;
                this.fillRight = fillRight;
                this.isFilled = true;
                return this;
              }
            });
            module2.exports = IsoTriangle;
          },
          9923: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var SetTransform = __webpack_require__2(49584);
            var IsoTriangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
                var size = src.width;
                var height = src.height;
                var sizeA = size / 2;
                var sizeB = size / src.projection;
                var reversed = src.isReversed;
                if (src.showTop && reversed) {
                  FillStyleCanvas(ctx, src, src.fillTop);
                  ctx.beginPath();
                  ctx.moveTo(-sizeA, -height);
                  ctx.lineTo(0, -sizeB - height);
                  ctx.lineTo(sizeA, -height);
                  ctx.lineTo(0, sizeB - height);
                  ctx.fill();
                }
                if (src.showLeft) {
                  FillStyleCanvas(ctx, src, src.fillLeft);
                  ctx.beginPath();
                  if (reversed) {
                    ctx.moveTo(-sizeA, -height);
                    ctx.lineTo(0, sizeB);
                    ctx.lineTo(0, sizeB - height);
                  } else {
                    ctx.moveTo(-sizeA, 0);
                    ctx.lineTo(0, sizeB);
                    ctx.lineTo(0, sizeB - height);
                  }
                  ctx.fill();
                }
                if (src.showRight) {
                  FillStyleCanvas(ctx, src, src.fillRight);
                  ctx.beginPath();
                  if (reversed) {
                    ctx.moveTo(sizeA, -height);
                    ctx.lineTo(0, sizeB);
                    ctx.lineTo(0, sizeB - height);
                  } else {
                    ctx.moveTo(sizeA, 0);
                    ctx.lineTo(0, sizeB);
                    ctx.lineTo(0, sizeB - height);
                  }
                  ctx.fill();
                }
                ctx.restore();
              }
            };
            module2.exports = IsoTriangleCanvasRenderer;
          },
          67765: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var IsoTriangle = __webpack_require__2(65159);
            GameObjectFactory.register("isotriangle", function(x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
              return this.displayList.add(new IsoTriangle(this.scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight));
            });
          },
          93387: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(54946);
            }
            if (true) {
              renderCanvas = __webpack_require__2(9923);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          54946: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var Utils = __webpack_require__2(75512);
            var IsoTriangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
              var size = src.width;
              var height = src.height;
              var sizeA = size / 2;
              var sizeB = size / src.projection;
              var reversed = src.isReversed;
              var alpha = camera.alpha * src.alpha;
              if (!src.isFilled) {
                return;
              }
              renderer.pipelines.preBatch(src);
              var tint;
              var x0;
              var y0;
              var x1;
              var y1;
              var x2;
              var y2;
              if (src.showTop && reversed) {
                tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
                x0 = calcMatrix.getX(-sizeA, -height);
                y0 = calcMatrix.getY(-sizeA, -height);
                x1 = calcMatrix.getX(0, -sizeB - height);
                y1 = calcMatrix.getY(0, -sizeB - height);
                x2 = calcMatrix.getX(sizeA, -height);
                y2 = calcMatrix.getY(sizeA, -height);
                var x3 = calcMatrix.getX(0, sizeB - height);
                var y3 = calcMatrix.getY(0, sizeB - height);
                pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
              }
              if (src.showLeft) {
                tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
                if (reversed) {
                  x0 = calcMatrix.getX(-sizeA, -height);
                  y0 = calcMatrix.getY(-sizeA, -height);
                  x1 = calcMatrix.getX(0, sizeB);
                  y1 = calcMatrix.getY(0, sizeB);
                  x2 = calcMatrix.getX(0, sizeB - height);
                  y2 = calcMatrix.getY(0, sizeB - height);
                } else {
                  x0 = calcMatrix.getX(-sizeA, 0);
                  y0 = calcMatrix.getY(-sizeA, 0);
                  x1 = calcMatrix.getX(0, sizeB);
                  y1 = calcMatrix.getY(0, sizeB);
                  x2 = calcMatrix.getX(0, sizeB - height);
                  y2 = calcMatrix.getY(0, sizeB - height);
                }
                pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
              }
              if (src.showRight) {
                tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
                if (reversed) {
                  x0 = calcMatrix.getX(sizeA, -height);
                  y0 = calcMatrix.getY(sizeA, -height);
                  x1 = calcMatrix.getX(0, sizeB);
                  y1 = calcMatrix.getY(0, sizeB);
                  x2 = calcMatrix.getX(0, sizeB - height);
                  y2 = calcMatrix.getY(0, sizeB - height);
                } else {
                  x0 = calcMatrix.getX(sizeA, 0);
                  y0 = calcMatrix.getY(sizeA, 0);
                  x1 = calcMatrix.getX(0, sizeB);
                  y1 = calcMatrix.getY(0, sizeB);
                  x2 = calcMatrix.getX(0, sizeB - height);
                  y2 = calcMatrix.getY(0, sizeB - height);
                }
                pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = IsoTriangleWebGLRenderer;
          },
          579: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Shape = __webpack_require__2(91461);
            var GeomLine = __webpack_require__2(88829);
            var LineRender = __webpack_require__2(52660);
            var Line = new Class({
              Extends: Shape,
              Mixins: [
                LineRender
              ],
              initialize: function Line2(scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (x1 === void 0) {
                  x1 = 0;
                }
                if (y1 === void 0) {
                  y1 = 0;
                }
                if (x2 === void 0) {
                  x2 = 128;
                }
                if (y2 === void 0) {
                  y2 = 0;
                }
                Shape.call(this, scene, "Line", new GeomLine(x1, y1, x2, y2));
                var width = Math.max(1, this.geom.right - this.geom.left);
                var height = Math.max(1, this.geom.bottom - this.geom.top);
                this.lineWidth = 1;
                this._startWidth = 1;
                this._endWidth = 1;
                this.setPosition(x, y);
                this.setSize(width, height);
                if (strokeColor !== void 0) {
                  this.setStrokeStyle(1, strokeColor, strokeAlpha);
                }
                this.updateDisplayOrigin();
              },
              setLineWidth: function(startWidth, endWidth) {
                if (endWidth === void 0) {
                  endWidth = startWidth;
                }
                this._startWidth = startWidth;
                this._endWidth = endWidth;
                this.lineWidth = startWidth;
                return this;
              },
              setTo: function(x1, y1, x2, y2) {
                this.geom.setTo(x1, y1, x2, y2);
                return this;
              }
            });
            module2.exports = Line;
          },
          52044: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var LineCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var dx = src._displayOriginX;
                var dy = src._displayOriginY;
                if (src.isStroked) {
                  LineStyleCanvas(ctx, src);
                  ctx.beginPath();
                  ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);
                  ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);
                  ctx.stroke();
                }
                ctx.restore();
              }
            };
            module2.exports = LineCanvasRenderer;
          },
          85665: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var Line = __webpack_require__2(579);
            GameObjectFactory.register("line", function(x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
              return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));
            });
          },
          52660: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(46952);
            }
            if (true) {
              renderCanvas = __webpack_require__2(52044);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          46952: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var Utils = __webpack_require__2(75512);
            var LineWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              pipeline.calcMatrix.copyFrom(result.calc);
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              renderer.pipelines.preBatch(src);
              if (src.isStroked) {
                var strokeTint = pipeline.strokeTint;
                var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
                strokeTint.TL = color;
                strokeTint.TR = color;
                strokeTint.BL = color;
                strokeTint.BR = color;
                pipeline.batchLine(src.geom.x1 - dx, src.geom.y1 - dy, src.geom.x2 - dx, src.geom.y2 - dy, src._startWidth / 2, src._endWidth / 2, 1, 0, false, result.sprite, result.camera);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = LineWebGLRenderer;
          },
          91249: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PolygonRender = __webpack_require__2(70573);
            var Class = __webpack_require__2(56694);
            var Earcut = __webpack_require__2(11117);
            var GetAABB = __webpack_require__2(14045);
            var GeomPolygon = __webpack_require__2(8580);
            var Shape = __webpack_require__2(91461);
            var Smooth = __webpack_require__2(18974);
            var Polygon = new Class({
              Extends: Shape,
              Mixins: [
                PolygonRender
              ],
              initialize: function Polygon2(scene, x, y, points, fillColor, fillAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                Shape.call(this, scene, "Polygon", new GeomPolygon(points));
                var bounds = GetAABB(this.geom);
                this.setPosition(x, y);
                this.setSize(bounds.width, bounds.height);
                if (fillColor !== void 0) {
                  this.setFillStyle(fillColor, fillAlpha);
                }
                this.updateDisplayOrigin();
                this.updateData();
              },
              smooth: function(iterations) {
                if (iterations === void 0) {
                  iterations = 1;
                }
                for (var i = 0; i < iterations; i++) {
                  Smooth(this.geom);
                }
                return this.updateData();
              },
              setTo: function(points) {
                this.geom.setTo(points);
                var bounds = GetAABB(this.geom);
                this.setSize(bounds.width, bounds.height);
                this.updateDisplayOrigin();
                return this.updateData();
              },
              updateData: function() {
                var path = [];
                var points = this.geom.points;
                for (var i = 0; i < points.length; i++) {
                  path.push(points[i].x, points[i].y);
                }
                path.push(points[0].x, points[0].y);
                this.pathIndexes = Earcut(path);
                this.pathData = path;
                return this;
              }
            });
            module2.exports = Polygon;
          },
          40834: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var PolygonCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var dx = src._displayOriginX;
                var dy = src._displayOriginY;
                var path = src.pathData;
                var pathLength = path.length - 1;
                var px1 = path[0] - dx;
                var py1 = path[1] - dy;
                ctx.beginPath();
                ctx.moveTo(px1, py1);
                if (!src.closePath) {
                  pathLength -= 2;
                }
                for (var i = 2; i < pathLength; i += 2) {
                  var px2 = path[i] - dx;
                  var py2 = path[i + 1] - dy;
                  ctx.lineTo(px2, py2);
                }
                if (src.closePath) {
                  ctx.closePath();
                }
                if (src.isFilled) {
                  FillStyleCanvas(ctx, src);
                  ctx.fill();
                }
                if (src.isStroked) {
                  LineStyleCanvas(ctx, src);
                  ctx.stroke();
                }
                ctx.restore();
              }
            };
            module2.exports = PolygonCanvasRenderer;
          },
          88203: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var Polygon = __webpack_require__2(91249);
            GameObjectFactory.register("polygon", function(x, y, points, fillColor, fillAlpha) {
              return this.displayList.add(new Polygon(this.scene, x, y, points, fillColor, fillAlpha));
            });
          },
          70573: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(72841);
            }
            if (true) {
              renderCanvas = __webpack_require__2(40834);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          72841: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillPathWebGL = __webpack_require__2(19543);
            var GetCalcMatrix = __webpack_require__2(73329);
            var StrokePathWebGL = __webpack_require__2(50262);
            var PolygonWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              renderer.pipelines.preBatch(src);
              if (src.isFilled) {
                FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
              }
              if (src.isStroked) {
                StrokePathWebGL(pipeline, src, alpha, dx, dy);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = PolygonWebGLRenderer;
          },
          517: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GeomRectangle = __webpack_require__2(74118);
            var Shape = __webpack_require__2(91461);
            var RectangleRender = __webpack_require__2(37673);
            var Rectangle = new Class({
              Extends: Shape,
              Mixins: [
                RectangleRender
              ],
              initialize: function Rectangle2(scene, x, y, width, height, fillColor, fillAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = 128;
                }
                if (height === void 0) {
                  height = 128;
                }
                Shape.call(this, scene, "Rectangle", new GeomRectangle(0, 0, width, height));
                this.setPosition(x, y);
                this.setSize(width, height);
                if (fillColor !== void 0) {
                  this.setFillStyle(fillColor, fillAlpha);
                }
                this.updateDisplayOrigin();
                this.updateData();
              },
              setSize: function(width, height) {
                this.width = width;
                this.height = height;
                this.geom.setSize(width, height);
                this.updateData();
                this.updateDisplayOrigin();
                var input = this.input;
                if (input && !input.customHitArea) {
                  input.hitArea.width = width;
                  input.hitArea.height = height;
                }
                return this;
              },
              updateData: function() {
                var path = [];
                var rect = this.geom;
                var line = this._tempLine;
                rect.getLineA(line);
                path.push(line.x1, line.y1, line.x2, line.y2);
                rect.getLineB(line);
                path.push(line.x2, line.y2);
                rect.getLineC(line);
                path.push(line.x2, line.y2);
                rect.getLineD(line);
                path.push(line.x2, line.y2);
                this.pathData = path;
                return this;
              }
            });
            module2.exports = Rectangle;
          },
          4091: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var RectangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var dx = src._displayOriginX;
                var dy = src._displayOriginY;
                if (src.isFilled) {
                  FillStyleCanvas(ctx, src);
                  ctx.fillRect(-dx, -dy, src.width, src.height);
                }
                if (src.isStroked) {
                  LineStyleCanvas(ctx, src);
                  ctx.beginPath();
                  ctx.rect(-dx, -dy, src.width, src.height);
                  ctx.stroke();
                }
                ctx.restore();
              }
            };
            module2.exports = RectangleCanvasRenderer;
          },
          94355: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var Rectangle = __webpack_require__2(517);
            GameObjectFactory.register("rectangle", function(x, y, width, height, fillColor, fillAlpha) {
              return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));
            });
          },
          37673: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(43532);
            }
            if (true) {
              renderCanvas = __webpack_require__2(4091);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          43532: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var StrokePathWebGL = __webpack_require__2(50262);
            var Utils = __webpack_require__2(75512);
            var RectangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              pipeline.calcMatrix.copyFrom(result.calc);
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              renderer.pipelines.preBatch(src);
              if (src.isFilled) {
                var fillTint = pipeline.fillTint;
                var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
                fillTint.TL = fillTintColor;
                fillTint.TR = fillTintColor;
                fillTint.BL = fillTintColor;
                fillTint.BR = fillTintColor;
                pipeline.batchFillRect(-dx, -dy, src.width, src.height);
              }
              if (src.isStroked) {
                StrokePathWebGL(pipeline, src, alpha, dx, dy);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = RectangleWebGLRenderer;
          },
          77843: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var StarRender = __webpack_require__2(87956);
            var Class = __webpack_require__2(56694);
            var Earcut = __webpack_require__2(11117);
            var Shape = __webpack_require__2(91461);
            var Star = new Class({
              Extends: Shape,
              Mixins: [
                StarRender
              ],
              initialize: function Star2(scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (points === void 0) {
                  points = 5;
                }
                if (innerRadius === void 0) {
                  innerRadius = 32;
                }
                if (outerRadius === void 0) {
                  outerRadius = 64;
                }
                Shape.call(this, scene, "Star", null);
                this._points = points;
                this._innerRadius = innerRadius;
                this._outerRadius = outerRadius;
                this.setPosition(x, y);
                this.setSize(outerRadius * 2, outerRadius * 2);
                if (fillColor !== void 0) {
                  this.setFillStyle(fillColor, fillAlpha);
                }
                this.updateDisplayOrigin();
                this.updateData();
              },
              setPoints: function(value) {
                this._points = value;
                return this.updateData();
              },
              setInnerRadius: function(value) {
                this._innerRadius = value;
                return this.updateData();
              },
              setOuterRadius: function(value) {
                this._outerRadius = value;
                return this.updateData();
              },
              points: {
                get: function() {
                  return this._points;
                },
                set: function(value) {
                  this._points = value;
                  this.updateData();
                }
              },
              innerRadius: {
                get: function() {
                  return this._innerRadius;
                },
                set: function(value) {
                  this._innerRadius = value;
                  this.updateData();
                }
              },
              outerRadius: {
                get: function() {
                  return this._outerRadius;
                },
                set: function(value) {
                  this._outerRadius = value;
                  this.updateData();
                }
              },
              updateData: function() {
                var path = [];
                var points = this._points;
                var innerRadius = this._innerRadius;
                var outerRadius = this._outerRadius;
                var rot = Math.PI / 2 * 3;
                var step = Math.PI / points;
                var x = outerRadius;
                var y = outerRadius;
                path.push(x, y + -outerRadius);
                for (var i = 0; i < points; i++) {
                  path.push(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
                  rot += step;
                  path.push(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
                  rot += step;
                }
                path.push(x, y + -outerRadius);
                this.pathIndexes = Earcut(path);
                this.pathData = path;
                return this;
              }
            });
            module2.exports = Star;
          },
          11401: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var StarCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var dx = src._displayOriginX;
                var dy = src._displayOriginY;
                var path = src.pathData;
                var pathLength = path.length - 1;
                var px1 = path[0] - dx;
                var py1 = path[1] - dy;
                ctx.beginPath();
                ctx.moveTo(px1, py1);
                if (!src.closePath) {
                  pathLength -= 2;
                }
                for (var i = 2; i < pathLength; i += 2) {
                  var px2 = path[i] - dx;
                  var py2 = path[i + 1] - dy;
                  ctx.lineTo(px2, py2);
                }
                ctx.closePath();
                if (src.isFilled) {
                  FillStyleCanvas(ctx, src);
                  ctx.fill();
                }
                if (src.isStroked) {
                  LineStyleCanvas(ctx, src);
                  ctx.stroke();
                }
                ctx.restore();
              }
            };
            module2.exports = StarCanvasRenderer;
          },
          23962: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Star = __webpack_require__2(77843);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("star", function(x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
              return this.displayList.add(new Star(this.scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha));
            });
          },
          87956: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(12037);
            }
            if (true) {
              renderCanvas = __webpack_require__2(11401);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          12037: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillPathWebGL = __webpack_require__2(19543);
            var GetCalcMatrix = __webpack_require__2(73329);
            var StrokePathWebGL = __webpack_require__2(50262);
            var StarWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              renderer.pipelines.preBatch(src);
              if (src.isFilled) {
                FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
              }
              if (src.isStroked) {
                StrokePathWebGL(pipeline, src, alpha, dx, dy);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = StarWebGLRenderer;
          },
          21873: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Shape = __webpack_require__2(91461);
            var GeomTriangle = __webpack_require__2(66349);
            var TriangleRender = __webpack_require__2(70498);
            var Triangle = new Class({
              Extends: Shape,
              Mixins: [
                TriangleRender
              ],
              initialize: function Triangle2(scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (x1 === void 0) {
                  x1 = 0;
                }
                if (y1 === void 0) {
                  y1 = 128;
                }
                if (x2 === void 0) {
                  x2 = 64;
                }
                if (y2 === void 0) {
                  y2 = 0;
                }
                if (x3 === void 0) {
                  x3 = 128;
                }
                if (y3 === void 0) {
                  y3 = 128;
                }
                Shape.call(this, scene, "Triangle", new GeomTriangle(x1, y1, x2, y2, x3, y3));
                var width = this.geom.right - this.geom.left;
                var height = this.geom.bottom - this.geom.top;
                this.setPosition(x, y);
                this.setSize(width, height);
                if (fillColor !== void 0) {
                  this.setFillStyle(fillColor, fillAlpha);
                }
                this.updateDisplayOrigin();
                this.updateData();
              },
              setTo: function(x1, y1, x2, y2, x3, y3) {
                this.geom.setTo(x1, y1, x2, y2, x3, y3);
                return this.updateData();
              },
              updateData: function() {
                var path = [];
                var tri = this.geom;
                var line = this._tempLine;
                tri.getLineA(line);
                path.push(line.x1, line.y1, line.x2, line.y2);
                tri.getLineB(line);
                path.push(line.x2, line.y2);
                tri.getLineC(line);
                path.push(line.x2, line.y2);
                this.pathData = path;
                return this;
              }
            });
            module2.exports = Triangle;
          },
          60213: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FillStyleCanvas = __webpack_require__2(15608);
            var LineStyleCanvas = __webpack_require__2(17876);
            var SetTransform = __webpack_require__2(49584);
            var TriangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var ctx = renderer.currentContext;
              if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
                var dx = src._displayOriginX;
                var dy = src._displayOriginY;
                var x1 = src.geom.x1 - dx;
                var y1 = src.geom.y1 - dy;
                var x2 = src.geom.x2 - dx;
                var y2 = src.geom.y2 - dy;
                var x3 = src.geom.x3 - dx;
                var y3 = src.geom.y3 - dy;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.lineTo(x3, y3);
                ctx.closePath();
                if (src.isFilled) {
                  FillStyleCanvas(ctx, src);
                  ctx.fill();
                }
                if (src.isStroked) {
                  LineStyleCanvas(ctx, src);
                  ctx.stroke();
                }
                ctx.restore();
              }
            };
            module2.exports = TriangleCanvasRenderer;
          },
          79296: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var Triangle = __webpack_require__2(21873);
            GameObjectFactory.register("triangle", function(x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
              return this.displayList.add(new Triangle(this.scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha));
            });
          },
          70498: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(72291);
            }
            if (true) {
              renderCanvas = __webpack_require__2(60213);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          72291: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var StrokePathWebGL = __webpack_require__2(50262);
            var Utils = __webpack_require__2(75512);
            var TriangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              var pipeline = renderer.pipelines.set(src.pipeline);
              var result = GetCalcMatrix(src, camera, parentMatrix);
              pipeline.calcMatrix.copyFrom(result.calc);
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              renderer.pipelines.preBatch(src);
              if (src.isFilled) {
                var fillTint = pipeline.fillTint;
                var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
                fillTint.TL = fillTintColor;
                fillTint.TR = fillTintColor;
                fillTint.BL = fillTintColor;
                fillTint.BR = fillTintColor;
                var x1 = src.geom.x1 - dx;
                var y1 = src.geom.y1 - dy;
                var x2 = src.geom.x2 - dx;
                var y2 = src.geom.y2 - dy;
                var x3 = src.geom.x3 - dx;
                var y3 = src.geom.y3 - dy;
                pipeline.batchFillTriangle(x1, y1, x2, y2, x3, y3, result.sprite, result.camera);
              }
              if (src.isStroked) {
                StrokePathWebGL(pipeline, src, alpha, dx, dy);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = TriangleWebGLRenderer;
          },
          13747: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AnimationState = __webpack_require__2(16569);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var SpriteRender = __webpack_require__2(20791);
            var Sprite = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Size,
                Components.TextureCrop,
                Components.Tint,
                Components.Transform,
                Components.Visible,
                SpriteRender
              ],
              initialize: function Sprite2(scene, x, y, texture, frame) {
                GameObject.call(this, scene, "Sprite");
                this._crop = this.resetCropObject();
                this.anims = new AnimationState(this);
                this.setTexture(texture, frame);
                this.setPosition(x, y);
                this.setSizeToFrame();
                this.setOriginFromFrame();
                this.initPipeline();
                this.initPostPipeline(true);
              },
              addedToScene: function() {
                this.scene.sys.updateList.add(this);
              },
              removedFromScene: function() {
                this.scene.sys.updateList.remove(this);
              },
              preUpdate: function(time, delta) {
                this.anims.update(time, delta);
              },
              play: function(key, ignoreIfPlaying) {
                return this.anims.play(key, ignoreIfPlaying);
              },
              playReverse: function(key, ignoreIfPlaying) {
                return this.anims.playReverse(key, ignoreIfPlaying);
              },
              playAfterDelay: function(key, delay) {
                return this.anims.playAfterDelay(key, delay);
              },
              playAfterRepeat: function(key, repeatCount) {
                return this.anims.playAfterRepeat(key, repeatCount);
              },
              chain: function(key) {
                return this.anims.chain(key);
              },
              stop: function() {
                return this.anims.stop();
              },
              stopAfterDelay: function(delay) {
                return this.anims.stopAfterDelay(delay);
              },
              stopAfterRepeat: function(repeatCount) {
                return this.anims.stopAfterRepeat(repeatCount);
              },
              stopOnFrame: function(frame) {
                return this.anims.stopOnFrame(frame);
              },
              toJSON: function() {
                return Components.ToJSON(this);
              },
              preDestroy: function() {
                this.anims.destroy();
                this.anims = void 0;
              }
            });
            module2.exports = Sprite;
          },
          27573: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              renderer.batchSprite(src, src.frame, camera, parentMatrix);
            };
            module2.exports = SpriteCanvasRenderer;
          },
          89219: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var BuildGameObjectAnimation = __webpack_require__2(32291);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var Sprite = __webpack_require__2(13747);
            GameObjectCreator.register("sprite", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var frame = GetAdvancedValue(config2, "frame", null);
              var sprite = new Sprite(this.scene, 0, 0, key, frame);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, sprite, config2);
              BuildGameObjectAnimation(sprite, config2);
              return sprite;
            });
          },
          66135: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var Sprite = __webpack_require__2(13747);
            GameObjectFactory.register("sprite", function(x, y, texture, frame) {
              return this.displayList.add(new Sprite(this.scene, x, y, texture, frame));
            });
          },
          20791: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(21034);
            }
            if (true) {
              renderCanvas = __webpack_require__2(27573);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          21034: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              camera.addToRenderList(src);
              src.pipeline.batchSprite(src, camera, parentMatrix);
            };
            module2.exports = SpriteWebGLRenderer;
          },
          32979: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTextSize = function(text, size, lines) {
              var canvas = text.canvas;
              var context = text.context;
              var style = text.style;
              var lineWidths = [];
              var maxLineWidth = 0;
              var drawnLines = lines.length;
              if (style.maxLines > 0 && style.maxLines < lines.length) {
                drawnLines = style.maxLines;
              }
              style.syncFont(canvas, context);
              for (var i = 0; i < drawnLines; i++) {
                var lineWidth = style.strokeThickness;
                lineWidth += context.measureText(lines[i]).width;
                if (lines[i].length > 1) {
                  lineWidth += text.letterSpacing * (lines[i].length - 1);
                }
                if (style.wordWrap) {
                  lineWidth -= context.measureText(" ").width;
                }
                lineWidths[i] = Math.ceil(lineWidth);
                maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
              }
              var lineHeight = size.fontSize + style.strokeThickness;
              var height = lineHeight * drawnLines;
              var lineSpacing = text.lineSpacing;
              if (drawnLines > 1) {
                height += lineSpacing * (drawnLines - 1);
              }
              return {
                width: maxLineWidth,
                height,
                lines: drawnLines,
                lineWidths,
                lineSpacing,
                lineHeight
              };
            };
            module2.exports = GetTextSize;
          },
          27030: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasPool = __webpack_require__2(61068);
            var MeasureText = function(textStyle) {
              var canvas = CanvasPool.create(this);
              var context = canvas.getContext("2d", {willReadFrequently: true});
              textStyle.syncFont(canvas, context);
              var metrics = context.measureText(textStyle.testString);
              if ("actualBoundingBoxAscent" in metrics) {
                var ascent = metrics.actualBoundingBoxAscent;
                var descent = metrics.actualBoundingBoxDescent;
                CanvasPool.remove(canvas);
                return {
                  ascent,
                  descent,
                  fontSize: ascent + descent
                };
              }
              var width = Math.ceil(metrics.width * textStyle.baselineX);
              var baseline = width;
              var height = 2 * baseline;
              baseline = baseline * textStyle.baselineY | 0;
              canvas.width = width;
              canvas.height = height;
              context.fillStyle = "#f00";
              context.fillRect(0, 0, width, height);
              context.font = textStyle._font;
              context.textBaseline = "alphabetic";
              context.fillStyle = "#000";
              context.fillText(textStyle.testString, 0, baseline);
              var output = {
                ascent: 0,
                descent: 0,
                fontSize: 0
              };
              var imagedata = context.getImageData(0, 0, width, height);
              if (!imagedata) {
                output.ascent = baseline;
                output.descent = baseline + 6;
                output.fontSize = output.ascent + output.descent;
                CanvasPool.remove(canvas);
                return output;
              }
              var pixels = imagedata.data;
              var numPixels = pixels.length;
              var line = width * 4;
              var i;
              var j;
              var idx = 0;
              var stop = false;
              for (i = 0; i < baseline; i++) {
                for (j = 0; j < line; j += 4) {
                  if (pixels[idx + j] !== 255) {
                    stop = true;
                    break;
                  }
                }
                if (!stop) {
                  idx += line;
                } else {
                  break;
                }
              }
              output.ascent = baseline - i;
              idx = numPixels - line;
              stop = false;
              for (i = height; i > baseline; i--) {
                for (j = 0; j < line; j += 4) {
                  if (pixels[idx + j] !== 255) {
                    stop = true;
                    break;
                  }
                }
                if (!stop) {
                  idx -= line;
                } else {
                  break;
                }
              }
              output.descent = i - baseline;
              output.fontSize = output.ascent + output.descent;
              CanvasPool.remove(canvas);
              return output;
            };
            module2.exports = MeasureText;
          },
          76555: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AddToDOM = __webpack_require__2(99584);
            var CanvasPool = __webpack_require__2(61068);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var GetTextSize = __webpack_require__2(32979);
            var GetValue = __webpack_require__2(10850);
            var RemoveFromDOM = __webpack_require__2(55638);
            var TextRender = __webpack_require__2(80032);
            var TextStyle = __webpack_require__2(74744);
            var Text = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Crop,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Tint,
                Components.Transform,
                Components.Visible,
                TextRender
              ],
              initialize: function Text2(scene, x, y, text, style) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                GameObject.call(this, scene, "Text");
                this.renderer = scene.sys.renderer;
                this.setPosition(x, y);
                this.setOrigin(0, 0);
                this.initPipeline();
                this.initPostPipeline(true);
                this.canvas = CanvasPool.create(this);
                this.context;
                this.style = new TextStyle(this, style);
                this.autoRound = true;
                this.splitRegExp = /(?:\r\n|\r|\n)/;
                this._text = void 0;
                this.padding = {left: 0, right: 0, top: 0, bottom: 0};
                this.width = 1;
                this.height = 1;
                this.lineSpacing = 0;
                this.letterSpacing = 0;
                if (this.style.resolution === 0) {
                  this.style.resolution = 1;
                }
                this._crop = this.resetCropObject();
                this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
                this.context = this.texture.context;
                this.frame = this.texture.get();
                this.frame.source.resolution = this.style.resolution;
                if (this.renderer && this.renderer.gl) {
                  this.renderer.deleteTexture(this.frame.source.glTexture);
                  this.frame.source.glTexture = null;
                }
                this.initRTL();
                this.setText(text);
                if (style && style.padding) {
                  this.setPadding(style.padding);
                }
                if (style && style.lineSpacing) {
                  this.setLineSpacing(style.lineSpacing);
                }
              },
              initRTL: function() {
                if (!this.style.rtl) {
                  return;
                }
                this.canvas.dir = "rtl";
                this.context.direction = "rtl";
                this.canvas.style.display = "none";
                AddToDOM(this.canvas, this.scene.sys.canvas);
                this.originX = 1;
              },
              runWordWrap: function(text) {
                var style = this.style;
                if (style.wordWrapCallback) {
                  var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);
                  if (Array.isArray(wrappedLines)) {
                    wrappedLines = wrappedLines.join("\n");
                  }
                  return wrappedLines;
                } else if (style.wordWrapWidth) {
                  if (style.wordWrapUseAdvanced) {
                    return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);
                  } else {
                    return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);
                  }
                } else {
                  return text;
                }
              },
              advancedWordWrap: function(text, context, wordWrapWidth) {
                var output = "";
                var lines = text.replace(/ +/gi, " ").split(this.splitRegExp);
                var linesCount = lines.length;
                for (var i = 0; i < linesCount; i++) {
                  var line = lines[i];
                  var out = "";
                  line = line.replace(/^ *|\s*$/gi, "");
                  var lineWidth = context.measureText(line).width;
                  if (lineWidth < wordWrapWidth) {
                    output += line + "\n";
                    continue;
                  }
                  var currentLineWidth = wordWrapWidth;
                  var words = line.split(" ");
                  for (var j = 0; j < words.length; j++) {
                    var word = words[j];
                    var wordWithSpace = word + " ";
                    var wordWidth = context.measureText(wordWithSpace).width;
                    if (wordWidth > currentLineWidth) {
                      if (j === 0) {
                        var newWord = wordWithSpace;
                        while (newWord.length) {
                          newWord = newWord.slice(0, -1);
                          wordWidth = context.measureText(newWord).width;
                          if (wordWidth <= currentLineWidth) {
                            break;
                          }
                        }
                        if (!newWord.length) {
                          throw new Error("wordWrapWidth < a single character");
                        }
                        var secondPart = word.substr(newWord.length);
                        words[j] = secondPart;
                        out += newWord;
                      }
                      var offset = words[j].length ? j : j + 1;
                      var remainder = words.slice(offset).join(" ").replace(/[ \n]*$/gi, "");
                      lines.splice(i + 1, 0, remainder);
                      linesCount = lines.length;
                      break;
                    } else {
                      out += wordWithSpace;
                      currentLineWidth -= wordWidth;
                    }
                  }
                  output += out.replace(/[ \n]*$/gi, "") + "\n";
                }
                output = output.replace(/[\s|\n]*$/gi, "");
                return output;
              },
              basicWordWrap: function(text, context, wordWrapWidth) {
                var result = "";
                var lines = text.split(this.splitRegExp);
                var lastLineIndex = lines.length - 1;
                var whiteSpaceWidth = context.measureText(" ").width;
                for (var i = 0; i <= lastLineIndex; i++) {
                  var spaceLeft = wordWrapWidth;
                  var words = lines[i].split(" ");
                  var lastWordIndex = words.length - 1;
                  for (var j = 0; j <= lastWordIndex; j++) {
                    var word = words[j];
                    var wordWidth = context.measureText(word).width;
                    var wordWidthWithSpace = wordWidth;
                    if (j < lastWordIndex) {
                      wordWidthWithSpace += whiteSpaceWidth;
                    }
                    if (wordWidthWithSpace > spaceLeft) {
                      if (j > 0) {
                        result += "\n";
                        spaceLeft = wordWrapWidth;
                      }
                    }
                    result += word;
                    if (j < lastWordIndex) {
                      result += " ";
                      spaceLeft -= wordWidthWithSpace;
                    } else {
                      spaceLeft -= wordWidth;
                    }
                  }
                  if (i < lastLineIndex) {
                    result += "\n";
                  }
                }
                return result;
              },
              getWrappedText: function(text) {
                if (text === void 0) {
                  text = this._text;
                }
                this.style.syncFont(this.canvas, this.context);
                var wrappedLines = this.runWordWrap(text);
                return wrappedLines.split(this.splitRegExp);
              },
              setText: function(value) {
                if (!value && value !== 0) {
                  value = "";
                }
                if (Array.isArray(value)) {
                  value = value.join("\n");
                }
                if (value !== this._text) {
                  this._text = value.toString();
                  this.updateText();
                }
                return this;
              },
              appendText: function(value, addCR) {
                if (addCR === void 0) {
                  addCR = true;
                }
                if (!value && value !== 0) {
                  value = "";
                }
                if (Array.isArray(value)) {
                  value = value.join("\n");
                }
                value = value.toString();
                var newText = this._text.concat(addCR ? "\n" + value : value);
                if (newText !== this._text) {
                  this._text = newText;
                  this.updateText();
                }
                return this;
              },
              setStyle: function(style) {
                return this.style.setStyle(style);
              },
              setFont: function(font) {
                return this.style.setFont(font);
              },
              setFontFamily: function(family) {
                return this.style.setFontFamily(family);
              },
              setFontSize: function(size) {
                return this.style.setFontSize(size);
              },
              setFontStyle: function(style) {
                return this.style.setFontStyle(style);
              },
              setFixedSize: function(width, height) {
                return this.style.setFixedSize(width, height);
              },
              setBackgroundColor: function(color) {
                return this.style.setBackgroundColor(color);
              },
              setFill: function(fillStyle) {
                return this.style.setFill(fillStyle);
              },
              setColor: function(color) {
                return this.style.setColor(color);
              },
              setStroke: function(color, thickness) {
                return this.style.setStroke(color, thickness);
              },
              setShadow: function(x, y, color, blur, shadowStroke, shadowFill) {
                return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
              },
              setShadowOffset: function(x, y) {
                return this.style.setShadowOffset(x, y);
              },
              setShadowColor: function(color) {
                return this.style.setShadowColor(color);
              },
              setShadowBlur: function(blur) {
                return this.style.setShadowBlur(blur);
              },
              setShadowStroke: function(enabled) {
                return this.style.setShadowStroke(enabled);
              },
              setShadowFill: function(enabled) {
                return this.style.setShadowFill(enabled);
              },
              setWordWrapWidth: function(width, useAdvancedWrap) {
                return this.style.setWordWrapWidth(width, useAdvancedWrap);
              },
              setWordWrapCallback: function(callback, scope) {
                return this.style.setWordWrapCallback(callback, scope);
              },
              setAlign: function(align) {
                return this.style.setAlign(align);
              },
              setResolution: function(value) {
                return this.style.setResolution(value);
              },
              setLineSpacing: function(value) {
                this.lineSpacing = value;
                return this.updateText();
              },
              setLetterSpacing: function(value) {
                this.letterSpacing = value;
                return this.updateText();
              },
              setPadding: function(left, top, right, bottom) {
                if (typeof left === "object") {
                  var config2 = left;
                  var x = GetValue(config2, "x", null);
                  if (x !== null) {
                    left = x;
                    right = x;
                  } else {
                    left = GetValue(config2, "left", 0);
                    right = GetValue(config2, "right", left);
                  }
                  var y = GetValue(config2, "y", null);
                  if (y !== null) {
                    top = y;
                    bottom = y;
                  } else {
                    top = GetValue(config2, "top", 0);
                    bottom = GetValue(config2, "bottom", top);
                  }
                } else {
                  if (left === void 0) {
                    left = 0;
                  }
                  if (top === void 0) {
                    top = left;
                  }
                  if (right === void 0) {
                    right = left;
                  }
                  if (bottom === void 0) {
                    bottom = top;
                  }
                }
                this.padding.left = left;
                this.padding.top = top;
                this.padding.right = right;
                this.padding.bottom = bottom;
                return this.updateText();
              },
              setMaxLines: function(max) {
                return this.style.setMaxLines(max);
              },
              setRTL: function(rtl) {
                if (rtl === void 0) {
                  rtl = true;
                }
                var style = this.style;
                if (style.rtl === rtl) {
                  return this;
                }
                style.rtl = rtl;
                if (rtl) {
                  this.canvas.dir = "rtl";
                  this.context.direction = "rtl";
                  this.canvas.style.display = "none";
                  AddToDOM(this.canvas, this.scene.sys.canvas);
                } else {
                  this.canvas.dir = "ltr";
                  this.context.direction = "ltr";
                }
                if (style.align === "left") {
                  style.align = "right";
                } else if (style.align === "right") {
                  style.align = "left";
                }
                return this;
              },
              updateText: function() {
                var canvas = this.canvas;
                var context = this.context;
                var style = this.style;
                var resolution = style.resolution;
                var size = style.metrics;
                style.syncFont(canvas, context);
                var outputText = this._text;
                if (style.wordWrapWidth || style.wordWrapCallback) {
                  outputText = this.runWordWrap(this._text);
                }
                var lines = outputText.split(this.splitRegExp);
                var textSize = GetTextSize(this, size, lines);
                var padding = this.padding;
                var textWidth;
                if (style.fixedWidth === 0) {
                  this.width = textSize.width + padding.left + padding.right;
                  textWidth = textSize.width;
                } else {
                  this.width = style.fixedWidth;
                  textWidth = this.width - padding.left - padding.right;
                  if (textWidth < textSize.width) {
                    textWidth = textSize.width;
                  }
                }
                if (style.fixedHeight === 0) {
                  this.height = textSize.height + padding.top + padding.bottom;
                } else {
                  this.height = style.fixedHeight;
                }
                var w = this.width;
                var h = this.height;
                this.updateDisplayOrigin();
                w *= resolution;
                h *= resolution;
                w = Math.max(w, 1);
                h = Math.max(h, 1);
                if (canvas.width !== w || canvas.height !== h) {
                  canvas.width = w;
                  canvas.height = h;
                  this.frame.setSize(w, h);
                  style.syncFont(canvas, context);
                  if (style.rtl) {
                    context.direction = "rtl";
                  }
                } else {
                  context.clearRect(0, 0, w, h);
                }
                context.save();
                context.scale(resolution, resolution);
                if (style.backgroundColor) {
                  context.fillStyle = style.backgroundColor;
                  context.fillRect(0, 0, w, h);
                }
                style.syncStyle(canvas, context);
                context.translate(padding.left, padding.top);
                var linePositionX;
                var linePositionY;
                for (var i = 0; i < textSize.lines; i++) {
                  linePositionX = style.strokeThickness / 2;
                  linePositionY = style.strokeThickness / 2 + i * textSize.lineHeight + size.ascent;
                  if (i > 0) {
                    linePositionY += textSize.lineSpacing * i;
                  }
                  if (style.rtl) {
                    linePositionX = w - linePositionX - padding.left - padding.right;
                  } else if (style.align === "right") {
                    linePositionX += textWidth - textSize.lineWidths[i];
                  } else if (style.align === "center") {
                    linePositionX += (textWidth - textSize.lineWidths[i]) / 2;
                  } else if (style.align === "justify") {
                    var minimumLengthToApplyJustification = 0.85;
                    if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification) {
                      var extraSpace = textSize.width - textSize.lineWidths[i];
                      var spaceSize = context.measureText(" ").width;
                      var trimmedLine = lines[i].trim();
                      var array = trimmedLine.split(" ");
                      extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;
                      var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);
                      var idx = 0;
                      while (extraSpaceCharacters > 0) {
                        array[idx] += " ";
                        idx = (idx + 1) % (array.length - 1 || 1);
                        --extraSpaceCharacters;
                      }
                      lines[i] = array.join(" ");
                    }
                  }
                  if (this.autoRound) {
                    linePositionX = Math.round(linePositionX);
                    linePositionY = Math.round(linePositionY);
                  }
                  if (style.strokeThickness) {
                    style.syncShadow(context, style.shadowStroke);
                    context.strokeText(lines[i], linePositionX, linePositionY);
                  }
                  if (style.color) {
                    style.syncShadow(context, style.shadowFill);
                    var letterSpacing = this.letterSpacing;
                    if (letterSpacing !== 0) {
                      var charPositionX = 0;
                      var line = lines[i].split("");
                      for (var l = 0; l < line.length; l++) {
                        context.fillText(line[l], linePositionX + charPositionX, linePositionY);
                        charPositionX += context.measureText(line[l]).width + letterSpacing;
                      }
                    } else {
                      context.fillText(lines[i], linePositionX, linePositionY);
                    }
                  }
                }
                context.restore();
                if (this.renderer && this.renderer.gl) {
                  this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
                  this.frame.glTexture = this.frame.source.glTexture;
                  if (false) {
                  }
                }
                var input = this.input;
                if (input && !input.customHitArea) {
                  input.hitArea.width = this.width;
                  input.hitArea.height = this.height;
                }
                return this;
              },
              getTextMetrics: function() {
                return this.style.getTextMetrics();
              },
              text: {
                get: function() {
                  return this._text;
                },
                set: function(value) {
                  this.setText(value);
                }
              },
              toJSON: function() {
                var out = Components.ToJSON(this);
                var data = {
                  autoRound: this.autoRound,
                  text: this._text,
                  style: this.style.toJSON(),
                  padding: {
                    left: this.padding.left,
                    right: this.padding.right,
                    top: this.padding.top,
                    bottom: this.padding.bottom
                  }
                };
                out.data = data;
                return out;
              },
              preDestroy: function() {
                RemoveFromDOM(this.canvas);
                CanvasPool.remove(this.canvas);
                this.texture.destroy();
              }
            });
            module2.exports = Text;
          },
          71649: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              if (src.width === 0 || src.height === 0) {
                return;
              }
              camera.addToRenderList(src);
              renderer.batchSprite(src, src.frame, camera, parentMatrix);
            };
            module2.exports = TextCanvasRenderer;
          },
          75397: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var Text = __webpack_require__2(76555);
            GameObjectCreator.register("text", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var content = GetAdvancedValue(config2, "text", "");
              var style = GetAdvancedValue(config2, "style", null);
              var padding = GetAdvancedValue(config2, "padding", null);
              if (padding !== null) {
                style.padding = padding;
              }
              var text = new Text(this.scene, 0, 0, content, style);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, text, config2);
              text.autoRound = GetAdvancedValue(config2, "autoRound", true);
              text.resolution = GetAdvancedValue(config2, "resolution", 1);
              return text;
            });
          },
          94627: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Text = __webpack_require__2(76555);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("text", function(x, y, text, style) {
              return this.displayList.add(new Text(this.scene, x, y, text, style));
            });
          },
          80032: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(76128);
            }
            if (true) {
              renderCanvas = __webpack_require__2(71649);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          74744: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetValue = __webpack_require__2(10850);
            var MeasureText = __webpack_require__2(27030);
            var propertyMap = {
              fontFamily: ["fontFamily", "Courier"],
              fontSize: ["fontSize", "16px"],
              fontStyle: ["fontStyle", ""],
              backgroundColor: ["backgroundColor", null],
              color: ["color", "#fff"],
              stroke: ["stroke", "#fff"],
              strokeThickness: ["strokeThickness", 0],
              shadowOffsetX: ["shadow.offsetX", 0],
              shadowOffsetY: ["shadow.offsetY", 0],
              shadowColor: ["shadow.color", "#000"],
              shadowBlur: ["shadow.blur", 0],
              shadowStroke: ["shadow.stroke", false],
              shadowFill: ["shadow.fill", false],
              align: ["align", "left"],
              maxLines: ["maxLines", 0],
              fixedWidth: ["fixedWidth", 0],
              fixedHeight: ["fixedHeight", 0],
              resolution: ["resolution", 0],
              rtl: ["rtl", false],
              testString: ["testString", "|M\xC3\u2030qgy"],
              baselineX: ["baselineX", 1.2],
              baselineY: ["baselineY", 1.4],
              wordWrapWidth: ["wordWrap.width", null],
              wordWrapCallback: ["wordWrap.callback", null],
              wordWrapCallbackScope: ["wordWrap.callbackScope", null],
              wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", false]
            };
            var TextStyle = new Class({
              initialize: function TextStyle2(text, style) {
                this.parent = text;
                this.fontFamily;
                this.fontSize;
                this.fontStyle;
                this.backgroundColor;
                this.color;
                this.stroke;
                this.strokeThickness;
                this.shadowOffsetX;
                this.shadowOffsetY;
                this.shadowColor;
                this.shadowBlur;
                this.shadowStroke;
                this.shadowFill;
                this.align;
                this.maxLines;
                this.fixedWidth;
                this.fixedHeight;
                this.resolution;
                this.rtl;
                this.testString;
                this.baselineX;
                this.baselineY;
                this.wordWrapWidth;
                this.wordWrapCallback;
                this.wordWrapCallbackScope;
                this.wordWrapUseAdvanced;
                this._font;
                this.setStyle(style, false, true);
              },
              setStyle: function(style, updateText, setDefaults) {
                if (updateText === void 0) {
                  updateText = true;
                }
                if (setDefaults === void 0) {
                  setDefaults = false;
                }
                if (style && style.hasOwnProperty("fontSize") && typeof style.fontSize === "number") {
                  style.fontSize = style.fontSize.toString() + "px";
                }
                for (var key in propertyMap) {
                  var value = setDefaults ? propertyMap[key][1] : this[key];
                  if (key === "wordWrapCallback" || key === "wordWrapCallbackScope") {
                    this[key] = GetValue(style, propertyMap[key][0], value);
                  } else {
                    this[key] = GetAdvancedValue(style, propertyMap[key][0], value);
                  }
                }
                var font = GetValue(style, "font", null);
                if (font !== null) {
                  this.setFont(font, false);
                }
                this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
                var fill = GetValue(style, "fill", null);
                if (fill !== null) {
                  this.color = fill;
                }
                var metrics = GetValue(style, "metrics", false);
                if (metrics) {
                  this.metrics = {
                    ascent: GetValue(metrics, "ascent", 0),
                    descent: GetValue(metrics, "descent", 0),
                    fontSize: GetValue(metrics, "fontSize", 0)
                  };
                } else if (updateText || !this.metrics) {
                  this.metrics = MeasureText(this);
                }
                if (updateText) {
                  return this.parent.updateText();
                } else {
                  return this.parent;
                }
              },
              syncFont: function(canvas, context) {
                context.font = this._font;
              },
              syncStyle: function(canvas, context) {
                context.textBaseline = "alphabetic";
                context.fillStyle = this.color;
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeThickness;
                context.lineCap = "round";
                context.lineJoin = "round";
              },
              syncShadow: function(context, enabled) {
                if (enabled) {
                  context.shadowOffsetX = this.shadowOffsetX;
                  context.shadowOffsetY = this.shadowOffsetY;
                  context.shadowColor = this.shadowColor;
                  context.shadowBlur = this.shadowBlur;
                } else {
                  context.shadowOffsetX = 0;
                  context.shadowOffsetY = 0;
                  context.shadowColor = 0;
                  context.shadowBlur = 0;
                }
              },
              update: function(recalculateMetrics) {
                if (recalculateMetrics) {
                  this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
                  this.metrics = MeasureText(this);
                }
                return this.parent.updateText();
              },
              setFont: function(font, updateText) {
                if (updateText === void 0) {
                  updateText = true;
                }
                var fontFamily = font;
                var fontSize = "";
                var fontStyle = "";
                if (typeof font !== "string") {
                  fontFamily = GetValue(font, "fontFamily", "Courier");
                  fontSize = GetValue(font, "fontSize", "16px");
                  fontStyle = GetValue(font, "fontStyle", "");
                } else {
                  var fontSplit = font.split(" ");
                  var i = 0;
                  fontStyle = fontSplit.length > 2 ? fontSplit[i++] : "";
                  fontSize = fontSplit[i++] || "16px";
                  fontFamily = fontSplit[i++] || "Courier";
                }
                if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle) {
                  this.fontFamily = fontFamily;
                  this.fontSize = fontSize;
                  this.fontStyle = fontStyle;
                  if (updateText) {
                    this.update(true);
                  }
                }
                return this.parent;
              },
              setFontFamily: function(family) {
                if (this.fontFamily !== family) {
                  this.fontFamily = family;
                  this.update(true);
                }
                return this.parent;
              },
              setFontStyle: function(style) {
                if (this.fontStyle !== style) {
                  this.fontStyle = style;
                  this.update(true);
                }
                return this.parent;
              },
              setFontSize: function(size) {
                if (typeof size === "number") {
                  size = size.toString() + "px";
                }
                if (this.fontSize !== size) {
                  this.fontSize = size;
                  this.update(true);
                }
                return this.parent;
              },
              setTestString: function(string) {
                this.testString = string;
                return this.update(true);
              },
              setFixedSize: function(width, height) {
                this.fixedWidth = width;
                this.fixedHeight = height;
                if (width) {
                  this.parent.width = width;
                }
                if (height) {
                  this.parent.height = height;
                }
                return this.update(false);
              },
              setBackgroundColor: function(color) {
                this.backgroundColor = color;
                return this.update(false);
              },
              setFill: function(color) {
                this.color = color;
                return this.update(false);
              },
              setColor: function(color) {
                this.color = color;
                return this.update(false);
              },
              setResolution: function(value) {
                this.resolution = value;
                return this.update(false);
              },
              setStroke: function(color, thickness) {
                if (thickness === void 0) {
                  thickness = this.strokeThickness;
                }
                if (color === void 0 && this.strokeThickness !== 0) {
                  this.strokeThickness = 0;
                  this.update(true);
                } else if (this.stroke !== color || this.strokeThickness !== thickness) {
                  this.stroke = color;
                  this.strokeThickness = thickness;
                  this.update(true);
                }
                return this.parent;
              },
              setShadow: function(x, y, color, blur, shadowStroke, shadowFill) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (color === void 0) {
                  color = "#000";
                }
                if (blur === void 0) {
                  blur = 0;
                }
                if (shadowStroke === void 0) {
                  shadowStroke = false;
                }
                if (shadowFill === void 0) {
                  shadowFill = true;
                }
                this.shadowOffsetX = x;
                this.shadowOffsetY = y;
                this.shadowColor = color;
                this.shadowBlur = blur;
                this.shadowStroke = shadowStroke;
                this.shadowFill = shadowFill;
                return this.update(false);
              },
              setShadowOffset: function(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = x;
                }
                this.shadowOffsetX = x;
                this.shadowOffsetY = y;
                return this.update(false);
              },
              setShadowColor: function(color) {
                if (color === void 0) {
                  color = "#000";
                }
                this.shadowColor = color;
                return this.update(false);
              },
              setShadowBlur: function(blur) {
                if (blur === void 0) {
                  blur = 0;
                }
                this.shadowBlur = blur;
                return this.update(false);
              },
              setShadowStroke: function(enabled) {
                this.shadowStroke = enabled;
                return this.update(false);
              },
              setShadowFill: function(enabled) {
                this.shadowFill = enabled;
                return this.update(false);
              },
              setWordWrapWidth: function(width, useAdvancedWrap) {
                if (useAdvancedWrap === void 0) {
                  useAdvancedWrap = false;
                }
                this.wordWrapWidth = width;
                this.wordWrapUseAdvanced = useAdvancedWrap;
                return this.update(false);
              },
              setWordWrapCallback: function(callback, scope) {
                if (scope === void 0) {
                  scope = null;
                }
                this.wordWrapCallback = callback;
                this.wordWrapCallbackScope = scope;
                return this.update(false);
              },
              setAlign: function(align) {
                if (align === void 0) {
                  align = "left";
                }
                this.align = align;
                return this.update(false);
              },
              setMaxLines: function(max) {
                if (max === void 0) {
                  max = 0;
                }
                this.maxLines = max;
                return this.update(false);
              },
              getTextMetrics: function() {
                var metrics = this.metrics;
                return {
                  ascent: metrics.ascent,
                  descent: metrics.descent,
                  fontSize: metrics.fontSize
                };
              },
              toJSON: function() {
                var output = {};
                for (var key in propertyMap) {
                  output[key] = this[key];
                }
                output.metrics = this.getTextMetrics();
                return output;
              },
              destroy: function() {
                this.parent = void 0;
              }
            });
            module2.exports = TextStyle;
          },
          76128: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Utils = __webpack_require__2(75512);
            var TextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              if (src.width === 0 || src.height === 0) {
                return;
              }
              camera.addToRenderList(src);
              var frame = src.frame;
              var width = frame.width;
              var height = frame.height;
              var getTint = Utils.getTintAppendFloatAlpha;
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
              pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
            };
            module2.exports = TextWebGLRenderer;
          },
          35856: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasPool = __webpack_require__2(61068);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var GetPowerOfTwo = __webpack_require__2(3504);
            var Smoothing = __webpack_require__2(8213);
            var TileSpriteRender = __webpack_require__2(9271);
            var Vector2 = __webpack_require__2(93736);
            var _FLAG = 8;
            var TileSprite = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Crop,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Tint,
                Components.Transform,
                Components.Visible,
                TileSpriteRender
              ],
              initialize: function TileSprite2(scene, x, y, width, height, textureKey, frameKey) {
                var renderer = scene.sys.renderer;
                GameObject.call(this, scene, "TileSprite");
                var displayTexture = scene.sys.textures.get(textureKey);
                var displayFrame = displayTexture.get(frameKey);
                if (displayFrame.source.compressionAlgorithm) {
                  console.warn("TileSprite cannot use compressed texture");
                  displayTexture = scene.sys.textures.get("__MISSING");
                  displayFrame = displayTexture.get();
                }
                if (displayTexture.type === "DynamicTexture") {
                  console.warn("TileSprite cannot use Dynamic Texture");
                  displayTexture = scene.sys.textures.get("__MISSING");
                  displayFrame = displayTexture.get();
                }
                if (!width || !height) {
                  width = displayFrame.width;
                  height = displayFrame.height;
                } else {
                  width = Math.floor(width);
                  height = Math.floor(height);
                }
                this._tilePosition = new Vector2();
                this._tileScale = new Vector2(1, 1);
                this.dirty = false;
                this.renderer = renderer;
                this.canvas = CanvasPool.create(this, width, height);
                this.context = this.canvas.getContext("2d", {willReadFrequently: false});
                this.displayTexture = displayTexture;
                this.displayFrame = displayFrame;
                this._crop = this.resetCropObject();
                this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
                this.frame = this.texture.get();
                this.potWidth = GetPowerOfTwo(displayFrame.width);
                this.potHeight = GetPowerOfTwo(displayFrame.height);
                this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);
                this.fillContext = this.fillCanvas.getContext("2d", {willReadFrequently: false});
                this.fillPattern = null;
                this.setPosition(x, y);
                this.setSize(width, height);
                this.setFrame(frameKey);
                this.setOriginFromFrame();
                this.initPipeline();
                this.initPostPipeline(true);
              },
              setTexture: function(key, frame) {
                this.displayTexture = this.scene.sys.textures.get(key);
                return this.setFrame(frame);
              },
              setFrame: function(frame) {
                var newFrame = this.displayTexture.get(frame);
                this.potWidth = GetPowerOfTwo(newFrame.width);
                this.potHeight = GetPowerOfTwo(newFrame.height);
                this.canvas.width = 0;
                if (!newFrame.cutWidth || !newFrame.cutHeight) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
                this.displayFrame = newFrame;
                this.dirty = true;
                this.updateTileTexture();
                return this;
              },
              setTilePosition: function(x, y) {
                if (x !== void 0) {
                  this.tilePositionX = x;
                }
                if (y !== void 0) {
                  this.tilePositionY = y;
                }
                return this;
              },
              setTileScale: function(x, y) {
                if (x === void 0) {
                  x = this.tileScaleX;
                }
                if (y === void 0) {
                  y = x;
                }
                this.tileScaleX = x;
                this.tileScaleY = y;
                return this;
              },
              updateTileTexture: function() {
                if (!this.dirty || !this.renderer) {
                  return;
                }
                var frame = this.displayFrame;
                if (frame.source.isRenderTexture || frame.source.isGLTexture) {
                  console.warn("TileSprites can only use Image or Canvas based textures");
                  this.dirty = false;
                  return;
                }
                var ctx = this.fillContext;
                var canvas = this.fillCanvas;
                var fw = this.potWidth;
                var fh = this.potHeight;
                if (!this.renderer || !this.renderer.gl) {
                  fw = frame.cutWidth;
                  fh = frame.cutHeight;
                }
                ctx.clearRect(0, 0, fw, fh);
                canvas.width = fw;
                canvas.height = fh;
                ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, fw, fh);
                if (this.renderer && this.renderer.gl) {
                  this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);
                  if (false) {
                  }
                } else {
                  this.fillPattern = ctx.createPattern(canvas, "repeat");
                }
                this.updateCanvas();
                this.dirty = false;
              },
              updateCanvas: function() {
                var canvas = this.canvas;
                if (canvas.width !== this.width || canvas.height !== this.height) {
                  canvas.width = this.width;
                  canvas.height = this.height;
                  this.frame.setSize(this.width, this.height);
                  this.updateDisplayOrigin();
                  this.dirty = true;
                }
                if (!this.dirty || this.renderer && this.renderer.gl) {
                  this.dirty = false;
                  return;
                }
                var ctx = this.context;
                if (!this.scene.sys.game.config.antialias) {
                  Smoothing.disable(ctx);
                }
                var scaleX = this._tileScale.x;
                var scaleY = this._tileScale.y;
                var positionX = this._tilePosition.x;
                var positionY = this._tilePosition.y;
                ctx.clearRect(0, 0, this.width, this.height);
                ctx.save();
                ctx.scale(scaleX, scaleY);
                ctx.translate(-positionX, -positionY);
                ctx.fillStyle = this.fillPattern;
                ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);
                ctx.restore();
                this.dirty = false;
              },
              preDestroy: function() {
                if (this.renderer && this.renderer.gl) {
                  this.renderer.deleteTexture(this.fillPattern);
                }
                CanvasPool.remove(this.canvas);
                CanvasPool.remove(this.fillCanvas);
                this.fillPattern = null;
                this.fillContext = null;
                this.fillCanvas = null;
                this.displayTexture = null;
                this.displayFrame = null;
                this.texture.destroy();
                this.renderer = null;
              },
              tilePositionX: {
                get: function() {
                  return this._tilePosition.x;
                },
                set: function(value) {
                  this._tilePosition.x = value;
                  this.dirty = true;
                }
              },
              tilePositionY: {
                get: function() {
                  return this._tilePosition.y;
                },
                set: function(value) {
                  this._tilePosition.y = value;
                  this.dirty = true;
                }
              },
              tileScaleX: {
                get: function() {
                  return this._tileScale.x;
                },
                set: function(value) {
                  this._tileScale.x = value;
                  this.dirty = true;
                }
              },
              tileScaleY: {
                get: function() {
                  return this._tileScale.y;
                },
                set: function(value) {
                  this._tileScale.y = value;
                  this.dirty = true;
                }
              }
            });
            module2.exports = TileSprite;
          },
          93305: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TileSpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              src.updateCanvas();
              camera.addToRenderList(src);
              renderer.batchSprite(src, src.frame, camera, parentMatrix);
            };
            module2.exports = TileSpriteCanvasRenderer;
          },
          63950: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var TileSprite = __webpack_require__2(35856);
            GameObjectCreator.register("tileSprite", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var x = GetAdvancedValue(config2, "x", 0);
              var y = GetAdvancedValue(config2, "y", 0);
              var width = GetAdvancedValue(config2, "width", 512);
              var height = GetAdvancedValue(config2, "height", 512);
              var key = GetAdvancedValue(config2, "key", "");
              var frame = GetAdvancedValue(config2, "frame", "");
              var tile = new TileSprite(this.scene, x, y, width, height, key, frame);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, tile, config2);
              return tile;
            });
          },
          20509: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TileSprite = __webpack_require__2(35856);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("tileSprite", function(x, y, width, height, texture, frame) {
              return this.displayList.add(new TileSprite(this.scene, x, y, width, height, texture, frame));
            });
          },
          9271: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(74287);
            }
            if (true) {
              renderCanvas = __webpack_require__2(93305);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          74287: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Utils = __webpack_require__2(75512);
            var TileSpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              src.updateCanvas();
              var width = src.width;
              var height = src.height;
              if (width === 0 || height === 0) {
                return;
              }
              camera.addToRenderList(src);
              var getTint = Utils.getTintAppendFloatAlpha;
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              var textureUnit = pipeline.setTexture2D(src.fillPattern, src);
              pipeline.batchTexture(src, src.fillPattern, src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.originX * width, src.originY * height, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, src.tilePositionX % src.displayFrame.width / src.displayFrame.width, src.tilePositionY % src.displayFrame.height / src.displayFrame.height, camera, parentMatrix, false, textureUnit);
            };
            module2.exports = TileSpriteWebGLRenderer;
          },
          8630: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var Events = __webpack_require__2(56631);
            var GameEvents = __webpack_require__2(97081);
            var GameObject = __webpack_require__2(89980);
            var MATH_CONST = __webpack_require__2(83392);
            var SoundEvents = __webpack_require__2(76038);
            var UUID = __webpack_require__2(76583);
            var VideoRender = __webpack_require__2(77974);
            var Video = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.ScrollFactor,
                Components.Size,
                Components.TextureCrop,
                Components.Tint,
                Components.Transform,
                Components.Visible,
                VideoRender
              ],
              initialize: function Video2(scene, x, y, key) {
                GameObject.call(this, scene, "Video");
                this.video;
                this.videoTexture;
                this.videoTextureSource;
                this.snapshotTexture;
                this.flipY = false;
                this._key = UUID();
                this.touchLocked = false;
                this.playWhenUnlocked = false;
                this.frameReady = false;
                this.isStalled = false;
                this.failedPlayAttempts = 0;
                this.metadata;
                this.retry = 0;
                this.retryInterval = 500;
                this._systemMuted = false;
                this._codeMuted = false;
                this._systemPaused = false;
                this._codePaused = false;
                this._callbacks = {
                  ended: this.completeHandler.bind(this),
                  legacy: this.legacyPlayHandler.bind(this),
                  playing: this.playingHandler.bind(this),
                  seeked: this.seekedHandler.bind(this),
                  seeking: this.seekingHandler.bind(this),
                  stalled: this.stalledHandler.bind(this),
                  suspend: this.stalledHandler.bind(this),
                  waiting: this.stalledHandler.bind(this)
                };
                this._loadCallbackHandler = this.loadErrorHandler.bind(this);
                this._crop = this.resetCropObject();
                this.markers = {};
                this._markerIn = 0;
                this._markerOut = 0;
                this._playingMarker = false;
                this._lastUpdate = 0;
                this.cacheKey = "";
                this.isSeeking = false;
                this._playCalled = false;
                this._rfvCallbackId = 0;
                var game = scene.sys.game;
                this._device = game.device.video;
                this.setPosition(x, y);
                this.setSize(256, 256);
                this.initPipeline();
                this.initPostPipeline(true);
                game.events.on(GameEvents.PAUSE, this.globalPause, this);
                game.events.on(GameEvents.RESUME, this.globalResume, this);
                var sound = scene.sys.sound;
                if (sound) {
                  sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
                }
                if (key) {
                  this.load(key);
                }
              },
              addedToScene: function() {
                this.scene.sys.updateList.add(this);
              },
              removedFromScene: function() {
                this.scene.sys.updateList.remove(this);
              },
              load: function(key) {
                var video = this.scene.sys.cache.video.get(key);
                if (video) {
                  this.cacheKey = key;
                  this.loadHandler(video.url, video.noAudio, video.crossOrigin);
                } else {
                  console.warn("No video in cache for key: " + key);
                }
                return this;
              },
              changeSource: function(key, autoplay, loop, markerIn, markerOut) {
                if (autoplay === void 0) {
                  autoplay = true;
                }
                if (loop === void 0) {
                  loop = false;
                }
                if (this.cacheKey !== key) {
                  this.load(key);
                  if (autoplay) {
                    this.play(loop, markerIn, markerOut);
                  }
                }
              },
              getVideoKey: function() {
                return this.cacheKey;
              },
              loadURL: function(urls, noAudio, crossOrigin) {
                if (noAudio === void 0) {
                  noAudio = false;
                }
                var urlConfig = this._device.getVideoURL(urls);
                if (!urlConfig) {
                  console.warn("No supported video format found for " + urls);
                } else {
                  this.cacheKey = "";
                  this.loadHandler(urlConfig.url, noAudio, crossOrigin);
                }
                return this;
              },
              loadMediaStream: function(stream, noAudio, crossOrigin) {
                return this.loadHandler(null, noAudio, crossOrigin, stream);
              },
              loadHandler: function(url, noAudio, crossOrigin, stream) {
                if (!noAudio) {
                  noAudio = false;
                }
                var video = this.video;
                if (video) {
                  this.removeLoadEventHandlers();
                  this.stop();
                } else {
                  video = document.createElement("video");
                  video.controls = false;
                  video.setAttribute("playsinline", "playsinline");
                  video.setAttribute("preload", "auto");
                  video.setAttribute("disablePictureInPicture", "true");
                }
                if (noAudio) {
                  video.muted = true;
                  video.defaultMuted = true;
                  video.setAttribute("autoplay", "autoplay");
                } else {
                  video.muted = false;
                  video.defaultMuted = false;
                  video.removeAttribute("autoplay");
                }
                if (!crossOrigin) {
                  video.removeAttribute("crossorigin");
                } else {
                  video.setAttribute("crossorigin", crossOrigin);
                }
                if (stream) {
                  if ("srcObject" in video) {
                    try {
                      video.srcObject = stream;
                    } catch (err) {
                      if (err.name !== "TypeError") {
                        throw err;
                      }
                      video.src = URL.createObjectURL(stream);
                    }
                  } else {
                    video.src = URL.createObjectURL(stream);
                  }
                } else {
                  video.src = url;
                }
                this.addLoadEventHandlers();
                this.retry = 0;
                this.video = video;
                this._playCalled = false;
                video.load();
                return this;
              },
              requestVideoFrame: function(now, metadata) {
                var video = this.video;
                if (!video) {
                  return;
                }
                var width = metadata.width;
                var height = metadata.height;
                var texture = this.videoTexture;
                var textureSource = this.videoTextureSource;
                var newVideo = !texture || textureSource.source !== video;
                if (newVideo) {
                  this._codePaused = video.paused;
                  this._codeMuted = video.muted;
                  if (!texture) {
                    texture = this.scene.sys.textures.create(this._key, video, width, height);
                    texture.add("__BASE", 0, 0, 0, width, height);
                    this.setTexture(texture);
                    this.videoTexture = texture;
                    this.videoTextureSource = texture.source[0];
                    this.videoTextureSource.setFlipY(this.flipY);
                    this.emit(Events.VIDEO_TEXTURE, this, texture);
                  } else {
                    textureSource.source = video;
                    textureSource.width = width;
                    textureSource.height = height;
                    texture.get().setSize(width, height);
                  }
                  this.setSizeToFrame();
                  this.updateDisplayOrigin();
                } else {
                  textureSource.update();
                }
                this.isStalled = false;
                this.metadata = metadata;
                var currentTime = metadata.mediaTime;
                if (newVideo) {
                  this._lastUpdate = currentTime;
                  this.emit(Events.VIDEO_CREATED, this, width, height);
                  if (!this.frameReady) {
                    this.frameReady = true;
                    this.emit(Events.VIDEO_PLAY, this);
                  }
                }
                if (this._playingMarker) {
                  if (currentTime >= this._markerOut) {
                    if (video.loop) {
                      video.currentTime = this._markerIn;
                      this.emit(Events.VIDEO_LOOP, this);
                    } else {
                      this.stop(false);
                      this.emit(Events.VIDEO_COMPLETE, this);
                    }
                  }
                } else if (currentTime < this._lastUpdate) {
                  this.emit(Events.VIDEO_LOOP, this);
                }
                this._lastUpdate = currentTime;
                this._rfvCallbackId = this.video.requestVideoFrameCallback(this.requestVideoFrame.bind(this));
              },
              play: function(loop, markerIn, markerOut) {
                if (markerIn === void 0) {
                  markerIn = -1;
                }
                if (markerOut === void 0) {
                  markerOut = MATH_CONST.MAX_SAFE_INTEGER;
                }
                var video = this.video;
                if (!video || this.isPlaying()) {
                  if (!video) {
                    console.warn("Video not loaded");
                  }
                  return this;
                }
                if (loop === void 0) {
                  loop = video.loop;
                }
                video.loop = loop;
                this._markerIn = markerIn;
                this._markerOut = markerOut;
                this._playingMarker = markerIn > -1 && markerOut > markerIn && markerOut < MATH_CONST.MAX_SAFE_INTEGER;
                if (!this._playCalled) {
                  this._rfvCallbackId = video.requestVideoFrameCallback(this.requestVideoFrame.bind(this));
                  this._playCalled = true;
                  this.createPlayPromise();
                }
                return this;
              },
              addLoadEventHandlers: function() {
                var video = this.video;
                if (video) {
                  video.addEventListener("error", this._loadCallbackHandler);
                  video.addEventListener("abort", this._loadCallbackHandler);
                }
              },
              removeLoadEventHandlers: function() {
                var video = this.video;
                if (video) {
                  video.removeEventListener("error", this._loadCallbackHandler);
                  video.removeEventListener("abort", this._loadCallbackHandler);
                }
              },
              addEventHandlers: function() {
                var video = this.video;
                if (video) {
                  var callbacks = this._callbacks;
                  for (var callback in callbacks) {
                    video.addEventListener(callback, callbacks[callback]);
                  }
                }
              },
              removeEventHandlers: function() {
                var video = this.video;
                if (video) {
                  var callbacks = this._callbacks;
                  for (var callback in callbacks) {
                    video.removeEventListener(callback, callbacks[callback]);
                  }
                }
              },
              createPlayPromise: function(catchError) {
                if (catchError === void 0) {
                  catchError = true;
                }
                var video = this.video;
                var playPromise = video.play();
                if (playPromise !== void 0) {
                  var success = this.playSuccess.bind(this);
                  var error = this.playError.bind(this);
                  if (!catchError) {
                    var _this = this;
                    error = function() {
                      _this.failedPlayAttempts++;
                    };
                  }
                  playPromise.then(success).catch(error);
                } else {
                  video.addEventListener("playing", this._callbacks.legacy);
                  if (!catchError) {
                    this.failedPlayAttempts++;
                  }
                }
              },
              addMarker: function(key, markerIn, markerOut) {
                if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut) && markerOut > markerIn) {
                  this.markers[key] = [markerIn, markerOut];
                }
                return this;
              },
              playMarker: function(key, loop) {
                var marker = this.markers[key];
                if (marker) {
                  this.play(loop, marker[0], marker[1]);
                }
                return this;
              },
              removeMarker: function(key) {
                delete this.markers[key];
                return this;
              },
              snapshot: function(width, height) {
                if (width === void 0) {
                  width = this.width;
                }
                if (height === void 0) {
                  height = this.height;
                }
                return this.snapshotArea(0, 0, this.width, this.height, width, height);
              },
              snapshotArea: function(x, y, srcWidth, srcHeight, destWidth, destHeight) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (srcWidth === void 0) {
                  srcWidth = this.width;
                }
                if (srcHeight === void 0) {
                  srcHeight = this.height;
                }
                if (destWidth === void 0) {
                  destWidth = srcWidth;
                }
                if (destHeight === void 0) {
                  destHeight = srcHeight;
                }
                var video = this.video;
                var snap = this.snapshotTexture;
                if (!snap) {
                  snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);
                  this.snapshotTexture = snap;
                  if (video) {
                    snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
                  }
                } else {
                  snap.setSize(destWidth, destHeight);
                  if (video) {
                    snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
                  }
                }
                return snap.update();
              },
              saveSnapshotTexture: function(key) {
                if (this.snapshotTexture) {
                  this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);
                } else {
                  this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);
                }
                return this.snapshotTexture;
              },
              playSuccess: function() {
                if (!this._playCalled) {
                  return;
                }
                this.addEventHandlers();
                this._codePaused = false;
                if (this.touchLocked) {
                  this.touchLocked = false;
                  this.emit(Events.VIDEO_UNLOCKED, this);
                }
                var sound = this.scene.sys.sound;
                if (sound && sound.mute) {
                  this.setMute(true);
                }
                if (this._markerIn > -1) {
                  this.video.currentTime = this._markerIn;
                }
              },
              playError: function(error) {
                var name = error.name;
                if (name === "NotAllowedError") {
                  this.touchLocked = true;
                  this.playWhenUnlocked = true;
                  this.failedPlayAttempts = 1;
                  this.emit(Events.VIDEO_LOCKED, this);
                } else if (name === "NotSupportedError") {
                  this.stop(false);
                  this.emit(Events.VIDEO_UNSUPPORTED, this, error);
                } else {
                  this.stop(false);
                  this.emit(Events.VIDEO_ERROR, this, error);
                }
              },
              legacyPlayHandler: function() {
                var video = this.video;
                if (video) {
                  this.playSuccess();
                  video.removeEventListener("playing", this._callbacks.legacy);
                }
              },
              playingHandler: function() {
                this.isStalled = false;
                this.emit(Events.VIDEO_PLAYING, this);
              },
              loadErrorHandler: function(event) {
                this.stop(false);
                this.emit(Events.VIDEO_ERROR, this, event);
              },
              stalledHandler: function(event) {
                this.isStalled = true;
                this.emit(Events.VIDEO_STALLED, this, event);
              },
              completeHandler: function() {
                this._playCalled = false;
                this.emit(Events.VIDEO_COMPLETE, this);
              },
              preUpdate: function(time, delta) {
                var video = this.video;
                if (!video || !this._playCalled) {
                  return;
                }
                if (this.touchLocked && this.playWhenUnlocked) {
                  this.retry += delta;
                  if (this.retry >= this.retryInterval) {
                    this.createPlayPromise(false);
                    this.retry = 0;
                  }
                }
              },
              seekTo: function(value) {
                var video = this.video;
                if (video) {
                  var duration = video.duration;
                  if (duration !== Infinity && !isNaN(duration)) {
                    var seekTime = duration * value;
                    this.setCurrentTime(seekTime);
                  }
                }
                return this;
              },
              getCurrentTime: function() {
                return this.video ? this.video.currentTime : 0;
              },
              setCurrentTime: function(value) {
                var video = this.video;
                if (video) {
                  if (typeof value === "string") {
                    var op = value[0];
                    var num = parseFloat(value.substr(1));
                    if (op === "+") {
                      value = video.currentTime + num;
                    } else if (op === "-") {
                      value = video.currentTime - num;
                    }
                  }
                  video.currentTime = value;
                }
                return this;
              },
              seekingHandler: function() {
                this.isSeeking = true;
                this.emit(Events.VIDEO_SEEKING, this);
              },
              seekedHandler: function() {
                this.isSeeking = false;
                this.emit(Events.VIDEO_SEEKED, this);
              },
              getProgress: function() {
                var video = this.video;
                if (video) {
                  var duration = video.duration;
                  if (duration !== Infinity && !isNaN(duration)) {
                    return video.currentTime / duration;
                  }
                }
                return -1;
              },
              getDuration: function() {
                return this.video ? this.video.duration : 0;
              },
              setMute: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this._codeMuted = value;
                var video = this.video;
                if (video) {
                  video.muted = this._systemMuted ? true : value;
                }
                return this;
              },
              isMuted: function() {
                return this._codeMuted;
              },
              globalMute: function(soundManager, value) {
                this._systemMuted = value;
                var video = this.video;
                if (video) {
                  video.muted = this._codeMuted ? true : value;
                }
              },
              globalPause: function() {
                this._systemPaused = true;
                if (this.video && !this.video.ended) {
                  this.removeEventHandlers();
                  this.video.pause();
                }
              },
              globalResume: function() {
                this._systemPaused = false;
                if (this.video && !this._codePaused && !this.video.ended) {
                  this.createPlayPromise();
                }
              },
              setPaused: function(value) {
                if (value === void 0) {
                  value = true;
                }
                var video = this.video;
                this._codePaused = value;
                if (video && !video.ended) {
                  if (value) {
                    if (!video.paused) {
                      this.removeEventHandlers();
                      video.pause();
                    }
                  } else if (!value) {
                    if (!this._playCalled) {
                      this.play();
                    } else if (video.paused && !this._systemPaused) {
                      this.createPlayPromise();
                    }
                  }
                }
                return this;
              },
              pause: function() {
                return this.setPaused(true);
              },
              resume: function() {
                return this.setPaused(false);
              },
              getVolume: function() {
                return this.video ? this.video.volume : 1;
              },
              setVolume: function(value) {
                if (value === void 0) {
                  value = 1;
                }
                if (this.video) {
                  this.video.volume = Clamp(value, 0, 1);
                }
                return this;
              },
              getPlaybackRate: function() {
                return this.video ? this.video.playbackRate : 1;
              },
              setPlaybackRate: function(rate) {
                if (this.video) {
                  this.video.playbackRate = rate;
                }
                return this;
              },
              getLoop: function() {
                return this.video ? this.video.loop : false;
              },
              setLoop: function(value) {
                if (value === void 0) {
                  value = true;
                }
                if (this.video) {
                  this.video.loop = value;
                }
                return this;
              },
              isPlaying: function() {
                return this.video ? !(this.video.paused || this.video.ended) : false;
              },
              isPaused: function() {
                return this.video && this._playCalled && this.video.paused || this._codePaused || this._systemPaused;
              },
              saveTexture: function(key, flipY) {
                if (flipY === void 0) {
                  flipY = false;
                }
                if (this.videoTexture) {
                  this.scene.sys.textures.renameTexture(this._key, key);
                  this.videoTextureSource.setFlipY(flipY);
                }
                this._key = key;
                this.flipY = flipY;
                return this.videoTexture ? true : false;
              },
              stop: function(emitStopEvent) {
                if (emitStopEvent === void 0) {
                  emitStopEvent = true;
                }
                var video = this.video;
                if (video) {
                  this.removeEventHandlers();
                  video.cancelVideoFrameCallback(this._rfvCallbackId);
                  video.pause();
                }
                this.retry = 0;
                this._playCalled = false;
                if (emitStopEvent) {
                  this.emit(Events.VIDEO_STOP, this);
                }
                return this;
              },
              removeVideoElement: function() {
                var video = this.video;
                if (!video) {
                  return;
                }
                if (video.parentNode) {
                  video.parentNode.removeChild(video);
                }
                while (video.hasChildNodes()) {
                  video.removeChild(video.firstChild);
                }
                video.removeAttribute("autoplay");
                video.removeAttribute("src");
                this.video = null;
              },
              preDestroy: function() {
                this.stop(false);
                this.removeLoadEventHandlers();
                this.removeVideoElement();
                var game = this.scene.sys.game.events;
                game.off(GameEvents.PAUSE, this.globalPause, this);
                game.off(GameEvents.RESUME, this.globalResume, this);
                var sound = this.scene.sys.sound;
                if (sound) {
                  sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
                }
              }
            });
            module2.exports = Video;
          },
          56933: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var VideoCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              if (src.videoTexture) {
                camera.addToRenderList(src);
                renderer.batchSprite(src, src.frame, camera, parentMatrix);
              }
            };
            module2.exports = VideoCanvasRenderer;
          },
          65601: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildGameObject = __webpack_require__2(88933);
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var Video = __webpack_require__2(8630);
            GameObjectCreator.register("video", function(config2, addToScene) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetAdvancedValue(config2, "key", null);
              var video = new Video(this.scene, 0, 0, key);
              if (addToScene !== void 0) {
                config2.add = addToScene;
              }
              BuildGameObject(this.scene, video, config2);
              return video;
            });
          },
          215: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Video = __webpack_require__2(8630);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("video", function(x, y, key) {
              return this.displayList.add(new Video(this.scene, x, y, key));
            });
          },
          77974: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(83572);
            }
            if (true) {
              renderCanvas = __webpack_require__2(56933);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          83572: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var VideoWebGLRenderer = function(renderer, src, camera, parentMatrix) {
              if (src.videoTexture) {
                camera.addToRenderList(src);
                src.pipeline.batchSprite(src, camera, parentMatrix);
              }
            };
            module2.exports = VideoWebGLRenderer;
          },
          71030: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BlendModes = __webpack_require__2(95723);
            var Circle = __webpack_require__2(26673);
            var CircleContains = __webpack_require__2(65650);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var Rectangle = __webpack_require__2(74118);
            var RectangleContains = __webpack_require__2(94287);
            var Zone = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Depth,
                Components.GetBounds,
                Components.Origin,
                Components.Transform,
                Components.ScrollFactor,
                Components.Visible
              ],
              initialize: function Zone2(scene, x, y, width, height) {
                if (width === void 0) {
                  width = 1;
                }
                if (height === void 0) {
                  height = width;
                }
                GameObject.call(this, scene, "Zone");
                this.setPosition(x, y);
                this.width = width;
                this.height = height;
                this.blendMode = BlendModes.NORMAL;
                this.updateDisplayOrigin();
              },
              displayWidth: {
                get: function() {
                  return this.scaleX * this.width;
                },
                set: function(value) {
                  this.scaleX = value / this.width;
                }
              },
              displayHeight: {
                get: function() {
                  return this.scaleY * this.height;
                },
                set: function(value) {
                  this.scaleY = value / this.height;
                }
              },
              setSize: function(width, height, resizeInput) {
                if (resizeInput === void 0) {
                  resizeInput = true;
                }
                this.width = width;
                this.height = height;
                this.updateDisplayOrigin();
                var input = this.input;
                if (resizeInput && input && !input.customHitArea) {
                  input.hitArea.width = width;
                  input.hitArea.height = height;
                }
                return this;
              },
              setDisplaySize: function(width, height) {
                this.displayWidth = width;
                this.displayHeight = height;
                return this;
              },
              setCircleDropZone: function(radius) {
                return this.setDropZone(new Circle(0, 0, radius), CircleContains);
              },
              setRectangleDropZone: function(width, height) {
                return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);
              },
              setDropZone: function(hitArea, hitAreaCallback) {
                if (!this.input) {
                  this.setInteractive(hitArea, hitAreaCallback, true);
                }
                return this;
              },
              setAlpha: function() {
              },
              setBlendMode: function() {
              },
              renderCanvas: function(renderer, src, camera) {
                camera.addToRenderList(src);
              },
              renderWebGL: function(renderer, src, camera) {
                camera.addToRenderList(src);
              }
            });
            module2.exports = Zone;
          },
          24067: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectCreator = __webpack_require__2(99325);
            var GetAdvancedValue = __webpack_require__2(20494);
            var Zone = __webpack_require__2(71030);
            GameObjectCreator.register("zone", function(config2) {
              var x = GetAdvancedValue(config2, "x", 0);
              var y = GetAdvancedValue(config2, "y", 0);
              var width = GetAdvancedValue(config2, "width", 1);
              var height = GetAdvancedValue(config2, "height", width);
              return new Zone(this.scene, x, y, width, height);
            });
          },
          34546: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Zone = __webpack_require__2(71030);
            var GameObjectFactory = __webpack_require__2(61286);
            GameObjectFactory.register("zone", function(x, y, width, height) {
              return this.displayList.add(new Zone(this.scene, x, y, width, height));
            });
          },
          95847: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Area = function(circle) {
              return circle.radius > 0 ? Math.PI * circle.radius * circle.radius : 0;
            };
            module2.exports = Area;
          },
          26673: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Contains = __webpack_require__2(65650);
            var GetPoint = __webpack_require__2(94026);
            var GetPoints = __webpack_require__2(62941);
            var GEOM_CONST = __webpack_require__2(52394);
            var Random = __webpack_require__2(30977);
            var Circle = new Class({
              initialize: function Circle2(x, y, radius) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (radius === void 0) {
                  radius = 0;
                }
                this.type = GEOM_CONST.CIRCLE;
                this.x = x;
                this.y = y;
                this._radius = radius;
                this._diameter = radius * 2;
              },
              contains: function(x, y) {
                return Contains(this, x, y);
              },
              getPoint: function(position, point) {
                return GetPoint(this, position, point);
              },
              getPoints: function(quantity, stepRate, output) {
                return GetPoints(this, quantity, stepRate, output);
              },
              getRandomPoint: function(point) {
                return Random(this, point);
              },
              setTo: function(x, y, radius) {
                this.x = x;
                this.y = y;
                this._radius = radius;
                this._diameter = radius * 2;
                return this;
              },
              setEmpty: function() {
                this._radius = 0;
                this._diameter = 0;
                return this;
              },
              setPosition: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.x = x;
                this.y = y;
                return this;
              },
              isEmpty: function() {
                return this._radius <= 0;
              },
              radius: {
                get: function() {
                  return this._radius;
                },
                set: function(value) {
                  this._radius = value;
                  this._diameter = value * 2;
                }
              },
              diameter: {
                get: function() {
                  return this._diameter;
                },
                set: function(value) {
                  this._diameter = value;
                  this._radius = value * 0.5;
                }
              },
              left: {
                get: function() {
                  return this.x - this._radius;
                },
                set: function(value) {
                  this.x = value + this._radius;
                }
              },
              right: {
                get: function() {
                  return this.x + this._radius;
                },
                set: function(value) {
                  this.x = value - this._radius;
                }
              },
              top: {
                get: function() {
                  return this.y - this._radius;
                },
                set: function(value) {
                  this.y = value + this._radius;
                }
              },
              bottom: {
                get: function() {
                  return this.y + this._radius;
                },
                set: function(value) {
                  this.y = value - this._radius;
                }
              }
            });
            module2.exports = Circle;
          },
          37964: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circumference = function(circle) {
              return 2 * (Math.PI * circle.radius);
            };
            module2.exports = Circumference;
          },
          72233: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var CircumferencePoint = function(circle, angle, out) {
              if (out === void 0) {
                out = new Point();
              }
              out.x = circle.x + circle.radius * Math.cos(angle);
              out.y = circle.y + circle.radius * Math.sin(angle);
              return out;
            };
            module2.exports = CircumferencePoint;
          },
          61761: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circle = __webpack_require__2(26673);
            var Clone = function(source) {
              return new Circle(source.x, source.y, source.radius);
            };
            module2.exports = Clone;
          },
          65650: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = function(circle, x, y) {
              if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom) {
                var dx = (circle.x - x) * (circle.x - x);
                var dy = (circle.y - y) * (circle.y - y);
                return dx + dy <= circle.radius * circle.radius;
              } else {
                return false;
              }
            };
            module2.exports = Contains;
          },
          39187: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = __webpack_require__2(65650);
            var ContainsPoint = function(circle, point) {
              return Contains(circle, point.x, point.y);
            };
            module2.exports = ContainsPoint;
          },
          58672: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = __webpack_require__2(65650);
            var ContainsRect = function(circle, rect) {
              return Contains(circle, rect.x, rect.y) && Contains(circle, rect.right, rect.y) && Contains(circle, rect.x, rect.bottom) && Contains(circle, rect.right, rect.bottom);
            };
            module2.exports = ContainsRect;
          },
          42997: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CopyFrom = function(source, dest) {
              return dest.setTo(source.x, source.y, source.radius);
            };
            module2.exports = CopyFrom;
          },
          94894: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Equals = function(circle, toCompare) {
              return circle.x === toCompare.x && circle.y === toCompare.y && circle.radius === toCompare.radius;
            };
            module2.exports = Equals;
          },
          48027: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var GetBounds = function(circle, out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              out.x = circle.left;
              out.y = circle.top;
              out.width = circle.diameter;
              out.height = circle.diameter;
              return out;
            };
            module2.exports = GetBounds;
          },
          94026: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CircumferencePoint = __webpack_require__2(72233);
            var FromPercent = __webpack_require__2(91806);
            var MATH_CONST = __webpack_require__2(83392);
            var Point = __webpack_require__2(79967);
            var GetPoint = function(circle, position, out) {
              if (out === void 0) {
                out = new Point();
              }
              var angle = FromPercent(position, 0, MATH_CONST.PI2);
              return CircumferencePoint(circle, angle, out);
            };
            module2.exports = GetPoint;
          },
          62941: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circumference = __webpack_require__2(37964);
            var CircumferencePoint = __webpack_require__2(72233);
            var FromPercent = __webpack_require__2(91806);
            var MATH_CONST = __webpack_require__2(83392);
            var GetPoints = function(circle, quantity, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              if (!quantity && stepRate > 0) {
                quantity = Circumference(circle) / stepRate;
              }
              for (var i = 0; i < quantity; i++) {
                var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
                out.push(CircumferencePoint(circle, angle));
              }
              return out;
            };
            module2.exports = GetPoints;
          },
          34585: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Offset = function(circle, x, y) {
              circle.x += x;
              circle.y += y;
              return circle;
            };
            module2.exports = Offset;
          },
          88665: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var OffsetPoint = function(circle, point) {
              circle.x += point.x;
              circle.y += point.y;
              return circle;
            };
            module2.exports = OffsetPoint;
          },
          30977: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Random = function(circle, out) {
              if (out === void 0) {
                out = new Point();
              }
              var t = 2 * Math.PI * Math.random();
              var u = Math.random() + Math.random();
              var r = u > 1 ? 2 - u : u;
              var x = r * Math.cos(t);
              var y = r * Math.sin(t);
              out.x = circle.x + x * circle.radius;
              out.y = circle.y + y * circle.radius;
              return out;
            };
            module2.exports = Random;
          },
          6112: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circle = __webpack_require__2(26673);
            Circle.Area = __webpack_require__2(95847);
            Circle.Circumference = __webpack_require__2(37964);
            Circle.CircumferencePoint = __webpack_require__2(72233);
            Circle.Clone = __webpack_require__2(61761);
            Circle.Contains = __webpack_require__2(65650);
            Circle.ContainsPoint = __webpack_require__2(39187);
            Circle.ContainsRect = __webpack_require__2(58672);
            Circle.CopyFrom = __webpack_require__2(42997);
            Circle.Equals = __webpack_require__2(94894);
            Circle.GetBounds = __webpack_require__2(48027);
            Circle.GetPoint = __webpack_require__2(94026);
            Circle.GetPoints = __webpack_require__2(62941);
            Circle.Offset = __webpack_require__2(34585);
            Circle.OffsetPoint = __webpack_require__2(88665);
            Circle.Random = __webpack_require__2(30977);
            module2.exports = Circle;
          },
          52394: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GEOM_CONST = {
              CIRCLE: 0,
              ELLIPSE: 1,
              LINE: 2,
              POINT: 3,
              POLYGON: 4,
              RECTANGLE: 5,
              TRIANGLE: 6
            };
            module2.exports = GEOM_CONST;
          },
          58605: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Area = function(ellipse) {
              if (ellipse.isEmpty()) {
                return 0;
              }
              return ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI;
            };
            module2.exports = Area;
          },
          39507: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circumference = function(ellipse) {
              var rx = ellipse.width / 2;
              var ry = ellipse.height / 2;
              var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
              return Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
            };
            module2.exports = Circumference;
          },
          86998: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var CircumferencePoint = function(ellipse, angle, out) {
              if (out === void 0) {
                out = new Point();
              }
              var halfWidth = ellipse.width / 2;
              var halfHeight = ellipse.height / 2;
              out.x = ellipse.x + halfWidth * Math.cos(angle);
              out.y = ellipse.y + halfHeight * Math.sin(angle);
              return out;
            };
            module2.exports = CircumferencePoint;
          },
          81773: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Ellipse = __webpack_require__2(95669);
            var Clone = function(source) {
              return new Ellipse(source.x, source.y, source.width, source.height);
            };
            module2.exports = Clone;
          },
          72313: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = function(ellipse, x, y) {
              if (ellipse.width <= 0 || ellipse.height <= 0) {
                return false;
              }
              var normx = (x - ellipse.x) / ellipse.width;
              var normy = (y - ellipse.y) / ellipse.height;
              normx *= normx;
              normy *= normy;
              return normx + normy < 0.25;
            };
            module2.exports = Contains;
          },
          34368: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = __webpack_require__2(72313);
            var ContainsPoint = function(ellipse, point) {
              return Contains(ellipse, point.x, point.y);
            };
            module2.exports = ContainsPoint;
          },
          71431: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = __webpack_require__2(72313);
            var ContainsRect = function(ellipse, rect) {
              return Contains(ellipse, rect.x, rect.y) && Contains(ellipse, rect.right, rect.y) && Contains(ellipse, rect.x, rect.bottom) && Contains(ellipse, rect.right, rect.bottom);
            };
            module2.exports = ContainsRect;
          },
          75459: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CopyFrom = function(source, dest) {
              return dest.setTo(source.x, source.y, source.width, source.height);
            };
            module2.exports = CopyFrom;
          },
          95669: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Contains = __webpack_require__2(72313);
            var GetPoint = __webpack_require__2(95340);
            var GetPoints = __webpack_require__2(54978);
            var GEOM_CONST = __webpack_require__2(52394);
            var Random = __webpack_require__2(72006);
            var Ellipse = new Class({
              initialize: function Ellipse2(x, y, width, height) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = 0;
                }
                if (height === void 0) {
                  height = 0;
                }
                this.type = GEOM_CONST.ELLIPSE;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
              },
              contains: function(x, y) {
                return Contains(this, x, y);
              },
              getPoint: function(position, point) {
                return GetPoint(this, position, point);
              },
              getPoints: function(quantity, stepRate, output) {
                return GetPoints(this, quantity, stepRate, output);
              },
              getRandomPoint: function(point) {
                return Random(this, point);
              },
              setTo: function(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                return this;
              },
              setEmpty: function() {
                this.width = 0;
                this.height = 0;
                return this;
              },
              setPosition: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.x = x;
                this.y = y;
                return this;
              },
              setSize: function(width, height) {
                if (height === void 0) {
                  height = width;
                }
                this.width = width;
                this.height = height;
                return this;
              },
              isEmpty: function() {
                return this.width <= 0 || this.height <= 0;
              },
              getMinorRadius: function() {
                return Math.min(this.width, this.height) / 2;
              },
              getMajorRadius: function() {
                return Math.max(this.width, this.height) / 2;
              },
              left: {
                get: function() {
                  return this.x - this.width / 2;
                },
                set: function(value) {
                  this.x = value + this.width / 2;
                }
              },
              right: {
                get: function() {
                  return this.x + this.width / 2;
                },
                set: function(value) {
                  this.x = value - this.width / 2;
                }
              },
              top: {
                get: function() {
                  return this.y - this.height / 2;
                },
                set: function(value) {
                  this.y = value + this.height / 2;
                }
              },
              bottom: {
                get: function() {
                  return this.y + this.height / 2;
                },
                set: function(value) {
                  this.y = value - this.height / 2;
                }
              }
            });
            module2.exports = Ellipse;
          },
          98068: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Equals = function(ellipse, toCompare) {
              return ellipse.x === toCompare.x && ellipse.y === toCompare.y && ellipse.width === toCompare.width && ellipse.height === toCompare.height;
            };
            module2.exports = Equals;
          },
          72897: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var GetBounds = function(ellipse, out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              out.x = ellipse.left;
              out.y = ellipse.top;
              out.width = ellipse.width;
              out.height = ellipse.height;
              return out;
            };
            module2.exports = GetBounds;
          },
          95340: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CircumferencePoint = __webpack_require__2(86998);
            var FromPercent = __webpack_require__2(91806);
            var MATH_CONST = __webpack_require__2(83392);
            var Point = __webpack_require__2(79967);
            var GetPoint = function(ellipse, position, out) {
              if (out === void 0) {
                out = new Point();
              }
              var angle = FromPercent(position, 0, MATH_CONST.PI2);
              return CircumferencePoint(ellipse, angle, out);
            };
            module2.exports = GetPoint;
          },
          54978: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circumference = __webpack_require__2(39507);
            var CircumferencePoint = __webpack_require__2(86998);
            var FromPercent = __webpack_require__2(91806);
            var MATH_CONST = __webpack_require__2(83392);
            var GetPoints = function(ellipse, quantity, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              if (!quantity && stepRate > 0) {
                quantity = Circumference(ellipse) / stepRate;
              }
              for (var i = 0; i < quantity; i++) {
                var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
                out.push(CircumferencePoint(ellipse, angle));
              }
              return out;
            };
            module2.exports = GetPoints;
          },
          77951: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Offset = function(ellipse, x, y) {
              ellipse.x += x;
              ellipse.y += y;
              return ellipse;
            };
            module2.exports = Offset;
          },
          36233: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var OffsetPoint = function(ellipse, point) {
              ellipse.x += point.x;
              ellipse.y += point.y;
              return ellipse;
            };
            module2.exports = OffsetPoint;
          },
          72006: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Random = function(ellipse, out) {
              if (out === void 0) {
                out = new Point();
              }
              var p = Math.random() * Math.PI * 2;
              var s = Math.sqrt(Math.random());
              out.x = ellipse.x + s * Math.cos(p) * ellipse.width / 2;
              out.y = ellipse.y + s * Math.sin(p) * ellipse.height / 2;
              return out;
            };
            module2.exports = Random;
          },
          40652: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Ellipse = __webpack_require__2(95669);
            Ellipse.Area = __webpack_require__2(58605);
            Ellipse.Circumference = __webpack_require__2(39507);
            Ellipse.CircumferencePoint = __webpack_require__2(86998);
            Ellipse.Clone = __webpack_require__2(81773);
            Ellipse.Contains = __webpack_require__2(72313);
            Ellipse.ContainsPoint = __webpack_require__2(34368);
            Ellipse.ContainsRect = __webpack_require__2(71431);
            Ellipse.CopyFrom = __webpack_require__2(75459);
            Ellipse.Equals = __webpack_require__2(98068);
            Ellipse.GetBounds = __webpack_require__2(72897);
            Ellipse.GetPoint = __webpack_require__2(95340);
            Ellipse.GetPoints = __webpack_require__2(54978);
            Ellipse.Offset = __webpack_require__2(77951);
            Ellipse.OffsetPoint = __webpack_require__2(36233);
            Ellipse.Random = __webpack_require__2(72006);
            module2.exports = Ellipse;
          },
          84068: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(52394);
            var Extend = __webpack_require__2(98611);
            var Geom = {
              Circle: __webpack_require__2(6112),
              Ellipse: __webpack_require__2(40652),
              Intersects: __webpack_require__2(7563),
              Line: __webpack_require__2(28482),
              Mesh: __webpack_require__2(14293),
              Point: __webpack_require__2(63472),
              Polygon: __webpack_require__2(44359),
              Rectangle: __webpack_require__2(66658),
              Triangle: __webpack_require__2(87619)
            };
            Geom = Extend(false, Geom, CONST);
            module2.exports = Geom;
          },
          22184: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DistanceBetween = __webpack_require__2(53996);
            var CircleToCircle = function(circleA, circleB) {
              return DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= circleA.radius + circleB.radius;
            };
            module2.exports = CircleToCircle;
          },
          26535: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CircleToRectangle = function(circle, rect) {
              var halfWidth = rect.width / 2;
              var halfHeight = rect.height / 2;
              var cx = Math.abs(circle.x - rect.x - halfWidth);
              var cy = Math.abs(circle.y - rect.y - halfHeight);
              var xDist = halfWidth + circle.radius;
              var yDist = halfHeight + circle.radius;
              if (cx > xDist || cy > yDist) {
                return false;
              } else if (cx <= halfWidth || cy <= halfHeight) {
                return true;
              } else {
                var xCornerDist = cx - halfWidth;
                var yCornerDist = cy - halfHeight;
                var xCornerDistSq = xCornerDist * xCornerDist;
                var yCornerDistSq = yCornerDist * yCornerDist;
                var maxCornerDistSq = circle.radius * circle.radius;
                return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;
              }
            };
            module2.exports = CircleToRectangle;
          },
          71145: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var CircleToCircle = __webpack_require__2(22184);
            var GetCircleToCircle = function(circleA, circleB, out) {
              if (out === void 0) {
                out = [];
              }
              if (CircleToCircle(circleA, circleB)) {
                var x0 = circleA.x;
                var y0 = circleA.y;
                var r0 = circleA.radius;
                var x1 = circleB.x;
                var y1 = circleB.y;
                var r1 = circleB.radius;
                var coefficientA, coefficientB, coefficientC, lambda, x;
                if (y0 === y1) {
                  x = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0) / (2 * (x0 - x1));
                  coefficientA = 1;
                  coefficientB = -2 * y1;
                  coefficientC = x1 * x1 + x * x - 2 * x1 * x + y1 * y1 - r1 * r1;
                  lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
                  if (lambda === 0) {
                    out.push(new Point(x, -coefficientB / (2 * coefficientA)));
                  } else if (lambda > 0) {
                    out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));
                    out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));
                  }
                } else {
                  var v1 = (x0 - x1) / (y0 - y1);
                  var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));
                  coefficientA = v1 * v1 + 1;
                  coefficientB = 2 * y0 * v1 - 2 * n * v1 - 2 * x0;
                  coefficientC = x0 * x0 + y0 * y0 + n * n - r0 * r0 - 2 * y0 * n;
                  lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
                  if (lambda === 0) {
                    x = -coefficientB / (2 * coefficientA);
                    out.push(new Point(x, n - x * v1));
                  } else if (lambda > 0) {
                    x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
                    out.push(new Point(x, n - x * v1));
                    x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
                    out.push(new Point(x, n - x * v1));
                  }
                }
              }
              return out;
            };
            module2.exports = GetCircleToCircle;
          },
          62508: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLineToCircle = __webpack_require__2(26111);
            var CircleToRectangle = __webpack_require__2(26535);
            var GetCircleToRectangle = function(circle, rect, out) {
              if (out === void 0) {
                out = [];
              }
              if (CircleToRectangle(circle, rect)) {
                var lineA = rect.getLineA();
                var lineB = rect.getLineB();
                var lineC = rect.getLineC();
                var lineD = rect.getLineD();
                GetLineToCircle(lineA, circle, out);
                GetLineToCircle(lineB, circle, out);
                GetLineToCircle(lineC, circle, out);
                GetLineToCircle(lineD, circle, out);
              }
              return out;
            };
            module2.exports = GetCircleToRectangle;
          },
          26111: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var LineToCircle = __webpack_require__2(61472);
            var GetLineToCircle = function(line, circle, out) {
              if (out === void 0) {
                out = [];
              }
              if (LineToCircle(line, circle)) {
                var lx1 = line.x1;
                var ly1 = line.y1;
                var lx2 = line.x2;
                var ly2 = line.y2;
                var cx = circle.x;
                var cy = circle.y;
                var cr = circle.radius;
                var lDirX = lx2 - lx1;
                var lDirY = ly2 - ly1;
                var oDirX = lx1 - cx;
                var oDirY = ly1 - cy;
                var coefficientA = lDirX * lDirX + lDirY * lDirY;
                var coefficientB = 2 * (lDirX * oDirX + lDirY * oDirY);
                var coefficientC = oDirX * oDirX + oDirY * oDirY - cr * cr;
                var lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
                var x, y;
                if (lambda === 0) {
                  var root = -coefficientB / (2 * coefficientA);
                  x = lx1 + root * lDirX;
                  y = ly1 + root * lDirY;
                  if (root >= 0 && root <= 1) {
                    out.push(new Point(x, y));
                  }
                } else if (lambda > 0) {
                  var root1 = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
                  x = lx1 + root1 * lDirX;
                  y = ly1 + root1 * lDirY;
                  if (root1 >= 0 && root1 <= 1) {
                    out.push(new Point(x, y));
                  }
                  var root2 = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
                  x = lx1 + root2 * lDirX;
                  y = ly1 + root2 * lDirY;
                  if (root2 >= 0 && root2 <= 1) {
                    out.push(new Point(x, y));
                  }
                }
              }
              return out;
            };
            module2.exports = GetLineToCircle;
          },
          96537: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector3 = __webpack_require__2(70015);
            var GetLineToLine = function(line1, line2, isRay, out) {
              if (isRay === void 0) {
                isRay = false;
              }
              var x1 = line1.x1;
              var y1 = line1.y1;
              var x2 = line1.x2;
              var y2 = line1.y2;
              var x3 = line2.x1;
              var y3 = line2.y1;
              var x4 = line2.x2;
              var y4 = line2.y2;
              var dx1 = x2 - x1;
              var dy1 = y2 - y1;
              var dx2 = x4 - x3;
              var dy2 = y4 - y3;
              var denom = dx1 * dy2 - dy1 * dx2;
              if (denom === 0) {
                return null;
              }
              var t;
              var u;
              var s;
              if (isRay) {
                t = (dx1 * (y3 - y1) + dy1 * (x1 - x3)) / (dx2 * dy1 - dy2 * dx1);
                u = (x3 + dx2 * t - x1) / dx1;
                if (u < 0 || t < 0 || t > 1) {
                  return null;
                }
                s = u;
              } else {
                t = ((x3 - x1) * dy2 - (y3 - y1) * dx2) / denom;
                u = ((y1 - y3) * dx1 - (x1 - x3) * dy1) / denom;
                if (t < 0 || t > 1 || u < 0 || u > 1) {
                  return null;
                }
                s = t;
              }
              if (out === void 0) {
                out = new Vector3();
              }
              return out.set(x1 + dx1 * s, y1 + dy1 * s, s);
            };
            module2.exports = GetLineToLine;
          },
          17647: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLineToLine = __webpack_require__2(96537);
            var Line = __webpack_require__2(88829);
            var Vector3 = __webpack_require__2(70015);
            var segment = new Line();
            var tempIntersect = new Vector3();
            var GetLineToPoints = function(line, points, isRay, out) {
              if (isRay === void 0) {
                isRay = false;
              }
              if (out === void 0) {
                out = new Vector3();
              }
              var closestIntersect = false;
              out.set();
              tempIntersect.set();
              var prev = points[points.length - 1];
              for (var i = 0; i < points.length; i++) {
                var current = points[i];
                segment.setTo(prev.x, prev.y, current.x, current.y);
                prev = current;
                if (GetLineToLine(line, segment, isRay, tempIntersect)) {
                  if (!closestIntersect || tempIntersect.z < out.z) {
                    out.copy(tempIntersect);
                    closestIntersect = true;
                  }
                }
              }
              return closestIntersect ? out : null;
            };
            module2.exports = GetLineToPoints;
          },
          68439: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector3 = __webpack_require__2(70015);
            var Vector4 = __webpack_require__2(51729);
            var GetLineToPoints = __webpack_require__2(17647);
            var tempIntersect = new Vector3();
            var GetLineToPolygon = function(line, polygons, isRay, out) {
              if (out === void 0) {
                out = new Vector4();
              }
              if (!Array.isArray(polygons)) {
                polygons = [polygons];
              }
              var closestIntersect = false;
              out.set();
              tempIntersect.set();
              for (var i = 0; i < polygons.length; i++) {
                if (GetLineToPoints(line, polygons[i].points, isRay, tempIntersect)) {
                  if (!closestIntersect || tempIntersect.z < out.z) {
                    out.set(tempIntersect.x, tempIntersect.y, tempIntersect.z, i);
                    closestIntersect = true;
                  }
                }
              }
              return closestIntersect ? out : null;
            };
            module2.exports = GetLineToPolygon;
          },
          9569: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var LineToLine = __webpack_require__2(25227);
            var LineToRectangle = __webpack_require__2(47910);
            var GetLineToRectangle = function(line, rect, out) {
              if (out === void 0) {
                out = [];
              }
              if (LineToRectangle(line, rect)) {
                var lineA = rect.getLineA();
                var lineB = rect.getLineB();
                var lineC = rect.getLineC();
                var lineD = rect.getLineD();
                var output = [new Point(), new Point(), new Point(), new Point()];
                var result = [
                  LineToLine(lineA, line, output[0]),
                  LineToLine(lineB, line, output[1]),
                  LineToLine(lineC, line, output[2]),
                  LineToLine(lineD, line, output[3])
                ];
                for (var i = 0; i < 4; i++) {
                  if (result[i]) {
                    out.push(output[i]);
                  }
                }
              }
              return out;
            };
            module2.exports = GetLineToRectangle;
          },
          7449: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector4 = __webpack_require__2(51729);
            var GetLineToPolygon = __webpack_require__2(68439);
            var Line = __webpack_require__2(88829);
            var segment = new Line();
            function CheckIntersects(angle, x, y, polygons, intersects) {
              var dx = Math.cos(angle);
              var dy = Math.sin(angle);
              segment.setTo(x, y, x + dx, y + dy);
              var closestIntersect = GetLineToPolygon(segment, polygons, true);
              if (closestIntersect) {
                intersects.push(new Vector4(closestIntersect.x, closestIntersect.y, angle, closestIntersect.w));
              }
            }
            function SortIntersects(a, b) {
              return a.z - b.z;
            }
            var GetRaysFromPointToPolygon = function(x, y, polygons) {
              if (!Array.isArray(polygons)) {
                polygons = [polygons];
              }
              var intersects = [];
              var angles = [];
              for (var i = 0; i < polygons.length; i++) {
                var points = polygons[i].points;
                for (var p = 0; p < points.length; p++) {
                  var angle = Math.atan2(points[p].y - y, points[p].x - x);
                  if (angles.indexOf(angle) === -1) {
                    CheckIntersects(angle, x, y, polygons, intersects);
                    CheckIntersects(angle - 1e-5, x, y, polygons, intersects);
                    CheckIntersects(angle + 1e-5, x, y, polygons, intersects);
                    angles.push(angle);
                  }
                }
              }
              return intersects.sort(SortIntersects);
            };
            module2.exports = GetRaysFromPointToPolygon;
          },
          82931: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var RectangleToRectangle = __webpack_require__2(90205);
            var GetRectangleIntersection = function(rectA, rectB, output) {
              if (output === void 0) {
                output = new Rectangle();
              }
              if (RectangleToRectangle(rectA, rectB)) {
                output.x = Math.max(rectA.x, rectB.x);
                output.y = Math.max(rectA.y, rectB.y);
                output.width = Math.min(rectA.right, rectB.right) - output.x;
                output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
              }
              return output;
            };
            module2.exports = GetRectangleIntersection;
          },
          1946: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLineToRectangle = __webpack_require__2(9569);
            var RectangleToRectangle = __webpack_require__2(90205);
            var GetRectangleToRectangle = function(rectA, rectB, out) {
              if (out === void 0) {
                out = [];
              }
              if (RectangleToRectangle(rectA, rectB)) {
                var lineA = rectA.getLineA();
                var lineB = rectA.getLineB();
                var lineC = rectA.getLineC();
                var lineD = rectA.getLineD();
                GetLineToRectangle(lineA, rectB, out);
                GetLineToRectangle(lineB, rectB, out);
                GetLineToRectangle(lineC, rectB, out);
                GetLineToRectangle(lineD, rectB, out);
              }
              return out;
            };
            module2.exports = GetRectangleToRectangle;
          },
          34211: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RectangleToTriangle = __webpack_require__2(20370);
            var GetLineToRectangle = __webpack_require__2(9569);
            var GetRectangleToTriangle = function(rect, triangle, out) {
              if (out === void 0) {
                out = [];
              }
              if (RectangleToTriangle(rect, triangle)) {
                var lineA = triangle.getLineA();
                var lineB = triangle.getLineB();
                var lineC = triangle.getLineC();
                GetLineToRectangle(lineA, rect, out);
                GetLineToRectangle(lineB, rect, out);
                GetLineToRectangle(lineC, rect, out);
              }
              return out;
            };
            module2.exports = GetRectangleToTriangle;
          },
          80511: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetLineToCircle = __webpack_require__2(26111);
            var TriangleToCircle = __webpack_require__2(48411);
            var GetTriangleToCircle = function(triangle, circle, out) {
              if (out === void 0) {
                out = [];
              }
              if (TriangleToCircle(triangle, circle)) {
                var lineA = triangle.getLineA();
                var lineB = triangle.getLineB();
                var lineC = triangle.getLineC();
                GetLineToCircle(lineA, circle, out);
                GetLineToCircle(lineB, circle, out);
                GetLineToCircle(lineC, circle, out);
              }
              return out;
            };
            module2.exports = GetTriangleToCircle;
          },
          31343: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var TriangleToLine = __webpack_require__2(86117);
            var LineToLine = __webpack_require__2(25227);
            var GetTriangleToLine = function(triangle, line, out) {
              if (out === void 0) {
                out = [];
              }
              if (TriangleToLine(triangle, line)) {
                var lineA = triangle.getLineA();
                var lineB = triangle.getLineB();
                var lineC = triangle.getLineC();
                var output = [new Point(), new Point(), new Point()];
                var result = [
                  LineToLine(lineA, line, output[0]),
                  LineToLine(lineB, line, output[1]),
                  LineToLine(lineC, line, output[2])
                ];
                for (var i = 0; i < 3; i++) {
                  if (result[i]) {
                    out.push(output[i]);
                  }
                }
              }
              return out;
            };
            module2.exports = GetTriangleToLine;
          },
          70534: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Florian Vazelle
             * @author       Geoffrey Glaive
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TriangleToTriangle = __webpack_require__2(23589);
            var GetTriangleToLine = __webpack_require__2(31343);
            var GetTriangleToTriangle = function(triangleA, triangleB, out) {
              if (out === void 0) {
                out = [];
              }
              if (TriangleToTriangle(triangleA, triangleB)) {
                var lineA = triangleB.getLineA();
                var lineB = triangleB.getLineB();
                var lineC = triangleB.getLineC();
                GetTriangleToLine(triangleA, lineA, out);
                GetTriangleToLine(triangleA, lineB, out);
                GetTriangleToLine(triangleA, lineC, out);
              }
              return out;
            };
            module2.exports = GetTriangleToTriangle;
          },
          61472: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = __webpack_require__2(65650);
            var Point = __webpack_require__2(79967);
            var tmp = new Point();
            var LineToCircle = function(line, circle, nearest) {
              if (nearest === void 0) {
                nearest = tmp;
              }
              if (Contains(circle, line.x1, line.y1)) {
                nearest.x = line.x1;
                nearest.y = line.y1;
                return true;
              }
              if (Contains(circle, line.x2, line.y2)) {
                nearest.x = line.x2;
                nearest.y = line.y2;
                return true;
              }
              var dx = line.x2 - line.x1;
              var dy = line.y2 - line.y1;
              var lcx = circle.x - line.x1;
              var lcy = circle.y - line.y1;
              var dLen2 = dx * dx + dy * dy;
              var px = dx;
              var py = dy;
              if (dLen2 > 0) {
                var dp = (lcx * dx + lcy * dy) / dLen2;
                px *= dp;
                py *= dp;
              }
              nearest.x = line.x1 + px;
              nearest.y = line.y1 + py;
              var pLen2 = px * px + py * py;
              return pLen2 <= dLen2 && px * dx + py * dy >= 0 && Contains(circle, nearest.x, nearest.y);
            };
            module2.exports = LineToCircle;
          },
          25227: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LineToLine = function(line1, line2, out) {
              var x1 = line1.x1;
              var y1 = line1.y1;
              var x2 = line1.x2;
              var y2 = line1.y2;
              var x3 = line2.x1;
              var y3 = line2.y1;
              var x4 = line2.x2;
              var y4 = line2.y2;
              if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) {
                return false;
              }
              var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
              if (denom === 0) {
                return false;
              }
              var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
              var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
              if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
                return false;
              } else {
                if (out) {
                  out.x = x1 + ua * (x2 - x1);
                  out.y = y1 + ua * (y2 - y1);
                }
                return true;
              }
            };
            module2.exports = LineToLine;
          },
          47910: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LineToRectangle = function(line, rect) {
              var x1 = line.x1;
              var y1 = line.y1;
              var x2 = line.x2;
              var y2 = line.y2;
              var bx1 = rect.x;
              var by1 = rect.y;
              var bx2 = rect.right;
              var by2 = rect.bottom;
              var t = 0;
              if (x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2 || x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2) {
                return true;
              }
              if (x1 < bx1 && x2 >= bx1) {
                t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);
                if (t > by1 && t <= by2) {
                  return true;
                }
              } else if (x1 > bx2 && x2 <= bx2) {
                t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);
                if (t >= by1 && t <= by2) {
                  return true;
                }
              }
              if (y1 < by1 && y2 >= by1) {
                t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);
                if (t >= bx1 && t <= bx2) {
                  return true;
                }
              } else if (y1 > by2 && y2 <= by2) {
                t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);
                if (t >= bx1 && t <= bx2) {
                  return true;
                }
              }
              return false;
            };
            module2.exports = LineToRectangle;
          },
          34426: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Florian Mertens
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PointToLine = function(point, line, lineThickness) {
              if (lineThickness === void 0) {
                lineThickness = 1;
              }
              var x1 = line.x1;
              var y1 = line.y1;
              var x2 = line.x2;
              var y2 = line.y2;
              var px = point.x;
              var py = point.y;
              var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
              if (L2 === 0) {
                return false;
              }
              var r = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
              if (r < 0) {
                return Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py)) <= lineThickness;
              } else if (r >= 0 && r <= 1) {
                var s = ((y1 - py) * (x2 - x1) - (x1 - px) * (y2 - y1)) / L2;
                return Math.abs(s) * Math.sqrt(L2) <= lineThickness;
              } else {
                return Math.sqrt((x2 - px) * (x2 - px) + (y2 - py) * (y2 - py)) <= lineThickness;
              }
            };
            module2.exports = PointToLine;
          },
          81414: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PointToLine = __webpack_require__2(34426);
            var PointToLineSegment = function(point, line) {
              if (!PointToLine(point, line)) {
                return false;
              }
              var xMin = Math.min(line.x1, line.x2);
              var xMax = Math.max(line.x1, line.x2);
              var yMin = Math.min(line.y1, line.y2);
              var yMax = Math.max(line.y1, line.y2);
              return point.x >= xMin && point.x <= xMax && (point.y >= yMin && point.y <= yMax);
            };
            module2.exports = PointToLineSegment;
          },
          90205: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RectangleToRectangle = function(rectA, rectB) {
              if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0) {
                return false;
              }
              return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
            };
            module2.exports = RectangleToRectangle;
          },
          20370: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LineToLine = __webpack_require__2(25227);
            var Contains = __webpack_require__2(94287);
            var ContainsArray = __webpack_require__2(86875);
            var Decompose = __webpack_require__2(87279);
            var RectangleToTriangle = function(rect, triangle) {
              if (triangle.left > rect.right || triangle.right < rect.left || triangle.top > rect.bottom || triangle.bottom < rect.top) {
                return false;
              }
              var triA = triangle.getLineA();
              var triB = triangle.getLineB();
              var triC = triangle.getLineC();
              if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2)) {
                return true;
              }
              if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2)) {
                return true;
              }
              if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2)) {
                return true;
              }
              var rectA = rect.getLineA();
              var rectB = rect.getLineB();
              var rectC = rect.getLineC();
              var rectD = rect.getLineD();
              if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD)) {
                return true;
              }
              if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD)) {
                return true;
              }
              if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD)) {
                return true;
              }
              var points = Decompose(rect);
              var within = ContainsArray(triangle, points, true);
              return within.length > 0;
            };
            module2.exports = RectangleToTriangle;
          },
          8786: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RectangleToValues = function(rect, left, right, top, bottom, tolerance) {
              if (tolerance === void 0) {
                tolerance = 0;
              }
              return !(left > rect.right + tolerance || right < rect.left - tolerance || top > rect.bottom + tolerance || bottom < rect.top - tolerance);
            };
            module2.exports = RectangleToValues;
          },
          48411: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LineToCircle = __webpack_require__2(61472);
            var Contains = __webpack_require__2(60689);
            var TriangleToCircle = function(triangle, circle) {
              if (triangle.left > circle.right || triangle.right < circle.left || triangle.top > circle.bottom || triangle.bottom < circle.top) {
                return false;
              }
              if (Contains(triangle, circle.x, circle.y)) {
                return true;
              }
              if (LineToCircle(triangle.getLineA(), circle)) {
                return true;
              }
              if (LineToCircle(triangle.getLineB(), circle)) {
                return true;
              }
              if (LineToCircle(triangle.getLineC(), circle)) {
                return true;
              }
              return false;
            };
            module2.exports = TriangleToCircle;
          },
          86117: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LineToLine = __webpack_require__2(25227);
            var TriangleToLine = function(triangle, line) {
              if (triangle.contains(line.x1, line.y1) || triangle.contains(line.x2, line.y2)) {
                return true;
              }
              if (LineToLine(triangle.getLineA(), line)) {
                return true;
              }
              if (LineToLine(triangle.getLineB(), line)) {
                return true;
              }
              if (LineToLine(triangle.getLineC(), line)) {
                return true;
              }
              return false;
            };
            module2.exports = TriangleToLine;
          },
          23589: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ContainsArray = __webpack_require__2(86875);
            var Decompose = __webpack_require__2(18680);
            var LineToLine = __webpack_require__2(25227);
            var TriangleToTriangle = function(triangleA, triangleB) {
              if (triangleA.left > triangleB.right || triangleA.right < triangleB.left || triangleA.top > triangleB.bottom || triangleA.bottom < triangleB.top) {
                return false;
              }
              var lineAA = triangleA.getLineA();
              var lineAB = triangleA.getLineB();
              var lineAC = triangleA.getLineC();
              var lineBA = triangleB.getLineA();
              var lineBB = triangleB.getLineB();
              var lineBC = triangleB.getLineC();
              if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC)) {
                return true;
              }
              if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC)) {
                return true;
              }
              if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC)) {
                return true;
              }
              var points = Decompose(triangleA);
              var within = ContainsArray(triangleB, points, true);
              if (within.length > 0) {
                return true;
              }
              points = Decompose(triangleB);
              within = ContainsArray(triangleA, points, true);
              if (within.length > 0) {
                return true;
              }
              return false;
            };
            module2.exports = TriangleToTriangle;
          },
          7563: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              CircleToCircle: __webpack_require__2(22184),
              CircleToRectangle: __webpack_require__2(26535),
              GetCircleToCircle: __webpack_require__2(71145),
              GetCircleToRectangle: __webpack_require__2(62508),
              GetLineToCircle: __webpack_require__2(26111),
              GetLineToLine: __webpack_require__2(96537),
              GetLineToPoints: __webpack_require__2(17647),
              GetLineToPolygon: __webpack_require__2(68439),
              GetLineToRectangle: __webpack_require__2(9569),
              GetRaysFromPointToPolygon: __webpack_require__2(7449),
              GetRectangleIntersection: __webpack_require__2(82931),
              GetRectangleToRectangle: __webpack_require__2(1946),
              GetRectangleToTriangle: __webpack_require__2(34211),
              GetTriangleToCircle: __webpack_require__2(80511),
              GetTriangleToLine: __webpack_require__2(31343),
              GetTriangleToTriangle: __webpack_require__2(70534),
              LineToCircle: __webpack_require__2(61472),
              LineToLine: __webpack_require__2(25227),
              LineToRectangle: __webpack_require__2(47910),
              PointToLine: __webpack_require__2(34426),
              PointToLineSegment: __webpack_require__2(81414),
              RectangleToRectangle: __webpack_require__2(90205),
              RectangleToTriangle: __webpack_require__2(20370),
              RectangleToValues: __webpack_require__2(8786),
              TriangleToCircle: __webpack_require__2(48411),
              TriangleToLine: __webpack_require__2(86117),
              TriangleToTriangle: __webpack_require__2(23589)
            };
          },
          50599: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Angle = function(line) {
              return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
            };
            module2.exports = Angle;
          },
          58813: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BresenhamPoints = function(line, stepRate, results) {
              if (stepRate === void 0) {
                stepRate = 1;
              }
              if (results === void 0) {
                results = [];
              }
              var x1 = Math.round(line.x1);
              var y1 = Math.round(line.y1);
              var x2 = Math.round(line.x2);
              var y2 = Math.round(line.y2);
              var dx = Math.abs(x2 - x1);
              var dy = Math.abs(y2 - y1);
              var sx = x1 < x2 ? 1 : -1;
              var sy = y1 < y2 ? 1 : -1;
              var err = dx - dy;
              results.push({x: x1, y: y1});
              var i = 1;
              while (!(x1 === x2 && y1 === y2)) {
                var e2 = err << 1;
                if (e2 > -dy) {
                  err -= dy;
                  x1 += sx;
                }
                if (e2 < dx) {
                  err += dx;
                  y1 += sy;
                }
                if (i % stepRate === 0) {
                  results.push({x: x1, y: y1});
                }
                i++;
              }
              return results;
            };
            module2.exports = BresenhamPoints;
          },
          88513: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CenterOn = function(line, x, y) {
              var tx = x - (line.x1 + line.x2) / 2;
              var ty = y - (line.y1 + line.y2) / 2;
              line.x1 += tx;
              line.y1 += ty;
              line.x2 += tx;
              line.y2 += ty;
              return line;
            };
            module2.exports = CenterOn;
          },
          26718: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Line = __webpack_require__2(88829);
            var Clone = function(source) {
              return new Line(source.x1, source.y1, source.x2, source.y2);
            };
            module2.exports = Clone;
          },
          88930: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CopyFrom = function(source, dest) {
              return dest.setTo(source.x1, source.y1, source.x2, source.y2);
            };
            module2.exports = CopyFrom;
          },
          90656: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Equals = function(line, toCompare) {
              return line.x1 === toCompare.x1 && line.y1 === toCompare.y1 && line.x2 === toCompare.x2 && line.y2 === toCompare.y2;
            };
            module2.exports = Equals;
          },
          30897: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Length = __webpack_require__2(16028);
            var Extend = function(line, left, right) {
              if (right === void 0) {
                right = left;
              }
              var length = Length(line);
              var slopX = line.x2 - line.x1;
              var slopY = line.y2 - line.y1;
              if (left) {
                line.x1 = line.x1 - slopX / length * left;
                line.y1 = line.y1 - slopY / length * left;
              }
              if (right) {
                line.x2 = line.x2 + slopX / length * right;
                line.y2 = line.y2 + slopY / length * right;
              }
              return line;
            };
            module2.exports = Extend;
          },
          30684: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DistanceBetweenPoints = __webpack_require__2(92951);
            var GetEaseFunction = __webpack_require__2(21902);
            var Point = __webpack_require__2(79967);
            var GetEasedPoints = function(line, ease, quantity, collinearThreshold, easeParams) {
              if (collinearThreshold === void 0) {
                collinearThreshold = 0;
              }
              if (easeParams === void 0) {
                easeParams = [];
              }
              var results = [];
              var x1 = line.x1;
              var y1 = line.y1;
              var spaceX = line.x2 - x1;
              var spaceY = line.y2 - y1;
              var easeFunc = GetEaseFunction(ease, easeParams);
              var i;
              var v;
              var q = quantity - 1;
              for (i = 0; i < q; i++) {
                v = easeFunc(i / q);
                results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
              }
              v = easeFunc(1);
              results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
              if (collinearThreshold > 0) {
                var prevPoint = results[0];
                var sortedResults = [prevPoint];
                for (i = 1; i < results.length - 1; i++) {
                  var point = results[i];
                  if (DistanceBetweenPoints(prevPoint, point) >= collinearThreshold) {
                    sortedResults.push(point);
                    prevPoint = point;
                  }
                }
                var endPoint = results[results.length - 1];
                if (DistanceBetweenPoints(prevPoint, endPoint) < collinearThreshold) {
                  sortedResults.pop();
                }
                sortedResults.push(endPoint);
                return sortedResults;
              } else {
                return results;
              }
            };
            module2.exports = GetEasedPoints;
          },
          20487: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var GetMidPoint = function(line, out) {
              if (out === void 0) {
                out = new Point();
              }
              out.x = (line.x1 + line.x2) / 2;
              out.y = (line.y1 + line.y2) / 2;
              return out;
            };
            module2.exports = GetMidPoint;
          },
          11222: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Florian Mertens
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var GetNearestPoint = function(line, point, out) {
              if (out === void 0) {
                out = new Point();
              }
              var x1 = line.x1;
              var y1 = line.y1;
              var x2 = line.x2;
              var y2 = line.y2;
              var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
              if (L2 === 0) {
                return out;
              }
              var r = ((point.x - x1) * (x2 - x1) + (point.y - y1) * (y2 - y1)) / L2;
              out.x = x1 + r * (x2 - x1);
              out.y = y1 + r * (y2 - y1);
              return out;
            };
            module2.exports = GetNearestPoint;
          },
          7377: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MATH_CONST = __webpack_require__2(83392);
            var Angle = __webpack_require__2(50599);
            var Point = __webpack_require__2(79967);
            var GetNormal = function(line, out) {
              if (out === void 0) {
                out = new Point();
              }
              var a = Angle(line) - MATH_CONST.TAU;
              out.x = Math.cos(a);
              out.y = Math.sin(a);
              return out;
            };
            module2.exports = GetNormal;
          },
          66464: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var GetPoint = function(line, position, out) {
              if (out === void 0) {
                out = new Point();
              }
              out.x = line.x1 + (line.x2 - line.x1) * position;
              out.y = line.y1 + (line.y2 - line.y1) * position;
              return out;
            };
            module2.exports = GetPoint;
          },
          8570: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Length = __webpack_require__2(16028);
            var Point = __webpack_require__2(79967);
            var GetPoints = function(line, quantity, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              if (!quantity && stepRate > 0) {
                quantity = Length(line) / stepRate;
              }
              var x1 = line.x1;
              var y1 = line.y1;
              var x2 = line.x2;
              var y2 = line.y2;
              for (var i = 0; i < quantity; i++) {
                var position = i / quantity;
                var x = x1 + (x2 - x1) * position;
                var y = y1 + (y2 - y1) * position;
                out.push(new Point(x, y));
              }
              return out;
            };
            module2.exports = GetPoints;
          },
          65269: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Florian Mertens
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetShortestDistance = function(line, point) {
              var x1 = line.x1;
              var y1 = line.y1;
              var x2 = line.x2;
              var y2 = line.y2;
              var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
              if (L2 === 0) {
                return false;
              }
              var s = ((y1 - point.y) * (x2 - x1) - (x1 - point.x) * (y2 - y1)) / L2;
              return Math.abs(s) * Math.sqrt(L2);
            };
            module2.exports = GetShortestDistance;
          },
          82996: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Height = function(line) {
              return Math.abs(line.y1 - line.y2);
            };
            module2.exports = Height;
          },
          16028: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Length = function(line) {
              return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
            };
            module2.exports = Length;
          },
          88829: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetPoint = __webpack_require__2(66464);
            var GetPoints = __webpack_require__2(8570);
            var GEOM_CONST = __webpack_require__2(52394);
            var Random = __webpack_require__2(74077);
            var Vector2 = __webpack_require__2(93736);
            var Line = new Class({
              initialize: function Line2(x1, y1, x2, y2) {
                if (x1 === void 0) {
                  x1 = 0;
                }
                if (y1 === void 0) {
                  y1 = 0;
                }
                if (x2 === void 0) {
                  x2 = 0;
                }
                if (y2 === void 0) {
                  y2 = 0;
                }
                this.type = GEOM_CONST.LINE;
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
              },
              getPoint: function(position, output) {
                return GetPoint(this, position, output);
              },
              getPoints: function(quantity, stepRate, output) {
                return GetPoints(this, quantity, stepRate, output);
              },
              getRandomPoint: function(point) {
                return Random(this, point);
              },
              setTo: function(x1, y1, x2, y2) {
                if (x1 === void 0) {
                  x1 = 0;
                }
                if (y1 === void 0) {
                  y1 = 0;
                }
                if (x2 === void 0) {
                  x2 = 0;
                }
                if (y2 === void 0) {
                  y2 = 0;
                }
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                return this;
              },
              setFromObjects: function(start, end) {
                this.x1 = start.x;
                this.y1 = start.y;
                this.x2 = end.x;
                this.y2 = end.y;
                return this;
              },
              getPointA: function(vec2) {
                if (vec2 === void 0) {
                  vec2 = new Vector2();
                }
                vec2.set(this.x1, this.y1);
                return vec2;
              },
              getPointB: function(vec2) {
                if (vec2 === void 0) {
                  vec2 = new Vector2();
                }
                vec2.set(this.x2, this.y2);
                return vec2;
              },
              left: {
                get: function() {
                  return Math.min(this.x1, this.x2);
                },
                set: function(value) {
                  if (this.x1 <= this.x2) {
                    this.x1 = value;
                  } else {
                    this.x2 = value;
                  }
                }
              },
              right: {
                get: function() {
                  return Math.max(this.x1, this.x2);
                },
                set: function(value) {
                  if (this.x1 > this.x2) {
                    this.x1 = value;
                  } else {
                    this.x2 = value;
                  }
                }
              },
              top: {
                get: function() {
                  return Math.min(this.y1, this.y2);
                },
                set: function(value) {
                  if (this.y1 <= this.y2) {
                    this.y1 = value;
                  } else {
                    this.y2 = value;
                  }
                }
              },
              bottom: {
                get: function() {
                  return Math.max(this.y1, this.y2);
                },
                set: function(value) {
                  if (this.y1 > this.y2) {
                    this.y1 = value;
                  } else {
                    this.y2 = value;
                  }
                }
              }
            });
            module2.exports = Line;
          },
          73273: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MATH_CONST = __webpack_require__2(83392);
            var Wrap = __webpack_require__2(1071);
            var Angle = __webpack_require__2(50599);
            var NormalAngle = function(line) {
              var angle = Angle(line) - MATH_CONST.TAU;
              return Wrap(angle, -Math.PI, Math.PI);
            };
            module2.exports = NormalAngle;
          },
          96936: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MATH_CONST = __webpack_require__2(83392);
            var Angle = __webpack_require__2(50599);
            var NormalX = function(line) {
              return Math.cos(Angle(line) - MATH_CONST.TAU);
            };
            module2.exports = NormalX;
          },
          43581: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MATH_CONST = __webpack_require__2(83392);
            var Angle = __webpack_require__2(50599);
            var NormalY = function(line) {
              return Math.sin(Angle(line) - MATH_CONST.TAU);
            };
            module2.exports = NormalY;
          },
          13990: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Offset = function(line, x, y) {
              line.x1 += x;
              line.y1 += y;
              line.x2 += x;
              line.y2 += y;
              return line;
            };
            module2.exports = Offset;
          },
          1298: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PerpSlope = function(line) {
              return -((line.x2 - line.x1) / (line.y2 - line.y1));
            };
            module2.exports = PerpSlope;
          },
          74077: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Random = function(line, out) {
              if (out === void 0) {
                out = new Point();
              }
              var t = Math.random();
              out.x = line.x1 + t * (line.x2 - line.x1);
              out.y = line.y1 + t * (line.y2 - line.y1);
              return out;
            };
            module2.exports = Random;
          },
          30473: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Angle = __webpack_require__2(50599);
            var NormalAngle = __webpack_require__2(73273);
            var ReflectAngle = function(lineA, lineB) {
              return 2 * NormalAngle(lineB) - Math.PI - Angle(lineA);
            };
            module2.exports = ReflectAngle;
          },
          25968: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAroundXY = __webpack_require__2(1809);
            var Rotate = function(line, angle) {
              var x = (line.x1 + line.x2) / 2;
              var y = (line.y1 + line.y2) / 2;
              return RotateAroundXY(line, x, y, angle);
            };
            module2.exports = Rotate;
          },
          24296: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAroundXY = __webpack_require__2(1809);
            var RotateAroundPoint = function(line, point, angle) {
              return RotateAroundXY(line, point.x, point.y, angle);
            };
            module2.exports = RotateAroundPoint;
          },
          1809: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAroundXY = function(line, x, y, angle) {
              var c = Math.cos(angle);
              var s = Math.sin(angle);
              var tx = line.x1 - x;
              var ty = line.y1 - y;
              line.x1 = tx * c - ty * s + x;
              line.y1 = tx * s + ty * c + y;
              tx = line.x2 - x;
              ty = line.y2 - y;
              line.x2 = tx * c - ty * s + x;
              line.y2 = tx * s + ty * c + y;
              return line;
            };
            module2.exports = RotateAroundXY;
          },
          88171: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetToAngle = function(line, x, y, angle, length) {
              line.x1 = x;
              line.y1 = y;
              line.x2 = x + Math.cos(angle) * length;
              line.y2 = y + Math.sin(angle) * length;
              return line;
            };
            module2.exports = SetToAngle;
          },
          82797: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Slope = function(line) {
              return (line.y2 - line.y1) / (line.x2 - line.x1);
            };
            module2.exports = Slope;
          },
          41067: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Width = function(line) {
              return Math.abs(line.x1 - line.x2);
            };
            module2.exports = Width;
          },
          28482: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Line = __webpack_require__2(88829);
            Line.Angle = __webpack_require__2(50599);
            Line.BresenhamPoints = __webpack_require__2(58813);
            Line.CenterOn = __webpack_require__2(88513);
            Line.Clone = __webpack_require__2(26718);
            Line.CopyFrom = __webpack_require__2(88930);
            Line.Equals = __webpack_require__2(90656);
            Line.Extend = __webpack_require__2(30897);
            Line.GetEasedPoints = __webpack_require__2(30684);
            Line.GetMidPoint = __webpack_require__2(20487);
            Line.GetNearestPoint = __webpack_require__2(11222);
            Line.GetNormal = __webpack_require__2(7377);
            Line.GetPoint = __webpack_require__2(66464);
            Line.GetPoints = __webpack_require__2(8570);
            Line.GetShortestDistance = __webpack_require__2(65269);
            Line.Height = __webpack_require__2(82996);
            Line.Length = __webpack_require__2(16028);
            Line.NormalAngle = __webpack_require__2(73273);
            Line.NormalX = __webpack_require__2(96936);
            Line.NormalY = __webpack_require__2(43581);
            Line.Offset = __webpack_require__2(13990);
            Line.PerpSlope = __webpack_require__2(1298);
            Line.Random = __webpack_require__2(74077);
            Line.ReflectAngle = __webpack_require__2(30473);
            Line.Rotate = __webpack_require__2(25968);
            Line.RotateAroundPoint = __webpack_require__2(24296);
            Line.RotateAroundXY = __webpack_require__2(1809);
            Line.SetToAngle = __webpack_require__2(88171);
            Line.Slope = __webpack_require__2(82797);
            Line.Width = __webpack_require__2(41067);
            module2.exports = Line;
          },
          18693: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Rectangle = __webpack_require__2(74118);
            var Vector2 = __webpack_require__2(93736);
            function GetLength(x1, y1, x2, y2) {
              var x = x1 - x2;
              var y = y1 - y2;
              var magnitude = x * x + y * y;
              return Math.sqrt(magnitude);
            }
            var Face = new Class({
              initialize: function Face2(vertex1, vertex2, vertex3) {
                this.vertex1 = vertex1;
                this.vertex2 = vertex2;
                this.vertex3 = vertex3;
                this.bounds = new Rectangle();
                this._inCenter = new Vector2();
              },
              getInCenter: function(local) {
                if (local === void 0) {
                  local = true;
                }
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                var v1x;
                var v1y;
                var v2x;
                var v2y;
                var v3x;
                var v3y;
                if (local) {
                  v1x = v1.x;
                  v1y = v1.y;
                  v2x = v2.x;
                  v2y = v2.y;
                  v3x = v3.x;
                  v3y = v3.y;
                } else {
                  v1x = v1.vx;
                  v1y = v1.vy;
                  v2x = v2.vx;
                  v2y = v2.vy;
                  v3x = v3.vx;
                  v3y = v3.vy;
                }
                var d1 = GetLength(v3x, v3y, v2x, v2y);
                var d2 = GetLength(v1x, v1y, v3x, v3y);
                var d3 = GetLength(v2x, v2y, v1x, v1y);
                var p = d1 + d2 + d3;
                return this._inCenter.set((v1x * d1 + v2x * d2 + v3x * d3) / p, (v1y * d1 + v2y * d2 + v3y * d3) / p);
              },
              contains: function(x, y, calcMatrix) {
                var vertex1 = this.vertex1;
                var vertex2 = this.vertex2;
                var vertex3 = this.vertex3;
                var v1x = vertex1.vx;
                var v1y = vertex1.vy;
                var v2x = vertex2.vx;
                var v2y = vertex2.vy;
                var v3x = vertex3.vx;
                var v3y = vertex3.vy;
                if (calcMatrix) {
                  var a = calcMatrix.a;
                  var b = calcMatrix.b;
                  var c = calcMatrix.c;
                  var d = calcMatrix.d;
                  var e = calcMatrix.e;
                  var f = calcMatrix.f;
                  v1x = vertex1.vx * a + vertex1.vy * c + e;
                  v1y = vertex1.vx * b + vertex1.vy * d + f;
                  v2x = vertex2.vx * a + vertex2.vy * c + e;
                  v2y = vertex2.vx * b + vertex2.vy * d + f;
                  v3x = vertex3.vx * a + vertex3.vy * c + e;
                  v3y = vertex3.vx * b + vertex3.vy * d + f;
                }
                var t0x = v3x - v1x;
                var t0y = v3y - v1y;
                var t1x = v2x - v1x;
                var t1y = v2y - v1y;
                var t2x = x - v1x;
                var t2y = y - v1y;
                var dot00 = t0x * t0x + t0y * t0y;
                var dot01 = t0x * t1x + t0y * t1y;
                var dot02 = t0x * t2x + t0y * t2y;
                var dot11 = t1x * t1x + t1y * t1y;
                var dot12 = t1x * t2x + t1y * t2y;
                var bc = dot00 * dot11 - dot01 * dot01;
                var inv = bc === 0 ? 0 : 1 / bc;
                var u = (dot11 * dot02 - dot01 * dot12) * inv;
                var v = (dot00 * dot12 - dot01 * dot02) * inv;
                return u >= 0 && v >= 0 && u + v < 1;
              },
              isCounterClockwise: function(z) {
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                var d = (v2.vx - v1.vx) * (v3.vy - v1.vy) - (v2.vy - v1.vy) * (v3.vx - v1.vx);
                return z <= 0 ? d >= 0 : d < 0;
              },
              load: function(F32, U32, offset, textureUnit, tintEffect) {
                offset = this.vertex1.load(F32, U32, offset, textureUnit, tintEffect);
                offset = this.vertex2.load(F32, U32, offset, textureUnit, tintEffect);
                offset = this.vertex3.load(F32, U32, offset, textureUnit, tintEffect);
                return offset;
              },
              transformCoordinatesLocal: function(transformMatrix, width, height, cameraZ) {
                this.vertex1.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
                this.vertex2.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
                this.vertex3.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
                return this;
              },
              updateBounds: function() {
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                var bounds = this.bounds;
                bounds.x = Math.min(v1.vx, v2.vx, v3.vx);
                bounds.y = Math.min(v1.vy, v2.vy, v3.vy);
                bounds.width = Math.max(v1.vx, v2.vx, v3.vx) - bounds.x;
                bounds.height = Math.max(v1.vy, v2.vy, v3.vy) - bounds.y;
                return this;
              },
              isInView: function(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels) {
                this.update(alpha, a, b, c, d, e, f, roundPixels);
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                if (v1.ta <= 0 && v2.ta <= 0 && v3.ta <= 0) {
                  return false;
                }
                if (hideCCW && !this.isCounterClockwise(z)) {
                  return false;
                }
                var bounds = this.bounds;
                bounds.x = Math.min(v1.tx, v2.tx, v3.tx);
                bounds.y = Math.min(v1.ty, v2.ty, v3.ty);
                bounds.width = Math.max(v1.tx, v2.tx, v3.tx) - bounds.x;
                bounds.height = Math.max(v1.ty, v2.ty, v3.ty) - bounds.y;
                var cr = camera.x + camera.width;
                var cb = camera.y + camera.height;
                if (bounds.width <= 0 || bounds.height <= 0 || camera.width <= 0 || camera.height <= 0) {
                  return false;
                }
                return !(bounds.right < camera.x || bounds.bottom < camera.y || bounds.x > cr || bounds.y > cb);
              },
              scrollUV: function(x, y) {
                this.vertex1.scrollUV(x, y);
                this.vertex2.scrollUV(x, y);
                this.vertex3.scrollUV(x, y);
                return this;
              },
              scaleUV: function(x, y) {
                this.vertex1.scaleUV(x, y);
                this.vertex2.scaleUV(x, y);
                this.vertex3.scaleUV(x, y);
                return this;
              },
              setColor: function(color) {
                this.vertex1.color = color;
                this.vertex2.color = color;
                this.vertex3.color = color;
                return this;
              },
              update: function(alpha, a, b, c, d, e, f, roundPixels) {
                this.vertex1.update(a, b, c, d, e, f, roundPixels, alpha);
                this.vertex2.update(a, b, c, d, e, f, roundPixels, alpha);
                this.vertex3.update(a, b, c, d, e, f, roundPixels, alpha);
                return this;
              },
              translate: function(x, y) {
                if (y === void 0) {
                  y = 0;
                }
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                v1.x += x;
                v1.y += y;
                v2.x += x;
                v2.y += y;
                v3.x += x;
                v3.y += y;
                return this;
              },
              x: {
                get: function() {
                  return this.getInCenter().x;
                },
                set: function(value) {
                  var current = this.getInCenter();
                  this.translate(value - current.x, 0);
                }
              },
              y: {
                get: function() {
                  return this.getInCenter().y;
                },
                set: function(value) {
                  var current = this.getInCenter();
                  this.translate(0, value - current.y);
                }
              },
              alpha: {
                get: function() {
                  var v1 = this.vertex1;
                  var v2 = this.vertex2;
                  var v3 = this.vertex3;
                  return (v1.alpha + v2.alpha + v3.alpha) / 3;
                },
                set: function(value) {
                  this.vertex1.alpha = value;
                  this.vertex2.alpha = value;
                  this.vertex3.alpha = value;
                }
              },
              depth: {
                get: function() {
                  var v1 = this.vertex1;
                  var v2 = this.vertex2;
                  var v3 = this.vertex3;
                  return (v1.vz + v2.vz + v3.vz) / 3;
                }
              },
              destroy: function() {
                this.vertex1 = null;
                this.vertex2 = null;
                this.vertex3 = null;
              }
            });
            module2.exports = Face;
          },
          99425: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Face = __webpack_require__2(18693);
            var GetFastValue = __webpack_require__2(72632);
            var Matrix4 = __webpack_require__2(16650);
            var Vector3 = __webpack_require__2(70015);
            var Vertex = __webpack_require__2(85769);
            var tempPosition = new Vector3();
            var tempRotation = new Vector3();
            var tempMatrix = new Matrix4();
            var GenerateGridVerts = function(config2) {
              var mesh = GetFastValue(config2, "mesh");
              var texture = GetFastValue(config2, "texture", null);
              var frame = GetFastValue(config2, "frame");
              var width = GetFastValue(config2, "width", 1);
              var height = GetFastValue(config2, "height", width);
              var widthSegments = GetFastValue(config2, "widthSegments", 1);
              var heightSegments = GetFastValue(config2, "heightSegments", widthSegments);
              var posX = GetFastValue(config2, "x", 0);
              var posY = GetFastValue(config2, "y", 0);
              var posZ = GetFastValue(config2, "z", 0);
              var rotateX = GetFastValue(config2, "rotateX", 0);
              var rotateY = GetFastValue(config2, "rotateY", 0);
              var rotateZ = GetFastValue(config2, "rotateZ", 0);
              var zIsUp = GetFastValue(config2, "zIsUp", true);
              var isOrtho = GetFastValue(config2, "isOrtho", mesh ? mesh.dirtyCache[11] : false);
              var colors = GetFastValue(config2, "colors", [16777215]);
              var alphas = GetFastValue(config2, "alphas", [1]);
              var tile = GetFastValue(config2, "tile", false);
              var flipY = GetFastValue(config2, "flipY", false);
              var widthSet = GetFastValue(config2, "width", null);
              var result = {
                faces: [],
                verts: []
              };
              tempPosition.set(posX, posY, posZ);
              tempRotation.set(rotateX, rotateY, rotateZ);
              tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
              var textureFrame;
              if (!texture && mesh) {
                texture = mesh.texture;
                if (!frame) {
                  textureFrame = mesh.frame;
                }
              } else if (mesh && typeof texture === "string") {
                texture = mesh.scene.sys.textures.get(texture);
              } else if (!texture) {
                return result;
              }
              if (!textureFrame) {
                textureFrame = texture.get(frame);
              }
              if (!widthSet && isOrtho && texture && mesh) {
                width = textureFrame.width / mesh.height;
                height = textureFrame.height / mesh.height;
              }
              var halfWidth = width / 2;
              var halfHeight = height / 2;
              var gridX = Math.floor(widthSegments);
              var gridY = Math.floor(heightSegments);
              var gridX1 = gridX + 1;
              var gridY1 = gridY + 1;
              var segmentWidth = width / gridX;
              var segmentHeight = height / gridY;
              var uvs = [];
              var vertices = [];
              var ix;
              var iy;
              var frameU0 = 0;
              var frameU1 = 1;
              var frameV0 = 0;
              var frameV1 = 1;
              if (textureFrame) {
                frameU0 = textureFrame.u0;
                frameU1 = textureFrame.u1;
                if (!flipY) {
                  frameV0 = textureFrame.v0;
                  frameV1 = textureFrame.v1;
                } else {
                  frameV0 = textureFrame.v1;
                  frameV1 = textureFrame.v0;
                }
              }
              var frameU = frameU1 - frameU0;
              var frameV = frameV1 - frameV0;
              for (iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - halfHeight;
                for (ix = 0; ix < gridX1; ix++) {
                  var x = ix * segmentWidth - halfWidth;
                  vertices.push(x, -y);
                  var tu = frameU0 + frameU * (ix / gridX);
                  var tv = frameV0 + frameV * (iy / gridY);
                  uvs.push(tu, tv);
                }
              }
              if (!Array.isArray(colors)) {
                colors = [colors];
              }
              if (!Array.isArray(alphas)) {
                alphas = [alphas];
              }
              var alphaIndex = 0;
              var colorIndex = 0;
              for (iy = 0; iy < gridY; iy++) {
                for (ix = 0; ix < gridX; ix++) {
                  var a = (ix + gridX1 * iy) * 2;
                  var b = (ix + gridX1 * (iy + 1)) * 2;
                  var c = (ix + 1 + gridX1 * (iy + 1)) * 2;
                  var d = (ix + 1 + gridX1 * iy) * 2;
                  var color = colors[colorIndex];
                  var alpha = alphas[alphaIndex];
                  var vert1 = new Vertex(vertices[a], vertices[a + 1], 0, uvs[a], uvs[a + 1], color, alpha).transformMat4(tempMatrix);
                  var vert2 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
                  var vert3 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
                  var vert4 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
                  var vert5 = new Vertex(vertices[c], vertices[c + 1], 0, uvs[c], uvs[c + 1], color, alpha).transformMat4(tempMatrix);
                  var vert6 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
                  if (tile) {
                    vert1.setUVs(frameU0, frameV1);
                    vert2.setUVs(frameU0, frameV0);
                    vert3.setUVs(frameU1, frameV1);
                    vert4.setUVs(frameU0, frameV0);
                    vert5.setUVs(frameU1, frameV0);
                    vert6.setUVs(frameU1, frameV1);
                  }
                  colorIndex++;
                  if (colorIndex === colors.length) {
                    colorIndex = 0;
                  }
                  alphaIndex++;
                  if (alphaIndex === alphas.length) {
                    alphaIndex = 0;
                  }
                  result.verts.push(vert1, vert2, vert3, vert4, vert5, vert6);
                  result.faces.push(new Face(vert1, vert2, vert3), new Face(vert4, vert5, vert6));
                }
              }
              if (mesh) {
                mesh.faces = mesh.faces.concat(result.faces);
                mesh.vertices = mesh.vertices.concat(result.verts);
              }
              return result;
            };
            module2.exports = GenerateGridVerts;
          },
          53267: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Face = __webpack_require__2(18693);
            var Matrix4 = __webpack_require__2(16650);
            var Vector3 = __webpack_require__2(70015);
            var Vertex = __webpack_require__2(85769);
            var tempPosition = new Vector3();
            var tempRotation = new Vector3();
            var tempMatrix = new Matrix4();
            var GenerateObjVerts = function(data, mesh, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
              if (scale === void 0) {
                scale = 1;
              }
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (z === void 0) {
                z = 0;
              }
              if (rotateX === void 0) {
                rotateX = 0;
              }
              if (rotateY === void 0) {
                rotateY = 0;
              }
              if (rotateZ === void 0) {
                rotateZ = 0;
              }
              if (zIsUp === void 0) {
                zIsUp = true;
              }
              var result = {
                faces: [],
                verts: []
              };
              var materials = data.materials;
              tempPosition.set(x, y, z);
              tempRotation.set(rotateX, rotateY, rotateZ);
              tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
              for (var m = 0; m < data.models.length; m++) {
                var model = data.models[m];
                var vertices = model.vertices;
                var textureCoords = model.textureCoords;
                var faces = model.faces;
                for (var i = 0; i < faces.length; i++) {
                  var face = faces[i];
                  var v1 = face.vertices[0];
                  var v2 = face.vertices[1];
                  var v3 = face.vertices[2];
                  var m1 = vertices[v1.vertexIndex];
                  var m2 = vertices[v2.vertexIndex];
                  var m3 = vertices[v3.vertexIndex];
                  var t1 = v1.textureCoordsIndex;
                  var t2 = v2.textureCoordsIndex;
                  var t3 = v3.textureCoordsIndex;
                  var uv1 = t1 === -1 ? {u: 0, v: 1} : textureCoords[t1];
                  var uv2 = t2 === -1 ? {u: 0, v: 0} : textureCoords[t2];
                  var uv3 = t3 === -1 ? {u: 1, v: 1} : textureCoords[t3];
                  var color = 16777215;
                  if (face.material !== "" && materials[face.material]) {
                    color = materials[face.material];
                  }
                  var vert1 = new Vertex(m1.x * scale, m1.y * scale, m1.z * scale, uv1.u, uv1.v, color).transformMat4(tempMatrix);
                  var vert2 = new Vertex(m2.x * scale, m2.y * scale, m2.z * scale, uv2.u, uv2.v, color).transformMat4(tempMatrix);
                  var vert3 = new Vertex(m3.x * scale, m3.y * scale, m3.z * scale, uv3.u, uv3.v, color).transformMat4(tempMatrix);
                  result.verts.push(vert1, vert2, vert3);
                  result.faces.push(new Face(vert1, vert2, vert3));
                }
              }
              if (mesh) {
                mesh.faces = mesh.faces.concat(result.faces);
                mesh.vertices = mesh.vertices.concat(result.verts);
              }
              return result;
            };
            module2.exports = GenerateObjVerts;
          },
          67623: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Face = __webpack_require__2(18693);
            var Vertex = __webpack_require__2(85769);
            var GenerateVerts = function(vertices, uvs, indicies, containsZ, normals, colors, alphas, flipUV) {
              if (containsZ === void 0) {
                containsZ = false;
              }
              if (colors === void 0) {
                colors = 16777215;
              }
              if (alphas === void 0) {
                alphas = 1;
              }
              if (flipUV === void 0) {
                flipUV = false;
              }
              if (vertices.length !== uvs.length && !containsZ) {
                console.warn("GenerateVerts: vertices and uvs count not equal");
                return;
              }
              var result = {
                faces: [],
                vertices: []
              };
              var i;
              var x;
              var y;
              var z;
              var u;
              var v;
              var color;
              var alpha;
              var normalX;
              var normalY;
              var normalZ;
              var iInc = containsZ ? 3 : 2;
              var isColorArray = Array.isArray(colors);
              var isAlphaArray = Array.isArray(alphas);
              if (Array.isArray(indicies) && indicies.length > 0) {
                for (i = 0; i < indicies.length; i++) {
                  var index1 = indicies[i];
                  var index2 = indicies[i] * 2;
                  var index3 = indicies[i] * iInc;
                  x = vertices[index3];
                  y = vertices[index3 + 1];
                  z = containsZ ? vertices[index3 + 2] : 0;
                  u = uvs[index2];
                  v = uvs[index2 + 1];
                  if (flipUV) {
                    v = 1 - v;
                  }
                  color = isColorArray ? colors[index1] : colors;
                  alpha = isAlphaArray ? alphas[index1] : alphas;
                  normalX = 0;
                  normalY = 0;
                  normalZ = 0;
                  if (normals) {
                    normalX = normals[index3];
                    normalY = normals[index3 + 1];
                    normalZ = containsZ ? normals[index3 + 2] : 0;
                  }
                  result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
                }
              } else {
                var uvIndex = 0;
                var colorIndex = 0;
                for (i = 0; i < vertices.length; i += iInc) {
                  x = vertices[i];
                  y = vertices[i + 1];
                  z = containsZ ? vertices[i + 2] : 0;
                  u = uvs[uvIndex];
                  v = uvs[uvIndex + 1];
                  color = isColorArray ? colors[colorIndex] : colors;
                  alpha = isAlphaArray ? alphas[colorIndex] : alphas;
                  normalX = 0;
                  normalY = 0;
                  normalZ = 0;
                  if (normals) {
                    normalX = normals[i];
                    normalY = normals[i + 1];
                    normalZ = containsZ ? normals[i + 2] : 0;
                  }
                  result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
                  uvIndex += 2;
                  colorIndex++;
                }
              }
              for (i = 0; i < result.vertices.length; i += 3) {
                var vert1 = result.vertices[i];
                var vert2 = result.vertices[i + 1];
                var vert3 = result.vertices[i + 2];
                result.faces.push(new Face(vert1, vert2, vert3));
              }
              return result;
            };
            module2.exports = GenerateVerts;
          },
          27291: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var flip = true;
            var defaultModelName = "untitled";
            var currentGroup = "";
            var currentMaterial = "";
            function stripComments(line) {
              var idx = line.indexOf("#");
              return idx > -1 ? line.substring(0, idx) : line;
            }
            function currentModel(result) {
              if (result.models.length === 0) {
                result.models.push({
                  faces: [],
                  name: defaultModelName,
                  textureCoords: [],
                  vertexNormals: [],
                  vertices: []
                });
              }
              currentGroup = "";
              return result.models[result.models.length - 1];
            }
            function parseObject(lineItems, result) {
              var modelName = lineItems.length >= 2 ? lineItems[1] : defaultModelName;
              result.models.push({
                faces: [],
                name: modelName,
                textureCoords: [],
                vertexNormals: [],
                vertices: []
              });
              currentGroup = "";
            }
            function parseGroup(lineItems) {
              if (lineItems.length === 2) {
                currentGroup = lineItems[1];
              }
            }
            function parseVertexCoords(lineItems, result) {
              var len = lineItems.length;
              var x = len >= 2 ? parseFloat(lineItems[1]) : 0;
              var y = len >= 3 ? parseFloat(lineItems[2]) : 0;
              var z = len >= 4 ? parseFloat(lineItems[3]) : 0;
              currentModel(result).vertices.push({x, y, z});
            }
            function parseTextureCoords(lineItems, result) {
              var len = lineItems.length;
              var u = len >= 2 ? parseFloat(lineItems[1]) : 0;
              var v = len >= 3 ? parseFloat(lineItems[2]) : 0;
              var w = len >= 4 ? parseFloat(lineItems[3]) : 0;
              if (isNaN(u)) {
                u = 0;
              }
              if (isNaN(v)) {
                v = 0;
              }
              if (isNaN(w)) {
                w = 0;
              }
              if (flip) {
                v = 1 - v;
              }
              currentModel(result).textureCoords.push({u, v, w});
            }
            function parseVertexNormal(lineItems, result) {
              var len = lineItems.length;
              var x = len >= 2 ? parseFloat(lineItems[1]) : 0;
              var y = len >= 3 ? parseFloat(lineItems[2]) : 0;
              var z = len >= 4 ? parseFloat(lineItems[3]) : 0;
              currentModel(result).vertexNormals.push({x, y, z});
            }
            function parsePolygon(lineItems, result) {
              var totalVertices = lineItems.length - 1;
              if (totalVertices < 3) {
                return;
              }
              var face = {
                group: currentGroup,
                material: currentMaterial,
                vertices: []
              };
              for (var i = 0; i < totalVertices; i++) {
                var vertexString = lineItems[i + 1];
                var vertexValues = vertexString.split("/");
                var vvLen = vertexValues.length;
                if (vvLen < 1 || vvLen > 3) {
                  continue;
                }
                var vertexIndex = 0;
                var textureCoordsIndex = 0;
                var vertexNormalIndex = 0;
                vertexIndex = parseInt(vertexValues[0], 10);
                if (vvLen > 1 && vertexValues[1] !== "") {
                  textureCoordsIndex = parseInt(vertexValues[1], 10);
                }
                if (vvLen > 2) {
                  vertexNormalIndex = parseInt(vertexValues[2], 10);
                }
                if (vertexIndex !== 0) {
                  if (vertexIndex < 0) {
                    vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex;
                  }
                  textureCoordsIndex -= 1;
                  vertexIndex -= 1;
                  vertexNormalIndex -= 1;
                  face.vertices.push({
                    textureCoordsIndex,
                    vertexIndex,
                    vertexNormalIndex
                  });
                }
              }
              currentModel(result).faces.push(face);
            }
            function parseMtlLib(lineItems, result) {
              if (lineItems.length >= 2) {
                result.materialLibraries.push(lineItems[1]);
              }
            }
            function parseUseMtl(lineItems) {
              if (lineItems.length >= 2) {
                currentMaterial = lineItems[1];
              }
            }
            var ParseObj = function(data, flipUV) {
              if (flipUV === void 0) {
                flipUV = true;
              }
              flip = flipUV;
              var result = {
                materials: {},
                materialLibraries: [],
                models: []
              };
              currentGroup = "";
              currentMaterial = "";
              var lines = data.split("\n");
              for (var i = 0; i < lines.length; i++) {
                var line = stripComments(lines[i]);
                var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
                switch (lineItems[0].toLowerCase()) {
                  case "o":
                    parseObject(lineItems, result);
                    break;
                  case "g":
                    parseGroup(lineItems);
                    break;
                  case "v":
                    parseVertexCoords(lineItems, result);
                    break;
                  case "vt":
                    parseTextureCoords(lineItems, result);
                    break;
                  case "vn":
                    parseVertexNormal(lineItems, result);
                    break;
                  case "f":
                    parsePolygon(lineItems, result);
                    break;
                  case "mtllib":
                    parseMtlLib(lineItems, result);
                    break;
                  case "usemtl":
                    parseUseMtl(lineItems);
                    break;
                }
              }
              return result;
            };
            module2.exports = ParseObj;
          },
          76799: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetColor = __webpack_require__2(22946);
            var ParseObjMaterial = function(mtl) {
              var output = {};
              var lines = mtl.split("\n");
              var currentMaterial = "";
              for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line.indexOf("#") === 0 || line === "") {
                  continue;
                }
                var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
                switch (lineItems[0].toLowerCase()) {
                  case "newmtl": {
                    currentMaterial = lineItems[1];
                    break;
                  }
                  case "kd": {
                    var r = Math.floor(lineItems[1] * 255);
                    var g = lineItems.length >= 2 ? Math.floor(lineItems[2] * 255) : r;
                    var b = lineItems.length >= 3 ? Math.floor(lineItems[3] * 255) : r;
                    output[currentMaterial] = GetColor(r, g, b);
                    break;
                  }
                }
              }
              return output;
            };
            module2.exports = ParseObjMaterial;
          },
          15313: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateFace = function(face, angle, cx, cy) {
              var x;
              var y;
              if (cx === void 0 && cy === void 0) {
                var inCenter = face.getInCenter();
                x = inCenter.x;
                y = inCenter.y;
              }
              var c = Math.cos(angle);
              var s = Math.sin(angle);
              var v1 = face.vertex1;
              var v2 = face.vertex2;
              var v3 = face.vertex3;
              var tx = v1.x - x;
              var ty = v1.y - y;
              v1.set(tx * c - ty * s + x, tx * s + ty * c + y);
              tx = v2.x - x;
              ty = v2.y - y;
              v2.set(tx * c - ty * s + x, tx * s + ty * c + y);
              tx = v3.x - x;
              ty = v3.y - y;
              v3.set(tx * c - ty * s + x, tx * s + ty * c + y);
            };
            module2.exports = RotateFace;
          },
          85769: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Utils = __webpack_require__2(75512);
            var Vector3 = __webpack_require__2(70015);
            var Vertex = new Class({
              Extends: Vector3,
              initialize: function Vertex2(x, y, z, u, v, color, alpha, nx, ny, nz) {
                if (color === void 0) {
                  color = 16777215;
                }
                if (alpha === void 0) {
                  alpha = 1;
                }
                if (nx === void 0) {
                  nx = 0;
                }
                if (ny === void 0) {
                  ny = 0;
                }
                if (nz === void 0) {
                  nz = 0;
                }
                Vector3.call(this, x, y, z);
                this.vx = 0;
                this.vy = 0;
                this.vz = 0;
                this.nx = nx;
                this.ny = ny;
                this.nz = nz;
                this.u = u;
                this.v = v;
                this.color = color;
                this.alpha = alpha;
                this.tx = 0;
                this.ty = 0;
                this.ta = 0;
                this.tu = u;
                this.tv = v;
              },
              setUVs: function(u, v) {
                this.u = u;
                this.v = v;
                this.tu = u;
                this.tv = v;
                return this;
              },
              scrollUV: function(x, y) {
                this.tu += x;
                this.tv += y;
                return this;
              },
              scaleUV: function(x, y) {
                this.tu = this.u * x;
                this.tv = this.v * y;
                return this;
              },
              transformCoordinatesLocal: function(transformMatrix, width, height, cameraZ) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var m = transformMatrix.val;
                var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
                var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
                var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
                var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
                this.vx = tx / tw * width;
                this.vy = -(ty / tw) * height;
                if (cameraZ <= 0) {
                  this.vz = tz / tw;
                } else {
                  this.vz = -(tz / tw);
                }
              },
              resize: function(x, y, width, height, originX, originY) {
                this.x = x;
                this.y = y;
                this.vx = this.x * width;
                this.vy = -this.y * height;
                this.vz = 0;
                if (originX < 0.5) {
                  this.vx += width * (0.5 - originX);
                } else if (originX > 0.5) {
                  this.vx -= width * (originX - 0.5);
                }
                if (originY < 0.5) {
                  this.vy += height * (0.5 - originY);
                } else if (originY > 0.5) {
                  this.vy -= height * (originY - 0.5);
                }
                return this;
              },
              update: function(a, b, c, d, e, f, roundPixels, alpha) {
                var tx = this.vx * a + this.vy * c + e;
                var ty = this.vx * b + this.vy * d + f;
                if (roundPixels) {
                  tx = Math.round(tx);
                  ty = Math.round(ty);
                }
                this.tx = tx;
                this.ty = ty;
                this.ta = this.alpha * alpha;
                return this;
              },
              load: function(F32, U32, offset, textureUnit, tintEffect) {
                F32[++offset] = this.tx;
                F32[++offset] = this.ty;
                F32[++offset] = this.tu;
                F32[++offset] = this.tv;
                F32[++offset] = textureUnit;
                F32[++offset] = tintEffect;
                U32[++offset] = Utils.getTintAppendFloatAlpha(this.color, this.ta);
                return offset;
              }
            });
            module2.exports = Vertex;
          },
          14293: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Mesh = {
              Face: __webpack_require__2(18693),
              GenerateGridVerts: __webpack_require__2(99425),
              GenerateObjVerts: __webpack_require__2(53267),
              GenerateVerts: __webpack_require__2(67623),
              ParseObj: __webpack_require__2(27291),
              ParseObjMaterial: __webpack_require__2(76799),
              RotateFace: __webpack_require__2(15313),
              Vertex: __webpack_require__2(85769)
            };
            module2.exports = Mesh;
          },
          77601: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Ceil = function(point) {
              return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
            };
            module2.exports = Ceil;
          },
          38933: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Clone = function(source) {
              return new Point(source.x, source.y);
            };
            module2.exports = Clone;
          },
          47103: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CopyFrom = function(source, dest) {
              return dest.setTo(source.x, source.y);
            };
            module2.exports = CopyFrom;
          },
          13625: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Equals = function(point, toCompare) {
              return point.x === toCompare.x && point.y === toCompare.y;
            };
            module2.exports = Equals;
          },
          12536: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Floor = function(point) {
              return point.setTo(Math.floor(point.x), Math.floor(point.y));
            };
            module2.exports = Floor;
          },
          54205: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var GetCentroid = function(points, out) {
              if (out === void 0) {
                out = new Point();
              }
              if (!Array.isArray(points)) {
                throw new Error("GetCentroid points argument must be an array");
              }
              var len = points.length;
              if (len < 1) {
                throw new Error("GetCentroid points array must not be empty");
              } else if (len === 1) {
                out.x = points[0].x;
                out.y = points[0].y;
              } else {
                for (var i = 0; i < len; i++) {
                  out.x += points[i].x;
                  out.y += points[i].y;
                }
                out.x /= len;
                out.y /= len;
              }
              return out;
            };
            module2.exports = GetCentroid;
          },
          50083: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetMagnitude = function(point) {
              return Math.sqrt(point.x * point.x + point.y * point.y);
            };
            module2.exports = GetMagnitude;
          },
          82712: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetMagnitudeSq = function(point) {
              return point.x * point.x + point.y * point.y;
            };
            module2.exports = GetMagnitudeSq;
          },
          20052: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var GetRectangleFromPoints = function(points, out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              var xMax = Number.NEGATIVE_INFINITY;
              var xMin = Number.POSITIVE_INFINITY;
              var yMax = Number.NEGATIVE_INFINITY;
              var yMin = Number.POSITIVE_INFINITY;
              for (var i = 0; i < points.length; i++) {
                var point = points[i];
                if (point.x > xMax) {
                  xMax = point.x;
                }
                if (point.x < xMin) {
                  xMin = point.x;
                }
                if (point.y > yMax) {
                  yMax = point.y;
                }
                if (point.y < yMin) {
                  yMin = point.y;
                }
              }
              out.x = xMin;
              out.y = yMin;
              out.width = xMax - xMin;
              out.height = yMax - yMin;
              return out;
            };
            module2.exports = GetRectangleFromPoints;
          },
          77154: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Interpolate = function(pointA, pointB, t, out) {
              if (t === void 0) {
                t = 0;
              }
              if (out === void 0) {
                out = new Point();
              }
              out.x = pointA.x + (pointB.x - pointA.x) * t;
              out.y = pointA.y + (pointB.y - pointA.y) * t;
              return out;
            };
            module2.exports = Interpolate;
          },
          42397: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Invert = function(point) {
              return point.setTo(point.y, point.x);
            };
            module2.exports = Invert;
          },
          59464: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Negative = function(point, out) {
              if (out === void 0) {
                out = new Point();
              }
              return out.setTo(-point.x, -point.y);
            };
            module2.exports = Negative;
          },
          79967: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GEOM_CONST = __webpack_require__2(52394);
            var Point = new Class({
              initialize: function Point2(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = x;
                }
                this.type = GEOM_CONST.POINT;
                this.x = x;
                this.y = y;
              },
              setTo: function(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = x;
                }
                this.x = x;
                this.y = y;
                return this;
              }
            });
            module2.exports = Point;
          },
          53581: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var GetMagnitudeSq = __webpack_require__2(82712);
            var Project = function(pointA, pointB, out) {
              if (out === void 0) {
                out = new Point();
              }
              var dot = pointA.x * pointB.x + pointA.y * pointB.y;
              var amt = dot / GetMagnitudeSq(pointB);
              if (amt !== 0) {
                out.x = amt * pointB.x;
                out.y = amt * pointB.y;
              }
              return out;
            };
            module2.exports = Project;
          },
          50817: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var ProjectUnit = function(pointA, pointB, out) {
              if (out === void 0) {
                out = new Point();
              }
              var amt = pointA.x * pointB.x + pointA.y * pointB.y;
              if (amt !== 0) {
                out.x = amt * pointB.x;
                out.y = amt * pointB.y;
              }
              return out;
            };
            module2.exports = ProjectUnit;
          },
          40525: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetMagnitude = __webpack_require__2(50083);
            var SetMagnitude = function(point, magnitude) {
              if (point.x !== 0 || point.y !== 0) {
                var m = GetMagnitude(point);
                point.x /= m;
                point.y /= m;
              }
              point.x *= magnitude;
              point.y *= magnitude;
              return point;
            };
            module2.exports = SetMagnitude;
          },
          63472: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            Point.Ceil = __webpack_require__2(77601);
            Point.Clone = __webpack_require__2(38933);
            Point.CopyFrom = __webpack_require__2(47103);
            Point.Equals = __webpack_require__2(13625);
            Point.Floor = __webpack_require__2(12536);
            Point.GetCentroid = __webpack_require__2(54205);
            Point.GetMagnitude = __webpack_require__2(50083);
            Point.GetMagnitudeSq = __webpack_require__2(82712);
            Point.GetRectangleFromPoints = __webpack_require__2(20052);
            Point.Interpolate = __webpack_require__2(77154);
            Point.Invert = __webpack_require__2(42397);
            Point.Negative = __webpack_require__2(59464);
            Point.Project = __webpack_require__2(53581);
            Point.ProjectUnit = __webpack_require__2(50817);
            Point.SetMagnitude = __webpack_require__2(40525);
            module2.exports = Point;
          },
          19631: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Polygon = __webpack_require__2(8580);
            var Clone = function(polygon) {
              return new Polygon(polygon.points);
            };
            module2.exports = Clone;
          },
          45604: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = function(polygon, x, y) {
              var inside = false;
              for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i) {
                var ix = polygon.points[i].x;
                var iy = polygon.points[i].y;
                var jx = polygon.points[j].x;
                var jy = polygon.points[j].y;
                if ((iy <= y && y < jy || jy <= y && y < iy) && x < (jx - ix) * (y - iy) / (jy - iy) + ix) {
                  inside = !inside;
                }
              }
              return inside;
            };
            module2.exports = Contains;
          },
          87289: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = __webpack_require__2(45604);
            var ContainsPoint = function(polygon, point) {
              return Contains(polygon, point.x, point.y);
            };
            module2.exports = ContainsPoint;
          },
          11117: (module2) => {
            "use strict";
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            function earcut(data, holeIndices, dim) {
              dim = dim || 2;
              var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
              if (!outerNode || outerNode.next === outerNode.prev)
                return triangles;
              var minX, minY, maxX, maxY, x, y, invSize;
              if (hasHoles)
                outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
              if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                  x = data[i];
                  y = data[i + 1];
                  if (x < minX)
                    minX = x;
                  if (y < minY)
                    minY = y;
                  if (x > maxX)
                    maxX = x;
                  if (y > maxY)
                    maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 32767 / invSize : 0;
              }
              earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
              return triangles;
            }
            function linkedList(data, start, end, dim, clockwise) {
              var i, last;
              if (clockwise === signedArea(data, start, end, dim) > 0) {
                for (i = start; i < end; i += dim)
                  last = insertNode(i, data[i], data[i + 1], last);
              } else {
                for (i = end - dim; i >= start; i -= dim)
                  last = insertNode(i, data[i], data[i + 1], last);
              }
              if (last && equals(last, last.next)) {
                removeNode(last);
                last = last.next;
              }
              return last;
            }
            function filterPoints(start, end) {
              if (!start)
                return start;
              if (!end)
                end = start;
              var p = start, again;
              do {
                again = false;
                if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                  removeNode(p);
                  p = end = p.prev;
                  if (p === p.next)
                    break;
                  again = true;
                } else {
                  p = p.next;
                }
              } while (again || p !== end);
              return end;
            }
            function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
              if (!ear)
                return;
              if (!pass && invSize)
                indexCurve(ear, minX, minY, invSize);
              var stop = ear, prev, next;
              while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;
                if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                  triangles.push(prev.i / dim | 0);
                  triangles.push(ear.i / dim | 0);
                  triangles.push(next.i / dim | 0);
                  removeNode(ear);
                  ear = next.next;
                  stop = next.next;
                  continue;
                }
                ear = next;
                if (ear === stop) {
                  if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                  } else if (pass === 1) {
                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                  } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                  }
                  break;
                }
              }
            }
            function isEar(ear) {
              var a = ear.prev, b = ear, c = ear.next;
              if (area(a, b, c) >= 0)
                return false;
              var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
              var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
              var p = c.next;
              while (p !== a) {
                if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                  return false;
                p = p.next;
              }
              return true;
            }
            function isEarHashed(ear, minX, minY, invSize) {
              var a = ear.prev, b = ear, c = ear.next;
              if (area(a, b, c) >= 0)
                return false;
              var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
              var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
              var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
              var p = ear.prevZ, n = ear.nextZ;
              while (p && p.z >= minZ && n && n.z <= maxZ) {
                if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                  return false;
                p = p.prevZ;
                if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
                  return false;
                n = n.nextZ;
              }
              while (p && p.z >= minZ) {
                if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                  return false;
                p = p.prevZ;
              }
              while (n && n.z <= maxZ) {
                if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
                  return false;
                n = n.nextZ;
              }
              return true;
            }
            function cureLocalIntersections(start, triangles, dim) {
              var p = start;
              do {
                var a = p.prev, b = p.next.next;
                if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                  triangles.push(a.i / dim | 0);
                  triangles.push(p.i / dim | 0);
                  triangles.push(b.i / dim | 0);
                  removeNode(p);
                  removeNode(p.next);
                  p = start = b;
                }
                p = p.next;
              } while (p !== start);
              return filterPoints(p);
            }
            function splitEarcut(start, triangles, dim, minX, minY, invSize) {
              var a = start;
              do {
                var b = a.next.next;
                while (b !== a.prev) {
                  if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                    earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                    return;
                  }
                  b = b.next;
                }
                a = a.next;
              } while (a !== start);
            }
            function eliminateHoles(data, holeIndices, outerNode, dim) {
              var queue = [], i, len, start, end, list;
              for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                list = linkedList(data, start, end, dim, false);
                if (list === list.next)
                  list.steiner = true;
                queue.push(getLeftmost(list));
              }
              queue.sort(compareX);
              for (i = 0; i < queue.length; i++) {
                outerNode = eliminateHole(queue[i], outerNode);
              }
              return outerNode;
            }
            function compareX(a, b) {
              return a.x - b.x;
            }
            function eliminateHole(hole, outerNode) {
              var bridge = findHoleBridge(hole, outerNode);
              if (!bridge) {
                return outerNode;
              }
              var bridgeReverse = splitPolygon(bridge, hole);
              filterPoints(bridgeReverse, bridgeReverse.next);
              return filterPoints(bridge, bridge.next);
            }
            function findHoleBridge(hole, outerNode) {
              var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
              do {
                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                  var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                  if (x <= hx && x > qx) {
                    qx = x;
                    m = p.x < p.next.x ? p : p.next;
                    if (x === hx)
                      return m;
                  }
                }
                p = p.next;
              } while (p !== outerNode);
              if (!m)
                return null;
              var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
              p = m;
              do {
                if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                  tan = Math.abs(hy - p.y) / (hx - p.x);
                  if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                    m = p;
                    tanMin = tan;
                  }
                }
                p = p.next;
              } while (p !== stop);
              return m;
            }
            function sectorContainsSector(m, p) {
              return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
            }
            function indexCurve(start, minX, minY, invSize) {
              var p = start;
              do {
                if (p.z === 0)
                  p.z = zOrder(p.x, p.y, minX, minY, invSize);
                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
              } while (p !== start);
              p.prevZ.nextZ = null;
              p.prevZ = null;
              sortLinked(p);
            }
            function sortLinked(list) {
              var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
              do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;
                while (p) {
                  numMerges++;
                  q = p;
                  pSize = 0;
                  for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q)
                      break;
                  }
                  qSize = inSize;
                  while (pSize > 0 || qSize > 0 && q) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                      e = p;
                      p = p.nextZ;
                      pSize--;
                    } else {
                      e = q;
                      q = q.nextZ;
                      qSize--;
                    }
                    if (tail)
                      tail.nextZ = e;
                    else
                      list = e;
                    e.prevZ = tail;
                    tail = e;
                  }
                  p = q;
                }
                tail.nextZ = null;
                inSize *= 2;
              } while (numMerges > 1);
              return list;
            }
            function zOrder(x, y, minX, minY, invSize) {
              x = (x - minX) * invSize | 0;
              y = (y - minY) * invSize | 0;
              x = (x | x << 8) & 16711935;
              x = (x | x << 4) & 252645135;
              x = (x | x << 2) & 858993459;
              x = (x | x << 1) & 1431655765;
              y = (y | y << 8) & 16711935;
              y = (y | y << 4) & 252645135;
              y = (y | y << 2) & 858993459;
              y = (y | y << 1) & 1431655765;
              return x | y << 1;
            }
            function getLeftmost(start) {
              var p = start, leftmost = start;
              do {
                if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
                  leftmost = p;
                p = p.next;
              } while (p !== start);
              return leftmost;
            }
            function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
              return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
            }
            function isValidDiagonal(a, b) {
              return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
            }
            function area(p, q, r) {
              return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            }
            function equals(p1, p2) {
              return p1.x === p2.x && p1.y === p2.y;
            }
            function intersects(p1, q1, p2, q2) {
              var o1 = sign(area(p1, q1, p2));
              var o2 = sign(area(p1, q1, q2));
              var o3 = sign(area(p2, q2, p1));
              var o4 = sign(area(p2, q2, q1));
              if (o1 !== o2 && o3 !== o4)
                return true;
              if (o1 === 0 && onSegment(p1, p2, q1))
                return true;
              if (o2 === 0 && onSegment(p1, q2, q1))
                return true;
              if (o3 === 0 && onSegment(p2, p1, q2))
                return true;
              if (o4 === 0 && onSegment(p2, q1, q2))
                return true;
              return false;
            }
            function onSegment(p, q, r) {
              return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
            }
            function sign(num) {
              return num > 0 ? 1 : num < 0 ? -1 : 0;
            }
            function intersectsPolygon(a, b) {
              var p = a;
              do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
                  return true;
                p = p.next;
              } while (p !== a);
              return false;
            }
            function locallyInside(a, b) {
              return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
            }
            function middleInside(a, b) {
              var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
              do {
                if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
                  inside = !inside;
                p = p.next;
              } while (p !== a);
              return inside;
            }
            function splitPolygon(a, b) {
              var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
              a.next = b;
              b.prev = a;
              a2.next = an;
              an.prev = a2;
              b2.next = a2;
              a2.prev = b2;
              bp.next = b2;
              b2.prev = bp;
              return b2;
            }
            function insertNode(i, x, y, last) {
              var p = new Node(i, x, y);
              if (!last) {
                p.prev = p;
                p.next = p;
              } else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
              }
              return p;
            }
            function removeNode(p) {
              p.next.prev = p.prev;
              p.prev.next = p.next;
              if (p.prevZ)
                p.prevZ.nextZ = p.nextZ;
              if (p.nextZ)
                p.nextZ.prevZ = p.prevZ;
            }
            function Node(i, x, y) {
              this.i = i;
              this.x = x;
              this.y = y;
              this.prev = null;
              this.next = null;
              this.z = 0;
              this.prevZ = null;
              this.nextZ = null;
              this.steiner = false;
            }
            earcut.deviation = function(data, holeIndices, dim, triangles) {
              var hasHoles = holeIndices && holeIndices.length;
              var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
              var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
              if (hasHoles) {
                for (var i = 0, len = holeIndices.length; i < len; i++) {
                  var start = holeIndices[i] * dim;
                  var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                  polygonArea -= Math.abs(signedArea(data, start, end, dim));
                }
              }
              var trianglesArea = 0;
              for (i = 0; i < triangles.length; i += 3) {
                var a = triangles[i] * dim;
                var b = triangles[i + 1] * dim;
                var c = triangles[i + 2] * dim;
                trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
              }
              return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
            };
            function signedArea(data, start, end, dim) {
              var sum = 0;
              for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                j = i;
              }
              return sum;
            }
            earcut.flatten = function(data) {
              var dim = data[0][0].length, result = {vertices: [], holes: [], dimensions: dim}, holeIndex = 0;
              for (var i = 0; i < data.length; i++) {
                for (var j = 0; j < data[i].length; j++) {
                  for (var d = 0; d < dim; d++)
                    result.vertices.push(data[i][j][d]);
                }
                if (i > 0) {
                  holeIndex += data[i - 1].length;
                  result.holes.push(holeIndex);
                }
              }
              return result;
            };
            module2.exports = earcut;
          },
          14045: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var GetAABB = function(polygon, out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              var minX = Infinity;
              var minY = Infinity;
              var maxX = -minX;
              var maxY = -minY;
              var p;
              for (var i = 0; i < polygon.points.length; i++) {
                p = polygon.points[i];
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
              }
              out.x = minX;
              out.y = minY;
              out.width = maxX - minX;
              out.height = maxY - minY;
              return out;
            };
            module2.exports = GetAABB;
          },
          98286: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetNumberArray = function(polygon, output) {
              if (output === void 0) {
                output = [];
              }
              for (var i = 0; i < polygon.points.length; i++) {
                output.push(polygon.points[i].x);
                output.push(polygon.points[i].y);
              }
              return output;
            };
            module2.exports = GetNumberArray;
          },
          89294: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Length = __webpack_require__2(16028);
            var Line = __webpack_require__2(88829);
            var Perimeter = __webpack_require__2(5159);
            var GetPoints = function(polygon, quantity, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              var points = polygon.points;
              var perimeter = Perimeter(polygon);
              if (!quantity && stepRate > 0) {
                quantity = perimeter / stepRate;
              }
              for (var i = 0; i < quantity; i++) {
                var position = perimeter * (i / quantity);
                var accumulatedPerimeter = 0;
                for (var j = 0; j < points.length; j++) {
                  var pointA = points[j];
                  var pointB = points[(j + 1) % points.length];
                  var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
                  var length = Length(line);
                  if (position < accumulatedPerimeter || position > accumulatedPerimeter + length) {
                    accumulatedPerimeter += length;
                    continue;
                  }
                  var point = line.getPoint((position - accumulatedPerimeter) / length);
                  out.push(point);
                  break;
                }
              }
              return out;
            };
            module2.exports = GetPoints;
          },
          5159: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Length = __webpack_require__2(16028);
            var Line = __webpack_require__2(88829);
            var Perimeter = function(polygon) {
              var points = polygon.points;
              var perimeter = 0;
              for (var i = 0; i < points.length; i++) {
                var pointA = points[i];
                var pointB = points[(i + 1) % points.length];
                var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
                perimeter += Length(line);
              }
              return perimeter;
            };
            module2.exports = Perimeter;
          },
          8580: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Contains = __webpack_require__2(45604);
            var GetPoints = __webpack_require__2(89294);
            var GEOM_CONST = __webpack_require__2(52394);
            var Polygon = new Class({
              initialize: function Polygon2(points) {
                this.type = GEOM_CONST.POLYGON;
                this.area = 0;
                this.points = [];
                if (points) {
                  this.setTo(points);
                }
              },
              contains: function(x, y) {
                return Contains(this, x, y);
              },
              setTo: function(points) {
                this.area = 0;
                this.points = [];
                if (typeof points === "string") {
                  points = points.split(" ");
                }
                if (!Array.isArray(points)) {
                  return this;
                }
                var p;
                for (var i = 0; i < points.length; i++) {
                  p = {x: 0, y: 0};
                  if (typeof points[i] === "number" || typeof points[i] === "string") {
                    p.x = parseFloat(points[i]);
                    p.y = parseFloat(points[i + 1]);
                    i++;
                  } else if (Array.isArray(points[i])) {
                    p.x = points[i][0];
                    p.y = points[i][1];
                  } else {
                    p.x = points[i].x;
                    p.y = points[i].y;
                  }
                  this.points.push(p);
                }
                this.calculateArea();
                return this;
              },
              calculateArea: function() {
                if (this.points.length < 3) {
                  this.area = 0;
                  return this.area;
                }
                var sum = 0;
                var p1;
                var p2;
                for (var i = 0; i < this.points.length - 1; i++) {
                  p1 = this.points[i];
                  p2 = this.points[i + 1];
                  sum += (p2.x - p1.x) * (p1.y + p2.y);
                }
                p1 = this.points[0];
                p2 = this.points[this.points.length - 1];
                sum += (p1.x - p2.x) * (p2.y + p1.y);
                this.area = -sum * 0.5;
                return this.area;
              },
              getPoints: function(quantity, step, output) {
                return GetPoints(this, quantity, step, output);
              }
            });
            module2.exports = Polygon;
          },
          32244: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Reverse = function(polygon) {
              polygon.points.reverse();
              return polygon;
            };
            module2.exports = Reverse;
          },
          95874: (module2) => {
            function getSqDist(p1, p2) {
              var dx = p1.x - p2.x, dy = p1.y - p2.y;
              return dx * dx + dy * dy;
            }
            function getSqSegDist(p, p1, p2) {
              var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
              if (dx !== 0 || dy !== 0) {
                var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
                if (t > 1) {
                  x = p2.x;
                  y = p2.y;
                } else if (t > 0) {
                  x += dx * t;
                  y += dy * t;
                }
              }
              dx = p.x - x;
              dy = p.y - y;
              return dx * dx + dy * dy;
            }
            function simplifyRadialDist(points, sqTolerance) {
              var prevPoint = points[0], newPoints = [prevPoint], point;
              for (var i = 1, len = points.length; i < len; i++) {
                point = points[i];
                if (getSqDist(point, prevPoint) > sqTolerance) {
                  newPoints.push(point);
                  prevPoint = point;
                }
              }
              if (prevPoint !== point) {
                newPoints.push(point);
              }
              return newPoints;
            }
            function simplifyDPStep(points, first, last, sqTolerance, simplified) {
              var maxSqDist = sqTolerance, index;
              for (var i = first + 1; i < last; i++) {
                var sqDist = getSqSegDist(points[i], points[first], points[last]);
                if (sqDist > maxSqDist) {
                  index = i;
                  maxSqDist = sqDist;
                }
              }
              if (maxSqDist > sqTolerance) {
                if (index - first > 1) {
                  simplifyDPStep(points, first, index, sqTolerance, simplified);
                }
                simplified.push(points[index]);
                if (last - index > 1) {
                  simplifyDPStep(points, index, last, sqTolerance, simplified);
                }
              }
            }
            function simplifyDouglasPeucker(points, sqTolerance) {
              var last = points.length - 1;
              var simplified = [points[0]];
              simplifyDPStep(points, 0, last, sqTolerance, simplified);
              simplified.push(points[last]);
              return simplified;
            }
            var Simplify = function(polygon, tolerance, highestQuality) {
              if (tolerance === void 0) {
                tolerance = 1;
              }
              if (highestQuality === void 0) {
                highestQuality = false;
              }
              var points = polygon.points;
              if (points.length > 2) {
                var sqTolerance = tolerance * tolerance;
                if (!highestQuality) {
                  points = simplifyRadialDist(points, sqTolerance);
                }
                polygon.setTo(simplifyDouglasPeucker(points, sqTolerance));
              }
              return polygon;
            };
            module2.exports = Simplify;
          },
          18974: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var copy = function(out, a) {
              out[0] = a[0];
              out[1] = a[1];
              return out;
            };
            var Smooth = function(polygon) {
              var i;
              var points = [];
              var data = polygon.points;
              for (i = 0; i < data.length; i++) {
                points.push([data[i].x, data[i].y]);
              }
              var output = [];
              if (points.length > 0) {
                output.push(copy([0, 0], points[0]));
              }
              for (i = 0; i < points.length - 1; i++) {
                var p0 = points[i];
                var p1 = points[i + 1];
                var p0x = p0[0];
                var p0y = p0[1];
                var p1x = p1[0];
                var p1y = p1[1];
                output.push([0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y]);
                output.push([0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y]);
              }
              if (points.length > 1) {
                output.push(copy([0, 0], points[points.length - 1]));
              }
              return polygon.setTo(output);
            };
            module2.exports = Smooth;
          },
          23490: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Translate = function(polygon, x, y) {
              var points = polygon.points;
              for (var i = 0; i < points.length; i++) {
                points[i].x += x;
                points[i].y += y;
              }
              return polygon;
            };
            module2.exports = Translate;
          },
          44359: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Polygon = __webpack_require__2(8580);
            Polygon.Clone = __webpack_require__2(19631);
            Polygon.Contains = __webpack_require__2(45604);
            Polygon.ContainsPoint = __webpack_require__2(87289);
            Polygon.Earcut = __webpack_require__2(11117);
            Polygon.GetAABB = __webpack_require__2(14045);
            Polygon.GetNumberArray = __webpack_require__2(98286);
            Polygon.GetPoints = __webpack_require__2(89294);
            Polygon.Perimeter = __webpack_require__2(5159);
            Polygon.Reverse = __webpack_require__2(32244);
            Polygon.Simplify = __webpack_require__2(95874);
            Polygon.Smooth = __webpack_require__2(18974);
            Polygon.Translate = __webpack_require__2(23490);
            module2.exports = Polygon;
          },
          1653: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Area = function(rect) {
              return rect.width * rect.height;
            };
            module2.exports = Area;
          },
          33943: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Ceil = function(rect) {
              rect.x = Math.ceil(rect.x);
              rect.y = Math.ceil(rect.y);
              return rect;
            };
            module2.exports = Ceil;
          },
          58662: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CeilAll = function(rect) {
              rect.x = Math.ceil(rect.x);
              rect.y = Math.ceil(rect.y);
              rect.width = Math.ceil(rect.width);
              rect.height = Math.ceil(rect.height);
              return rect;
            };
            module2.exports = CeilAll;
          },
          79993: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CenterOn = function(rect, x, y) {
              rect.x = x - rect.width / 2;
              rect.y = y - rect.height / 2;
              return rect;
            };
            module2.exports = CenterOn;
          },
          81572: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var Clone = function(source) {
              return new Rectangle(source.x, source.y, source.width, source.height);
            };
            module2.exports = Clone;
          },
          94287: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = function(rect, x, y) {
              if (rect.width <= 0 || rect.height <= 0) {
                return false;
              }
              return rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;
            };
            module2.exports = Contains;
          },
          28687: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = __webpack_require__2(94287);
            var ContainsPoint = function(rect, point) {
              return Contains(rect, point.x, point.y);
            };
            module2.exports = ContainsPoint;
          },
          73222: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ContainsRect = function(rectA, rectB) {
              if (rectB.width * rectB.height > rectA.width * rectA.height) {
                return false;
              }
              return rectB.x > rectA.x && rectB.x < rectA.right && (rectB.right > rectA.x && rectB.right < rectA.right) && (rectB.y > rectA.y && rectB.y < rectA.bottom) && (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom);
            };
            module2.exports = ContainsRect;
          },
          29538: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CopyFrom = function(source, dest) {
              return dest.setTo(source.x, source.y, source.width, source.height);
            };
            module2.exports = CopyFrom;
          },
          87279: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Decompose = function(rect, out) {
              if (out === void 0) {
                out = [];
              }
              out.push({x: rect.x, y: rect.y});
              out.push({x: rect.right, y: rect.y});
              out.push({x: rect.right, y: rect.bottom});
              out.push({x: rect.x, y: rect.bottom});
              return out;
            };
            module2.exports = Decompose;
          },
          19989: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Equals = function(rect, toCompare) {
              return rect.x === toCompare.x && rect.y === toCompare.y && rect.width === toCompare.width && rect.height === toCompare.height;
            };
            module2.exports = Equals;
          },
          92628: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetAspectRatio = __webpack_require__2(6700);
            var FitInside = function(target, source) {
              var ratio = GetAspectRatio(target);
              if (ratio < GetAspectRatio(source)) {
                target.setSize(source.height * ratio, source.height);
              } else {
                target.setSize(source.width, source.width / ratio);
              }
              return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
            };
            module2.exports = FitInside;
          },
          85028: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetAspectRatio = __webpack_require__2(6700);
            var FitOutside = function(target, source) {
              var ratio = GetAspectRatio(target);
              if (ratio > GetAspectRatio(source)) {
                target.setSize(source.height * ratio, source.height);
              } else {
                target.setSize(source.width, source.width / ratio);
              }
              return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
            };
            module2.exports = FitOutside;
          },
          71356: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Floor = function(rect) {
              rect.x = Math.floor(rect.x);
              rect.y = Math.floor(rect.y);
              return rect;
            };
            module2.exports = Floor;
          },
          21687: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FloorAll = function(rect) {
              rect.x = Math.floor(rect.x);
              rect.y = Math.floor(rect.y);
              rect.width = Math.floor(rect.width);
              rect.height = Math.floor(rect.height);
              return rect;
            };
            module2.exports = FloorAll;
          },
          80222: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var MATH_CONST = __webpack_require__2(83392);
            var FromPoints = function(points, out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              if (points.length === 0) {
                return out;
              }
              var minX = Number.MAX_VALUE;
              var minY = Number.MAX_VALUE;
              var maxX = MATH_CONST.MIN_SAFE_INTEGER;
              var maxY = MATH_CONST.MIN_SAFE_INTEGER;
              var p;
              var px;
              var py;
              for (var i = 0; i < points.length; i++) {
                p = points[i];
                if (Array.isArray(p)) {
                  px = p[0];
                  py = p[1];
                } else {
                  px = p.x;
                  py = p.y;
                }
                minX = Math.min(minX, px);
                minY = Math.min(minY, py);
                maxX = Math.max(maxX, px);
                maxY = Math.max(maxY, py);
              }
              out.x = minX;
              out.y = minY;
              out.width = maxX - minX;
              out.height = maxY - minY;
              return out;
            };
            module2.exports = FromPoints;
          },
          75785: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var FromXY = function(x1, y1, x2, y2, out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              return out.setTo(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
            };
            module2.exports = FromXY;
          },
          6700: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetAspectRatio = function(rect) {
              return rect.height === 0 ? NaN : rect.width / rect.height;
            };
            module2.exports = GetAspectRatio;
          },
          35242: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var GetCenter = function(rect, out) {
              if (out === void 0) {
                out = new Point();
              }
              out.x = rect.centerX;
              out.y = rect.centerY;
              return out;
            };
            module2.exports = GetCenter;
          },
          47698: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Perimeter = __webpack_require__2(85876);
            var Point = __webpack_require__2(79967);
            var GetPoint = function(rectangle, position, out) {
              if (out === void 0) {
                out = new Point();
              }
              if (position <= 0 || position >= 1) {
                out.x = rectangle.x;
                out.y = rectangle.y;
                return out;
              }
              var p = Perimeter(rectangle) * position;
              if (position > 0.5) {
                p -= rectangle.width + rectangle.height;
                if (p <= rectangle.width) {
                  out.x = rectangle.right - p;
                  out.y = rectangle.bottom;
                } else {
                  out.x = rectangle.x;
                  out.y = rectangle.bottom - (p - rectangle.width);
                }
              } else if (p <= rectangle.width) {
                out.x = rectangle.x + p;
                out.y = rectangle.y;
              } else {
                out.x = rectangle.right;
                out.y = rectangle.y + (p - rectangle.width);
              }
              return out;
            };
            module2.exports = GetPoint;
          },
          54932: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetPoint = __webpack_require__2(47698);
            var Perimeter = __webpack_require__2(85876);
            var GetPoints = function(rectangle, quantity, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              if (!quantity && stepRate > 0) {
                quantity = Perimeter(rectangle) / stepRate;
              }
              for (var i = 0; i < quantity; i++) {
                var position = i / quantity;
                out.push(GetPoint(rectangle, position));
              }
              return out;
            };
            module2.exports = GetPoints;
          },
          31591: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var GetSize = function(rect, out) {
              if (out === void 0) {
                out = new Point();
              }
              out.x = rect.width;
              out.y = rect.height;
              return out;
            };
            module2.exports = GetSize;
          },
          7782: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CenterOn = __webpack_require__2(79993);
            var Inflate = function(rect, x, y) {
              var cx = rect.centerX;
              var cy = rect.centerY;
              rect.setSize(rect.width + x * 2, rect.height + y * 2);
              return CenterOn(rect, cx, cy);
            };
            module2.exports = Inflate;
          },
          66217: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var Intersects = __webpack_require__2(90205);
            var Intersection = function(rectA, rectB, out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              if (Intersects(rectA, rectB)) {
                out.x = Math.max(rectA.x, rectB.x);
                out.y = Math.max(rectA.y, rectB.y);
                out.width = Math.min(rectA.right, rectB.right) - out.x;
                out.height = Math.min(rectA.bottom, rectB.bottom) - out.y;
              } else {
                out.setEmpty();
              }
              return out;
            };
            module2.exports = Intersection;
          },
          40053: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Perimeter = __webpack_require__2(85876);
            var Point = __webpack_require__2(79967);
            var MarchingAnts = function(rect, step, quantity, out) {
              if (out === void 0) {
                out = [];
              }
              if (!step && !quantity) {
                return out;
              }
              if (!step) {
                step = Perimeter(rect) / quantity;
              } else {
                quantity = Math.round(Perimeter(rect) / step);
              }
              var x = rect.x;
              var y = rect.y;
              var face = 0;
              for (var i = 0; i < quantity; i++) {
                out.push(new Point(x, y));
                switch (face) {
                  case 0:
                    x += step;
                    if (x >= rect.right) {
                      face = 1;
                      y += x - rect.right;
                      x = rect.right;
                    }
                    break;
                  case 1:
                    y += step;
                    if (y >= rect.bottom) {
                      face = 2;
                      x -= y - rect.bottom;
                      y = rect.bottom;
                    }
                    break;
                  case 2:
                    x -= step;
                    if (x <= rect.left) {
                      face = 3;
                      y -= rect.left - x;
                      x = rect.left;
                    }
                    break;
                  case 3:
                    y -= step;
                    if (y <= rect.top) {
                      face = 0;
                      y = rect.top;
                    }
                    break;
                }
              }
              return out;
            };
            module2.exports = MarchingAnts;
          },
          86673: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MergePoints = function(target, points) {
              var minX = target.x;
              var maxX = target.right;
              var minY = target.y;
              var maxY = target.bottom;
              for (var i = 0; i < points.length; i++) {
                minX = Math.min(minX, points[i].x);
                maxX = Math.max(maxX, points[i].x);
                minY = Math.min(minY, points[i].y);
                maxY = Math.max(maxY, points[i].y);
              }
              target.x = minX;
              target.y = minY;
              target.width = maxX - minX;
              target.height = maxY - minY;
              return target;
            };
            module2.exports = MergePoints;
          },
          14655: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MergeRect = function(target, source) {
              var minX = Math.min(target.x, source.x);
              var maxX = Math.max(target.right, source.right);
              target.x = minX;
              target.width = maxX - minX;
              var minY = Math.min(target.y, source.y);
              var maxY = Math.max(target.bottom, source.bottom);
              target.y = minY;
              target.height = maxY - minY;
              return target;
            };
            module2.exports = MergeRect;
          },
          44755: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MergeXY = function(target, x, y) {
              var minX = Math.min(target.x, x);
              var maxX = Math.max(target.right, x);
              target.x = minX;
              target.width = maxX - minX;
              var minY = Math.min(target.y, y);
              var maxY = Math.max(target.bottom, y);
              target.y = minY;
              target.height = maxY - minY;
              return target;
            };
            module2.exports = MergeXY;
          },
          74466: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Offset = function(rect, x, y) {
              rect.x += x;
              rect.y += y;
              return rect;
            };
            module2.exports = Offset;
          },
          55946: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var OffsetPoint = function(rect, point) {
              rect.x += point.x;
              rect.y += point.y;
              return rect;
            };
            module2.exports = OffsetPoint;
          },
          97474: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Overlaps = function(rectA, rectB) {
              return rectA.x < rectB.right && rectA.right > rectB.x && rectA.y < rectB.bottom && rectA.bottom > rectB.y;
            };
            module2.exports = Overlaps;
          },
          85876: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Perimeter = function(rect) {
              return 2 * (rect.width + rect.height);
            };
            module2.exports = Perimeter;
          },
          20243: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var DegToRad = __webpack_require__2(75606);
            var PerimeterPoint = function(rectangle, angle, out) {
              if (out === void 0) {
                out = new Point();
              }
              angle = DegToRad(angle);
              var s = Math.sin(angle);
              var c = Math.cos(angle);
              var dx = c > 0 ? rectangle.width / 2 : rectangle.width / -2;
              var dy = s > 0 ? rectangle.height / 2 : rectangle.height / -2;
              if (Math.abs(dx * s) < Math.abs(dy * c)) {
                dy = dx * s / c;
              } else {
                dx = dy * c / s;
              }
              out.x = dx + rectangle.centerX;
              out.y = dy + rectangle.centerY;
              return out;
            };
            module2.exports = PerimeterPoint;
          },
          30001: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Random = function(rect, out) {
              if (out === void 0) {
                out = new Point();
              }
              out.x = rect.x + Math.random() * rect.width;
              out.y = rect.y + Math.random() * rect.height;
              return out;
            };
            module2.exports = Random;
          },
          97691: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Between = __webpack_require__2(17489);
            var ContainsRect = __webpack_require__2(73222);
            var Point = __webpack_require__2(79967);
            var RandomOutside = function(outer, inner, out) {
              if (out === void 0) {
                out = new Point();
              }
              if (ContainsRect(outer, inner)) {
                switch (Between(0, 3)) {
                  case 0:
                    out.x = outer.x + Math.random() * (inner.right - outer.x);
                    out.y = outer.y + Math.random() * (inner.top - outer.y);
                    break;
                  case 1:
                    out.x = inner.x + Math.random() * (outer.right - inner.x);
                    out.y = inner.bottom + Math.random() * (outer.bottom - inner.bottom);
                    break;
                  case 2:
                    out.x = outer.x + Math.random() * (inner.x - outer.x);
                    out.y = inner.y + Math.random() * (outer.bottom - inner.y);
                    break;
                  case 3:
                    out.x = inner.right + Math.random() * (outer.right - inner.right);
                    out.y = outer.y + Math.random() * (inner.bottom - outer.y);
                    break;
                }
              }
              return out;
            };
            module2.exports = RandomOutside;
          },
          74118: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Contains = __webpack_require__2(94287);
            var GetPoint = __webpack_require__2(47698);
            var GetPoints = __webpack_require__2(54932);
            var GEOM_CONST = __webpack_require__2(52394);
            var Line = __webpack_require__2(88829);
            var Random = __webpack_require__2(30001);
            var Rectangle = new Class({
              initialize: function Rectangle2(x, y, width, height) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = 0;
                }
                if (height === void 0) {
                  height = 0;
                }
                this.type = GEOM_CONST.RECTANGLE;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
              },
              contains: function(x, y) {
                return Contains(this, x, y);
              },
              getPoint: function(position, output) {
                return GetPoint(this, position, output);
              },
              getPoints: function(quantity, stepRate, output) {
                return GetPoints(this, quantity, stepRate, output);
              },
              getRandomPoint: function(point) {
                return Random(this, point);
              },
              setTo: function(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                return this;
              },
              setEmpty: function() {
                return this.setTo(0, 0, 0, 0);
              },
              setPosition: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.x = x;
                this.y = y;
                return this;
              },
              setSize: function(width, height) {
                if (height === void 0) {
                  height = width;
                }
                this.width = width;
                this.height = height;
                return this;
              },
              isEmpty: function() {
                return this.width <= 0 || this.height <= 0;
              },
              getLineA: function(line) {
                if (line === void 0) {
                  line = new Line();
                }
                line.setTo(this.x, this.y, this.right, this.y);
                return line;
              },
              getLineB: function(line) {
                if (line === void 0) {
                  line = new Line();
                }
                line.setTo(this.right, this.y, this.right, this.bottom);
                return line;
              },
              getLineC: function(line) {
                if (line === void 0) {
                  line = new Line();
                }
                line.setTo(this.right, this.bottom, this.x, this.bottom);
                return line;
              },
              getLineD: function(line) {
                if (line === void 0) {
                  line = new Line();
                }
                line.setTo(this.x, this.bottom, this.x, this.y);
                return line;
              },
              left: {
                get: function() {
                  return this.x;
                },
                set: function(value) {
                  if (value >= this.right) {
                    this.width = 0;
                  } else {
                    this.width = this.right - value;
                  }
                  this.x = value;
                }
              },
              right: {
                get: function() {
                  return this.x + this.width;
                },
                set: function(value) {
                  if (value <= this.x) {
                    this.width = 0;
                  } else {
                    this.width = value - this.x;
                  }
                }
              },
              top: {
                get: function() {
                  return this.y;
                },
                set: function(value) {
                  if (value >= this.bottom) {
                    this.height = 0;
                  } else {
                    this.height = this.bottom - value;
                  }
                  this.y = value;
                }
              },
              bottom: {
                get: function() {
                  return this.y + this.height;
                },
                set: function(value) {
                  if (value <= this.y) {
                    this.height = 0;
                  } else {
                    this.height = value - this.y;
                  }
                }
              },
              centerX: {
                get: function() {
                  return this.x + this.width / 2;
                },
                set: function(value) {
                  this.x = value - this.width / 2;
                }
              },
              centerY: {
                get: function() {
                  return this.y + this.height / 2;
                },
                set: function(value) {
                  this.y = value - this.height / 2;
                }
              }
            });
            module2.exports = Rectangle;
          },
          51828: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SameDimensions = function(rect, toCompare) {
              return rect.width === toCompare.width && rect.height === toCompare.height;
            };
            module2.exports = SameDimensions;
          },
          5691: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Scale = function(rect, x, y) {
              if (y === void 0) {
                y = x;
              }
              rect.width *= x;
              rect.height *= y;
              return rect;
            };
            module2.exports = Scale;
          },
          58795: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var Union = function(rectA, rectB, out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              var x = Math.min(rectA.x, rectB.x);
              var y = Math.min(rectA.y, rectB.y);
              var w = Math.max(rectA.right, rectB.right) - x;
              var h = Math.max(rectA.bottom, rectB.bottom) - y;
              return out.setTo(x, y, w, h);
            };
            module2.exports = Union;
          },
          66658: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            Rectangle.Area = __webpack_require__2(1653);
            Rectangle.Ceil = __webpack_require__2(33943);
            Rectangle.CeilAll = __webpack_require__2(58662);
            Rectangle.CenterOn = __webpack_require__2(79993);
            Rectangle.Clone = __webpack_require__2(81572);
            Rectangle.Contains = __webpack_require__2(94287);
            Rectangle.ContainsPoint = __webpack_require__2(28687);
            Rectangle.ContainsRect = __webpack_require__2(73222);
            Rectangle.CopyFrom = __webpack_require__2(29538);
            Rectangle.Decompose = __webpack_require__2(87279);
            Rectangle.Equals = __webpack_require__2(19989);
            Rectangle.FitInside = __webpack_require__2(92628);
            Rectangle.FitOutside = __webpack_require__2(85028);
            Rectangle.Floor = __webpack_require__2(71356);
            Rectangle.FloorAll = __webpack_require__2(21687);
            Rectangle.FromPoints = __webpack_require__2(80222);
            Rectangle.FromXY = __webpack_require__2(75785);
            Rectangle.GetAspectRatio = __webpack_require__2(6700);
            Rectangle.GetCenter = __webpack_require__2(35242);
            Rectangle.GetPoint = __webpack_require__2(47698);
            Rectangle.GetPoints = __webpack_require__2(54932);
            Rectangle.GetSize = __webpack_require__2(31591);
            Rectangle.Inflate = __webpack_require__2(7782);
            Rectangle.Intersection = __webpack_require__2(66217);
            Rectangle.MarchingAnts = __webpack_require__2(40053);
            Rectangle.MergePoints = __webpack_require__2(86673);
            Rectangle.MergeRect = __webpack_require__2(14655);
            Rectangle.MergeXY = __webpack_require__2(44755);
            Rectangle.Offset = __webpack_require__2(74466);
            Rectangle.OffsetPoint = __webpack_require__2(55946);
            Rectangle.Overlaps = __webpack_require__2(97474);
            Rectangle.Perimeter = __webpack_require__2(85876);
            Rectangle.PerimeterPoint = __webpack_require__2(20243);
            Rectangle.Random = __webpack_require__2(30001);
            Rectangle.RandomOutside = __webpack_require__2(97691);
            Rectangle.SameDimensions = __webpack_require__2(51828);
            Rectangle.Scale = __webpack_require__2(5691);
            Rectangle.Union = __webpack_require__2(58795);
            module2.exports = Rectangle;
          },
          19108: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Area = function(triangle) {
              var x1 = triangle.x1;
              var y1 = triangle.y1;
              var x2 = triangle.x2;
              var y2 = triangle.y2;
              var x3 = triangle.x3;
              var y3 = triangle.y3;
              return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
            };
            module2.exports = Area;
          },
          41199: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Triangle = __webpack_require__2(66349);
            var BuildEquilateral = function(x, y, length) {
              var height = length * (Math.sqrt(3) / 2);
              var x1 = x;
              var y1 = y;
              var x2 = x + length / 2;
              var y2 = y + height;
              var x3 = x - length / 2;
              var y3 = y + height;
              return new Triangle(x1, y1, x2, y2, x3, y3);
            };
            module2.exports = BuildEquilateral;
          },
          88730: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var EarCut = __webpack_require__2(11117);
            var Triangle = __webpack_require__2(66349);
            var BuildFromPolygon = function(data, holes, scaleX, scaleY, out) {
              if (holes === void 0) {
                holes = null;
              }
              if (scaleX === void 0) {
                scaleX = 1;
              }
              if (scaleY === void 0) {
                scaleY = 1;
              }
              if (out === void 0) {
                out = [];
              }
              var tris = EarCut(data, holes);
              var a;
              var b;
              var c;
              var x1;
              var y1;
              var x2;
              var y2;
              var x3;
              var y3;
              for (var i = 0; i < tris.length; i += 3) {
                a = tris[i];
                b = tris[i + 1];
                c = tris[i + 2];
                x1 = data[a * 2] * scaleX;
                y1 = data[a * 2 + 1] * scaleY;
                x2 = data[b * 2] * scaleX;
                y2 = data[b * 2 + 1] * scaleY;
                x3 = data[c * 2] * scaleX;
                y3 = data[c * 2 + 1] * scaleY;
                out.push(new Triangle(x1, y1, x2, y2, x3, y3));
              }
              return out;
            };
            module2.exports = BuildFromPolygon;
          },
          3635: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Triangle = __webpack_require__2(66349);
            var BuildRight = function(x, y, width, height) {
              if (height === void 0) {
                height = width;
              }
              var x1 = x;
              var y1 = y;
              var x2 = x;
              var y2 = y - height;
              var x3 = x + width;
              var y3 = y;
              return new Triangle(x1, y1, x2, y2, x3, y3);
            };
            module2.exports = BuildRight;
          },
          1882: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Centroid = __webpack_require__2(56595);
            var Offset = __webpack_require__2(9640);
            var CenterOn = function(triangle, x, y, centerFunc) {
              if (centerFunc === void 0) {
                centerFunc = Centroid;
              }
              var center = centerFunc(triangle);
              var diffX = x - center.x;
              var diffY = y - center.y;
              return Offset(triangle, diffX, diffY);
            };
            module2.exports = CenterOn;
          },
          56595: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Centroid = function(triangle, out) {
              if (out === void 0) {
                out = new Point();
              }
              out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
              out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;
              return out;
            };
            module2.exports = Centroid;
          },
          91835: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            function det(m00, m01, m10, m11) {
              return m00 * m11 - m01 * m10;
            }
            var CircumCenter = function(triangle, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var cx = triangle.x3;
              var cy = triangle.y3;
              var ax = triangle.x1 - cx;
              var ay = triangle.y1 - cy;
              var bx = triangle.x2 - cx;
              var by = triangle.y2 - cy;
              var denom = 2 * det(ax, ay, bx, by);
              var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
              var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
              out.x = cx - numx / denom;
              out.y = cy + numy / denom;
              return out;
            };
            module2.exports = CircumCenter;
          },
          97073: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circle = __webpack_require__2(26673);
            var CircumCircle = function(triangle, out) {
              if (out === void 0) {
                out = new Circle();
              }
              var x1 = triangle.x1;
              var y1 = triangle.y1;
              var x2 = triangle.x2;
              var y2 = triangle.y2;
              var x3 = triangle.x3;
              var y3 = triangle.y3;
              var A = x2 - x1;
              var B = y2 - y1;
              var C = x3 - x1;
              var D = y3 - y1;
              var E = A * (x1 + x2) + B * (y1 + y2);
              var F = C * (x1 + x3) + D * (y1 + y3);
              var G = 2 * (A * (y3 - y2) - B * (x3 - x2));
              var dx;
              var dy;
              if (Math.abs(G) < 1e-6) {
                var minX = Math.min(x1, x2, x3);
                var minY = Math.min(y1, y2, y3);
                dx = (Math.max(x1, x2, x3) - minX) * 0.5;
                dy = (Math.max(y1, y2, y3) - minY) * 0.5;
                out.x = minX + dx;
                out.y = minY + dy;
                out.radius = Math.sqrt(dx * dx + dy * dy);
              } else {
                out.x = (D * E - B * F) / G;
                out.y = (A * F - C * E) / G;
                dx = out.x - x1;
                dy = out.y - y1;
                out.radius = Math.sqrt(dx * dx + dy * dy);
              }
              return out;
            };
            module2.exports = CircumCircle;
          },
          75974: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Triangle = __webpack_require__2(66349);
            var Clone = function(source) {
              return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
            };
            module2.exports = Clone;
          },
          60689: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = function(triangle, x, y) {
              var v0x = triangle.x3 - triangle.x1;
              var v0y = triangle.y3 - triangle.y1;
              var v1x = triangle.x2 - triangle.x1;
              var v1y = triangle.y2 - triangle.y1;
              var v2x = x - triangle.x1;
              var v2y = y - triangle.y1;
              var dot00 = v0x * v0x + v0y * v0y;
              var dot01 = v0x * v1x + v0y * v1y;
              var dot02 = v0x * v2x + v0y * v2y;
              var dot11 = v1x * v1x + v1y * v1y;
              var dot12 = v1x * v2x + v1y * v2y;
              var b = dot00 * dot11 - dot01 * dot01;
              var inv = b === 0 ? 0 : 1 / b;
              var u = (dot11 * dot02 - dot01 * dot12) * inv;
              var v = (dot00 * dot12 - dot01 * dot02) * inv;
              return u >= 0 && v >= 0 && u + v < 1;
            };
            module2.exports = Contains;
          },
          86875: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ContainsArray = function(triangle, points, returnFirst, out) {
              if (returnFirst === void 0) {
                returnFirst = false;
              }
              if (out === void 0) {
                out = [];
              }
              var v0x = triangle.x3 - triangle.x1;
              var v0y = triangle.y3 - triangle.y1;
              var v1x = triangle.x2 - triangle.x1;
              var v1y = triangle.y2 - triangle.y1;
              var dot00 = v0x * v0x + v0y * v0y;
              var dot01 = v0x * v1x + v0y * v1y;
              var dot11 = v1x * v1x + v1y * v1y;
              var b = dot00 * dot11 - dot01 * dot01;
              var inv = b === 0 ? 0 : 1 / b;
              var u;
              var v;
              var v2x;
              var v2y;
              var dot02;
              var dot12;
              var x1 = triangle.x1;
              var y1 = triangle.y1;
              for (var i = 0; i < points.length; i++) {
                v2x = points[i].x - x1;
                v2y = points[i].y - y1;
                dot02 = v0x * v2x + v0y * v2y;
                dot12 = v1x * v2x + v1y * v2y;
                u = (dot11 * dot02 - dot01 * dot12) * inv;
                v = (dot00 * dot12 - dot01 * dot02) * inv;
                if (u >= 0 && v >= 0 && u + v < 1) {
                  out.push({x: points[i].x, y: points[i].y});
                  if (returnFirst) {
                    break;
                  }
                }
              }
              return out;
            };
            module2.exports = ContainsArray;
          },
          51532: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Contains = __webpack_require__2(60689);
            var ContainsPoint = function(triangle, point) {
              return Contains(triangle, point.x, point.y);
            };
            module2.exports = ContainsPoint;
          },
          42538: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CopyFrom = function(source, dest) {
              return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
            };
            module2.exports = CopyFrom;
          },
          18680: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Decompose = function(triangle, out) {
              if (out === void 0) {
                out = [];
              }
              out.push({x: triangle.x1, y: triangle.y1});
              out.push({x: triangle.x2, y: triangle.y2});
              out.push({x: triangle.x3, y: triangle.y3});
              return out;
            };
            module2.exports = Decompose;
          },
          29977: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Equals = function(triangle, toCompare) {
              return triangle.x1 === toCompare.x1 && triangle.y1 === toCompare.y1 && triangle.x2 === toCompare.x2 && triangle.y2 === toCompare.y2 && triangle.x3 === toCompare.x3 && triangle.y3 === toCompare.y3;
            };
            module2.exports = Equals;
          },
          56088: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Length = __webpack_require__2(16028);
            var GetPoint = function(triangle, position, out) {
              if (out === void 0) {
                out = new Point();
              }
              var line1 = triangle.getLineA();
              var line2 = triangle.getLineB();
              var line3 = triangle.getLineC();
              if (position <= 0 || position >= 1) {
                out.x = line1.x1;
                out.y = line1.y1;
                return out;
              }
              var length1 = Length(line1);
              var length2 = Length(line2);
              var length3 = Length(line3);
              var perimeter = length1 + length2 + length3;
              var p = perimeter * position;
              var localPosition = 0;
              if (p < length1) {
                localPosition = p / length1;
                out.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
                out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
              } else if (p > length1 + length2) {
                p -= length1 + length2;
                localPosition = p / length3;
                out.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
                out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
              } else {
                p -= length1;
                localPosition = p / length2;
                out.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
                out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
              }
              return out;
            };
            module2.exports = GetPoint;
          },
          24402: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Length = __webpack_require__2(16028);
            var Point = __webpack_require__2(79967);
            var GetPoints = function(triangle, quantity, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              var line1 = triangle.getLineA();
              var line2 = triangle.getLineB();
              var line3 = triangle.getLineC();
              var length1 = Length(line1);
              var length2 = Length(line2);
              var length3 = Length(line3);
              var perimeter = length1 + length2 + length3;
              if (!quantity && stepRate > 0) {
                quantity = perimeter / stepRate;
              }
              for (var i = 0; i < quantity; i++) {
                var p = perimeter * (i / quantity);
                var localPosition = 0;
                var point = new Point();
                if (p < length1) {
                  localPosition = p / length1;
                  point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
                  point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
                } else if (p > length1 + length2) {
                  p -= length1 + length2;
                  localPosition = p / length3;
                  point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
                  point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
                } else {
                  p -= length1;
                  localPosition = p / length2;
                  point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
                  point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
                }
                out.push(point);
              }
              return out;
            };
            module2.exports = GetPoints;
          },
          83648: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            function getLength(x1, y1, x2, y2) {
              var x = x1 - x2;
              var y = y1 - y2;
              var magnitude = x * x + y * y;
              return Math.sqrt(magnitude);
            }
            var InCenter = function(triangle, out) {
              if (out === void 0) {
                out = new Point();
              }
              var x1 = triangle.x1;
              var y1 = triangle.y1;
              var x2 = triangle.x2;
              var y2 = triangle.y2;
              var x3 = triangle.x3;
              var y3 = triangle.y3;
              var d1 = getLength(x3, y3, x2, y2);
              var d2 = getLength(x1, y1, x3, y3);
              var d3 = getLength(x2, y2, x1, y1);
              var p = d1 + d2 + d3;
              out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p;
              out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p;
              return out;
            };
            module2.exports = InCenter;
          },
          9640: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Offset = function(triangle, x, y) {
              triangle.x1 += x;
              triangle.y1 += y;
              triangle.x2 += x;
              triangle.y2 += y;
              triangle.x3 += x;
              triangle.y3 += y;
              return triangle;
            };
            module2.exports = Offset;
          },
          95290: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Length = __webpack_require__2(16028);
            var Perimeter = function(triangle) {
              var line1 = triangle.getLineA();
              var line2 = triangle.getLineB();
              var line3 = triangle.getLineC();
              return Length(line1) + Length(line2) + Length(line3);
            };
            module2.exports = Perimeter;
          },
          99761: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Point = __webpack_require__2(79967);
            var Random = function(triangle, out) {
              if (out === void 0) {
                out = new Point();
              }
              var ux = triangle.x2 - triangle.x1;
              var uy = triangle.y2 - triangle.y1;
              var vx = triangle.x3 - triangle.x1;
              var vy = triangle.y3 - triangle.y1;
              var r = Math.random();
              var s = Math.random();
              if (r + s >= 1) {
                r = 1 - r;
                s = 1 - s;
              }
              out.x = triangle.x1 + (ux * r + vx * s);
              out.y = triangle.y1 + (uy * r + vy * s);
              return out;
            };
            module2.exports = Random;
          },
          21934: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAroundXY = __webpack_require__2(19211);
            var InCenter = __webpack_require__2(83648);
            var Rotate = function(triangle, angle) {
              var point = InCenter(triangle);
              return RotateAroundXY(triangle, point.x, point.y, angle);
            };
            module2.exports = Rotate;
          },
          68454: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAroundXY = __webpack_require__2(19211);
            var RotateAroundPoint = function(triangle, point, angle) {
              return RotateAroundXY(triangle, point.x, point.y, angle);
            };
            module2.exports = RotateAroundPoint;
          },
          19211: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAroundXY = function(triangle, x, y, angle) {
              var c = Math.cos(angle);
              var s = Math.sin(angle);
              var tx = triangle.x1 - x;
              var ty = triangle.y1 - y;
              triangle.x1 = tx * c - ty * s + x;
              triangle.y1 = tx * s + ty * c + y;
              tx = triangle.x2 - x;
              ty = triangle.y2 - y;
              triangle.x2 = tx * c - ty * s + x;
              triangle.y2 = tx * s + ty * c + y;
              tx = triangle.x3 - x;
              ty = triangle.y3 - y;
              triangle.x3 = tx * c - ty * s + x;
              triangle.y3 = tx * s + ty * c + y;
              return triangle;
            };
            module2.exports = RotateAroundXY;
          },
          66349: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Contains = __webpack_require__2(60689);
            var GetPoint = __webpack_require__2(56088);
            var GetPoints = __webpack_require__2(24402);
            var GEOM_CONST = __webpack_require__2(52394);
            var Line = __webpack_require__2(88829);
            var Random = __webpack_require__2(99761);
            var Triangle = new Class({
              initialize: function Triangle2(x1, y1, x2, y2, x3, y3) {
                if (x1 === void 0) {
                  x1 = 0;
                }
                if (y1 === void 0) {
                  y1 = 0;
                }
                if (x2 === void 0) {
                  x2 = 0;
                }
                if (y2 === void 0) {
                  y2 = 0;
                }
                if (x3 === void 0) {
                  x3 = 0;
                }
                if (y3 === void 0) {
                  y3 = 0;
                }
                this.type = GEOM_CONST.TRIANGLE;
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.x3 = x3;
                this.y3 = y3;
              },
              contains: function(x, y) {
                return Contains(this, x, y);
              },
              getPoint: function(position, output) {
                return GetPoint(this, position, output);
              },
              getPoints: function(quantity, stepRate, output) {
                return GetPoints(this, quantity, stepRate, output);
              },
              getRandomPoint: function(point) {
                return Random(this, point);
              },
              setTo: function(x1, y1, x2, y2, x3, y3) {
                if (x1 === void 0) {
                  x1 = 0;
                }
                if (y1 === void 0) {
                  y1 = 0;
                }
                if (x2 === void 0) {
                  x2 = 0;
                }
                if (y2 === void 0) {
                  y2 = 0;
                }
                if (x3 === void 0) {
                  x3 = 0;
                }
                if (y3 === void 0) {
                  y3 = 0;
                }
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.x3 = x3;
                this.y3 = y3;
                return this;
              },
              getLineA: function(line) {
                if (line === void 0) {
                  line = new Line();
                }
                line.setTo(this.x1, this.y1, this.x2, this.y2);
                return line;
              },
              getLineB: function(line) {
                if (line === void 0) {
                  line = new Line();
                }
                line.setTo(this.x2, this.y2, this.x3, this.y3);
                return line;
              },
              getLineC: function(line) {
                if (line === void 0) {
                  line = new Line();
                }
                line.setTo(this.x3, this.y3, this.x1, this.y1);
                return line;
              },
              left: {
                get: function() {
                  return Math.min(this.x1, this.x2, this.x3);
                },
                set: function(value) {
                  var diff = 0;
                  if (this.x1 <= this.x2 && this.x1 <= this.x3) {
                    diff = this.x1 - value;
                  } else if (this.x2 <= this.x1 && this.x2 <= this.x3) {
                    diff = this.x2 - value;
                  } else {
                    diff = this.x3 - value;
                  }
                  this.x1 -= diff;
                  this.x2 -= diff;
                  this.x3 -= diff;
                }
              },
              right: {
                get: function() {
                  return Math.max(this.x1, this.x2, this.x3);
                },
                set: function(value) {
                  var diff = 0;
                  if (this.x1 >= this.x2 && this.x1 >= this.x3) {
                    diff = this.x1 - value;
                  } else if (this.x2 >= this.x1 && this.x2 >= this.x3) {
                    diff = this.x2 - value;
                  } else {
                    diff = this.x3 - value;
                  }
                  this.x1 -= diff;
                  this.x2 -= diff;
                  this.x3 -= diff;
                }
              },
              top: {
                get: function() {
                  return Math.min(this.y1, this.y2, this.y3);
                },
                set: function(value) {
                  var diff = 0;
                  if (this.y1 <= this.y2 && this.y1 <= this.y3) {
                    diff = this.y1 - value;
                  } else if (this.y2 <= this.y1 && this.y2 <= this.y3) {
                    diff = this.y2 - value;
                  } else {
                    diff = this.y3 - value;
                  }
                  this.y1 -= diff;
                  this.y2 -= diff;
                  this.y3 -= diff;
                }
              },
              bottom: {
                get: function() {
                  return Math.max(this.y1, this.y2, this.y3);
                },
                set: function(value) {
                  var diff = 0;
                  if (this.y1 >= this.y2 && this.y1 >= this.y3) {
                    diff = this.y1 - value;
                  } else if (this.y2 >= this.y1 && this.y2 >= this.y3) {
                    diff = this.y2 - value;
                  } else {
                    diff = this.y3 - value;
                  }
                  this.y1 -= diff;
                  this.y2 -= diff;
                  this.y3 -= diff;
                }
              }
            });
            module2.exports = Triangle;
          },
          87619: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Triangle = __webpack_require__2(66349);
            Triangle.Area = __webpack_require__2(19108);
            Triangle.BuildEquilateral = __webpack_require__2(41199);
            Triangle.BuildFromPolygon = __webpack_require__2(88730);
            Triangle.BuildRight = __webpack_require__2(3635);
            Triangle.CenterOn = __webpack_require__2(1882);
            Triangle.Centroid = __webpack_require__2(56595);
            Triangle.CircumCenter = __webpack_require__2(91835);
            Triangle.CircumCircle = __webpack_require__2(97073);
            Triangle.Clone = __webpack_require__2(75974);
            Triangle.Contains = __webpack_require__2(60689);
            Triangle.ContainsArray = __webpack_require__2(86875);
            Triangle.ContainsPoint = __webpack_require__2(51532);
            Triangle.CopyFrom = __webpack_require__2(42538);
            Triangle.Decompose = __webpack_require__2(18680);
            Triangle.Equals = __webpack_require__2(29977);
            Triangle.GetPoint = __webpack_require__2(56088);
            Triangle.GetPoints = __webpack_require__2(24402);
            Triangle.InCenter = __webpack_require__2(83648);
            Triangle.Perimeter = __webpack_require__2(95290);
            Triangle.Offset = __webpack_require__2(9640);
            Triangle.Random = __webpack_require__2(99761);
            Triangle.Rotate = __webpack_require__2(21934);
            Triangle.RotateAroundPoint = __webpack_require__2(68454);
            Triangle.RotateAroundXY = __webpack_require__2(19211);
            module2.exports = Triangle;
          },
          27395: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CreateInteractiveObject = function(gameObject, hitArea, hitAreaCallback) {
              return {
                gameObject,
                enabled: true,
                draggable: false,
                dropZone: false,
                cursor: false,
                target: null,
                camera: null,
                hitArea,
                hitAreaCallback,
                hitAreaDebug: null,
                customHitArea: false,
                localX: 0,
                localY: 0,
                dragState: 0,
                dragStartX: 0,
                dragStartY: 0,
                dragStartXGlobal: 0,
                dragStartYGlobal: 0,
                dragX: 0,
                dragY: 0
              };
            };
            module2.exports = CreateInteractiveObject;
          },
          18104: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CreatePixelPerfectHandler = function(textureManager, alphaTolerance) {
              return function(hitArea, x, y, gameObject) {
                var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);
                return alpha && alpha >= alphaTolerance;
              };
            };
            module2.exports = CreatePixelPerfectHandler;
          },
          69898: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(72687);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(33963);
            var GameEvents = __webpack_require__2(97081);
            var Keyboard = __webpack_require__2(71064);
            var Mouse = __webpack_require__2(7905);
            var Pointer = __webpack_require__2(40398);
            var Touch = __webpack_require__2(37579);
            var TransformMatrix = __webpack_require__2(69360);
            var TransformXY = __webpack_require__2(64462);
            var InputManager = new Class({
              initialize: function InputManager2(game, config2) {
                this.game = game;
                this.scaleManager;
                this.canvas;
                this.config = config2;
                this.enabled = true;
                this.events = new EventEmitter();
                this.isOver = true;
                this.defaultCursor = "";
                this.keyboard = config2.inputKeyboard ? new Keyboard(this) : null;
                this.mouse = config2.inputMouse ? new Mouse(this) : null;
                this.touch = config2.inputTouch ? new Touch(this) : null;
                this.pointers = [];
                this.pointersTotal = config2.inputActivePointers;
                if (config2.inputTouch && this.pointersTotal === 1) {
                  this.pointersTotal = 2;
                }
                for (var i = 0; i <= this.pointersTotal; i++) {
                  var pointer = new Pointer(this, i);
                  pointer.smoothFactor = config2.inputSmoothFactor;
                  this.pointers.push(pointer);
                }
                this.mousePointer = config2.inputMouse ? this.pointers[0] : null;
                this.activePointer = this.pointers[0];
                this.globalTopOnly = true;
                this.time = 0;
                this._tempPoint = {x: 0, y: 0};
                this._tempHitTest = [];
                this._tempMatrix = new TransformMatrix();
                this._tempMatrix2 = new TransformMatrix();
                this._tempSkip = false;
                this.mousePointerContainer = [this.mousePointer];
                game.events.once(GameEvents.BOOT, this.boot, this);
              },
              boot: function() {
                var game = this.game;
                var events = game.events;
                this.canvas = game.canvas;
                this.scaleManager = game.scale;
                this.events.emit(Events.MANAGER_BOOT);
                events.on(GameEvents.PRE_RENDER, this.preRender, this);
                events.once(GameEvents.DESTROY, this.destroy, this);
              },
              setCanvasOver: function(event) {
                this.isOver = true;
                this.events.emit(Events.GAME_OVER, event);
              },
              setCanvasOut: function(event) {
                this.isOver = false;
                this.events.emit(Events.GAME_OUT, event);
              },
              preRender: function() {
                var time = this.game.loop.now;
                var delta = this.game.loop.delta;
                var scenes = this.game.scene.getScenes(true, true);
                this.time = time;
                this.events.emit(Events.MANAGER_UPDATE);
                for (var i = 0; i < scenes.length; i++) {
                  var scene = scenes[i];
                  if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly) {
                    return;
                  }
                }
              },
              setDefaultCursor: function(cursor) {
                this.defaultCursor = cursor;
                if (this.canvas.style.cursor !== cursor) {
                  this.canvas.style.cursor = cursor;
                }
              },
              setCursor: function(interactiveObject) {
                if (interactiveObject.cursor) {
                  this.canvas.style.cursor = interactiveObject.cursor;
                }
              },
              resetCursor: function(interactiveObject) {
                if (interactiveObject.cursor && this.canvas) {
                  this.canvas.style.cursor = this.defaultCursor;
                }
              },
              addPointer: function(quantity) {
                if (quantity === void 0) {
                  quantity = 1;
                }
                var output = [];
                if (this.pointersTotal + quantity > 10) {
                  quantity = 10 - this.pointersTotal;
                }
                for (var i = 0; i < quantity; i++) {
                  var id = this.pointers.length;
                  var pointer = new Pointer(this, id);
                  pointer.smoothFactor = this.config.inputSmoothFactor;
                  this.pointers.push(pointer);
                  this.pointersTotal++;
                  output.push(pointer);
                }
                return output;
              },
              updateInputPlugins: function(type, pointers) {
                var scenes = this.game.scene.getScenes(false, true);
                this._tempSkip = false;
                for (var i = 0; i < scenes.length; i++) {
                  var scene = scenes[i];
                  if (scene.sys.input) {
                    var capture = scene.sys.input.update(type, pointers);
                    if (capture && this.globalTopOnly || this._tempSkip) {
                      return;
                    }
                  }
                }
              },
              onTouchStart: function(event) {
                var pointers = this.pointers;
                var changed = [];
                for (var c = 0; c < event.changedTouches.length; c++) {
                  var changedTouch = event.changedTouches[c];
                  for (var i = 1; i < this.pointersTotal; i++) {
                    var pointer = pointers[i];
                    if (!pointer.active) {
                      pointer.touchstart(changedTouch, event);
                      this.activePointer = pointer;
                      changed.push(pointer);
                      break;
                    }
                  }
                }
                this.updateInputPlugins(CONST.TOUCH_START, changed);
              },
              onTouchMove: function(event) {
                var pointers = this.pointers;
                var changed = [];
                for (var c = 0; c < event.changedTouches.length; c++) {
                  var changedTouch = event.changedTouches[c];
                  for (var i = 1; i < this.pointersTotal; i++) {
                    var pointer = pointers[i];
                    if (pointer.active && pointer.identifier === changedTouch.identifier) {
                      var element = document.elementFromPoint(changedTouch.pageX, changedTouch.pageY);
                      var overCanvas = element === this.canvas;
                      if (!this.isOver && overCanvas) {
                        this.setCanvasOver(event);
                      } else if (this.isOver && !overCanvas) {
                        this.setCanvasOut(event);
                      }
                      if (this.isOver) {
                        pointer.touchmove(changedTouch, event);
                        this.activePointer = pointer;
                        changed.push(pointer);
                      }
                      break;
                    }
                  }
                }
                this.updateInputPlugins(CONST.TOUCH_MOVE, changed);
              },
              onTouchEnd: function(event) {
                var pointers = this.pointers;
                var changed = [];
                for (var c = 0; c < event.changedTouches.length; c++) {
                  var changedTouch = event.changedTouches[c];
                  for (var i = 1; i < this.pointersTotal; i++) {
                    var pointer = pointers[i];
                    if (pointer.active && pointer.identifier === changedTouch.identifier) {
                      pointer.touchend(changedTouch, event);
                      changed.push(pointer);
                      break;
                    }
                  }
                }
                this.updateInputPlugins(CONST.TOUCH_END, changed);
              },
              onTouchCancel: function(event) {
                var pointers = this.pointers;
                var changed = [];
                for (var c = 0; c < event.changedTouches.length; c++) {
                  var changedTouch = event.changedTouches[c];
                  for (var i = 1; i < this.pointersTotal; i++) {
                    var pointer = pointers[i];
                    if (pointer.active && pointer.identifier === changedTouch.identifier) {
                      pointer.touchcancel(changedTouch, event);
                      changed.push(pointer);
                      break;
                    }
                  }
                }
                this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);
              },
              onMouseDown: function(event) {
                var mousePointer = this.mousePointer;
                mousePointer.down(event);
                mousePointer.updateMotion();
                this.activePointer = mousePointer;
                this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);
              },
              onMouseMove: function(event) {
                var mousePointer = this.mousePointer;
                mousePointer.move(event);
                mousePointer.updateMotion();
                this.activePointer = mousePointer;
                this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);
              },
              onMouseUp: function(event) {
                var mousePointer = this.mousePointer;
                mousePointer.up(event);
                mousePointer.updateMotion();
                this.activePointer = mousePointer;
                this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);
              },
              onMouseWheel: function(event) {
                var mousePointer = this.mousePointer;
                mousePointer.wheel(event);
                this.activePointer = mousePointer;
                this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);
              },
              onPointerLockChange: function(event) {
                var isLocked = this.mouse.locked;
                this.mousePointer.locked = isLocked;
                this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);
              },
              inputCandidate: function(gameObject, camera) {
                var input = gameObject.input;
                if (!input || !input.enabled || !gameObject.willRender(camera)) {
                  return false;
                }
                var visible = true;
                var parent = gameObject.parentContainer;
                if (parent) {
                  do {
                    if (!parent.willRender(camera)) {
                      visible = false;
                      break;
                    }
                    parent = parent.parentContainer;
                  } while (parent);
                }
                return visible;
              },
              hitTest: function(pointer, gameObjects, camera, output) {
                if (output === void 0) {
                  output = this._tempHitTest;
                }
                var tempPoint = this._tempPoint;
                var csx = camera.scrollX;
                var csy = camera.scrollY;
                output.length = 0;
                var x = pointer.x;
                var y = pointer.y;
                camera.getWorldPoint(x, y, tempPoint);
                pointer.worldX = tempPoint.x;
                pointer.worldY = tempPoint.y;
                var point = {x: 0, y: 0};
                var matrix = this._tempMatrix;
                var parentMatrix = this._tempMatrix2;
                for (var i = 0; i < gameObjects.length; i++) {
                  var gameObject = gameObjects[i];
                  if (!this.inputCandidate(gameObject, camera)) {
                    continue;
                  }
                  var px = tempPoint.x + csx * gameObject.scrollFactorX - csx;
                  var py = tempPoint.y + csy * gameObject.scrollFactorY - csy;
                  if (gameObject.parentContainer) {
                    gameObject.getWorldTransformMatrix(matrix, parentMatrix);
                    matrix.applyInverse(px, py, point);
                  } else {
                    TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);
                  }
                  if (this.pointWithinHitArea(gameObject, point.x, point.y)) {
                    output.push(gameObject);
                  }
                }
                return output;
              },
              pointWithinHitArea: function(gameObject, x, y) {
                x += gameObject.displayOriginX;
                y += gameObject.displayOriginY;
                var input = gameObject.input;
                if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject)) {
                  input.localX = x;
                  input.localY = y;
                  return true;
                } else {
                  return false;
                }
              },
              pointWithinInteractiveObject: function(object, x, y) {
                if (!object.hitArea) {
                  return false;
                }
                x += object.gameObject.displayOriginX;
                y += object.gameObject.displayOriginY;
                object.localX = x;
                object.localY = y;
                return object.hitAreaCallback(object.hitArea, x, y, object);
              },
              transformPointer: function(pointer, pageX, pageY, wasMove) {
                var p0 = pointer.position;
                var p1 = pointer.prevPosition;
                p1.x = p0.x;
                p1.y = p0.y;
                var x = this.scaleManager.transformX(pageX);
                var y = this.scaleManager.transformY(pageY);
                var a = pointer.smoothFactor;
                if (!wasMove || a === 0) {
                  p0.x = x;
                  p0.y = y;
                } else {
                  p0.x = x * a + p1.x * (1 - a);
                  p0.y = y * a + p1.y * (1 - a);
                }
              },
              destroy: function() {
                this.events.removeAllListeners();
                this.game.events.off(GameEvents.PRE_RENDER);
                if (this.keyboard) {
                  this.keyboard.destroy();
                }
                if (this.mouse) {
                  this.mouse.destroy();
                }
                if (this.touch) {
                  this.touch.destroy();
                }
                for (var i = 0; i < this.pointers.length; i++) {
                  this.pointers[i].destroy();
                }
                this.pointers = [];
                this._tempHitTest = [];
                this._tempMatrix.destroy();
                this.canvas = null;
                this.game = null;
              }
            });
            module2.exports = InputManager;
          },
          12499: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Circle = __webpack_require__2(26673);
            var CircleContains = __webpack_require__2(65650);
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(72687);
            var CreateInteractiveObject = __webpack_require__2(27395);
            var CreatePixelPerfectHandler = __webpack_require__2(18104);
            var DistanceBetween = __webpack_require__2(53996);
            var Ellipse = __webpack_require__2(95669);
            var EllipseContains = __webpack_require__2(72313);
            var Events = __webpack_require__2(33963);
            var EventEmitter = __webpack_require__2(6659);
            var GetFastValue = __webpack_require__2(72632);
            var GEOM_CONST = __webpack_require__2(52394);
            var InputPluginCache = __webpack_require__2(63399);
            var IsPlainObject = __webpack_require__2(42911);
            var PluginCache = __webpack_require__2(91963);
            var Rectangle = __webpack_require__2(74118);
            var RectangleContains = __webpack_require__2(94287);
            var SceneEvents = __webpack_require__2(7599);
            var Triangle = __webpack_require__2(66349);
            var TriangleContains = __webpack_require__2(60689);
            var InputPlugin = new Class({
              Extends: EventEmitter,
              initialize: function InputPlugin2(scene) {
                EventEmitter.call(this);
                this.scene = scene;
                this.systems = scene.sys;
                this.settings = scene.sys.settings;
                this.manager = scene.sys.game.input;
                this.pluginEvents = new EventEmitter();
                this.enabled = true;
                this.displayList;
                this.cameras;
                InputPluginCache.install(this);
                this.mouse = this.manager.mouse;
                this.topOnly = true;
                this.pollRate = -1;
                this._pollTimer = 0;
                var _eventData = {cancelled: false};
                this._eventContainer = {
                  stopPropagation: function() {
                    _eventData.cancelled = true;
                  }
                };
                this._eventData = _eventData;
                this.dragDistanceThreshold = 0;
                this.dragTimeThreshold = 0;
                this._temp = [];
                this._tempZones = [];
                this._list = [];
                this._pendingInsertion = [];
                this._pendingRemoval = [];
                this._draggable = [];
                this._drag = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: []};
                this._dragState = [];
                this._over = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: []};
                this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"];
                this._updatedThisFrame = false;
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                scene.sys.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.cameras = this.systems.cameras;
                this.displayList = this.systems.displayList;
                this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
                this.pluginEvents.emit(Events.BOOT);
              },
              start: function() {
                var eventEmitter = this.systems.events;
                eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);
                eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
                eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
                eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
                eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
                this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);
                this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);
                this.enabled = true;
                this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                this.pluginEvents.emit(Events.START);
              },
              onGameOver: function(event) {
                if (this.isActive()) {
                  this.emit(Events.GAME_OVER, event.timeStamp, event);
                }
              },
              onGameOut: function(event) {
                if (this.isActive()) {
                  this.emit(Events.GAME_OUT, event.timeStamp, event);
                }
              },
              preUpdate: function() {
                this.pluginEvents.emit(Events.PRE_UPDATE);
                var removeList = this._pendingRemoval;
                var insertList = this._pendingInsertion;
                var toRemove = removeList.length;
                var toInsert = insertList.length;
                if (toRemove === 0 && toInsert === 0) {
                  return;
                }
                var current = this._list;
                for (var i = 0; i < toRemove; i++) {
                  var gameObject = removeList[i];
                  var index = current.indexOf(gameObject);
                  if (index > -1) {
                    current.splice(index, 1);
                    this.clear(gameObject, true);
                  }
                }
                this._pendingRemoval.length = 0;
                this._list = current.concat(insertList.splice(0));
              },
              isActive: function() {
                return this.enabled && this.scene.sys.canInput();
              },
              updatePoll: function(time, delta) {
                if (!this.isActive()) {
                  return false;
                }
                this.pluginEvents.emit(Events.UPDATE, time, delta);
                if (this._updatedThisFrame) {
                  this._updatedThisFrame = false;
                  return false;
                }
                var i;
                var manager = this.manager;
                var pointers = manager.pointers;
                var pointersTotal = manager.pointersTotal;
                for (i = 0; i < pointersTotal; i++) {
                  pointers[i].updateMotion();
                }
                if (this._list.length === 0) {
                  return false;
                }
                var rate = this.pollRate;
                if (rate === -1) {
                  return false;
                } else if (rate > 0) {
                  this._pollTimer -= delta;
                  if (this._pollTimer < 0) {
                    this._pollTimer = this.pollRate;
                  } else {
                    return false;
                  }
                }
                var captured = false;
                for (i = 0; i < pointersTotal; i++) {
                  var total = 0;
                  var pointer = pointers[i];
                  this._tempZones = [];
                  this._temp = this.hitTestPointer(pointer);
                  this.sortGameObjects(this._temp, pointer);
                  this.sortDropZones(this._tempZones);
                  if (this.topOnly) {
                    if (this._temp.length) {
                      this._temp.splice(1);
                    }
                    if (this._tempZones.length) {
                      this._tempZones.splice(1);
                    }
                  }
                  total += this.processOverOutEvents(pointer);
                  if (this.getDragState(pointer) === 2) {
                    this.processDragThresholdEvent(pointer, time);
                  }
                  if (total > 0) {
                    captured = true;
                  }
                }
                return captured;
              },
              update: function(type, pointers) {
                if (!this.isActive()) {
                  return false;
                }
                var pointersTotal = pointers.length;
                var captured = false;
                for (var i = 0; i < pointersTotal; i++) {
                  var total = 0;
                  var pointer = pointers[i];
                  this._tempZones = [];
                  this._temp = this.hitTestPointer(pointer);
                  this.sortGameObjects(this._temp, pointer);
                  this.sortDropZones(this._tempZones);
                  if (this.topOnly) {
                    if (this._temp.length) {
                      this._temp.splice(1);
                    }
                    if (this._tempZones.length) {
                      this._tempZones.splice(1);
                    }
                  }
                  switch (type) {
                    case CONST.MOUSE_DOWN:
                      total += this.processDragDownEvent(pointer);
                      total += this.processDownEvents(pointer);
                      total += this.processOverOutEvents(pointer);
                      break;
                    case CONST.MOUSE_UP:
                      total += this.processDragUpEvent(pointer);
                      total += this.processUpEvents(pointer);
                      total += this.processOverOutEvents(pointer);
                      break;
                    case CONST.TOUCH_START:
                      total += this.processDragDownEvent(pointer);
                      total += this.processDownEvents(pointer);
                      total += this.processOverEvents(pointer);
                      break;
                    case CONST.TOUCH_END:
                    case CONST.TOUCH_CANCEL:
                      total += this.processDragUpEvent(pointer);
                      total += this.processUpEvents(pointer);
                      total += this.processOutEvents(pointer);
                      break;
                    case CONST.MOUSE_MOVE:
                    case CONST.TOUCH_MOVE:
                      total += this.processDragMoveEvent(pointer);
                      total += this.processMoveEvents(pointer);
                      total += this.processOverOutEvents(pointer);
                      break;
                    case CONST.MOUSE_WHEEL:
                      total += this.processWheelEvent(pointer);
                      break;
                  }
                  if (total > 0) {
                    captured = true;
                  }
                }
                this._updatedThisFrame = true;
                return captured;
              },
              clear: function(gameObject, skipQueue) {
                if (skipQueue === void 0) {
                  skipQueue = false;
                }
                this.disable(gameObject);
                var input = gameObject.input;
                if (input) {
                  this.removeDebug(gameObject);
                  input.gameObject = void 0;
                  input.target = void 0;
                  input.hitArea = void 0;
                  input.hitAreaCallback = void 0;
                  input.callbackContext = void 0;
                  gameObject.input = null;
                }
                if (!skipQueue) {
                  this.queueForRemoval(gameObject);
                }
                var index = this._draggable.indexOf(gameObject);
                if (index > -1) {
                  this._draggable.splice(index, 1);
                }
                return gameObject;
              },
              disable: function(gameObject) {
                var input = gameObject.input;
                if (input) {
                  input.enabled = false;
                  input.dragState = 0;
                }
                var temp = this._temp;
                var drag = this._drag;
                var over = this._over;
                var manager = this.manager;
                var index = temp.indexOf(gameObject);
                if (index > -1) {
                  temp.splice(index, 1);
                }
                for (var i = 0; i < manager.pointersTotal; i++) {
                  index = drag[i].indexOf(gameObject);
                  if (index > -1) {
                    drag[i].splice(index, 1);
                  }
                  index = over[i].indexOf(gameObject);
                  if (index > -1) {
                    over[i].splice(index, 1);
                    manager.resetCursor(input);
                  }
                }
                return this;
              },
              enable: function(gameObject, hitArea, hitAreaCallback, dropZone) {
                if (dropZone === void 0) {
                  dropZone = false;
                }
                if (gameObject.input) {
                  gameObject.input.enabled = true;
                } else {
                  this.setHitArea(gameObject, hitArea, hitAreaCallback);
                }
                if (gameObject.input && dropZone && !gameObject.input.dropZone) {
                  gameObject.input.dropZone = dropZone;
                }
                return this;
              },
              hitTestPointer: function(pointer) {
                var cameras = this.cameras.getCamerasBelowPointer(pointer);
                for (var c = 0; c < cameras.length; c++) {
                  var camera = cameras[c];
                  var over = this.manager.hitTest(pointer, this._list, camera);
                  for (var i = 0; i < over.length; i++) {
                    var obj = over[i];
                    if (obj.input.dropZone) {
                      this._tempZones.push(obj);
                    }
                  }
                  if (over.length > 0) {
                    pointer.camera = camera;
                    return over;
                  }
                }
                pointer.camera = cameras[0];
                return [];
              },
              processDownEvents: function(pointer) {
                var total = 0;
                var currentlyOver = this._temp;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                for (var i = 0; i < currentlyOver.length; i++) {
                  var gameObject = currentlyOver[i];
                  if (!gameObject.input || !gameObject.input.enabled) {
                    continue;
                  }
                  total++;
                  gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted && this.manager) {
                  if (pointer.downElement === this.manager.game.canvas) {
                    this.emit(Events.POINTER_DOWN, pointer, currentlyOver);
                  } else {
                    this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);
                  }
                }
                return total;
              },
              getDragState: function(pointer) {
                return this._dragState[pointer.id];
              },
              setDragState: function(pointer, state) {
                this._dragState[pointer.id] = state;
              },
              processDragThresholdEvent: function(pointer, time) {
                var passed = false;
                var timeThreshold = this.dragTimeThreshold;
                var distanceThreshold = this.dragDistanceThreshold;
                if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold) {
                  passed = true;
                } else if (timeThreshold > 0 && time >= pointer.downTime + timeThreshold) {
                  passed = true;
                }
                if (passed) {
                  this.setDragState(pointer, 3);
                  return this.processDragStartList(pointer);
                }
              },
              processDragStartList: function(pointer) {
                if (this.getDragState(pointer) !== 3) {
                  return 0;
                }
                var list = this._drag[pointer.id];
                for (var i = 0; i < list.length; i++) {
                  var gameObject = list[i];
                  var input = gameObject.input;
                  input.dragState = 2;
                  input.dragStartX = gameObject.x;
                  input.dragStartY = gameObject.y;
                  input.dragStartXGlobal = pointer.worldX;
                  input.dragStartYGlobal = pointer.worldY;
                  input.dragX = input.dragStartXGlobal - input.dragStartX;
                  input.dragY = input.dragStartYGlobal - input.dragStartY;
                  gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);
                  this.emit(Events.DRAG_START, pointer, gameObject);
                }
                this.setDragState(pointer, 4);
                return list.length;
              },
              processDragDownEvent: function(pointer) {
                var currentlyOver = this._temp;
                if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0) {
                  return 0;
                }
                this.setDragState(pointer, 1);
                var draglist = [];
                for (var i = 0; i < currentlyOver.length; i++) {
                  var gameObject = currentlyOver[i];
                  if (gameObject.input.draggable && gameObject.input.dragState === 0) {
                    draglist.push(gameObject);
                  }
                }
                if (draglist.length === 0) {
                  this.setDragState(pointer, 0);
                  return 0;
                } else if (draglist.length > 1) {
                  this.sortGameObjects(draglist, pointer);
                  if (this.topOnly) {
                    draglist.splice(1);
                  }
                }
                this._drag[pointer.id] = draglist;
                if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0) {
                  this.setDragState(pointer, 3);
                  return this.processDragStartList(pointer);
                } else {
                  this.setDragState(pointer, 2);
                  return 0;
                }
              },
              processDragMoveEvent: function(pointer) {
                if (this.getDragState(pointer) === 2) {
                  this.processDragThresholdEvent(pointer, this.manager.game.loop.now);
                }
                if (this.getDragState(pointer) !== 4) {
                  return 0;
                }
                var dropZones = this._tempZones;
                var list = this._drag[pointer.id];
                for (var i = 0; i < list.length; i++) {
                  var gameObject = list[i];
                  var input = gameObject.input;
                  var target = input.target;
                  if (target) {
                    var index = dropZones.indexOf(target);
                    if (index === 0) {
                      gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);
                      this.emit(Events.DRAG_OVER, pointer, gameObject, target);
                    } else if (index > 0) {
                      gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                      this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                      input.target = dropZones[0];
                      target = input.target;
                      gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                      this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                    } else {
                      gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                      this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                      if (dropZones[0]) {
                        input.target = dropZones[0];
                        target = input.target;
                        gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                        this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                      } else {
                        input.target = null;
                      }
                    }
                  } else if (!target && dropZones[0]) {
                    input.target = dropZones[0];
                    target = input.target;
                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                  }
                  var dragX;
                  var dragY;
                  if (!gameObject.parentContainer) {
                    dragX = pointer.worldX - input.dragX;
                    dragY = pointer.worldY - input.dragY;
                  } else {
                    var dx = pointer.worldX - input.dragStartXGlobal;
                    var dy = pointer.worldY - input.dragStartYGlobal;
                    var rotation = gameObject.getParentRotation();
                    var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);
                    var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);
                    dxRotated *= 1 / gameObject.parentContainer.scaleX;
                    dyRotated *= 1 / gameObject.parentContainer.scaleY;
                    dragX = dxRotated + input.dragStartX;
                    dragY = dyRotated + input.dragStartY;
                  }
                  gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);
                  this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);
                }
                return list.length;
              },
              processDragUpEvent: function(pointer) {
                var list = this._drag[pointer.id];
                for (var i = 0; i < list.length; i++) {
                  var gameObject = list[i];
                  var input = gameObject.input;
                  if (input && input.dragState === 2) {
                    input.dragState = 0;
                    input.dragX = input.localX - gameObject.displayOriginX;
                    input.dragY = input.localY - gameObject.displayOriginY;
                    var dropped = false;
                    var target = input.target;
                    if (target) {
                      gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);
                      this.emit(Events.DROP, pointer, gameObject, target);
                      input.target = null;
                      dropped = true;
                    }
                    if (gameObject.input && gameObject.input.enabled) {
                      gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);
                      this.emit(Events.DRAG_END, pointer, gameObject, dropped);
                    }
                  }
                }
                this.setDragState(pointer, 0);
                list.splice(0);
                return 0;
              },
              processMoveEvents: function(pointer) {
                var total = 0;
                var currentlyOver = this._temp;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                for (var i = 0; i < currentlyOver.length; i++) {
                  var gameObject = currentlyOver[i];
                  if (!gameObject.input || !gameObject.input.enabled) {
                    continue;
                  }
                  total++;
                  gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                    aborted = true;
                    break;
                  }
                  if (this.topOnly) {
                    break;
                  }
                }
                if (!aborted) {
                  this.emit(Events.POINTER_MOVE, pointer, currentlyOver);
                }
                return total;
              },
              processWheelEvent: function(pointer) {
                var total = 0;
                var currentlyOver = this._temp;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                var dx = pointer.deltaX;
                var dy = pointer.deltaY;
                var dz = pointer.deltaZ;
                for (var i = 0; i < currentlyOver.length; i++) {
                  var gameObject = currentlyOver[i];
                  if (!gameObject.input || !gameObject.input.enabled) {
                    continue;
                  }
                  total++;
                  gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted) {
                  this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);
                }
                return total;
              },
              processOverEvents: function(pointer) {
                var currentlyOver = this._temp;
                var totalInteracted = 0;
                var total = currentlyOver.length;
                var justOver = [];
                if (total > 0) {
                  var manager = this.manager;
                  var _eventData = this._eventData;
                  var _eventContainer = this._eventContainer;
                  _eventData.cancelled = false;
                  var aborted = false;
                  for (var i = 0; i < total; i++) {
                    var gameObject = currentlyOver[i];
                    if (!gameObject.input || !gameObject.input.enabled) {
                      continue;
                    }
                    justOver.push(gameObject);
                    manager.setCursor(gameObject.input);
                    gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                    totalInteracted++;
                    if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                      aborted = true;
                      break;
                    }
                    this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
                    if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                      aborted = true;
                      break;
                    }
                  }
                  if (!aborted) {
                    this.emit(Events.POINTER_OVER, pointer, justOver);
                  }
                }
                this._over[pointer.id] = justOver;
                return totalInteracted;
              },
              processOutEvents: function(pointer) {
                var previouslyOver = this._over[pointer.id];
                var totalInteracted = 0;
                var total = previouslyOver.length;
                if (total > 0) {
                  var manager = this.manager;
                  var _eventData = this._eventData;
                  var _eventContainer = this._eventContainer;
                  _eventData.cancelled = false;
                  var aborted = false;
                  this.sortGameObjects(previouslyOver, pointer);
                  for (var i = 0; i < total; i++) {
                    var gameObject = previouslyOver[i];
                    gameObject = previouslyOver[i];
                    if (!gameObject.input || !gameObject.input.enabled) {
                      continue;
                    }
                    manager.resetCursor(gameObject.input);
                    gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
                    totalInteracted++;
                    if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                      aborted = true;
                      break;
                    }
                    this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
                    if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                      aborted = true;
                      break;
                    }
                    if (!aborted) {
                      this.emit(Events.POINTER_OUT, pointer, previouslyOver);
                    }
                  }
                  this._over[pointer.id] = [];
                }
                return totalInteracted;
              },
              processOverOutEvents: function(pointer) {
                var currentlyOver = this._temp;
                var i;
                var gameObject;
                var justOut = [];
                var justOver = [];
                var stillOver = [];
                var previouslyOver = this._over[pointer.id];
                var currentlyDragging = this._drag[pointer.id];
                var manager = this.manager;
                for (i = 0; i < previouslyOver.length; i++) {
                  gameObject = previouslyOver[i];
                  if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1) {
                    justOut.push(gameObject);
                  } else {
                    stillOver.push(gameObject);
                  }
                }
                for (i = 0; i < currentlyOver.length; i++) {
                  gameObject = currentlyOver[i];
                  if (previouslyOver.indexOf(gameObject) === -1) {
                    justOver.push(gameObject);
                  }
                }
                var total = justOut.length;
                var totalInteracted = 0;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                if (total > 0) {
                  this.sortGameObjects(justOut, pointer);
                  for (i = 0; i < total; i++) {
                    gameObject = justOut[i];
                    if (!gameObject.input || !gameObject.input.enabled) {
                      continue;
                    }
                    manager.resetCursor(gameObject.input);
                    gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
                    totalInteracted++;
                    if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                      aborted = true;
                      break;
                    }
                    this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
                    if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                      aborted = true;
                      break;
                    }
                  }
                  if (!aborted) {
                    this.emit(Events.POINTER_OUT, pointer, justOut);
                  }
                }
                total = justOver.length;
                _eventData.cancelled = false;
                aborted = false;
                if (total > 0) {
                  this.sortGameObjects(justOver, pointer);
                  for (i = 0; i < total; i++) {
                    gameObject = justOver[i];
                    if (!gameObject.input || !gameObject.input.enabled) {
                      continue;
                    }
                    manager.setCursor(gameObject.input);
                    gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                    totalInteracted++;
                    if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                      aborted = true;
                      break;
                    }
                    this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
                    if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                      aborted = true;
                      break;
                    }
                  }
                  if (!aborted) {
                    this.emit(Events.POINTER_OVER, pointer, justOver);
                  }
                }
                previouslyOver = stillOver.concat(justOver);
                this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);
                return totalInteracted;
              },
              processUpEvents: function(pointer) {
                var currentlyOver = this._temp;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                for (var i = 0; i < currentlyOver.length; i++) {
                  var gameObject = currentlyOver[i];
                  if (!gameObject.input || !gameObject.input.enabled) {
                    continue;
                  }
                  gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted && this.manager) {
                  if (pointer.upElement === this.manager.game.canvas) {
                    this.emit(Events.POINTER_UP, pointer, currentlyOver);
                  } else {
                    this.emit(Events.POINTER_UP_OUTSIDE, pointer);
                  }
                }
                return currentlyOver.length;
              },
              queueForInsertion: function(child) {
                if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1) {
                  this._pendingInsertion.push(child);
                }
                return this;
              },
              queueForRemoval: function(child) {
                this._pendingRemoval.push(child);
                return this;
              },
              setDraggable: function(gameObjects, value) {
                if (value === void 0) {
                  value = true;
                }
                if (!Array.isArray(gameObjects)) {
                  gameObjects = [gameObjects];
                }
                for (var i = 0; i < gameObjects.length; i++) {
                  var gameObject = gameObjects[i];
                  gameObject.input.draggable = value;
                  var index = this._draggable.indexOf(gameObject);
                  if (value && index === -1) {
                    this._draggable.push(gameObject);
                  } else if (!value && index > -1) {
                    this._draggable.splice(index, 1);
                  }
                }
                return this;
              },
              makePixelPerfect: function(alphaTolerance) {
                if (alphaTolerance === void 0) {
                  alphaTolerance = 1;
                }
                var textureManager = this.systems.textures;
                return CreatePixelPerfectHandler(textureManager, alphaTolerance);
              },
              setHitArea: function(gameObjects, hitArea, hitAreaCallback) {
                if (hitArea === void 0) {
                  return this.setHitAreaFromTexture(gameObjects);
                }
                if (!Array.isArray(gameObjects)) {
                  gameObjects = [gameObjects];
                }
                var draggable = false;
                var dropZone = false;
                var cursor = false;
                var useHandCursor = false;
                var pixelPerfect = false;
                var customHitArea = true;
                if (IsPlainObject(hitArea)) {
                  var config2 = hitArea;
                  hitArea = GetFastValue(config2, "hitArea", null);
                  hitAreaCallback = GetFastValue(config2, "hitAreaCallback", null);
                  draggable = GetFastValue(config2, "draggable", false);
                  dropZone = GetFastValue(config2, "dropZone", false);
                  cursor = GetFastValue(config2, "cursor", false);
                  useHandCursor = GetFastValue(config2, "useHandCursor", false);
                  pixelPerfect = GetFastValue(config2, "pixelPerfect", false);
                  var alphaTolerance = GetFastValue(config2, "alphaTolerance", 1);
                  if (pixelPerfect) {
                    hitArea = {};
                    hitAreaCallback = this.makePixelPerfect(alphaTolerance);
                  }
                  if (!hitArea || !hitAreaCallback) {
                    this.setHitAreaFromTexture(gameObjects);
                    customHitArea = false;
                  }
                } else if (typeof hitArea === "function" && !hitAreaCallback) {
                  hitAreaCallback = hitArea;
                  hitArea = {};
                }
                for (var i = 0; i < gameObjects.length; i++) {
                  var gameObject = gameObjects[i];
                  if (pixelPerfect && gameObject.type === "Container") {
                    console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
                    continue;
                  }
                  var io = !gameObject.input ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;
                  io.customHitArea = customHitArea;
                  io.dropZone = dropZone;
                  io.cursor = useHandCursor ? "pointer" : cursor;
                  gameObject.input = io;
                  if (draggable) {
                    this.setDraggable(gameObject);
                  }
                  this.queueForInsertion(gameObject);
                }
                return this;
              },
              setHitAreaCircle: function(gameObjects, x, y, radius, callback) {
                if (callback === void 0) {
                  callback = CircleContains;
                }
                var shape = new Circle(x, y, radius);
                return this.setHitArea(gameObjects, shape, callback);
              },
              setHitAreaEllipse: function(gameObjects, x, y, width, height, callback) {
                if (callback === void 0) {
                  callback = EllipseContains;
                }
                var shape = new Ellipse(x, y, width, height);
                return this.setHitArea(gameObjects, shape, callback);
              },
              setHitAreaFromTexture: function(gameObjects, callback) {
                if (callback === void 0) {
                  callback = RectangleContains;
                }
                if (!Array.isArray(gameObjects)) {
                  gameObjects = [gameObjects];
                }
                for (var i = 0; i < gameObjects.length; i++) {
                  var gameObject = gameObjects[i];
                  var frame = gameObject.frame;
                  var width = 0;
                  var height = 0;
                  if (gameObject.width) {
                    width = gameObject.width;
                    height = gameObject.height;
                  } else if (frame) {
                    width = frame.realWidth;
                    height = frame.realHeight;
                  }
                  if (gameObject.type === "Container" && (width === 0 || height === 0)) {
                    console.warn("Container.setInteractive must specify a Shape or call setSize() first");
                    continue;
                  }
                  if (width !== 0 && height !== 0) {
                    gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);
                    this.queueForInsertion(gameObject);
                  }
                }
                return this;
              },
              setHitAreaRectangle: function(gameObjects, x, y, width, height, callback) {
                if (callback === void 0) {
                  callback = RectangleContains;
                }
                var shape = new Rectangle(x, y, width, height);
                return this.setHitArea(gameObjects, shape, callback);
              },
              setHitAreaTriangle: function(gameObjects, x1, y1, x2, y2, x3, y3, callback) {
                if (callback === void 0) {
                  callback = TriangleContains;
                }
                var shape = new Triangle(x1, y1, x2, y2, x3, y3);
                return this.setHitArea(gameObjects, shape, callback);
              },
              enableDebug: function(gameObject, color) {
                if (color === void 0) {
                  color = 65280;
                }
                var input = gameObject.input;
                if (!input || !input.hitArea) {
                  return this;
                }
                var shape = input.hitArea;
                var shapeType = shape.type;
                var debug = input.hitAreaDebug;
                var factory = this.systems.add;
                var updateList = this.systems.updateList;
                if (debug) {
                  updateList.remove(debug);
                  debug.destroy();
                  debug = null;
                }
                var offsetx = 0;
                var offsety = 0;
                switch (shapeType) {
                  case GEOM_CONST.CIRCLE:
                    debug = factory.arc(0, 0, shape.radius);
                    offsetx = shape.x - shape.radius;
                    offsety = shape.y - shape.radius;
                    break;
                  case GEOM_CONST.ELLIPSE:
                    debug = factory.ellipse(0, 0, shape.width, shape.height);
                    offsetx = shape.x - shape.width / 2;
                    offsety = shape.y - shape.height / 2;
                    break;
                  case GEOM_CONST.LINE:
                    debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);
                    break;
                  case GEOM_CONST.POLYGON:
                    debug = factory.polygon(0, 0, shape.points);
                    break;
                  case GEOM_CONST.RECTANGLE:
                    debug = factory.rectangle(0, 0, shape.width, shape.height);
                    offsetx = shape.x;
                    offsety = shape.y;
                    break;
                  case GEOM_CONST.TRIANGLE:
                    debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
                    break;
                }
                if (debug) {
                  debug.isFilled = false;
                  debug.strokeColor = color;
                  debug.preUpdate = function() {
                    debug.setStrokeStyle(1 / gameObject.scale, debug.strokeColor);
                    debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);
                    var x = gameObject.x;
                    var y = gameObject.y;
                    var rotation = gameObject.rotation;
                    var scaleX = gameObject.scaleX;
                    var scaleY = gameObject.scaleY;
                    if (gameObject.parentContainer) {
                      var matrix = gameObject.getWorldTransformMatrix();
                      x = matrix.tx;
                      y = matrix.ty;
                      rotation = matrix.rotation;
                      scaleX = matrix.scaleX;
                      scaleY = matrix.scaleY;
                    }
                    debug.setRotation(rotation);
                    debug.setScale(scaleX, scaleY);
                    debug.setPosition(x + offsetx * scaleX, y + offsety * scaleY);
                    debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);
                    debug.setDepth(gameObject.depth);
                  };
                  updateList.add(debug);
                  input.hitAreaDebug = debug;
                }
                return this;
              },
              removeDebug: function(gameObject) {
                var input = gameObject.input;
                if (input && input.hitAreaDebug) {
                  var debug = input.hitAreaDebug;
                  this.systems.updateList.remove(debug);
                  debug.destroy();
                  input.hitAreaDebug = null;
                }
                return this;
              },
              setPollAlways: function() {
                return this.setPollRate(0);
              },
              setPollOnMove: function() {
                return this.setPollRate(-1);
              },
              setPollRate: function(value) {
                this.pollRate = value;
                this._pollTimer = 0;
                return this;
              },
              setGlobalTopOnly: function(value) {
                this.manager.globalTopOnly = value;
                return this;
              },
              setTopOnly: function(value) {
                this.topOnly = value;
                return this;
              },
              sortGameObjects: function(gameObjects, pointer) {
                if (gameObjects.length < 2 || !pointer.camera) {
                  return gameObjects;
                }
                var list = pointer.camera.renderList;
                return gameObjects.sort(function(childA, childB) {
                  var indexA = Math.max(list.indexOf(childA), 0);
                  var indexB = Math.max(list.indexOf(childB), 0);
                  return indexB - indexA;
                });
              },
              sortDropZones: function(gameObjects) {
                if (gameObjects.length < 2) {
                  return gameObjects;
                }
                this.scene.sys.depthSort();
                return gameObjects.sort(this.sortDropZoneHandler.bind(this));
              },
              sortDropZoneHandler: function(childA, childB) {
                if (!childA.parentContainer && !childB.parentContainer) {
                  return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);
                } else if (childA.parentContainer === childB.parentContainer) {
                  return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);
                } else if (childA.parentContainer === childB) {
                  return -1;
                } else if (childB.parentContainer === childA) {
                  return 1;
                } else {
                  var listA = childA.getIndexList();
                  var listB = childB.getIndexList();
                  var len = Math.min(listA.length, listB.length);
                  for (var i = 0; i < len; i++) {
                    var indexA = listA[i];
                    var indexB = listB[i];
                    if (indexA === indexB) {
                      continue;
                    } else {
                      return indexB - indexA;
                    }
                  }
                  return listB.length - listA.length;
                }
                return 0;
              },
              stopPropagation: function() {
                this.manager._tempSkip = true;
                return this;
              },
              addPointer: function(quantity) {
                return this.manager.addPointer(quantity);
              },
              setDefaultCursor: function(cursor) {
                this.manager.setDefaultCursor(cursor);
                return this;
              },
              transitionIn: function() {
                this.enabled = this.settings.transitionAllowInput;
              },
              transitionComplete: function() {
                if (!this.settings.transitionAllowInput) {
                  this.enabled = true;
                }
              },
              transitionOut: function() {
                this.enabled = this.settings.transitionAllowInput;
              },
              shutdown: function() {
                this.pluginEvents.emit(Events.SHUTDOWN);
                this._temp.length = 0;
                this._list.length = 0;
                this._draggable.length = 0;
                this._pendingRemoval.length = 0;
                this._pendingInsertion.length = 0;
                this._dragState.length = 0;
                for (var i = 0; i < 10; i++) {
                  this._drag[i] = [];
                  this._over[i] = [];
                }
                this.removeAllListeners();
                var manager = this.manager;
                manager.canvas.style.cursor = manager.defaultCursor;
                var eventEmitter = this.systems.events;
                eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);
                eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
                eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
                eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
                manager.events.off(Events.GAME_OUT, this.onGameOut, this);
                manager.events.off(Events.GAME_OVER, this.onGameOver, this);
                eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              resetPointers: function() {
                var pointers = this.manager.pointers;
                for (var i = 0; i < pointers.length; i++) {
                  pointers[i].reset();
                }
              },
              destroy: function() {
                this.shutdown();
                this.pluginEvents.emit(Events.DESTROY);
                this.pluginEvents.removeAllListeners();
                this.scene.sys.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.cameras = null;
                this.manager = null;
                this.events = null;
                this.mouse = null;
              },
              x: {
                get: function() {
                  return this.manager.activePointer.x;
                }
              },
              y: {
                get: function() {
                  return this.manager.activePointer.y;
                }
              },
              isOver: {
                get: function() {
                  return this.manager.isOver;
                }
              },
              mousePointer: {
                get: function() {
                  return this.manager.mousePointer;
                }
              },
              activePointer: {
                get: function() {
                  return this.manager.activePointer;
                }
              },
              pointer1: {
                get: function() {
                  return this.manager.pointers[1];
                }
              },
              pointer2: {
                get: function() {
                  return this.manager.pointers[2];
                }
              },
              pointer3: {
                get: function() {
                  return this.manager.pointers[3];
                }
              },
              pointer4: {
                get: function() {
                  return this.manager.pointers[4];
                }
              },
              pointer5: {
                get: function() {
                  return this.manager.pointers[5];
                }
              },
              pointer6: {
                get: function() {
                  return this.manager.pointers[6];
                }
              },
              pointer7: {
                get: function() {
                  return this.manager.pointers[7];
                }
              },
              pointer8: {
                get: function() {
                  return this.manager.pointers[8];
                }
              },
              pointer9: {
                get: function() {
                  return this.manager.pointers[9];
                }
              },
              pointer10: {
                get: function() {
                  return this.manager.pointers[10];
                }
              }
            });
            PluginCache.register("InputPlugin", InputPlugin, "input");
            module2.exports = InputPlugin;
          },
          63399: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetValue = __webpack_require__2(10850);
            var inputPlugins = {};
            var InputPluginCache = {};
            InputPluginCache.register = function(key, plugin, mapping, settingsKey, configKey) {
              inputPlugins[key] = {plugin, mapping, settingsKey, configKey};
            };
            InputPluginCache.getPlugin = function(key) {
              return inputPlugins[key];
            };
            InputPluginCache.install = function(target) {
              var sys = target.scene.sys;
              var settings = sys.settings.input;
              var config2 = sys.game.config;
              for (var key in inputPlugins) {
                var source = inputPlugins[key].plugin;
                var mapping = inputPlugins[key].mapping;
                var settingsKey = inputPlugins[key].settingsKey;
                var configKey = inputPlugins[key].configKey;
                if (GetValue(settings, settingsKey, config2[configKey])) {
                  target[mapping] = new source(target);
                }
              }
            };
            InputPluginCache.remove = function(key) {
              if (inputPlugins.hasOwnProperty(key)) {
                delete inputPlugins[key];
              }
            };
            module2.exports = InputPluginCache;
          },
          40398: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Angle = __webpack_require__2(90447);
            var Class = __webpack_require__2(56694);
            var Distance = __webpack_require__2(53996);
            var FuzzyEqual = __webpack_require__2(88456);
            var SmoothStepInterpolation = __webpack_require__2(44521);
            var Vector2 = __webpack_require__2(93736);
            var OS = __webpack_require__2(36580);
            var Pointer = new Class({
              initialize: function Pointer2(manager, id) {
                this.manager = manager;
                this.id = id;
                this.event;
                this.downElement;
                this.upElement;
                this.camera = null;
                this.button = 0;
                this.buttons = 0;
                this.position = new Vector2();
                this.prevPosition = new Vector2();
                this.midPoint = new Vector2(-1, -1);
                this.velocity = new Vector2();
                this.angle = 0;
                this.distance = 0;
                this.smoothFactor = 0;
                this.motionFactor = 0.2;
                this.worldX = 0;
                this.worldY = 0;
                this.moveTime = 0;
                this.downX = 0;
                this.downY = 0;
                this.downTime = 0;
                this.upX = 0;
                this.upY = 0;
                this.upTime = 0;
                this.primaryDown = false;
                this.isDown = false;
                this.wasTouch = false;
                this.wasCanceled = false;
                this.movementX = 0;
                this.movementY = 0;
                this.identifier = 0;
                this.pointerId = null;
                this.active = id === 0 ? true : false;
                this.locked = false;
                this.deltaX = 0;
                this.deltaY = 0;
                this.deltaZ = 0;
              },
              updateWorldPoint: function(camera) {
                var temp = camera.getWorldPoint(this.x, this.y);
                this.worldX = temp.x;
                this.worldY = temp.y;
                return this;
              },
              positionToCamera: function(camera, output) {
                return camera.getWorldPoint(this.x, this.y, output);
              },
              updateMotion: function() {
                var cx = this.position.x;
                var cy = this.position.y;
                var mx = this.midPoint.x;
                var my = this.midPoint.y;
                if (cx === mx && cy === my) {
                  return;
                }
                var vx = SmoothStepInterpolation(this.motionFactor, mx, cx);
                var vy = SmoothStepInterpolation(this.motionFactor, my, cy);
                if (FuzzyEqual(vx, cx, 0.1)) {
                  vx = cx;
                }
                if (FuzzyEqual(vy, cy, 0.1)) {
                  vy = cy;
                }
                this.midPoint.set(vx, vy);
                var dx = cx - vx;
                var dy = cy - vy;
                this.velocity.set(dx, dy);
                this.angle = Angle(vx, vy, cx, cy);
                this.distance = Math.sqrt(dx * dx + dy * dy);
              },
              up: function(event) {
                if ("buttons" in event) {
                  this.buttons = event.buttons;
                }
                this.event = event;
                this.button = event.button;
                this.upElement = event.target;
                this.manager.transformPointer(this, event.pageX, event.pageY, false);
                if (event.button === 0) {
                  this.primaryDown = false;
                  this.upX = this.x;
                  this.upY = this.y;
                }
                if (this.buttons === 0) {
                  this.isDown = false;
                  this.upTime = event.timeStamp;
                  this.wasTouch = false;
                }
              },
              down: function(event) {
                if ("buttons" in event) {
                  this.buttons = event.buttons;
                }
                this.event = event;
                this.button = event.button;
                this.downElement = event.target;
                this.manager.transformPointer(this, event.pageX, event.pageY, false);
                if (event.button === 0) {
                  this.primaryDown = true;
                  this.downX = this.x;
                  this.downY = this.y;
                }
                if (OS.macOS && event.ctrlKey) {
                  this.buttons = 2;
                  this.primaryDown = false;
                }
                if (!this.isDown) {
                  this.isDown = true;
                  this.downTime = event.timeStamp;
                }
                this.wasTouch = false;
              },
              move: function(event) {
                if ("buttons" in event) {
                  this.buttons = event.buttons;
                }
                this.event = event;
                this.manager.transformPointer(this, event.pageX, event.pageY, true);
                if (this.locked) {
                  this.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                  this.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                }
                this.moveTime = event.timeStamp;
                this.wasTouch = false;
              },
              wheel: function(event) {
                if ("buttons" in event) {
                  this.buttons = event.buttons;
                }
                this.event = event;
                this.manager.transformPointer(this, event.pageX, event.pageY, false);
                this.deltaX = event.deltaX;
                this.deltaY = event.deltaY;
                this.deltaZ = event.deltaZ;
                this.wasTouch = false;
              },
              touchstart: function(touch, event) {
                if (touch["pointerId"]) {
                  this.pointerId = touch.pointerId;
                }
                this.identifier = touch.identifier;
                this.target = touch.target;
                this.active = true;
                this.buttons = 1;
                this.event = event;
                this.downElement = touch.target;
                this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
                this.primaryDown = true;
                this.downX = this.x;
                this.downY = this.y;
                this.downTime = event.timeStamp;
                this.isDown = true;
                this.wasTouch = true;
                this.wasCanceled = false;
                this.updateMotion();
              },
              touchmove: function(touch, event) {
                this.event = event;
                this.manager.transformPointer(this, touch.pageX, touch.pageY, true);
                this.moveTime = event.timeStamp;
                this.wasTouch = true;
                this.updateMotion();
              },
              touchend: function(touch, event) {
                this.buttons = 0;
                this.event = event;
                this.upElement = touch.target;
                this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
                this.primaryDown = false;
                this.upX = this.x;
                this.upY = this.y;
                this.upTime = event.timeStamp;
                this.isDown = false;
                this.wasTouch = true;
                this.wasCanceled = false;
                this.active = false;
                this.updateMotion();
              },
              touchcancel: function(touch, event) {
                this.buttons = 0;
                this.event = event;
                this.upElement = touch.target;
                this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
                this.primaryDown = false;
                this.upX = this.x;
                this.upY = this.y;
                this.upTime = event.timeStamp;
                this.isDown = false;
                this.wasTouch = true;
                this.wasCanceled = true;
                this.active = false;
              },
              noButtonDown: function() {
                return this.buttons === 0;
              },
              leftButtonDown: function() {
                return this.buttons & 1 ? true : false;
              },
              rightButtonDown: function() {
                return this.buttons & 2 ? true : false;
              },
              middleButtonDown: function() {
                return this.buttons & 4 ? true : false;
              },
              backButtonDown: function() {
                return this.buttons & 8 ? true : false;
              },
              forwardButtonDown: function() {
                return this.buttons & 16 ? true : false;
              },
              leftButtonReleased: function() {
                return this.button === 0 && !this.isDown;
              },
              rightButtonReleased: function() {
                return this.button === 2 && !this.isDown;
              },
              middleButtonReleased: function() {
                return this.button === 1 && !this.isDown;
              },
              backButtonReleased: function() {
                return this.button === 3 && !this.isDown;
              },
              forwardButtonReleased: function() {
                return this.button === 4 && !this.isDown;
              },
              getDistance: function() {
                if (this.isDown) {
                  return Distance(this.downX, this.downY, this.x, this.y);
                } else {
                  return Distance(this.downX, this.downY, this.upX, this.upY);
                }
              },
              getDistanceX: function() {
                if (this.isDown) {
                  return Math.abs(this.downX - this.x);
                } else {
                  return Math.abs(this.downX - this.upX);
                }
              },
              getDistanceY: function() {
                if (this.isDown) {
                  return Math.abs(this.downY - this.y);
                } else {
                  return Math.abs(this.downY - this.upY);
                }
              },
              getDuration: function() {
                if (this.isDown) {
                  return this.manager.time - this.downTime;
                } else {
                  return this.upTime - this.downTime;
                }
              },
              getAngle: function() {
                if (this.isDown) {
                  return Angle(this.downX, this.downY, this.x, this.y);
                } else {
                  return Angle(this.downX, this.downY, this.upX, this.upY);
                }
              },
              getInterpolatedPosition: function(steps, out) {
                if (steps === void 0) {
                  steps = 10;
                }
                if (out === void 0) {
                  out = [];
                }
                var prevX = this.prevPosition.x;
                var prevY = this.prevPosition.y;
                var curX = this.position.x;
                var curY = this.position.y;
                for (var i = 0; i < steps; i++) {
                  var t = 1 / steps * i;
                  out[i] = {x: SmoothStepInterpolation(t, prevX, curX), y: SmoothStepInterpolation(t, prevY, curY)};
                }
                return out;
              },
              reset: function() {
                this.event = null;
                this.downElement = null;
                this.upElement = null;
                this.button = 0;
                this.buttons = 0;
                this.position.set(0, 0);
                this.prevPosition.set(0, 0);
                this.midPoint.set(-1, -1);
                this.velocity.set(0, 0);
                this.angle = 0;
                this.distance = 0;
                this.worldX = 0;
                this.worldY = 0;
                this.downX = 0;
                this.downY = 0;
                this.upX = 0;
                this.upY = 0;
                this.moveTime = 0;
                this.upTime = 0;
                this.downTime = 0;
                this.primaryDown = false;
                this.isDown = false;
                this.wasTouch = false;
                this.wasCanceled = false;
                this.movementX = 0;
                this.movementY = 0;
                this.identifier = 0;
                this.pointerId = null;
                this.deltaX = 0;
                this.deltaY = 0;
                this.deltaZ = 0;
                this.active = this.id === 0 ? true : false;
              },
              destroy: function() {
                this.camera = null;
                this.manager = null;
                this.position = null;
              },
              x: {
                get: function() {
                  return this.position.x;
                },
                set: function(value) {
                  this.position.x = value;
                }
              },
              y: {
                get: function() {
                  return this.position.y;
                },
                set: function(value) {
                  this.position.y = value;
                }
              },
              time: {
                get: function() {
                  return this.event ? this.event.timeStamp : 0;
                }
              }
            });
            module2.exports = Pointer;
          },
          72687: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var INPUT_CONST = {
              MOUSE_DOWN: 0,
              MOUSE_MOVE: 1,
              MOUSE_UP: 2,
              TOUCH_START: 3,
              TOUCH_MOVE: 4,
              TOUCH_END: 5,
              POINTER_LOCK_CHANGE: 6,
              TOUCH_CANCEL: 7,
              MOUSE_WHEEL: 8
            };
            module2.exports = INPUT_CONST;
          },
          14874: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "boot";
          },
          54168: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "destroy";
          },
          526: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragend";
          },
          81623: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragenter";
          },
          94472: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "drag";
          },
          9304: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragleave";
          },
          34265: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragover";
          },
          50151: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragstart";
          },
          98134: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "drop";
          },
          56773: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "gameobjectdown";
          },
          45824: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragend";
          },
          39578: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragenter";
          },
          72072: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "drag";
          },
          82569: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragleave";
          },
          70833: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragover";
          },
          81442: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragstart";
          },
          32936: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "drop";
          },
          99658: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "gameobjectmove";
          },
          60515: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "gameobjectout";
          },
          55254: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "gameobjectover";
          },
          34782: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerdown";
          },
          41769: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointermove";
          },
          65588: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerout";
          },
          61640: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerover";
          },
          49342: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerup";
          },
          82662: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "wheel";
          },
          13058: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "gameobjectup";
          },
          52426: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "gameobjectwheel";
          },
          78072: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "gameout";
          },
          1545: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "gameover";
          },
          67137: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "boot";
          },
          27678: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "process";
          },
          22257: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "update";
          },
          90379: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerlockchange";
          },
          88909: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerdown";
          },
          36548: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerdownoutside";
          },
          18483: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointermove";
          },
          22355: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerout";
          },
          7997: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerover";
          },
          66318: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerup";
          },
          94812: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pointerupoutside";
          },
          37310: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "wheel";
          },
          24196: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "preupdate";
          },
          27053: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "shutdown";
          },
          29413: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "start";
          },
          25165: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "update";
          },
          33963: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BOOT: __webpack_require__2(14874),
              DESTROY: __webpack_require__2(54168),
              DRAG_END: __webpack_require__2(526),
              DRAG_ENTER: __webpack_require__2(81623),
              DRAG: __webpack_require__2(94472),
              DRAG_LEAVE: __webpack_require__2(9304),
              DRAG_OVER: __webpack_require__2(34265),
              DRAG_START: __webpack_require__2(50151),
              DROP: __webpack_require__2(98134),
              GAME_OUT: __webpack_require__2(78072),
              GAME_OVER: __webpack_require__2(1545),
              GAMEOBJECT_DOWN: __webpack_require__2(56773),
              GAMEOBJECT_DRAG_END: __webpack_require__2(45824),
              GAMEOBJECT_DRAG_ENTER: __webpack_require__2(39578),
              GAMEOBJECT_DRAG: __webpack_require__2(72072),
              GAMEOBJECT_DRAG_LEAVE: __webpack_require__2(82569),
              GAMEOBJECT_DRAG_OVER: __webpack_require__2(70833),
              GAMEOBJECT_DRAG_START: __webpack_require__2(81442),
              GAMEOBJECT_DROP: __webpack_require__2(32936),
              GAMEOBJECT_MOVE: __webpack_require__2(99658),
              GAMEOBJECT_OUT: __webpack_require__2(60515),
              GAMEOBJECT_OVER: __webpack_require__2(55254),
              GAMEOBJECT_POINTER_DOWN: __webpack_require__2(34782),
              GAMEOBJECT_POINTER_MOVE: __webpack_require__2(41769),
              GAMEOBJECT_POINTER_OUT: __webpack_require__2(65588),
              GAMEOBJECT_POINTER_OVER: __webpack_require__2(61640),
              GAMEOBJECT_POINTER_UP: __webpack_require__2(49342),
              GAMEOBJECT_POINTER_WHEEL: __webpack_require__2(82662),
              GAMEOBJECT_UP: __webpack_require__2(13058),
              GAMEOBJECT_WHEEL: __webpack_require__2(52426),
              MANAGER_BOOT: __webpack_require__2(67137),
              MANAGER_PROCESS: __webpack_require__2(27678),
              MANAGER_UPDATE: __webpack_require__2(22257),
              POINTER_DOWN: __webpack_require__2(88909),
              POINTER_DOWN_OUTSIDE: __webpack_require__2(36548),
              POINTER_MOVE: __webpack_require__2(18483),
              POINTER_OUT: __webpack_require__2(22355),
              POINTER_OVER: __webpack_require__2(7997),
              POINTER_UP: __webpack_require__2(66318),
              POINTER_UP_OUTSIDE: __webpack_require__2(94812),
              POINTER_WHEEL: __webpack_require__2(37310),
              POINTERLOCK_CHANGE: __webpack_require__2(90379),
              PRE_UPDATE: __webpack_require__2(24196),
              SHUTDOWN: __webpack_require__2(27053),
              START: __webpack_require__2(29413),
              UPDATE: __webpack_require__2(25165)
            };
          },
          70848: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Axis = new Class({
              initialize: function Axis2(pad, index) {
                this.pad = pad;
                this.events = pad.events;
                this.index = index;
                this.value = 0;
                this.threshold = 0.1;
              },
              update: function(value) {
                this.value = value;
              },
              getValue: function() {
                return Math.abs(this.value) < this.threshold ? 0 : this.value;
              },
              destroy: function() {
                this.pad = null;
                this.events = null;
              }
            });
            module2.exports = Axis;
          },
          21274: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(43200);
            var Button = new Class({
              initialize: function Button2(pad, index) {
                this.pad = pad;
                this.events = pad.manager;
                this.index = index;
                this.value = 0;
                this.threshold = 1;
                this.pressed = false;
              },
              update: function(value) {
                this.value = value;
                var pad = this.pad;
                var index = this.index;
                if (value >= this.threshold) {
                  if (!this.pressed) {
                    this.pressed = true;
                    this.events.emit(Events.BUTTON_DOWN, pad, this, value);
                    this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);
                  }
                } else if (this.pressed) {
                  this.pressed = false;
                  this.events.emit(Events.BUTTON_UP, pad, this, value);
                  this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);
                }
              },
              destroy: function() {
                this.pad = null;
                this.events = null;
              }
            });
            module2.exports = Button;
          },
          75956: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Axis = __webpack_require__2(70848);
            var Button = __webpack_require__2(21274);
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Vector2 = __webpack_require__2(93736);
            var Gamepad = new Class({
              Extends: EventEmitter,
              initialize: function Gamepad2(manager, pad) {
                EventEmitter.call(this);
                this.manager = manager;
                this.pad = pad;
                this.id = pad.id;
                this.index = pad.index;
                var buttons = [];
                for (var i = 0; i < pad.buttons.length; i++) {
                  buttons.push(new Button(this, i));
                }
                this.buttons = buttons;
                var axes = [];
                for (i = 0; i < pad.axes.length; i++) {
                  axes.push(new Axis(this, i));
                }
                this.axes = axes;
                this.vibration = pad.vibrationActuator;
                var _noButton = {value: 0, pressed: false};
                this._LCLeft = buttons[14] ? buttons[14] : _noButton;
                this._LCRight = buttons[15] ? buttons[15] : _noButton;
                this._LCTop = buttons[12] ? buttons[12] : _noButton;
                this._LCBottom = buttons[13] ? buttons[13] : _noButton;
                this._RCLeft = buttons[2] ? buttons[2] : _noButton;
                this._RCRight = buttons[1] ? buttons[1] : _noButton;
                this._RCTop = buttons[3] ? buttons[3] : _noButton;
                this._RCBottom = buttons[0] ? buttons[0] : _noButton;
                this._FBLeftTop = buttons[4] ? buttons[4] : _noButton;
                this._FBLeftBottom = buttons[6] ? buttons[6] : _noButton;
                this._FBRightTop = buttons[5] ? buttons[5] : _noButton;
                this._FBRightBottom = buttons[7] ? buttons[7] : _noButton;
                var _noAxis = {value: 0};
                this._HAxisLeft = axes[0] ? axes[0] : _noAxis;
                this._VAxisLeft = axes[1] ? axes[1] : _noAxis;
                this._HAxisRight = axes[2] ? axes[2] : _noAxis;
                this._VAxisRight = axes[3] ? axes[3] : _noAxis;
                this.leftStick = new Vector2();
                this.rightStick = new Vector2();
                this._created = performance.now();
              },
              getAxisTotal: function() {
                return this.axes.length;
              },
              getAxisValue: function(index) {
                return this.axes[index].getValue();
              },
              setAxisThreshold: function(value) {
                for (var i = 0; i < this.axes.length; i++) {
                  this.axes[i].threshold = value;
                }
              },
              getButtonTotal: function() {
                return this.buttons.length;
              },
              getButtonValue: function(index) {
                return this.buttons[index].value;
              },
              isButtonDown: function(index) {
                return this.buttons[index].pressed;
              },
              update: function(pad) {
                if (pad.timestamp < this._created) {
                  return;
                }
                var i;
                var localButtons = this.buttons;
                var gamepadButtons = pad.buttons;
                var len = localButtons.length;
                for (i = 0; i < len; i++) {
                  localButtons[i].update(gamepadButtons[i].value);
                }
                var localAxes = this.axes;
                var gamepadAxes = pad.axes;
                len = localAxes.length;
                for (i = 0; i < len; i++) {
                  localAxes[i].update(gamepadAxes[i]);
                }
                if (len >= 2) {
                  this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());
                  if (len >= 4) {
                    this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());
                  }
                }
              },
              destroy: function() {
                this.removeAllListeners();
                this.manager = null;
                this.pad = null;
                var i;
                for (i = 0; i < this.buttons.length; i++) {
                  this.buttons[i].destroy();
                }
                for (i = 0; i < this.axes.length; i++) {
                  this.axes[i].destroy();
                }
                this.buttons = [];
                this.axes = [];
              },
              connected: {
                get: function() {
                  return this.pad.connected;
                }
              },
              timestamp: {
                get: function() {
                  return this.pad.timestamp;
                }
              },
              left: {
                get: function() {
                  return this._LCLeft.pressed;
                }
              },
              right: {
                get: function() {
                  return this._LCRight.pressed;
                }
              },
              up: {
                get: function() {
                  return this._LCTop.pressed;
                }
              },
              down: {
                get: function() {
                  return this._LCBottom.pressed;
                }
              },
              A: {
                get: function() {
                  return this._RCBottom.pressed;
                }
              },
              Y: {
                get: function() {
                  return this._RCTop.pressed;
                }
              },
              X: {
                get: function() {
                  return this._RCLeft.pressed;
                }
              },
              B: {
                get: function() {
                  return this._RCRight.pressed;
                }
              },
              L1: {
                get: function() {
                  return this._FBLeftTop.value;
                }
              },
              L2: {
                get: function() {
                  return this._FBLeftBottom.value;
                }
              },
              R1: {
                get: function() {
                  return this._FBRightTop.value;
                }
              },
              R2: {
                get: function() {
                  return this._FBRightBottom.value;
                }
              }
            });
            module2.exports = Gamepad;
          },
          1379: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(43200);
            var Gamepad = __webpack_require__2(75956);
            var GetValue = __webpack_require__2(10850);
            var InputPluginCache = __webpack_require__2(63399);
            var InputEvents = __webpack_require__2(33963);
            var GamepadPlugin = new Class({
              Extends: EventEmitter,
              initialize: function GamepadPlugin2(sceneInputPlugin) {
                EventEmitter.call(this);
                this.scene = sceneInputPlugin.scene;
                this.settings = this.scene.sys.settings;
                this.sceneInputPlugin = sceneInputPlugin;
                this.enabled = true;
                this.target;
                this.gamepads = [];
                this.queue = [];
                this.onGamepadHandler;
                this._pad1;
                this._pad2;
                this._pad3;
                this._pad4;
                sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
                sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
              },
              boot: function() {
                var game = this.scene.sys.game;
                var settings = this.settings.input;
                var config2 = game.config;
                this.enabled = GetValue(settings, "gamepad", config2.inputGamepad) && game.device.input.gamepads;
                this.target = GetValue(settings, "gamepad.target", config2.inputGamepadEventTarget);
                this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                if (this.enabled) {
                  this.startListeners();
                  this.refreshPads();
                }
                this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
              },
              isActive: function() {
                return this.enabled && this.scene.sys.isActive();
              },
              startListeners: function() {
                var _this = this;
                var target = this.target;
                var handler = function(event) {
                  if (event.defaultPrevented || !_this.isActive()) {
                    return;
                  }
                  _this.refreshPads();
                  _this.queue.push(event);
                };
                this.onGamepadHandler = handler;
                target.addEventListener("gamepadconnected", handler, false);
                target.addEventListener("gamepaddisconnected", handler, false);
                this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);
              },
              stopListeners: function() {
                this.target.removeEventListener("gamepadconnected", this.onGamepadHandler);
                this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler);
                this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);
                for (var i = 0; i < this.gamepads.length; i++) {
                  this.gamepads[i].removeAllListeners();
                }
              },
              disconnectAll: function() {
                for (var i = 0; i < this.gamepads.length; i++) {
                  this.gamepads[i].pad.connected = false;
                }
              },
              refreshPads: function() {
                var connectedPads = navigator.getGamepads();
                if (!connectedPads) {
                  this.disconnectAll();
                } else {
                  var currentPads = this.gamepads;
                  for (var i = 0; i < connectedPads.length; i++) {
                    var livePad = connectedPads[i];
                    if (!livePad) {
                      continue;
                    }
                    var id = livePad.id;
                    var index = livePad.index;
                    var currentPad = currentPads[index];
                    if (!currentPad) {
                      var newPad = new Gamepad(this, livePad);
                      currentPads[index] = newPad;
                      if (!this._pad1) {
                        this._pad1 = newPad;
                      } else if (!this._pad2) {
                        this._pad2 = newPad;
                      } else if (!this._pad3) {
                        this._pad3 = newPad;
                      } else if (!this._pad4) {
                        this._pad4 = newPad;
                      }
                    } else if (currentPad.id !== id) {
                      currentPad.destroy();
                      currentPads[index] = new Gamepad(this, livePad);
                    } else {
                      currentPad.update(livePad);
                    }
                  }
                }
              },
              getAll: function() {
                var out = [];
                var pads = this.gamepads;
                for (var i = 0; i < pads.length; i++) {
                  if (pads[i]) {
                    out.push(pads[i]);
                  }
                }
                return out;
              },
              getPad: function(index) {
                var pads = this.gamepads;
                for (var i = 0; i < pads.length; i++) {
                  if (pads[i] && pads[i].index === index) {
                    return pads[i];
                  }
                }
              },
              update: function() {
                if (!this.enabled) {
                  return;
                }
                this.refreshPads();
                var len = this.queue.length;
                if (len === 0) {
                  return;
                }
                var queue = this.queue.splice(0, len);
                for (var i = 0; i < len; i++) {
                  var event = queue[i];
                  var pad = this.getPad(event.gamepad.index);
                  if (event.type === "gamepadconnected") {
                    this.emit(Events.CONNECTED, pad, event);
                  } else if (event.type === "gamepaddisconnected") {
                    this.emit(Events.DISCONNECTED, pad, event);
                  }
                }
              },
              shutdown: function() {
                this.stopListeners();
                this.removeAllListeners();
              },
              destroy: function() {
                this.shutdown();
                for (var i = 0; i < this.gamepads.length; i++) {
                  if (this.gamepads[i]) {
                    this.gamepads[i].destroy();
                  }
                }
                this.gamepads = [];
                this.scene = null;
                this.settings = null;
                this.sceneInputPlugin = null;
                this.target = null;
              },
              total: {
                get: function() {
                  return this.gamepads.length;
                }
              },
              pad1: {
                get: function() {
                  return this._pad1;
                }
              },
              pad2: {
                get: function() {
                  return this._pad2;
                }
              },
              pad3: {
                get: function() {
                  return this._pad3;
                }
              },
              pad4: {
                get: function() {
                  return this._pad4;
                }
              }
            });
            InputPluginCache.register("GamepadPlugin", GamepadPlugin, "gamepad", "gamepad", "inputGamepad");
            module2.exports = GamepadPlugin;
          },
          33171: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              UP: 12,
              DOWN: 13,
              LEFT: 14,
              RIGHT: 15,
              SELECT: 8,
              START: 9,
              B: 0,
              A: 1,
              Y: 2,
              X: 3,
              LEFT_SHOULDER: 4,
              RIGHT_SHOULDER: 5
            };
          },
          74982: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              UP: 12,
              DOWN: 13,
              LEFT: 14,
              RIGHT: 15,
              SHARE: 8,
              OPTIONS: 9,
              PS: 16,
              TOUCHBAR: 17,
              X: 0,
              CIRCLE: 1,
              SQUARE: 2,
              TRIANGLE: 3,
              L1: 4,
              R1: 5,
              L2: 6,
              R2: 7,
              L3: 10,
              R3: 11,
              LEFT_STICK_H: 0,
              LEFT_STICK_V: 1,
              RIGHT_STICK_H: 2,
              RIGHT_STICK_V: 3
            };
          },
          43247: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              UP: 12,
              DOWN: 13,
              LEFT: 14,
              RIGHT: 15,
              MENU: 16,
              A: 0,
              B: 1,
              X: 2,
              Y: 3,
              LB: 4,
              RB: 5,
              LT: 6,
              RT: 7,
              BACK: 8,
              START: 9,
              LS: 10,
              RS: 11,
              LEFT_STICK_H: 0,
              LEFT_STICK_V: 1,
              RIGHT_STICK_H: 2,
              RIGHT_STICK_V: 3
            };
          },
          4898: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              DUALSHOCK_4: __webpack_require__2(74982),
              SNES_USB: __webpack_require__2(33171),
              XBOX_360: __webpack_require__2(43247)
            };
          },
          17344: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "down";
          },
          36635: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "up";
          },
          85724: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "connected";
          },
          55832: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "disconnected";
          },
          772: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "down";
          },
          33608: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "up";
          },
          43200: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BUTTON_DOWN: __webpack_require__2(17344),
              BUTTON_UP: __webpack_require__2(36635),
              CONNECTED: __webpack_require__2(85724),
              DISCONNECTED: __webpack_require__2(55832),
              GAMEPAD_BUTTON_DOWN: __webpack_require__2(772),
              GAMEPAD_BUTTON_UP: __webpack_require__2(33608)
            };
          },
          92636: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Axis: __webpack_require__2(70848),
              Button: __webpack_require__2(21274),
              Events: __webpack_require__2(43200),
              Gamepad: __webpack_require__2(75956),
              GamepadPlugin: __webpack_require__2(1379),
              Configs: __webpack_require__2(4898)
            };
          },
          20873: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(72687);
            var Extend = __webpack_require__2(98611);
            var Input = {
              CreatePixelPerfectHandler: __webpack_require__2(18104),
              CreateInteractiveObject: __webpack_require__2(27395),
              Events: __webpack_require__2(33963),
              Gamepad: __webpack_require__2(92636),
              InputManager: __webpack_require__2(69898),
              InputPlugin: __webpack_require__2(12499),
              InputPluginCache: __webpack_require__2(63399),
              Keyboard: __webpack_require__2(28388),
              Mouse: __webpack_require__2(11343),
              Pointer: __webpack_require__2(40398),
              Touch: __webpack_require__2(77423)
            };
            Input = Extend(false, Input, CONST);
            module2.exports = Input;
          },
          71064: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArrayRemove = __webpack_require__2(66458);
            var Class = __webpack_require__2(56694);
            var GameEvents = __webpack_require__2(97081);
            var InputEvents = __webpack_require__2(33963);
            var KeyCodes = __webpack_require__2(11873);
            var NOOP = __webpack_require__2(72283);
            var KeyboardManager = new Class({
              initialize: function KeyboardManager2(inputManager) {
                this.manager = inputManager;
                this.queue = [];
                this.preventDefault = true;
                this.captures = [];
                this.enabled = false;
                this.target;
                this.onKeyDown = NOOP;
                this.onKeyUp = NOOP;
                inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
              },
              boot: function() {
                var config2 = this.manager.config;
                this.enabled = config2.inputKeyboard;
                this.target = config2.inputKeyboardEventTarget;
                this.addCapture(config2.inputKeyboardCapture);
                if (!this.target && window) {
                  this.target = window;
                }
                if (this.enabled && this.target) {
                  this.startListeners();
                }
                this.manager.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);
              },
              startListeners: function() {
                var _this = this;
                this.onKeyDown = function(event) {
                  if (event.defaultPrevented || !_this.enabled || !_this.manager) {
                    return;
                  }
                  _this.queue.push(event);
                  _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
                  var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
                  if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
                    event.preventDefault();
                  }
                };
                this.onKeyUp = function(event) {
                  if (event.defaultPrevented || !_this.enabled || !_this.manager) {
                    return;
                  }
                  _this.queue.push(event);
                  _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
                  var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
                  if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
                    event.preventDefault();
                  }
                };
                var target = this.target;
                if (target) {
                  target.addEventListener("keydown", this.onKeyDown, false);
                  target.addEventListener("keyup", this.onKeyUp, false);
                  this.enabled = true;
                }
              },
              stopListeners: function() {
                var target = this.target;
                target.removeEventListener("keydown", this.onKeyDown, false);
                target.removeEventListener("keyup", this.onKeyUp, false);
                this.enabled = false;
              },
              postUpdate: function() {
                this.queue = [];
              },
              addCapture: function(keycode) {
                if (typeof keycode === "string") {
                  keycode = keycode.split(",");
                }
                if (!Array.isArray(keycode)) {
                  keycode = [keycode];
                }
                var captures = this.captures;
                for (var i = 0; i < keycode.length; i++) {
                  var code = keycode[i];
                  if (typeof code === "string") {
                    code = KeyCodes[code.trim().toUpperCase()];
                  }
                  if (captures.indexOf(code) === -1) {
                    captures.push(code);
                  }
                }
                this.preventDefault = captures.length > 0;
              },
              removeCapture: function(keycode) {
                if (typeof keycode === "string") {
                  keycode = keycode.split(",");
                }
                if (!Array.isArray(keycode)) {
                  keycode = [keycode];
                }
                var captures = this.captures;
                for (var i = 0; i < keycode.length; i++) {
                  var code = keycode[i];
                  if (typeof code === "string") {
                    code = KeyCodes[code.toUpperCase()];
                  }
                  ArrayRemove(captures, code);
                }
                this.preventDefault = captures.length > 0;
              },
              clearCaptures: function() {
                this.captures = [];
                this.preventDefault = false;
              },
              destroy: function() {
                this.stopListeners();
                this.clearCaptures();
                this.queue = [];
                this.manager.game.events.off(GameEvents.POST_RENDER, this.postUpdate, this);
                this.target = null;
                this.enabled = false;
                this.manager = null;
              }
            });
            module2.exports = KeyboardManager;
          },
          89666: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(94030);
            var GameEvents = __webpack_require__2(97081);
            var GetValue = __webpack_require__2(10850);
            var InputEvents = __webpack_require__2(33963);
            var InputPluginCache = __webpack_require__2(63399);
            var Key = __webpack_require__2(50165);
            var KeyCodes = __webpack_require__2(11873);
            var KeyCombo = __webpack_require__2(95625);
            var KeyMap = __webpack_require__2(48044);
            var SceneEvents = __webpack_require__2(7599);
            var SnapFloor = __webpack_require__2(84314);
            var KeyboardPlugin = new Class({
              Extends: EventEmitter,
              initialize: function KeyboardPlugin2(sceneInputPlugin) {
                EventEmitter.call(this);
                this.game = sceneInputPlugin.systems.game;
                this.scene = sceneInputPlugin.scene;
                this.settings = this.scene.sys.settings;
                this.sceneInputPlugin = sceneInputPlugin;
                this.manager = sceneInputPlugin.manager.keyboard;
                this.enabled = true;
                this.keys = [];
                this.combos = [];
                this.prevCode = null;
                this.prevTime = 0;
                this.prevType = null;
                sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
                sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
              },
              boot: function() {
                var settings = this.settings.input;
                this.enabled = GetValue(settings, "keyboard", true);
                var captures = GetValue(settings, "keyboard.capture", null);
                if (captures) {
                  this.addCaptures(captures);
                }
                this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);
                this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
                this.game.events.on(GameEvents.BLUR, this.resetKeys, this);
                this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);
                this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);
              },
              isActive: function() {
                return this.enabled && this.scene.sys.canInput();
              },
              addCapture: function(keycode) {
                this.manager.addCapture(keycode);
                return this;
              },
              removeCapture: function(keycode) {
                this.manager.removeCapture(keycode);
                return this;
              },
              getCaptures: function() {
                return this.manager.captures;
              },
              enableGlobalCapture: function() {
                this.manager.preventDefault = true;
                return this;
              },
              disableGlobalCapture: function() {
                this.manager.preventDefault = false;
                return this;
              },
              clearCaptures: function() {
                this.manager.clearCaptures();
                return this;
              },
              createCursorKeys: function() {
                return this.addKeys({
                  up: KeyCodes.UP,
                  down: KeyCodes.DOWN,
                  left: KeyCodes.LEFT,
                  right: KeyCodes.RIGHT,
                  space: KeyCodes.SPACE,
                  shift: KeyCodes.SHIFT
                });
              },
              addKeys: function(keys, enableCapture, emitOnRepeat) {
                if (enableCapture === void 0) {
                  enableCapture = true;
                }
                if (emitOnRepeat === void 0) {
                  emitOnRepeat = false;
                }
                var output = {};
                if (typeof keys === "string") {
                  keys = keys.split(",");
                  for (var i = 0; i < keys.length; i++) {
                    var currentKey = keys[i].trim();
                    if (currentKey) {
                      output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);
                    }
                  }
                } else {
                  for (var key in keys) {
                    output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);
                  }
                }
                return output;
              },
              addKey: function(key, enableCapture, emitOnRepeat) {
                if (enableCapture === void 0) {
                  enableCapture = true;
                }
                if (emitOnRepeat === void 0) {
                  emitOnRepeat = false;
                }
                var keys = this.keys;
                if (key instanceof Key) {
                  var idx = keys.indexOf(key);
                  if (idx > -1) {
                    keys[idx] = key;
                  } else {
                    keys[key.keyCode] = key;
                  }
                  if (enableCapture) {
                    this.addCapture(key.keyCode);
                  }
                  key.setEmitOnRepeat(emitOnRepeat);
                  return key;
                }
                if (typeof key === "string") {
                  key = KeyCodes[key.toUpperCase()];
                }
                if (!keys[key]) {
                  keys[key] = new Key(this, key);
                  if (enableCapture) {
                    this.addCapture(key);
                  }
                  keys[key].setEmitOnRepeat(emitOnRepeat);
                }
                return keys[key];
              },
              removeKey: function(key, destroy, removeCapture) {
                if (destroy === void 0) {
                  destroy = false;
                }
                if (removeCapture === void 0) {
                  removeCapture = false;
                }
                var keys = this.keys;
                var ref;
                if (key instanceof Key) {
                  var idx = keys.indexOf(key);
                  if (idx > -1) {
                    ref = this.keys[idx];
                    this.keys[idx] = void 0;
                  }
                } else if (typeof key === "string") {
                  key = KeyCodes[key.toUpperCase()];
                }
                if (keys[key]) {
                  ref = keys[key];
                  keys[key] = void 0;
                }
                if (ref) {
                  ref.plugin = null;
                  if (removeCapture) {
                    this.removeCapture(ref.keyCode);
                  }
                  if (destroy) {
                    ref.destroy();
                  }
                }
                return this;
              },
              removeAllKeys: function(destroy, removeCapture) {
                if (destroy === void 0) {
                  destroy = false;
                }
                if (removeCapture === void 0) {
                  removeCapture = false;
                }
                var keys = this.keys;
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  if (key) {
                    keys[i] = void 0;
                    if (removeCapture) {
                      this.removeCapture(key.keyCode);
                    }
                    if (destroy) {
                      key.destroy();
                    }
                  }
                }
                return this;
              },
              createCombo: function(keys, config2) {
                return new KeyCombo(this, keys, config2);
              },
              checkDown: function(key, duration) {
                if (duration === void 0) {
                  duration = 0;
                }
                if (this.enabled && key.isDown) {
                  var t = SnapFloor(this.time - key.timeDown, duration);
                  if (t > key._tick) {
                    key._tick = t;
                    return true;
                  }
                }
                return false;
              },
              update: function() {
                var queue = this.manager.queue;
                var len = queue.length;
                if (!this.isActive() || len === 0) {
                  return;
                }
                var keys = this.keys;
                for (var i = 0; i < len; i++) {
                  var event = queue[i];
                  var code = event.keyCode;
                  var key = keys[code];
                  var repeat = false;
                  if (event.cancelled === void 0) {
                    event.cancelled = 0;
                    event.stopImmediatePropagation = function() {
                      event.cancelled = 1;
                    };
                    event.stopPropagation = function() {
                      event.cancelled = -1;
                    };
                  }
                  if (event.cancelled === -1) {
                    continue;
                  }
                  if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType) {
                    continue;
                  }
                  this.prevCode = code;
                  this.prevTime = event.timeStamp;
                  this.prevType = event.type;
                  if (event.type === "keydown") {
                    if (key) {
                      repeat = key.isDown;
                      key.onDown(event);
                    }
                    if (!event.cancelled && (!key || !repeat)) {
                      if (KeyMap[code]) {
                        this.emit(Events.KEY_DOWN + KeyMap[code], event);
                      }
                      if (!event.cancelled) {
                        this.emit(Events.ANY_KEY_DOWN, event);
                      }
                    }
                  } else {
                    if (key) {
                      key.onUp(event);
                    }
                    if (!event.cancelled) {
                      if (KeyMap[code]) {
                        this.emit(Events.KEY_UP + KeyMap[code], event);
                      }
                      if (!event.cancelled) {
                        this.emit(Events.ANY_KEY_UP, event);
                      }
                    }
                  }
                  if (event.cancelled === 1) {
                    event.cancelled = 0;
                  }
                }
              },
              resetKeys: function() {
                var keys = this.keys;
                for (var i = 0; i < keys.length; i++) {
                  if (keys[i]) {
                    keys[i].reset();
                  }
                }
                return this;
              },
              shutdown: function() {
                this.removeAllKeys(true);
                this.removeAllListeners();
                this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);
                this.game.events.off(GameEvents.BLUR, this.resetKeys);
                this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);
                this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);
                this.queue = [];
              },
              destroy: function() {
                this.shutdown();
                var keys = this.keys;
                for (var i = 0; i < keys.length; i++) {
                  if (keys[i]) {
                    keys[i].destroy();
                  }
                }
                this.keys = [];
                this.combos = [];
                this.queue = [];
                this.scene = null;
                this.settings = null;
                this.sceneInputPlugin = null;
                this.manager = null;
              },
              time: {
                get: function() {
                  return this.sceneInputPlugin.manager.time;
                }
              }
            });
            InputPluginCache.register("KeyboardPlugin", KeyboardPlugin, "keyboard", "keyboard", "inputKeyboard");
            module2.exports = KeyboardPlugin;
          },
          60258: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AdvanceKeyCombo = function(event, combo) {
              combo.timeLastMatched = event.timeStamp;
              combo.index++;
              if (combo.index === combo.size) {
                return true;
              } else {
                combo.current = combo.keyCodes[combo.index];
                return false;
              }
            };
            module2.exports = AdvanceKeyCombo;
          },
          95625: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(94030);
            var GetFastValue = __webpack_require__2(72632);
            var ProcessKeyCombo = __webpack_require__2(2544);
            var ResetKeyCombo = __webpack_require__2(88754);
            var KeyCombo = new Class({
              initialize: function KeyCombo2(keyboardPlugin, keys, config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                if (keys.length < 2) {
                  return false;
                }
                this.manager = keyboardPlugin;
                this.enabled = true;
                this.keyCodes = [];
                for (var i = 0; i < keys.length; i++) {
                  var char = keys[i];
                  if (typeof char === "string") {
                    this.keyCodes.push(char.toUpperCase().charCodeAt(0));
                  } else if (typeof char === "number") {
                    this.keyCodes.push(char);
                  } else if (char.hasOwnProperty("keyCode")) {
                    this.keyCodes.push(char.keyCode);
                  }
                }
                this.current = this.keyCodes[0];
                this.index = 0;
                this.size = this.keyCodes.length;
                this.timeLastMatched = 0;
                this.matched = false;
                this.timeMatched = 0;
                this.resetOnWrongKey = GetFastValue(config2, "resetOnWrongKey", true);
                this.maxKeyDelay = GetFastValue(config2, "maxKeyDelay", 0);
                this.resetOnMatch = GetFastValue(config2, "resetOnMatch", false);
                this.deleteOnMatch = GetFastValue(config2, "deleteOnMatch", false);
                var _this = this;
                var onKeyDownHandler = function(event) {
                  if (_this.matched || !_this.enabled) {
                    return;
                  }
                  var matched = ProcessKeyCombo(event, _this);
                  if (matched) {
                    _this.manager.emit(Events.COMBO_MATCH, _this, event);
                    if (_this.resetOnMatch) {
                      ResetKeyCombo(_this);
                    } else if (_this.deleteOnMatch) {
                      _this.destroy();
                    }
                  }
                };
                this.onKeyDown = onKeyDownHandler;
                this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);
              },
              progress: {
                get: function() {
                  return this.index / this.size;
                }
              },
              destroy: function() {
                this.enabled = false;
                this.keyCodes = [];
                this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);
                this.manager = null;
              }
            });
            module2.exports = KeyCombo;
          },
          2544: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AdvanceKeyCombo = __webpack_require__2(60258);
            var ProcessKeyCombo = function(event, combo) {
              if (combo.matched) {
                return true;
              }
              var comboMatched = false;
              var keyMatched = false;
              if (event.keyCode === combo.current) {
                if (combo.index > 0 && combo.maxKeyDelay > 0) {
                  var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;
                  if (event.timeStamp <= timeLimit) {
                    keyMatched = true;
                    comboMatched = AdvanceKeyCombo(event, combo);
                  }
                } else {
                  keyMatched = true;
                  comboMatched = AdvanceKeyCombo(event, combo);
                }
              }
              if (!keyMatched && combo.resetOnWrongKey) {
                combo.index = 0;
                combo.current = combo.keyCodes[0];
              }
              if (comboMatched) {
                combo.timeLastMatched = event.timeStamp;
                combo.matched = true;
                combo.timeMatched = event.timeStamp;
              }
              return comboMatched;
            };
            module2.exports = ProcessKeyCombo;
          },
          88754: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ResetKeyCombo = function(combo) {
              combo.current = combo.keyCodes[0];
              combo.index = 0;
              combo.timeLastMatched = 0;
              combo.matched = false;
              combo.timeMatched = 0;
              return combo;
            };
            module2.exports = ResetKeyCombo;
          },
          5044: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "keydown";
          },
          40813: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "keyup";
          },
          89319: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "keycombomatch";
          },
          43267: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "down";
          },
          78595: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "keydown-";
          },
          30056: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "keyup-";
          },
          81939: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "up";
          },
          94030: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ANY_KEY_DOWN: __webpack_require__2(5044),
              ANY_KEY_UP: __webpack_require__2(40813),
              COMBO_MATCH: __webpack_require__2(89319),
              DOWN: __webpack_require__2(43267),
              KEY_DOWN: __webpack_require__2(78595),
              KEY_UP: __webpack_require__2(30056),
              UP: __webpack_require__2(81939)
            };
          },
          28388: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Events: __webpack_require__2(94030),
              KeyboardManager: __webpack_require__2(71064),
              KeyboardPlugin: __webpack_require__2(89666),
              Key: __webpack_require__2(50165),
              KeyCodes: __webpack_require__2(11873),
              KeyCombo: __webpack_require__2(95625),
              AdvanceKeyCombo: __webpack_require__2(60258),
              ProcessKeyCombo: __webpack_require__2(2544),
              ResetKeyCombo: __webpack_require__2(88754),
              JustDown: __webpack_require__2(42460),
              JustUp: __webpack_require__2(53162),
              DownDuration: __webpack_require__2(64964),
              UpDuration: __webpack_require__2(70331)
            };
          },
          64964: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DownDuration = function(key, duration) {
              if (duration === void 0) {
                duration = 50;
              }
              var current = key.plugin.game.loop.time - key.timeDown;
              return key.isDown && current < duration;
            };
            module2.exports = DownDuration;
          },
          42460: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var JustDown = function(key) {
              if (key._justDown) {
                key._justDown = false;
                return true;
              } else {
                return false;
              }
            };
            module2.exports = JustDown;
          },
          53162: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var JustUp = function(key) {
              if (key._justUp) {
                key._justUp = false;
                return true;
              } else {
                return false;
              }
            };
            module2.exports = JustUp;
          },
          50165: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(94030);
            var Key = new Class({
              Extends: EventEmitter,
              initialize: function Key2(plugin, keyCode) {
                EventEmitter.call(this);
                this.plugin = plugin;
                this.keyCode = keyCode;
                this.originalEvent = void 0;
                this.enabled = true;
                this.isDown = false;
                this.isUp = true;
                this.altKey = false;
                this.ctrlKey = false;
                this.shiftKey = false;
                this.metaKey = false;
                this.location = 0;
                this.timeDown = 0;
                this.duration = 0;
                this.timeUp = 0;
                this.emitOnRepeat = false;
                this.repeats = 0;
                this._justDown = false;
                this._justUp = false;
                this._tick = -1;
              },
              setEmitOnRepeat: function(value) {
                this.emitOnRepeat = value;
                return this;
              },
              onDown: function(event) {
                this.originalEvent = event;
                if (!this.enabled) {
                  return;
                }
                this.altKey = event.altKey;
                this.ctrlKey = event.ctrlKey;
                this.shiftKey = event.shiftKey;
                this.metaKey = event.metaKey;
                this.location = event.location;
                this.repeats++;
                if (!this.isDown) {
                  this.isDown = true;
                  this.isUp = false;
                  this.timeDown = event.timeStamp;
                  this.duration = 0;
                  this._justDown = true;
                  this._justUp = false;
                  this.emit(Events.DOWN, this, event);
                } else if (this.emitOnRepeat) {
                  this.emit(Events.DOWN, this, event);
                }
              },
              onUp: function(event) {
                this.originalEvent = event;
                if (!this.enabled) {
                  return;
                }
                this.isDown = false;
                this.isUp = true;
                this.timeUp = event.timeStamp;
                this.duration = this.timeUp - this.timeDown;
                this.repeats = 0;
                this._justDown = false;
                this._justUp = true;
                this._tick = -1;
                this.emit(Events.UP, this, event);
              },
              reset: function() {
                this.isDown = false;
                this.isUp = true;
                this.altKey = false;
                this.ctrlKey = false;
                this.shiftKey = false;
                this.metaKey = false;
                this.timeDown = 0;
                this.duration = 0;
                this.timeUp = 0;
                this.repeats = 0;
                this._justDown = false;
                this._justUp = false;
                this._tick = -1;
                return this;
              },
              getDuration: function() {
                if (this.isDown) {
                  return this.plugin.game.loop.time - this.timeDown;
                } else {
                  return 0;
                }
              },
              destroy: function() {
                this.removeAllListeners();
                this.originalEvent = null;
                this.plugin = null;
              }
            });
            module2.exports = Key;
          },
          11873: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var KeyCodes = {
              BACKSPACE: 8,
              TAB: 9,
              ENTER: 13,
              SHIFT: 16,
              CTRL: 17,
              ALT: 18,
              PAUSE: 19,
              CAPS_LOCK: 20,
              ESC: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT: 37,
              UP: 38,
              RIGHT: 39,
              DOWN: 40,
              PRINT_SCREEN: 42,
              INSERT: 45,
              DELETE: 46,
              ZERO: 48,
              ONE: 49,
              TWO: 50,
              THREE: 51,
              FOUR: 52,
              FIVE: 53,
              SIX: 54,
              SEVEN: 55,
              EIGHT: 56,
              NINE: 57,
              NUMPAD_ZERO: 96,
              NUMPAD_ONE: 97,
              NUMPAD_TWO: 98,
              NUMPAD_THREE: 99,
              NUMPAD_FOUR: 100,
              NUMPAD_FIVE: 101,
              NUMPAD_SIX: 102,
              NUMPAD_SEVEN: 103,
              NUMPAD_EIGHT: 104,
              NUMPAD_NINE: 105,
              NUMPAD_ADD: 107,
              NUMPAD_SUBTRACT: 109,
              A: 65,
              B: 66,
              C: 67,
              D: 68,
              E: 69,
              F: 70,
              G: 71,
              H: 72,
              I: 73,
              J: 74,
              K: 75,
              L: 76,
              M: 77,
              N: 78,
              O: 79,
              P: 80,
              Q: 81,
              R: 82,
              S: 83,
              T: 84,
              U: 85,
              V: 86,
              W: 87,
              X: 88,
              Y: 89,
              Z: 90,
              F1: 112,
              F2: 113,
              F3: 114,
              F4: 115,
              F5: 116,
              F6: 117,
              F7: 118,
              F8: 119,
              F9: 120,
              F10: 121,
              F11: 122,
              F12: 123,
              SEMICOLON: 186,
              PLUS: 187,
              COMMA: 188,
              MINUS: 189,
              PERIOD: 190,
              FORWARD_SLASH: 191,
              BACK_SLASH: 220,
              QUOTES: 222,
              BACKTICK: 192,
              OPEN_BRACKET: 219,
              CLOSED_BRACKET: 221,
              SEMICOLON_FIREFOX: 59,
              COLON: 58,
              COMMA_FIREFOX_WINDOWS: 60,
              COMMA_FIREFOX: 62,
              BRACKET_RIGHT_FIREFOX: 174,
              BRACKET_LEFT_FIREFOX: 175
            };
            module2.exports = KeyCodes;
          },
          48044: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var KeyCodes = __webpack_require__2(11873);
            var KeyMap = {};
            for (var key in KeyCodes) {
              KeyMap[KeyCodes[key]] = key;
            }
            module2.exports = KeyMap;
          },
          70331: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var UpDuration = function(key, duration) {
              if (duration === void 0) {
                duration = 50;
              }
              var current = key.plugin.game.loop.time - key.timeUp;
              return key.isUp && current < duration;
            };
            module2.exports = UpDuration;
          },
          7905: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Features = __webpack_require__2(90185);
            var InputEvents = __webpack_require__2(33963);
            var NOOP = __webpack_require__2(72283);
            var MouseManager = new Class({
              initialize: function MouseManager2(inputManager) {
                this.manager = inputManager;
                this.preventDefaultDown = true;
                this.preventDefaultUp = true;
                this.preventDefaultMove = true;
                this.preventDefaultWheel = false;
                this.enabled = false;
                this.target;
                this.locked = false;
                this.onMouseMove = NOOP;
                this.onMouseDown = NOOP;
                this.onMouseUp = NOOP;
                this.onMouseDownWindow = NOOP;
                this.onMouseUpWindow = NOOP;
                this.onMouseOver = NOOP;
                this.onMouseOut = NOOP;
                this.onMouseWheel = NOOP;
                this.pointerLockChange = NOOP;
                this.isTop = true;
                inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
              },
              boot: function() {
                var config2 = this.manager.config;
                this.enabled = config2.inputMouse;
                this.target = config2.inputMouseEventTarget;
                this.passive = config2.inputMousePassive;
                this.preventDefaultDown = config2.inputMousePreventDefaultDown;
                this.preventDefaultUp = config2.inputMousePreventDefaultUp;
                this.preventDefaultMove = config2.inputMousePreventDefaultMove;
                this.preventDefaultWheel = config2.inputMousePreventDefaultWheel;
                if (!this.target) {
                  this.target = this.manager.game.canvas;
                } else if (typeof this.target === "string") {
                  this.target = document.getElementById(this.target);
                }
                if (config2.disableContextMenu) {
                  this.disableContextMenu();
                }
                if (this.enabled && this.target) {
                  this.startListeners();
                }
              },
              disableContextMenu: function() {
                this.target.addEventListener("contextmenu", function(event) {
                  event.preventDefault();
                  return false;
                });
                return this;
              },
              requestPointerLock: function() {
                if (Features.pointerLock) {
                  var element = this.target;
                  element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                  element.requestPointerLock();
                }
              },
              releasePointerLock: function() {
                if (Features.pointerLock) {
                  document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
                  document.exitPointerLock();
                }
              },
              startListeners: function() {
                var target = this.target;
                if (!target) {
                  return;
                }
                var _this = this;
                var manager = this.manager;
                var canvas = manager.canvas;
                var autoFocus = window && window.focus && manager.game.config.autoFocus;
                this.onMouseMove = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onMouseMove(event);
                    if (_this.preventDefaultMove) {
                      event.preventDefault();
                    }
                  }
                };
                this.onMouseDown = function(event) {
                  if (autoFocus) {
                    window.focus();
                  }
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onMouseDown(event);
                    if (_this.preventDefaultDown && event.target === canvas) {
                      event.preventDefault();
                    }
                  }
                };
                this.onMouseDownWindow = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                    manager.onMouseDown(event);
                  }
                };
                this.onMouseUp = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onMouseUp(event);
                    if (_this.preventDefaultUp && event.target === canvas) {
                      event.preventDefault();
                    }
                  }
                };
                this.onMouseUpWindow = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                    manager.onMouseUp(event);
                  }
                };
                this.onMouseOver = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.setCanvasOver(event);
                  }
                };
                this.onMouseOut = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.setCanvasOut(event);
                  }
                };
                this.onMouseWheel = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onMouseWheel(event);
                  }
                  if (_this.preventDefaultWheel && event.target === canvas) {
                    event.preventDefault();
                  }
                };
                var passive = {passive: true};
                target.addEventListener("mousemove", this.onMouseMove);
                target.addEventListener("mousedown", this.onMouseDown);
                target.addEventListener("mouseup", this.onMouseUp);
                target.addEventListener("mouseover", this.onMouseOver, passive);
                target.addEventListener("mouseout", this.onMouseOut, passive);
                if (this.preventDefaultWheel) {
                  target.addEventListener("wheel", this.onMouseWheel, {passive: false});
                } else {
                  target.addEventListener("wheel", this.onMouseWheel, passive);
                }
                if (window && manager.game.config.inputWindowEvents) {
                  try {
                    window.top.addEventListener("mousedown", this.onMouseDownWindow, passive);
                    window.top.addEventListener("mouseup", this.onMouseUpWindow, passive);
                  } catch (exception) {
                    window.addEventListener("mousedown", this.onMouseDownWindow, passive);
                    window.addEventListener("mouseup", this.onMouseUpWindow, passive);
                    this.isTop = false;
                  }
                }
                if (Features.pointerLock) {
                  this.pointerLockChange = function(event) {
                    var element = _this.target;
                    _this.locked = document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ? true : false;
                    manager.onPointerLockChange(event);
                  };
                  document.addEventListener("pointerlockchange", this.pointerLockChange, true);
                  document.addEventListener("mozpointerlockchange", this.pointerLockChange, true);
                  document.addEventListener("webkitpointerlockchange", this.pointerLockChange, true);
                }
                this.enabled = true;
              },
              stopListeners: function() {
                var target = this.target;
                target.removeEventListener("mousemove", this.onMouseMove);
                target.removeEventListener("mousedown", this.onMouseDown);
                target.removeEventListener("mouseup", this.onMouseUp);
                target.removeEventListener("mouseover", this.onMouseOver);
                target.removeEventListener("mouseout", this.onMouseOut);
                if (window) {
                  target = this.isTop ? window.top : window;
                  target.removeEventListener("mousedown", this.onMouseDownWindow);
                  target.removeEventListener("mouseup", this.onMouseUpWindow);
                }
                if (Features.pointerLock) {
                  document.removeEventListener("pointerlockchange", this.pointerLockChange, true);
                  document.removeEventListener("mozpointerlockchange", this.pointerLockChange, true);
                  document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, true);
                }
              },
              destroy: function() {
                this.stopListeners();
                this.target = null;
                this.enabled = false;
                this.manager = null;
              }
            });
            module2.exports = MouseManager;
          },
          11343: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              MouseManager: __webpack_require__2(7905)
            };
          },
          37579: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var InputEvents = __webpack_require__2(33963);
            var NOOP = __webpack_require__2(72283);
            var TouchManager = new Class({
              initialize: function TouchManager2(inputManager) {
                this.manager = inputManager;
                this.capture = true;
                this.enabled = false;
                this.target;
                this.onTouchStart = NOOP;
                this.onTouchStartWindow = NOOP;
                this.onTouchMove = NOOP;
                this.onTouchEnd = NOOP;
                this.onTouchEndWindow = NOOP;
                this.onTouchCancel = NOOP;
                this.onTouchCancelWindow = NOOP;
                this.isTop = true;
                inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
              },
              boot: function() {
                var config2 = this.manager.config;
                this.enabled = config2.inputTouch;
                this.target = config2.inputTouchEventTarget;
                this.capture = config2.inputTouchCapture;
                if (!this.target) {
                  this.target = this.manager.game.canvas;
                } else if (typeof this.target === "string") {
                  this.target = document.getElementById(this.target);
                }
                if (config2.disableContextMenu) {
                  this.disableContextMenu();
                }
                if (this.enabled && this.target) {
                  this.startListeners();
                }
              },
              disableContextMenu: function() {
                this.target.addEventListener("contextmenu", function(event) {
                  event.preventDefault();
                  return false;
                });
                return this;
              },
              startListeners: function() {
                var target = this.target;
                if (!target) {
                  return;
                }
                var _this = this;
                var manager = this.manager;
                var canvas = manager.canvas;
                var autoFocus = window && window.focus && manager.game.config.autoFocus;
                this.onTouchMove = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onTouchMove(event);
                    if (_this.capture && event.cancelable) {
                      event.preventDefault();
                    }
                  }
                };
                this.onTouchStart = function(event) {
                  if (autoFocus) {
                    window.focus();
                  }
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onTouchStart(event);
                    if (_this.capture && event.cancelable && event.target === canvas) {
                      event.preventDefault();
                    }
                  }
                };
                this.onTouchStartWindow = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                    manager.onTouchStart(event);
                  }
                };
                this.onTouchEnd = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onTouchEnd(event);
                    if (_this.capture && event.cancelable && event.target === canvas) {
                      event.preventDefault();
                    }
                  }
                };
                this.onTouchEndWindow = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                    manager.onTouchEnd(event);
                  }
                };
                this.onTouchCancel = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onTouchCancel(event);
                    if (_this.capture) {
                      event.preventDefault();
                    }
                  }
                };
                this.onTouchCancelWindow = function(event) {
                  if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                    manager.onTouchCancel(event);
                  }
                };
                var capture = this.capture;
                var passive = {passive: true};
                var nonPassive = {passive: false};
                target.addEventListener("touchstart", this.onTouchStart, capture ? nonPassive : passive);
                target.addEventListener("touchmove", this.onTouchMove, capture ? nonPassive : passive);
                target.addEventListener("touchend", this.onTouchEnd, capture ? nonPassive : passive);
                target.addEventListener("touchcancel", this.onTouchCancel, capture ? nonPassive : passive);
                if (window && manager.game.config.inputWindowEvents) {
                  try {
                    window.top.addEventListener("touchstart", this.onTouchStartWindow, nonPassive);
                    window.top.addEventListener("touchend", this.onTouchEndWindow, nonPassive);
                    window.top.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive);
                  } catch (exception) {
                    window.addEventListener("touchstart", this.onTouchStartWindow, nonPassive);
                    window.addEventListener("touchend", this.onTouchEndWindow, nonPassive);
                    window.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive);
                    this.isTop = false;
                  }
                }
                this.enabled = true;
              },
              stopListeners: function() {
                var target = this.target;
                target.removeEventListener("touchstart", this.onTouchStart);
                target.removeEventListener("touchmove", this.onTouchMove);
                target.removeEventListener("touchend", this.onTouchEnd);
                target.removeEventListener("touchcancel", this.onTouchCancel);
                if (window) {
                  target = this.isTop ? window.top : window;
                  target.removeEventListener("touchstart", this.onTouchStartWindow);
                  target.removeEventListener("touchend", this.onTouchEndWindow);
                  target.removeEventListener("touchcancel", this.onTouchCancelWindow);
                }
              },
              destroy: function() {
                this.stopListeners();
                this.target = null;
                this.enabled = false;
                this.manager = null;
              }
            });
            module2.exports = TouchManager;
          },
          77423: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              TouchManager: __webpack_require__2(37579)
            };
          },
          98035: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var Events = __webpack_require__2(683);
            var GetFastValue = __webpack_require__2(72632);
            var GetURL = __webpack_require__2(30750);
            var MergeXHRSettings = __webpack_require__2(43531);
            var XHRLoader = __webpack_require__2(88490);
            var XHRSettings = __webpack_require__2(33868);
            var File = new Class({
              initialize: function File2(loader, fileConfig) {
                this.loader = loader;
                this.cache = GetFastValue(fileConfig, "cache", false);
                this.type = GetFastValue(fileConfig, "type", false);
                if (!this.type) {
                  throw new Error("Invalid File type: " + this.type);
                }
                this.key = GetFastValue(fileConfig, "key", false);
                var loadKey = this.key;
                if (loader.prefix && loader.prefix !== "") {
                  this.key = loader.prefix + loadKey;
                }
                if (!this.key) {
                  throw new Error("Invalid File key: " + this.key);
                }
                var url = GetFastValue(fileConfig, "url");
                if (url === void 0) {
                  url = loader.path + loadKey + "." + GetFastValue(fileConfig, "extension", "");
                } else if (typeof url === "string" && !url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/)) {
                  url = loader.path + url;
                }
                this.url = url;
                this.src = "";
                this.xhrSettings = XHRSettings(GetFastValue(fileConfig, "responseType", void 0));
                if (GetFastValue(fileConfig, "xhrSettings", false)) {
                  this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, "xhrSettings", {}));
                }
                this.xhrLoader = null;
                this.state = typeof this.url === "function" ? CONST.FILE_POPULATED : CONST.FILE_PENDING;
                this.bytesTotal = 0;
                this.bytesLoaded = -1;
                this.percentComplete = -1;
                this.crossOrigin = void 0;
                this.data = void 0;
                this.config = GetFastValue(fileConfig, "config", {});
                this.multiFile;
                this.linkFile;
              },
              setLink: function(fileB) {
                this.linkFile = fileB;
                fileB.linkFile = this;
              },
              resetXHR: function() {
                if (this.xhrLoader) {
                  this.xhrLoader.onload = void 0;
                  this.xhrLoader.onerror = void 0;
                  this.xhrLoader.onprogress = void 0;
                }
              },
              load: function() {
                if (this.state === CONST.FILE_POPULATED) {
                  this.loader.nextFile(this, true);
                } else {
                  this.state = CONST.FILE_LOADING;
                  this.src = GetURL(this, this.loader.baseURL);
                  if (this.src.indexOf("data:") === 0) {
                    console.warn("Local data URIs are not supported: " + this.key);
                  } else {
                    this.xhrLoader = XHRLoader(this, this.loader.xhr);
                  }
                }
              },
              onLoad: function(xhr, event) {
                var isLocalFile = xhr.responseURL && this.loader.localSchemes.some(function(scheme) {
                  return xhr.responseURL.indexOf(scheme) === 0;
                });
                var localFileOk = isLocalFile && event.target.status === 0;
                var success = !(event.target && event.target.status !== 200) || localFileOk;
                if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599) {
                  success = false;
                }
                this.state = CONST.FILE_LOADED;
                this.resetXHR();
                this.loader.nextFile(this, success);
              },
              onError: function() {
                this.resetXHR();
                this.loader.nextFile(this, false);
              },
              onProgress: function(event) {
                if (event.lengthComputable) {
                  this.bytesLoaded = event.loaded;
                  this.bytesTotal = event.total;
                  this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1);
                  this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
                }
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.onProcessComplete();
              },
              onProcessComplete: function() {
                this.state = CONST.FILE_COMPLETE;
                if (this.multiFile) {
                  this.multiFile.onFileComplete(this);
                }
                this.loader.fileProcessComplete(this);
              },
              onProcessError: function() {
                console.error('Failed to process file: %s "%s"', this.type, this.key);
                this.state = CONST.FILE_ERRORED;
                if (this.multiFile) {
                  this.multiFile.onFileFailed(this);
                }
                this.loader.fileProcessComplete(this);
              },
              hasCacheConflict: function() {
                return this.cache && this.cache.exists(this.key);
              },
              addToCache: function() {
                if (this.cache && this.data) {
                  this.cache.add(this.key, this.data);
                }
              },
              pendingDestroy: function(data) {
                if (this.state === CONST.FILE_PENDING_DESTROY) {
                  return;
                }
                if (data === void 0) {
                  data = this.data;
                }
                var key = this.key;
                var type = this.type;
                this.loader.emit(Events.FILE_COMPLETE, key, type, data);
                this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type, data);
                this.loader.flagForRemoval(this);
                this.state = CONST.FILE_PENDING_DESTROY;
              },
              destroy: function() {
                this.loader = null;
                this.cache = null;
                this.xhrSettings = null;
                this.multiFile = null;
                this.linkFile = null;
                this.data = null;
              }
            });
            File.createObjectURL = function(image, blob, defaultType) {
              if (typeof URL === "function") {
                image.src = URL.createObjectURL(blob);
              } else {
                var reader = new FileReader();
                reader.onload = function() {
                  image.removeAttribute("crossOrigin");
                  image.src = "data:" + (blob.type || defaultType) + ";base64," + reader.result.split(",")[1];
                };
                reader.onerror = image.onerror;
                reader.readAsDataURL(blob);
              }
            };
            File.revokeObjectURL = function(image) {
              if (typeof URL === "function") {
                URL.revokeObjectURL(image.src);
              }
            };
            module2.exports = File;
          },
          76846: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var types = {};
            var FileTypesManager = {
              install: function(loader) {
                for (var key in types) {
                  loader[key] = types[key];
                }
              },
              register: function(key, factoryFunction) {
                types[key] = factoryFunction;
              },
              destroy: function() {
                types = {};
              }
            };
            module2.exports = FileTypesManager;
          },
          30750: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetURL = function(file, baseURL) {
              if (!file.url) {
                return false;
              }
              if (file.url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/)) {
                return file.url;
              } else {
                return baseURL + file.url;
              }
            };
            module2.exports = GetURL;
          },
          67285: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var CustomSet = __webpack_require__2(58403);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(683);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var GetValue = __webpack_require__2(10850);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var XHRSettings = __webpack_require__2(33868);
            var LoaderPlugin = new Class({
              Extends: EventEmitter,
              initialize: function LoaderPlugin2(scene) {
                EventEmitter.call(this);
                var gameConfig = scene.sys.game.config;
                var sceneConfig = scene.sys.settings.loader;
                this.scene = scene;
                this.systems = scene.sys;
                this.cacheManager = scene.sys.cache;
                this.textureManager = scene.sys.textures;
                this.sceneManager = scene.sys.game.scene;
                FileTypesManager.install(this);
                this.prefix = "";
                this.path = "";
                this.baseURL = "";
                this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
                this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
                this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
                this.maxParallelDownloads = GetFastValue(sceneConfig, "maxParallelDownloads", gameConfig.loaderMaxParallelDownloads);
                this.xhr = XHRSettings(GetFastValue(sceneConfig, "responseType", gameConfig.loaderResponseType), GetFastValue(sceneConfig, "async", gameConfig.loaderAsync), GetFastValue(sceneConfig, "user", gameConfig.loaderUser), GetFastValue(sceneConfig, "password", gameConfig.loaderPassword), GetFastValue(sceneConfig, "timeout", gameConfig.loaderTimeout), GetFastValue(sceneConfig, "withCredentials", gameConfig.loaderWithCredentials));
                this.crossOrigin = GetFastValue(sceneConfig, "crossOrigin", gameConfig.loaderCrossOrigin);
                this.imageLoadType = GetFastValue(sceneConfig, "imageLoadType", gameConfig.loaderImageLoadType);
                this.localSchemes = GetFastValue(sceneConfig, "localScheme", gameConfig.loaderLocalScheme);
                this.totalToLoad = 0;
                this.progress = 0;
                this.list = new CustomSet();
                this.inflight = new CustomSet();
                this.queue = new CustomSet();
                this._deleteQueue = new CustomSet();
                this.totalFailed = 0;
                this.totalComplete = 0;
                this.state = CONST.LOADER_IDLE;
                this.multiKeyIndex = 0;
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                scene.sys.events.on(SceneEvents.START, this.pluginStart, this);
              },
              boot: function() {
                this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              pluginStart: function() {
                this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              setBaseURL: function(url) {
                if (url === void 0) {
                  url = "";
                }
                if (url !== "" && url.substr(-1) !== "/") {
                  url = url.concat("/");
                }
                this.baseURL = url;
                return this;
              },
              setPath: function(path) {
                if (path === void 0) {
                  path = "";
                }
                if (path !== "" && path.substr(-1) !== "/") {
                  path = path.concat("/");
                }
                this.path = path;
                return this;
              },
              setPrefix: function(prefix) {
                if (prefix === void 0) {
                  prefix = "";
                }
                this.prefix = prefix;
                return this;
              },
              setCORS: function(crossOrigin) {
                this.crossOrigin = crossOrigin;
                return this;
              },
              addFile: function(file) {
                if (!Array.isArray(file)) {
                  file = [file];
                }
                for (var i = 0; i < file.length; i++) {
                  var item = file[i];
                  if (!this.keyExists(item)) {
                    this.list.set(item);
                    this.emit(Events.ADD, item.key, item.type, this, item);
                    if (this.isLoading()) {
                      this.totalToLoad++;
                      this.updateProgress();
                    }
                  }
                }
              },
              keyExists: function(file) {
                var keyConflict = file.hasCacheConflict();
                if (!keyConflict) {
                  this.list.iterate(function(item) {
                    if (item.type === file.type && item.key === file.key) {
                      keyConflict = true;
                      return false;
                    }
                  });
                }
                if (!keyConflict && this.isLoading()) {
                  this.inflight.iterate(function(item) {
                    if (item.type === file.type && item.key === file.key) {
                      keyConflict = true;
                      return false;
                    }
                  });
                  this.queue.iterate(function(item) {
                    if (item.type === file.type && item.key === file.key) {
                      keyConflict = true;
                      return false;
                    }
                  });
                }
                return keyConflict;
              },
              addPack: function(pack, packKey) {
                if (typeof packKey === "string") {
                  var subPack = GetValue(pack, packKey);
                  if (subPack) {
                    pack = {packKey: subPack};
                  }
                }
                var total = 0;
                var currentBaseURL = this.baseURL;
                var currentPath = this.path;
                var currentPrefix = this.prefix;
                for (var key in pack) {
                  if (!Object.prototype.hasOwnProperty.call(pack, key)) {
                    continue;
                  }
                  var config2 = pack[key];
                  var baseURL = GetFastValue(config2, "baseURL", currentBaseURL);
                  var path = GetFastValue(config2, "path", currentPath);
                  var prefix = GetFastValue(config2, "prefix", currentPrefix);
                  var files = GetFastValue(config2, "files", null);
                  var defaultType = GetFastValue(config2, "defaultType", "void");
                  if (Array.isArray(files)) {
                    this.setBaseURL(baseURL);
                    this.setPath(path);
                    this.setPrefix(prefix);
                    for (var i = 0; i < files.length; i++) {
                      var file = files[i];
                      var type = file.hasOwnProperty("type") ? file.type : defaultType;
                      if (this[type]) {
                        this[type](file);
                        total++;
                      }
                    }
                  }
                }
                this.setBaseURL(currentBaseURL);
                this.setPath(currentPath);
                this.setPrefix(currentPrefix);
                return total > 0;
              },
              isLoading: function() {
                return this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING;
              },
              isReady: function() {
                return this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE;
              },
              start: function() {
                if (!this.isReady()) {
                  return;
                }
                this.progress = 0;
                this.totalFailed = 0;
                this.totalComplete = 0;
                this.totalToLoad = this.list.size;
                this.emit(Events.START, this);
                if (this.list.size === 0) {
                  this.loadComplete();
                } else {
                  this.state = CONST.LOADER_LOADING;
                  this.inflight.clear();
                  this.queue.clear();
                  this.updateProgress();
                  this.checkLoadQueue();
                  this.systems.events.on(SceneEvents.UPDATE, this.update, this);
                }
              },
              updateProgress: function() {
                this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad;
                this.emit(Events.PROGRESS, this.progress);
              },
              update: function() {
                if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads) {
                  this.checkLoadQueue();
                }
              },
              checkLoadQueue: function() {
                this.list.each(function(file) {
                  if (file.state === CONST.FILE_POPULATED || file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) {
                    this.inflight.set(file);
                    this.list.delete(file);
                    if (!file.crossOrigin) {
                      file.crossOrigin = this.crossOrigin;
                    }
                    file.load();
                  }
                  if (this.inflight.size === this.maxParallelDownloads) {
                    return false;
                  }
                }, this);
              },
              nextFile: function(file, success) {
                if (!this.inflight) {
                  return;
                }
                this.inflight.delete(file);
                this.updateProgress();
                if (success) {
                  this.totalComplete++;
                  this.queue.set(file);
                  this.emit(Events.FILE_LOAD, file);
                  file.onProcess();
                } else {
                  this.totalFailed++;
                  this._deleteQueue.set(file);
                  this.emit(Events.FILE_LOAD_ERROR, file);
                  this.fileProcessComplete(file);
                }
              },
              fileProcessComplete: function(file) {
                if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy) {
                  return;
                }
                if (file.state === CONST.FILE_ERRORED) {
                  if (file.multiFile) {
                    file.multiFile.onFileFailed(file);
                  }
                } else if (file.state === CONST.FILE_COMPLETE) {
                  if (file.multiFile) {
                    if (file.multiFile.isReadyToProcess()) {
                      file.multiFile.addToCache();
                      file.multiFile.pendingDestroy();
                    }
                  } else {
                    file.addToCache();
                    file.pendingDestroy();
                  }
                }
                this.queue.delete(file);
                if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0) {
                  this.loadComplete();
                }
              },
              loadComplete: function() {
                this.emit(Events.POST_PROCESS, this);
                this.list.clear();
                this.inflight.clear();
                this.queue.clear();
                this.progress = 1;
                this.state = CONST.LOADER_COMPLETE;
                this.systems.events.off(SceneEvents.UPDATE, this.update, this);
                this._deleteQueue.iterateLocal("destroy");
                this._deleteQueue.clear();
                this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);
              },
              flagForRemoval: function(file) {
                this._deleteQueue.set(file);
              },
              saveJSON: function(data, filename) {
                return this.save(JSON.stringify(data), filename);
              },
              save: function(data, filename, filetype) {
                if (filename === void 0) {
                  filename = "file.json";
                }
                if (filetype === void 0) {
                  filetype = "application/json";
                }
                var blob = new Blob([data], {type: filetype});
                var url = URL.createObjectURL(blob);
                var a = document.createElement("a");
                a.download = filename;
                a.textContent = "Download " + filename;
                a.href = url;
                a.click();
                return this;
              },
              reset: function() {
                this.list.clear();
                this.inflight.clear();
                this.queue.clear();
                var gameConfig = this.systems.game.config;
                var sceneConfig = this.systems.settings.loader;
                this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
                this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
                this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
                this.state = CONST.LOADER_IDLE;
              },
              shutdown: function() {
                this.reset();
                this.state = CONST.LOADER_SHUTDOWN;
                this.removeAllListeners();
                this.systems.events.off(SceneEvents.UPDATE, this.update, this);
                this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                this.shutdown();
                this.state = CONST.LOADER_DESTROYED;
                this.systems.events.off(SceneEvents.UPDATE, this.update, this);
                this.systems.events.off(SceneEvents.START, this.pluginStart, this);
                this.list = null;
                this.inflight = null;
                this.queue = null;
                this.scene = null;
                this.systems = null;
                this.textureManager = null;
                this.cacheManager = null;
                this.sceneManager = null;
              }
            });
            PluginCache.register("Loader", LoaderPlugin, "load");
            module2.exports = LoaderPlugin;
          },
          43531: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Extend = __webpack_require__2(98611);
            var XHRSettings = __webpack_require__2(33868);
            var MergeXHRSettings = function(global, local) {
              var output = global === void 0 ? XHRSettings() : Extend({}, global);
              if (local) {
                for (var setting in local) {
                  if (local[setting] !== void 0) {
                    output[setting] = local[setting];
                  }
                }
              }
              return output;
            };
            module2.exports = MergeXHRSettings;
          },
          45176: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var Events = __webpack_require__2(683);
            var MultiFile = new Class({
              initialize: function MultiFile2(loader, type, key, files) {
                var finalFiles = [];
                files.forEach(function(file) {
                  if (file) {
                    finalFiles.push(file);
                  }
                });
                this.loader = loader;
                this.type = type;
                this.key = key;
                var loadKey = this.key;
                if (loader.prefix && loader.prefix !== "") {
                  this.key = loader.prefix + loadKey;
                }
                this.multiKeyIndex = loader.multiKeyIndex++;
                this.files = finalFiles;
                this.state = CONST.FILE_PENDING;
                this.complete = false;
                this.pending = finalFiles.length;
                this.failed = 0;
                this.config = {};
                this.baseURL = loader.baseURL;
                this.path = loader.path;
                this.prefix = loader.prefix;
                for (var i = 0; i < finalFiles.length; i++) {
                  finalFiles[i].multiFile = this;
                }
              },
              isReadyToProcess: function() {
                return this.pending === 0 && this.failed === 0 && !this.complete;
              },
              addToMultiFile: function(file) {
                this.files.push(file);
                file.multiFile = this;
                this.pending++;
                this.complete = false;
                return this;
              },
              onFileComplete: function(file) {
                var index = this.files.indexOf(file);
                if (index !== -1) {
                  this.pending--;
                }
              },
              onFileFailed: function(file) {
                var index = this.files.indexOf(file);
                if (index !== -1) {
                  this.failed++;
                  console.error('File failed: %s "%s" (via %s "%s")', this.type, this.key, file.type, file.key);
                }
              },
              pendingDestroy: function() {
                if (this.state === CONST.FILE_PENDING_DESTROY) {
                  return;
                }
                var key = this.key;
                var type = this.type;
                this.loader.emit(Events.FILE_COMPLETE, key, type);
                this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type);
                this.loader.flagForRemoval(this);
                for (var i = 0; i < this.files.length; i++) {
                  this.files[i].pendingDestroy();
                }
                this.state = CONST.FILE_PENDING_DESTROY;
              },
              destroy: function() {
                this.loader = null;
                this.files = null;
                this.config = null;
              }
            });
            module2.exports = MultiFile;
          },
          88490: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MergeXHRSettings = __webpack_require__2(43531);
            var XHRLoader = function(file, globalXHRSettings) {
              var config2 = MergeXHRSettings(globalXHRSettings, file.xhrSettings);
              var xhr = new XMLHttpRequest();
              xhr.open("GET", file.src, config2.async, config2.user, config2.password);
              xhr.responseType = file.xhrSettings.responseType;
              xhr.timeout = config2.timeout;
              if (config2.headers) {
                for (var key in config2.headers) {
                  xhr.setRequestHeader(key, config2.headers[key]);
                }
              }
              if (config2.header && config2.headerValue) {
                xhr.setRequestHeader(config2.header, config2.headerValue);
              }
              if (config2.requestedWith) {
                xhr.setRequestHeader("X-Requested-With", config2.requestedWith);
              }
              if (config2.overrideMimeType) {
                xhr.overrideMimeType(config2.overrideMimeType);
              }
              if (config2.withCredentials) {
                xhr.withCredentials = true;
              }
              xhr.onload = file.onLoad.bind(file, xhr);
              xhr.onerror = file.onError.bind(file, xhr);
              xhr.onprogress = file.onProgress.bind(file);
              xhr.send();
              return xhr;
            };
            module2.exports = XHRLoader;
          },
          33868: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var XHRSettings = function(responseType, async, user, password, timeout, withCredentials) {
              if (responseType === void 0) {
                responseType = "";
              }
              if (async === void 0) {
                async = true;
              }
              if (user === void 0) {
                user = "";
              }
              if (password === void 0) {
                password = "";
              }
              if (timeout === void 0) {
                timeout = 0;
              }
              if (withCredentials === void 0) {
                withCredentials = false;
              }
              return {
                responseType,
                async,
                user,
                password,
                timeout,
                headers: void 0,
                header: void 0,
                headerValue: void 0,
                requestedWith: false,
                overrideMimeType: void 0,
                withCredentials
              };
            };
            module2.exports = XHRSettings;
          },
          12117: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FILE_CONST = {
              LOADER_IDLE: 0,
              LOADER_LOADING: 1,
              LOADER_PROCESSING: 2,
              LOADER_COMPLETE: 3,
              LOADER_SHUTDOWN: 4,
              LOADER_DESTROYED: 5,
              FILE_PENDING: 10,
              FILE_LOADING: 11,
              FILE_LOADED: 12,
              FILE_FAILED: 13,
              FILE_PROCESSING: 14,
              FILE_ERRORED: 16,
              FILE_COMPLETE: 17,
              FILE_DESTROYED: 18,
              FILE_POPULATED: 19,
              FILE_PENDING_DESTROY: 20
            };
            module2.exports = FILE_CONST;
          },
          7398: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "addfile";
          },
          52187: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "complete";
          },
          36627: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "filecomplete";
          },
          81925: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "filecomplete-";
          },
          29774: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "loaderror";
          },
          20943: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "load";
          },
          74693: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "fileprogress";
          },
          71176: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "postprocess";
          },
          88984: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "progress";
          },
          72753: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "start";
          },
          683: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ADD: __webpack_require__2(7398),
              COMPLETE: __webpack_require__2(52187),
              FILE_COMPLETE: __webpack_require__2(36627),
              FILE_KEY_COMPLETE: __webpack_require__2(81925),
              FILE_LOAD_ERROR: __webpack_require__2(29774),
              FILE_LOAD: __webpack_require__2(20943),
              FILE_PROGRESS: __webpack_require__2(74693),
              POST_PROCESS: __webpack_require__2(71176),
              PROGRESS: __webpack_require__2(88984),
              START: __webpack_require__2(72753)
            };
          },
          46468: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var JSONFile = __webpack_require__2(70806);
            var LoaderEvents = __webpack_require__2(683);
            var AnimationJSONFile = new Class({
              Extends: JSONFile,
              initialize: function AnimationJSONFile2(loader, key, url, xhrSettings, dataKey) {
                JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
                this.type = "animationJSON";
              },
              onProcess: function() {
                this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);
                JSONFile.prototype.onProcess.call(this);
              },
              onLoadComplete: function() {
                this.loader.systems.anims.fromJSON(this.data);
              }
            });
            FileTypesManager.register("animation", function(key, url, dataKey, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new AnimationJSONFile(this, key[i]));
                }
              } else {
                this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));
              }
              return this;
            });
            module2.exports = AnimationJSONFile;
          },
          31648: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var ImageFile = __webpack_require__2(42927);
            var IsPlainObject = __webpack_require__2(42911);
            var JSONFile = __webpack_require__2(70806);
            var MultiFile = __webpack_require__2(45176);
            var AsepriteFile = new Class({
              Extends: MultiFile,
              initialize: function AsepriteFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
                var image;
                var data;
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  image = new ImageFile(loader, {
                    key,
                    url: GetFastValue(config2, "textureURL"),
                    extension: GetFastValue(config2, "textureExtension", "png"),
                    normalMap: GetFastValue(config2, "normalMap"),
                    xhrSettings: GetFastValue(config2, "textureXhrSettings")
                  });
                  data = new JSONFile(loader, {
                    key,
                    url: GetFastValue(config2, "atlasURL"),
                    extension: GetFastValue(config2, "atlasExtension", "json"),
                    xhrSettings: GetFastValue(config2, "atlasXhrSettings")
                  });
                } else {
                  image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                  data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
                }
                if (image.linkFile) {
                  MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
                } else {
                  MultiFile.call(this, loader, "atlasjson", key, [image, data]);
                }
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var image = this.files[0];
                  var json = this.files[1];
                  var normalMap = this.files[2] ? this.files[2].data : null;
                  this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
                  json.addToCache();
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("aseprite", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new AsepriteFile(this, key[i]);
                  this.addFile(multifile.files);
                }
              } else {
                multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
                this.addFile(multifile.files);
              }
              return this;
            });
            module2.exports = AsepriteFile;
          },
          73152: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var ImageFile = __webpack_require__2(42927);
            var IsPlainObject = __webpack_require__2(42911);
            var JSONFile = __webpack_require__2(70806);
            var MultiFile = __webpack_require__2(45176);
            var AtlasJSONFile = new Class({
              Extends: MultiFile,
              initialize: function AtlasJSONFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
                var image;
                var data;
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  image = new ImageFile(loader, {
                    key,
                    url: GetFastValue(config2, "textureURL"),
                    extension: GetFastValue(config2, "textureExtension", "png"),
                    normalMap: GetFastValue(config2, "normalMap"),
                    xhrSettings: GetFastValue(config2, "textureXhrSettings")
                  });
                  data = new JSONFile(loader, {
                    key,
                    url: GetFastValue(config2, "atlasURL"),
                    extension: GetFastValue(config2, "atlasExtension", "json"),
                    xhrSettings: GetFastValue(config2, "atlasXhrSettings")
                  });
                } else {
                  image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                  data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
                }
                if (image.linkFile) {
                  MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
                } else {
                  MultiFile.call(this, loader, "atlasjson", key, [image, data]);
                }
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var image = this.files[0];
                  var json = this.files[1];
                  var normalMap = this.files[2] ? this.files[2].data : null;
                  this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("atlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new AtlasJSONFile(this, key[i]);
                  this.addFile(multifile.files);
                }
              } else {
                multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
                this.addFile(multifile.files);
              }
              return this;
            });
            module2.exports = AtlasJSONFile;
          },
          24616: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var ImageFile = __webpack_require__2(42927);
            var IsPlainObject = __webpack_require__2(42911);
            var MultiFile = __webpack_require__2(45176);
            var XMLFile = __webpack_require__2(15297);
            var AtlasXMLFile = new Class({
              Extends: MultiFile,
              initialize: function AtlasXMLFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
                var image;
                var data;
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  image = new ImageFile(loader, {
                    key,
                    url: GetFastValue(config2, "textureURL"),
                    extension: GetFastValue(config2, "textureExtension", "png"),
                    normalMap: GetFastValue(config2, "normalMap"),
                    xhrSettings: GetFastValue(config2, "textureXhrSettings")
                  });
                  data = new XMLFile(loader, {
                    key,
                    url: GetFastValue(config2, "atlasURL"),
                    extension: GetFastValue(config2, "atlasExtension", "xml"),
                    xhrSettings: GetFastValue(config2, "atlasXhrSettings")
                  });
                } else {
                  image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                  data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);
                }
                if (image.linkFile) {
                  MultiFile.call(this, loader, "atlasxml", key, [image, data, image.linkFile]);
                } else {
                  MultiFile.call(this, loader, "atlasxml", key, [image, data]);
                }
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var image = this.files[0];
                  var xml = this.files[1];
                  var normalMap = this.files[2] ? this.files[2].data : null;
                  this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("atlasXML", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new AtlasXMLFile(this, key[i]);
                  this.addFile(multifile.files);
                }
              } else {
                multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
                this.addFile(multifile.files);
              }
              return this;
            });
            module2.exports = AtlasXMLFile;
          },
          67448: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var HTML5AudioFile = __webpack_require__2(30929);
            var IsPlainObject = __webpack_require__2(42911);
            var AudioFile = new Class({
              Extends: File,
              initialize: function AudioFile2(loader, key, urlConfig, xhrSettings, audioContext) {
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  audioContext = GetFastValue(config2, "context", audioContext);
                }
                var fileConfig = {
                  type: "audio",
                  cache: loader.cacheManager.audio,
                  extension: urlConfig.type,
                  responseType: "arraybuffer",
                  key,
                  url: urlConfig.url,
                  xhrSettings,
                  config: {context: audioContext}
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                var _this = this;
                this.config.context.decodeAudioData(this.xhrLoader.response, function(audioBuffer) {
                  _this.data = audioBuffer;
                  _this.onProcessComplete();
                }, function(e) {
                  console.error("Error decoding audio: " + _this.key + " - ", e ? e.message : null);
                  _this.onProcessError();
                });
                this.config.context = null;
              }
            });
            AudioFile.create = function(loader, key, urls, config2, xhrSettings) {
              var game = loader.systems.game;
              var audioConfig = game.config.audio;
              var deviceAudio = game.device.audio;
              if (IsPlainObject(key)) {
                urls = GetFastValue(key, "url", []);
                config2 = GetFastValue(key, "config", {});
              }
              var urlConfig = AudioFile.getAudioURL(game, urls);
              if (!urlConfig) {
                console.warn('No audio URLs for "%s" matched this device', key);
                return null;
              }
              if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
                return new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context);
              } else {
                return new HTML5AudioFile(loader, key, urlConfig, config2);
              }
            };
            AudioFile.getAudioURL = function(game, urls) {
              if (!Array.isArray(urls)) {
                urls = [urls];
              }
              for (var i = 0; i < urls.length; i++) {
                var url = GetFastValue(urls[i], "url", urls[i]);
                if (url.indexOf("blob:") === 0 || url.indexOf("data:") === 0) {
                  return {
                    url,
                    type: ""
                  };
                }
                var audioType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
                audioType = GetFastValue(urls[i], "type", audioType ? audioType[1] : "").toLowerCase();
                if (game.device.audio[audioType]) {
                  return {
                    url,
                    type: audioType
                  };
                }
              }
              return null;
            };
            FileTypesManager.register("audio", function(key, urls, config2, xhrSettings) {
              var game = this.systems.game;
              var audioConfig = game.config.audio;
              var deviceAudio = game.device.audio;
              if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
                return this;
              }
              var audioFile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  audioFile = AudioFile.create(this, key[i]);
                  if (audioFile) {
                    this.addFile(audioFile);
                  }
                }
              } else {
                audioFile = AudioFile.create(this, key, urls, config2, xhrSettings);
                if (audioFile) {
                  this.addFile(audioFile);
                }
              }
              return this;
            });
            module2.exports = AudioFile;
          },
          66109: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AudioFile = __webpack_require__2(67448);
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var JSONFile = __webpack_require__2(70806);
            var MultiFile = __webpack_require__2(45176);
            var AudioSpriteFile = new Class({
              Extends: MultiFile,
              initialize: function AudioSpriteFile2(loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  jsonURL = GetFastValue(config2, "jsonURL");
                  audioURL = GetFastValue(config2, "audioURL");
                  audioConfig = GetFastValue(config2, "audioConfig");
                  audioXhrSettings = GetFastValue(config2, "audioXhrSettings");
                  jsonXhrSettings = GetFastValue(config2, "jsonXhrSettings");
                }
                var data;
                if (!audioURL) {
                  data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
                  MultiFile.call(this, loader, "audiosprite", key, [data]);
                  this.config.resourceLoad = true;
                  this.config.audioConfig = audioConfig;
                  this.config.audioXhrSettings = audioXhrSettings;
                } else {
                  var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);
                  if (audio) {
                    data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
                    MultiFile.call(this, loader, "audiosprite", key, [audio, data]);
                    this.config.resourceLoad = false;
                  }
                }
              },
              onFileComplete: function(file) {
                var index = this.files.indexOf(file);
                if (index !== -1) {
                  this.pending--;
                  if (this.config.resourceLoad && file.type === "json" && file.data.hasOwnProperty("resources")) {
                    var urls = file.data.resources;
                    var audioConfig = GetFastValue(this.config, "audioConfig");
                    var audioXhrSettings = GetFastValue(this.config, "audioXhrSettings");
                    var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);
                    if (audio) {
                      this.addToMultiFile(audio);
                      this.loader.addFile(audio);
                    }
                  }
                }
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var fileA = this.files[0];
                  var fileB = this.files[1];
                  fileA.addToCache();
                  fileB.addToCache();
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("audioSprite", function(key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
              var game = this.systems.game;
              var gameAudioConfig = game.config.audio;
              var deviceAudio = game.device.audio;
              if (gameAudioConfig && gameAudioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
                return this;
              }
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new AudioSpriteFile(this, key[i]);
                  if (multifile.files) {
                    this.addFile(multifile.files);
                  }
                }
              } else {
                multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);
                if (multifile.files) {
                  this.addFile(multifile.files);
                }
              }
              return this;
            });
          },
          40612: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var BinaryFile = new Class({
              Extends: File,
              initialize: function BinaryFile2(loader, key, url, xhrSettings, dataType) {
                var extension = "bin";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                  dataType = GetFastValue(config2, "dataType", dataType);
                }
                var fileConfig = {
                  type: "binary",
                  cache: loader.cacheManager.binary,
                  extension,
                  responseType: "arraybuffer",
                  key,
                  url,
                  xhrSettings,
                  config: {dataType}
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                var ctor = this.config.dataType;
                this.data = ctor ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("binary", function(key, url, dataType, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new BinaryFile(this, key[i]));
                }
              } else {
                this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));
              }
              return this;
            });
            module2.exports = BinaryFile;
          },
          54565: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var ImageFile = __webpack_require__2(42927);
            var IsPlainObject = __webpack_require__2(42911);
            var MultiFile = __webpack_require__2(45176);
            var ParseXMLBitmapFont = __webpack_require__2(31476);
            var XMLFile = __webpack_require__2(15297);
            var BitmapFontFile = new Class({
              Extends: MultiFile,
              initialize: function BitmapFontFile2(loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
                var image;
                var data;
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  image = new ImageFile(loader, {
                    key,
                    url: GetFastValue(config2, "textureURL"),
                    extension: GetFastValue(config2, "textureExtension", "png"),
                    normalMap: GetFastValue(config2, "normalMap"),
                    xhrSettings: GetFastValue(config2, "textureXhrSettings")
                  });
                  data = new XMLFile(loader, {
                    key,
                    url: GetFastValue(config2, "fontDataURL"),
                    extension: GetFastValue(config2, "fontDataExtension", "xml"),
                    xhrSettings: GetFastValue(config2, "fontDataXhrSettings")
                  });
                } else {
                  image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                  data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);
                }
                if (image.linkFile) {
                  MultiFile.call(this, loader, "bitmapfont", key, [image, data, image.linkFile]);
                } else {
                  MultiFile.call(this, loader, "bitmapfont", key, [image, data]);
                }
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var image = this.files[0];
                  var xml = this.files[1];
                  image.addToCache();
                  var texture = image.cache.get(image.key);
                  var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);
                  this.loader.cacheManager.bitmapFont.add(image.key, {data, texture: image.key, frame: null});
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("bitmapFont", function(key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new BitmapFontFile(this, key[i]);
                  this.addFile(multifile.files);
                }
              } else {
                multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);
                this.addFile(multifile.files);
              }
              return this;
            });
            module2.exports = BitmapFontFile;
          },
          99898: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var CSSFile = new Class({
              Extends: File,
              initialize: function CSSFile2(loader, key, url, xhrSettings) {
                var extension = "css";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                }
                var fileConfig = {
                  type: "script",
                  cache: false,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = document.createElement("style");
                this.data.defer = false;
                this.data.innerHTML = this.xhrLoader.responseText;
                document.head.appendChild(this.data);
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("css", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new CSSFile(this, key[i]));
                }
              } else {
                this.addFile(new CSSFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = CSSFile;
          },
          47375: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2021 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AtlasJSONFile = __webpack_require__2(73152);
            var BinaryFile = __webpack_require__2(40612);
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var ImageFile = __webpack_require__2(42927);
            var IsPlainObject = __webpack_require__2(42911);
            var JSONFile = __webpack_require__2(70806);
            var KTXParser = __webpack_require__2(67409);
            var Merge = __webpack_require__2(30657);
            var MultiAtlasFile = __webpack_require__2(80802);
            var MultiFile = __webpack_require__2(45176);
            var PVRParser = __webpack_require__2(24904);
            var CompressedTextureFile = new Class({
              Extends: MultiFile,
              initialize: function CompressedTextureFile2(loader, key, entry, xhrSettings) {
                if (entry.multiAtlasURL) {
                  var multi = new JSONFile(loader, {
                    key,
                    url: entry.multiAtlasURL,
                    xhrSettings,
                    config: entry
                  });
                  MultiFile.call(this, loader, "texture", key, [multi]);
                } else {
                  var extension = entry.textureURL.substr(entry.textureURL.length - 3);
                  if (!entry.type) {
                    entry.type = extension.toLowerCase() === "ktx" ? "KTX" : "PVR";
                  }
                  var image = new BinaryFile(loader, {
                    key,
                    url: entry.textureURL,
                    extension,
                    xhrSettings,
                    config: entry
                  });
                  if (entry.atlasURL) {
                    var data = new JSONFile(loader, {
                      key,
                      url: entry.atlasURL,
                      xhrSettings,
                      config: entry
                    });
                    MultiFile.call(this, loader, "texture", key, [image, data]);
                  } else {
                    MultiFile.call(this, loader, "texture", key, [image]);
                  }
                }
                this.config = entry;
              },
              onFileComplete: function(file) {
                var index = this.files.indexOf(file);
                if (index !== -1) {
                  this.pending--;
                  if (!this.config.multiAtlasURL) {
                    return;
                  }
                  if (file.type === "json" && file.data.hasOwnProperty("textures")) {
                    var textures = file.data.textures;
                    var config2 = this.config;
                    var loader = this.loader;
                    var currentBaseURL = loader.baseURL;
                    var currentPath = loader.path;
                    var currentPrefix = loader.prefix;
                    var baseURL = GetFastValue(config2, "multiBaseURL", this.baseURL);
                    var path = GetFastValue(config2, "multiPath", this.path);
                    var prefix = GetFastValue(config2, "prefix", this.prefix);
                    var textureXhrSettings = GetFastValue(config2, "textureXhrSettings");
                    if (baseURL) {
                      loader.setBaseURL(baseURL);
                    }
                    if (path) {
                      loader.setPath(path);
                    }
                    if (prefix) {
                      loader.setPrefix(prefix);
                    }
                    for (var i = 0; i < textures.length; i++) {
                      var textureURL = textures[i].image;
                      var key = "CMA" + this.multiKeyIndex + "_" + textureURL;
                      var image = new BinaryFile(loader, key, textureURL, textureXhrSettings);
                      this.addToMultiFile(image);
                      loader.addFile(image);
                      if (textures[i].normalMap) {
                        var normalMap = new BinaryFile(loader, key, textures[i].normalMap, textureXhrSettings);
                        normalMap.type = "normalMap";
                        image.setLink(normalMap);
                        this.addToMultiFile(normalMap);
                        loader.addFile(normalMap);
                      }
                    }
                    loader.setBaseURL(currentBaseURL);
                    loader.setPath(currentPath);
                    loader.setPrefix(currentPrefix);
                  }
                }
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var entry = this.config;
                  if (entry.multiAtlasURL) {
                    this.addMultiToCache();
                  } else {
                    var renderer = this.loader.systems.renderer;
                    var textureManager = this.loader.textureManager;
                    var textureData;
                    var image = this.files[0];
                    var json = this.files[1];
                    if (entry.type === "PVR") {
                      textureData = PVRParser(image.data);
                    } else if (entry.type === "KTX") {
                      textureData = KTXParser(image.data);
                    }
                    if (textureData && renderer.supportsCompressedTexture(entry.format, textureData.internalFormat)) {
                      textureData.format = renderer.getCompressedTextureName(entry.format, textureData.internalFormat);
                      var atlasData = json && json.data ? json.data : null;
                      textureManager.addCompressedTexture(image.key, textureData, atlasData);
                    }
                  }
                  this.complete = true;
                }
              },
              addMultiToCache: function() {
                var entry = this.config;
                var json = this.files[0];
                var data = [];
                var images = [];
                var normalMaps = [];
                var renderer = this.loader.systems.renderer;
                var textureManager = this.loader.textureManager;
                var textureData;
                for (var i = 1; i < this.files.length; i++) {
                  var file = this.files[i];
                  if (file.type === "normalMap") {
                    continue;
                  }
                  var pos = file.key.indexOf("_");
                  var key = file.key.substr(pos + 1);
                  var image = file.data;
                  for (var t = 0; t < json.data.textures.length; t++) {
                    var item = json.data.textures[t];
                    if (item.image === key) {
                      if (entry.type === "PVR") {
                        textureData = PVRParser(image);
                      } else if (entry.type === "KTX") {
                        textureData = KTXParser(image);
                      }
                      if (textureData && renderer.supportsCompressedTexture(entry.format, textureData.internalFormat)) {
                        textureData.format = renderer.getCompressedTextureName(entry.format, textureData.internalFormat);
                        images.push(textureData);
                        data.push(item);
                        if (file.linkFile) {
                          normalMaps.push(file.linkFile.data);
                        }
                      }
                      break;
                    }
                  }
                }
                if (normalMaps.length === 0) {
                  normalMaps = void 0;
                }
                textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);
                this.complete = true;
              }
            });
            FileTypesManager.register("texture", function(key, url, xhrSettings) {
              var renderer = this.systems.renderer;
              var AddEntry = function(loader, key2, urls, xhrSettings2) {
                var entry = {
                  format: null,
                  type: null,
                  textureURL: void 0,
                  atlasURL: void 0,
                  multiAtlasURL: void 0,
                  multiPath: void 0,
                  multiBaseURL: void 0
                };
                if (IsPlainObject(key2)) {
                  var config2 = key2;
                  key2 = GetFastValue(config2, "key");
                  urls = GetFastValue(config2, "url"), xhrSettings2 = GetFastValue(config2, "xhrSettings");
                }
                var matched = false;
                for (var textureBaseFormat in urls) {
                  if (renderer.supportsCompressedTexture(textureBaseFormat)) {
                    var urlEntry = urls[textureBaseFormat];
                    if (typeof urlEntry === "string") {
                      entry.textureURL = urlEntry;
                    } else {
                      entry = Merge(urlEntry, entry);
                    }
                    entry.format = textureBaseFormat.toUpperCase();
                    matched = true;
                    break;
                  }
                }
                if (!matched) {
                  console.warn("No supported compressed texture format or IMG fallback", key2);
                } else if (entry.format === "IMG") {
                  var file;
                  var multifile;
                  if (entry.multiAtlasURL) {
                    multifile = new MultiAtlasFile(loader, key2, entry.multiAtlasURL, entry.multiPath, entry.multiBaseURL, xhrSettings2);
                    file = multifile.files;
                  } else if (entry.atlasURL) {
                    multifile = new AtlasJSONFile(loader, key2, entry.textureURL, entry.atlasURL, xhrSettings2);
                    file = multifile.files;
                  } else {
                    file = new ImageFile(loader, key2, entry.textureURL, xhrSettings2);
                  }
                  loader.addFile(file);
                } else {
                  var texture = new CompressedTextureFile(loader, key2, entry, xhrSettings2);
                  loader.addFile(texture.files);
                }
              };
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  AddEntry(this, key[i]);
                }
              } else {
                AddEntry(this, key, url, xhrSettings);
              }
              return this;
            });
            module2.exports = CompressedTextureFile;
          },
          46568: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var Shader = __webpack_require__2(31053);
            var GLSLFile = new Class({
              Extends: File,
              initialize: function GLSLFile2(loader, key, url, shaderType, xhrSettings) {
                var extension = "glsl";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  shaderType = GetFastValue(config2, "shaderType", "fragment");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                } else if (shaderType === void 0) {
                  shaderType = "fragment";
                }
                var fileConfig = {
                  type: "glsl",
                  cache: loader.cacheManager.shader,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  config: {
                    shaderType
                  },
                  xhrSettings
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = this.xhrLoader.responseText;
                this.onProcessComplete();
              },
              addToCache: function() {
                var data = this.data.split("\n");
                var block = this.extractBlock(data, 0);
                if (block) {
                  while (block) {
                    var key = this.getShaderName(block.header);
                    var shaderType = this.getShaderType(block.header);
                    var uniforms = this.getShaderUniforms(block.header);
                    var shaderSrc = block.shader;
                    if (this.cache.has(key)) {
                      var shader = this.cache.get(key);
                      if (shaderType === "fragment") {
                        shader.fragmentSrc = shaderSrc;
                      } else {
                        shader.vertexSrc = shaderSrc;
                      }
                      if (!shader.uniforms) {
                        shader.uniforms = uniforms;
                      }
                    } else if (shaderType === "fragment") {
                      this.cache.add(key, new Shader(key, shaderSrc, "", uniforms));
                    } else {
                      this.cache.add(key, new Shader(key, "", shaderSrc, uniforms));
                    }
                    block = this.extractBlock(data, block.offset);
                  }
                } else if (this.config.shaderType === "fragment") {
                  this.cache.add(this.key, new Shader(this.key, this.data));
                } else {
                  this.cache.add(this.key, new Shader(this.key, "", this.data));
                }
              },
              getShaderName: function(headerSource) {
                for (var i = 0; i < headerSource.length; i++) {
                  var line = headerSource[i].trim();
                  if (line.substring(0, 5) === "name:") {
                    return line.substring(5).trim();
                  }
                }
                return this.key;
              },
              getShaderType: function(headerSource) {
                for (var i = 0; i < headerSource.length; i++) {
                  var line = headerSource[i].trim();
                  if (line.substring(0, 5) === "type:") {
                    return line.substring(5).trim();
                  }
                }
                return this.config.shaderType;
              },
              getShaderUniforms: function(headerSource) {
                var uniforms = {};
                for (var i = 0; i < headerSource.length; i++) {
                  var line = headerSource[i].trim();
                  if (line.substring(0, 8) === "uniform.") {
                    var pos = line.indexOf(":");
                    if (pos) {
                      var key = line.substring(8, pos);
                      try {
                        uniforms[key] = JSON.parse(line.substring(pos + 1));
                      } catch (e) {
                        console.warn("Invalid uniform JSON: " + key);
                      }
                    }
                  }
                }
                return uniforms;
              },
              extractBlock: function(data, offset) {
                var headerStart = -1;
                var headerEnd = -1;
                var blockEnd = -1;
                var headerOpen = false;
                var captureSource = false;
                var headerSource = [];
                var shaderSource = [];
                for (var i = offset; i < data.length; i++) {
                  var line = data[i].trim();
                  if (line === "---") {
                    if (headerStart === -1) {
                      headerStart = i;
                      headerOpen = true;
                    } else if (headerOpen) {
                      headerEnd = i;
                      headerOpen = false;
                      captureSource = true;
                    } else {
                      captureSource = false;
                      break;
                    }
                  } else if (headerOpen) {
                    headerSource.push(line);
                  } else if (captureSource) {
                    shaderSource.push(line);
                    blockEnd = i;
                  }
                }
                if (!headerOpen && headerEnd !== -1) {
                  return {header: headerSource, shader: shaderSource.join("\n"), offset: blockEnd};
                } else {
                  return null;
                }
              }
            });
            FileTypesManager.register("glsl", function(key, url, shaderType, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new GLSLFile(this, key[i]));
                }
              } else {
                this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));
              }
              return this;
            });
            module2.exports = GLSLFile;
          },
          30929: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(683);
            var File = __webpack_require__2(98035);
            var GetFastValue = __webpack_require__2(72632);
            var GetURL = __webpack_require__2(30750);
            var IsPlainObject = __webpack_require__2(42911);
            var HTML5AudioFile = new Class({
              Extends: File,
              initialize: function HTML5AudioFile2(loader, key, urlConfig, audioConfig) {
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  audioConfig = GetFastValue(config2, "config", audioConfig);
                }
                var fileConfig = {
                  type: "audio",
                  cache: loader.cacheManager.audio,
                  extension: urlConfig.type,
                  key,
                  url: urlConfig.url,
                  config: audioConfig
                };
                File.call(this, loader, fileConfig);
                this.locked = "ontouchstart" in window;
                this.loaded = false;
                this.filesLoaded = 0;
                this.filesTotal = 0;
              },
              onLoad: function() {
                if (this.loaded) {
                  return;
                }
                this.loaded = true;
                this.loader.nextFile(this, true);
              },
              onError: function() {
                for (var i = 0; i < this.data.length; i++) {
                  var audio = this.data[i];
                  audio.oncanplaythrough = null;
                  audio.onerror = null;
                }
                this.loader.nextFile(this, false);
              },
              onProgress: function(event) {
                var audio = event.target;
                audio.oncanplaythrough = null;
                audio.onerror = null;
                this.filesLoaded++;
                this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1);
                this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
                if (this.filesLoaded === this.filesTotal) {
                  this.onLoad();
                }
              },
              load: function() {
                this.data = [];
                var instances = this.config && this.config.instances || 1;
                this.filesTotal = instances;
                this.filesLoaded = 0;
                this.percentComplete = 0;
                for (var i = 0; i < instances; i++) {
                  var audio = new Audio();
                  if (!audio.dataset) {
                    audio.dataset = {};
                  }
                  audio.dataset.name = this.key + ("0" + i).slice(-2);
                  audio.dataset.used = "false";
                  if (this.locked) {
                    audio.dataset.locked = "true";
                  } else {
                    audio.dataset.locked = "false";
                    audio.preload = "auto";
                    audio.oncanplaythrough = this.onProgress.bind(this);
                    audio.onerror = this.onError.bind(this);
                  }
                  this.data.push(audio);
                }
                for (i = 0; i < this.data.length; i++) {
                  audio = this.data[i];
                  audio.src = GetURL(this, this.loader.baseURL);
                  if (!this.locked) {
                    audio.load();
                  }
                }
                if (this.locked) {
                  setTimeout(this.onLoad.bind(this));
                }
              }
            });
            module2.exports = HTML5AudioFile;
          },
          77459: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var HTMLFile = new Class({
              Extends: File,
              initialize: function HTMLFile2(loader, key, url, xhrSettings) {
                var extension = "html";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                }
                var fileConfig = {
                  type: "text",
                  cache: loader.cacheManager.html,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = this.xhrLoader.responseText;
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("html", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new HTMLFile(this, key[i]));
                }
              } else {
                this.addFile(new HTMLFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = HTMLFile;
          },
          9755: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var HTMLTextureFile = new Class({
              Extends: File,
              initialize: function HTMLTextureFile2(loader, key, url, width, height, xhrSettings) {
                if (width === void 0) {
                  width = 512;
                }
                if (height === void 0) {
                  height = 512;
                }
                var extension = "html";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                  width = GetFastValue(config2, "width", width);
                  height = GetFastValue(config2, "height", height);
                }
                var fileConfig = {
                  type: "html",
                  cache: loader.textureManager,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings,
                  config: {
                    width,
                    height
                  }
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                var w = this.config.width;
                var h = this.config.height;
                var data = [];
                data.push('<svg width="' + w + 'px" height="' + h + 'px" viewBox="0 0 ' + w + " " + h + '" xmlns="http://www.w3.org/2000/svg">');
                data.push('<foreignObject width="100%" height="100%">');
                data.push('<body xmlns="http://www.w3.org/1999/xhtml">');
                data.push(this.xhrLoader.responseText);
                data.push("</body>");
                data.push("</foreignObject>");
                data.push("</svg>");
                var svg = [data.join("\n")];
                var _this = this;
                try {
                  var blob = new window.Blob(svg, {type: "image/svg+xml;charset=utf-8"});
                } catch (e) {
                  _this.state = CONST.FILE_ERRORED;
                  _this.onProcessComplete();
                  return;
                }
                this.data = new Image();
                this.data.crossOrigin = this.crossOrigin;
                this.data.onload = function() {
                  File.revokeObjectURL(_this.data);
                  _this.onProcessComplete();
                };
                this.data.onerror = function() {
                  File.revokeObjectURL(_this.data);
                  _this.onProcessError();
                };
                File.createObjectURL(this.data, blob, "image/svg+xml");
              },
              addToCache: function() {
                this.cache.addImage(this.key, this.data);
              }
            });
            FileTypesManager.register("htmlTexture", function(key, url, width, height, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new HTMLTextureFile(this, key[i]));
                }
              } else {
                this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));
              }
              return this;
            });
            module2.exports = HTMLTextureFile;
          },
          42927: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var GetURL = __webpack_require__2(30750);
            var ImageFile = new Class({
              Extends: File,
              initialize: function ImageFile2(loader, key, url, xhrSettings, frameConfig) {
                var extension = "png";
                var normalMapURL;
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  normalMapURL = GetFastValue(config2, "normalMap");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                  frameConfig = GetFastValue(config2, "frameConfig");
                }
                if (Array.isArray(url)) {
                  normalMapURL = url[1];
                  url = url[0];
                }
                var fileConfig = {
                  type: "image",
                  cache: loader.textureManager,
                  extension,
                  responseType: "blob",
                  key,
                  url,
                  xhrSettings,
                  config: frameConfig
                };
                File.call(this, loader, fileConfig);
                if (normalMapURL) {
                  var normalMap = new ImageFile2(loader, this.key, normalMapURL, xhrSettings, frameConfig);
                  normalMap.type = "normalMap";
                  this.setLink(normalMap);
                  loader.addFile(normalMap);
                }
                this.useImageElementLoad = loader.imageLoadType === "HTMLImageElement";
                if (this.useImageElementLoad) {
                  this.load = this.loadImage;
                  this.onProcess = this.onProcessImage;
                }
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = new Image();
                this.data.crossOrigin = this.crossOrigin;
                var _this = this;
                this.data.onload = function() {
                  File.revokeObjectURL(_this.data);
                  _this.onProcessComplete();
                };
                this.data.onerror = function() {
                  File.revokeObjectURL(_this.data);
                  _this.onProcessError();
                };
                File.createObjectURL(this.data, this.xhrLoader.response, "image/png");
              },
              onProcessImage: function() {
                var result = this.state;
                this.state = CONST.FILE_PROCESSING;
                if (result === CONST.FILE_LOADED) {
                  this.onProcessComplete();
                } else {
                  this.onProcessError();
                }
              },
              loadImage: function() {
                this.state = CONST.FILE_LOADING;
                this.src = GetURL(this, this.loader.baseURL);
                if (this.src.indexOf("data:") === 0) {
                  console.warn("Local data URIs are not supported: " + this.key);
                } else {
                  this.data = new Image();
                  this.data.crossOrigin = this.crossOrigin;
                  var _this = this;
                  this.data.onload = function() {
                    _this.state = CONST.FILE_LOADED;
                    _this.loader.nextFile(_this, true);
                  };
                  this.data.onerror = function() {
                    _this.loader.nextFile(_this, false);
                  };
                  this.data.src = this.src;
                }
              },
              addToCache: function() {
                var linkFile = this.linkFile;
                if (linkFile) {
                  if (linkFile.state >= CONST.FILE_COMPLETE) {
                    if (linkFile.type === "spritesheet") {
                      linkFile.addToCache();
                    } else if (this.type === "normalMap") {
                      this.cache.addImage(this.key, linkFile.data, this.data);
                    } else {
                      this.cache.addImage(this.key, this.data, linkFile.data);
                    }
                  }
                } else {
                  this.cache.addImage(this.key, this.data);
                }
              }
            });
            FileTypesManager.register("image", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new ImageFile(this, key[i]));
                }
              } else {
                this.addFile(new ImageFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = ImageFile;
          },
          70806: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var GetValue = __webpack_require__2(10850);
            var IsPlainObject = __webpack_require__2(42911);
            var JSONFile = new Class({
              Extends: File,
              initialize: function JSONFile2(loader, key, url, xhrSettings, dataKey) {
                var extension = "json";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                  dataKey = GetFastValue(config2, "dataKey", dataKey);
                }
                var fileConfig = {
                  type: "json",
                  cache: loader.cacheManager.json,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings,
                  config: dataKey
                };
                File.call(this, loader, fileConfig);
                if (IsPlainObject(url)) {
                  if (dataKey) {
                    this.data = GetValue(url, dataKey);
                  } else {
                    this.data = url;
                  }
                  this.state = CONST.FILE_POPULATED;
                }
              },
              onProcess: function() {
                if (this.state !== CONST.FILE_POPULATED) {
                  this.state = CONST.FILE_PROCESSING;
                  try {
                    var json = JSON.parse(this.xhrLoader.responseText);
                  } catch (e) {
                    this.onProcessError();
                    throw e;
                  }
                  var key = this.config;
                  if (typeof key === "string") {
                    this.data = GetValue(json, key, json);
                  } else {
                    this.data = json;
                  }
                }
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("json", function(key, url, dataKey, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new JSONFile(this, key[i]));
                }
              } else {
                this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));
              }
              return this;
            });
            module2.exports = JSONFile;
          },
          80802: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var ImageFile = __webpack_require__2(42927);
            var IsPlainObject = __webpack_require__2(42911);
            var JSONFile = __webpack_require__2(70806);
            var MultiFile = __webpack_require__2(45176);
            var MultiAtlasFile = new Class({
              Extends: MultiFile,
              initialize: function MultiAtlasFile2(loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings) {
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  if (GetFastValue(config2, "url", false)) {
                    atlasURL = GetFastValue(config2, "url");
                  } else {
                    atlasURL = GetFastValue(config2, "atlasURL");
                  }
                  atlasXhrSettings = GetFastValue(config2, "xhrSettings");
                  path = GetFastValue(config2, "path");
                  baseURL = GetFastValue(config2, "baseURL");
                  textureXhrSettings = GetFastValue(config2, "textureXhrSettings");
                }
                var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
                MultiFile.call(this, loader, "multiatlas", key, [data]);
                this.config.path = path;
                this.config.baseURL = baseURL;
                this.config.textureXhrSettings = textureXhrSettings;
              },
              onFileComplete: function(file) {
                var index = this.files.indexOf(file);
                if (index !== -1) {
                  this.pending--;
                  if (file.type === "json" && file.data.hasOwnProperty("textures")) {
                    var textures = file.data.textures;
                    var config2 = this.config;
                    var loader = this.loader;
                    var currentBaseURL = loader.baseURL;
                    var currentPath = loader.path;
                    var currentPrefix = loader.prefix;
                    var baseURL = GetFastValue(config2, "baseURL", this.baseURL);
                    var path = GetFastValue(config2, "path", this.path);
                    var prefix = GetFastValue(config2, "prefix", this.prefix);
                    var textureXhrSettings = GetFastValue(config2, "textureXhrSettings");
                    loader.setBaseURL(baseURL);
                    loader.setPath(path);
                    loader.setPrefix(prefix);
                    for (var i = 0; i < textures.length; i++) {
                      var textureURL = textures[i].image;
                      var key = "MA" + this.multiKeyIndex + "_" + textureURL;
                      var image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                      this.addToMultiFile(image);
                      loader.addFile(image);
                      if (textures[i].normalMap) {
                        var normalMap = new ImageFile(loader, key, textures[i].normalMap, textureXhrSettings);
                        normalMap.type = "normalMap";
                        image.setLink(normalMap);
                        this.addToMultiFile(normalMap);
                        loader.addFile(normalMap);
                      }
                    }
                    loader.setBaseURL(currentBaseURL);
                    loader.setPath(currentPath);
                    loader.setPrefix(currentPrefix);
                  }
                }
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var fileJSON = this.files[0];
                  var data = [];
                  var images = [];
                  var normalMaps = [];
                  for (var i = 1; i < this.files.length; i++) {
                    var file = this.files[i];
                    if (file.type === "normalMap") {
                      continue;
                    }
                    var pos = file.key.indexOf("_");
                    var key = file.key.substr(pos + 1);
                    var image = file.data;
                    for (var t = 0; t < fileJSON.data.textures.length; t++) {
                      var item = fileJSON.data.textures[t];
                      if (item.image === key) {
                        images.push(image);
                        data.push(item);
                        if (file.linkFile) {
                          normalMaps.push(file.linkFile.data);
                        }
                        break;
                      }
                    }
                  }
                  if (normalMaps.length === 0) {
                    normalMaps = void 0;
                  }
                  this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("multiatlas", function(key, atlasURL, path, baseURL, atlasXhrSettings) {
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new MultiAtlasFile(this, key[i]);
                  this.addFile(multifile.files);
                }
              } else {
                multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);
                this.addFile(multifile.files);
              }
              return this;
            });
            module2.exports = MultiAtlasFile;
          },
          39034: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var MultiFile = __webpack_require__2(45176);
            var ScriptFile = __webpack_require__2(55188);
            var MultiScriptFile = new Class({
              Extends: MultiFile,
              initialize: function MultiScriptFile2(loader, key, url, xhrSettings) {
                var extension = "js";
                var files = [];
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                }
                if (!Array.isArray(url)) {
                  url = [url];
                }
                for (var i = 0; i < url.length; i++) {
                  var scriptFile = new ScriptFile(loader, {
                    key: key + "_" + i.toString(),
                    url: url[i],
                    extension,
                    xhrSettings
                  });
                  scriptFile.onProcess = function() {
                    this.onProcessComplete();
                  };
                  files.push(scriptFile);
                }
                MultiFile.call(this, loader, "scripts", key, files);
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  for (var i = 0; i < this.files.length; i++) {
                    var file = this.files[i];
                    file.data = document.createElement("script");
                    file.data.language = "javascript";
                    file.data.type = "text/javascript";
                    file.data.defer = false;
                    file.data.text = file.xhrLoader.responseText;
                    document.head.appendChild(file.data);
                  }
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("scripts", function(key, url, xhrSettings) {
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new MultiScriptFile(this, key[i]);
                  this.addFile(multifile.files);
                }
              } else {
                multifile = new MultiScriptFile(this, key, url, xhrSettings);
                this.addFile(multifile.files);
              }
              return this;
            });
            module2.exports = MultiScriptFile;
          },
          85527: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var MultiFile = __webpack_require__2(45176);
            var ParseObj = __webpack_require__2(27291);
            var ParseObjMaterial = __webpack_require__2(76799);
            var TextFile = __webpack_require__2(86897);
            var OBJFile = new Class({
              Extends: MultiFile,
              initialize: function OBJFile2(loader, key, objURL, matURL, flipUV, xhrSettings) {
                var obj;
                var mat;
                var cache = loader.cacheManager.obj;
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  obj = new TextFile(loader, {
                    key,
                    type: "obj",
                    cache,
                    url: GetFastValue(config2, "url"),
                    extension: GetFastValue(config2, "extension", "obj"),
                    xhrSettings: GetFastValue(config2, "xhrSettings"),
                    config: {
                      flipUV: GetFastValue(config2, "flipUV", flipUV)
                    }
                  });
                  matURL = GetFastValue(config2, "matURL");
                  if (matURL) {
                    mat = new TextFile(loader, {
                      key,
                      type: "mat",
                      cache,
                      url: matURL,
                      extension: GetFastValue(config2, "matExtension", "mat"),
                      xhrSettings: GetFastValue(config2, "xhrSettings")
                    });
                  }
                } else {
                  obj = new TextFile(loader, {
                    key,
                    url: objURL,
                    type: "obj",
                    cache,
                    extension: "obj",
                    xhrSettings,
                    config: {
                      flipUV
                    }
                  });
                  if (matURL) {
                    mat = new TextFile(loader, {
                      key,
                      url: matURL,
                      type: "mat",
                      cache,
                      extension: "mat",
                      xhrSettings
                    });
                  }
                }
                MultiFile.call(this, loader, "obj", key, [obj, mat]);
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var obj = this.files[0];
                  var mat = this.files[1];
                  var objData = ParseObj(obj.data, obj.config.flipUV);
                  if (mat) {
                    objData.materials = ParseObjMaterial(mat.data);
                  }
                  obj.cache.add(obj.key, objData);
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("obj", function(key, objURL, matURL, flipUVs, xhrSettings) {
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new OBJFile(this, key[i]);
                  this.addFile(multifile.files);
                }
              } else {
                multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);
                this.addFile(multifile.files);
              }
              return this;
            });
            module2.exports = OBJFile;
          },
          3616: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var FileTypesManager = __webpack_require__2(76846);
            var JSONFile = __webpack_require__2(70806);
            var PackFile = new Class({
              Extends: JSONFile,
              initialize: function PackFile2(loader, key, url, xhrSettings, dataKey) {
                JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
                this.type = "packfile";
              },
              onProcess: function() {
                if (this.state !== CONST.FILE_POPULATED) {
                  this.state = CONST.FILE_PROCESSING;
                  this.data = JSON.parse(this.xhrLoader.responseText);
                }
                if (this.data.hasOwnProperty("files") && this.config) {
                  var newData = {};
                  newData[this.config] = this.data;
                  this.data = newData;
                }
                this.loader.addPack(this.data, this.config);
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("pack", function(key, url, dataKey, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new PackFile(this, key[i]));
                }
              } else {
                this.addFile(new PackFile(this, key, url, xhrSettings, dataKey));
              }
              return this;
            });
            module2.exports = PackFile;
          },
          12217: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var PluginFile = new Class({
              Extends: File,
              initialize: function PluginFile2(loader, key, url, start, mapping, xhrSettings) {
                var extension = "js";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                  start = GetFastValue(config2, "start");
                  mapping = GetFastValue(config2, "mapping");
                }
                var fileConfig = {
                  type: "plugin",
                  cache: false,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings,
                  config: {
                    start,
                    mapping
                  }
                };
                File.call(this, loader, fileConfig);
                if (typeof url === "function") {
                  this.data = url;
                  this.state = CONST.FILE_POPULATED;
                }
              },
              onProcess: function() {
                var pluginManager = this.loader.systems.plugins;
                var config2 = this.config;
                var start = GetFastValue(config2, "start", false);
                var mapping = GetFastValue(config2, "mapping", null);
                if (this.state === CONST.FILE_POPULATED) {
                  pluginManager.install(this.key, this.data, start, mapping);
                } else {
                  this.state = CONST.FILE_PROCESSING;
                  this.data = document.createElement("script");
                  this.data.language = "javascript";
                  this.data.type = "text/javascript";
                  this.data.defer = false;
                  this.data.text = this.xhrLoader.responseText;
                  document.head.appendChild(this.data);
                  var plugin = pluginManager.install(this.key, window[this.key], start, mapping);
                  if (start || mapping) {
                    this.loader.systems[mapping] = plugin;
                    this.loader.scene[mapping] = plugin;
                  }
                }
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("plugin", function(key, url, start, mapping, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new PluginFile(this, key[i]));
                }
              } else {
                this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));
              }
              return this;
            });
            module2.exports = PluginFile;
          },
          4474: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var SVGFile = new Class({
              Extends: File,
              initialize: function SVGFile2(loader, key, url, svgConfig, xhrSettings) {
                var extension = "svg";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  svgConfig = GetFastValue(config2, "svgConfig", {});
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                }
                var fileConfig = {
                  type: "svg",
                  cache: loader.textureManager,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings,
                  config: {
                    width: GetFastValue(svgConfig, "width"),
                    height: GetFastValue(svgConfig, "height"),
                    scale: GetFastValue(svgConfig, "scale")
                  }
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                var text = this.xhrLoader.responseText;
                var svg = [text];
                var width = this.config.width;
                var height = this.config.height;
                var scale = this.config.scale;
                resize:
                  if (width && height || scale) {
                    var xml = null;
                    var parser = new DOMParser();
                    xml = parser.parseFromString(text, "text/xml");
                    var svgXML = xml.getElementsByTagName("svg")[0];
                    var hasViewBox = svgXML.hasAttribute("viewBox");
                    var svgWidth = parseFloat(svgXML.getAttribute("width"));
                    var svgHeight = parseFloat(svgXML.getAttribute("height"));
                    if (!hasViewBox && svgWidth && svgHeight) {
                      svgXML.setAttribute("viewBox", "0  0 " + svgWidth + " " + svgHeight);
                    } else if (hasViewBox && !svgWidth && !svgHeight) {
                      var viewBox = svgXML.getAttribute("viewBox").split(/\s+|,/);
                      svgWidth = viewBox[2];
                      svgHeight = viewBox[3];
                    }
                    if (scale) {
                      if (svgWidth && svgHeight) {
                        width = svgWidth * scale;
                        height = svgHeight * scale;
                      } else {
                        break resize;
                      }
                    }
                    svgXML.setAttribute("width", width.toString() + "px");
                    svgXML.setAttribute("height", height.toString() + "px");
                    svg = [new XMLSerializer().serializeToString(svgXML)];
                  }
                try {
                  var blob = new window.Blob(svg, {type: "image/svg+xml;charset=utf-8"});
                } catch (e) {
                  this.onProcessError();
                  return;
                }
                this.data = new Image();
                this.data.crossOrigin = this.crossOrigin;
                var _this = this;
                var retry = false;
                this.data.onload = function() {
                  if (!retry) {
                    File.revokeObjectURL(_this.data);
                  }
                  _this.onProcessComplete();
                };
                this.data.onerror = function() {
                  if (!retry) {
                    retry = true;
                    File.revokeObjectURL(_this.data);
                    _this.data.src = "data:image/svg+xml," + encodeURIComponent(svg.join(""));
                  } else {
                    _this.onProcessError();
                  }
                };
                File.createObjectURL(this.data, blob, "image/svg+xml");
              },
              addToCache: function() {
                this.cache.addImage(this.key, this.data);
              }
            });
            FileTypesManager.register("svg", function(key, url, svgConfig, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new SVGFile(this, key[i]));
                }
              } else {
                this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));
              }
              return this;
            });
            module2.exports = SVGFile;
          },
          95171: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var SceneFile = new Class({
              Extends: File,
              initialize: function SceneFile2(loader, key, url, xhrSettings) {
                var extension = "js";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                }
                var fileConfig = {
                  type: "text",
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = this.xhrLoader.responseText;
                this.onProcessComplete();
              },
              addToCache: function() {
                var code = this.data.concat("(function(){\nreturn new " + this.key + "();\n}).call(this);");
                var eval2 = eval;
                this.loader.sceneManager.add(this.key, eval2(code));
                this.complete = true;
              }
            });
            FileTypesManager.register("sceneFile", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new SceneFile(this, key[i]));
                }
              } else {
                this.addFile(new SceneFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = SceneFile;
          },
          82458: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var ScenePluginFile = new Class({
              Extends: File,
              initialize: function ScenePluginFile2(loader, key, url, systemKey, sceneKey, xhrSettings) {
                var extension = "js";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                  systemKey = GetFastValue(config2, "systemKey");
                  sceneKey = GetFastValue(config2, "sceneKey");
                }
                var fileConfig = {
                  type: "scenePlugin",
                  cache: false,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings,
                  config: {
                    systemKey,
                    sceneKey
                  }
                };
                File.call(this, loader, fileConfig);
                if (typeof url === "function") {
                  this.data = url;
                  this.state = CONST.FILE_POPULATED;
                }
              },
              onProcess: function() {
                var pluginManager = this.loader.systems.plugins;
                var config2 = this.config;
                var key = this.key;
                var systemKey = GetFastValue(config2, "systemKey", key);
                var sceneKey = GetFastValue(config2, "sceneKey", key);
                if (this.state === CONST.FILE_POPULATED) {
                  pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);
                } else {
                  this.state = CONST.FILE_PROCESSING;
                  this.data = document.createElement("script");
                  this.data.language = "javascript";
                  this.data.type = "text/javascript";
                  this.data.defer = false;
                  this.data.text = this.xhrLoader.responseText;
                  document.head.appendChild(this.data);
                  pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);
                }
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("scenePlugin", function(key, url, systemKey, sceneKey, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new ScenePluginFile(this, key[i]));
                }
              } else {
                this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));
              }
              return this;
            });
            module2.exports = ScenePluginFile;
          },
          55188: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var ScriptFile = new Class({
              Extends: File,
              initialize: function ScriptFile2(loader, key, url, type, xhrSettings) {
                var extension = "js";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  type = GetFastValue(config2, "type", "script");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                } else if (type === void 0) {
                  type = "script";
                }
                var fileConfig = {
                  type,
                  cache: false,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = document.createElement("script");
                this.data.language = "javascript";
                this.data.type = "text/javascript";
                this.data.defer = false;
                this.data.text = this.xhrLoader.responseText;
                document.head.appendChild(this.data);
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("script", function(key, url, type, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new ScriptFile(this, key[i]));
                }
              } else {
                this.addFile(new ScriptFile(this, key, url, type, xhrSettings));
              }
              return this;
            });
            module2.exports = ScriptFile;
          },
          33536: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var FileTypesManager = __webpack_require__2(76846);
            var ImageFile = __webpack_require__2(42927);
            var SpriteSheetFile = new Class({
              Extends: ImageFile,
              initialize: function SpriteSheetFile2(loader, key, url, frameConfig, xhrSettings) {
                ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);
                this.type = "spritesheet";
              },
              addToCache: function() {
                var linkFile = this.linkFile;
                if (linkFile) {
                  if (linkFile.state >= CONST.FILE_COMPLETE) {
                    if (this.type === "normalMap") {
                      this.cache.addSpriteSheet(this.key, linkFile.data, this.config, this.data);
                    } else {
                      this.cache.addSpriteSheet(this.key, this.data, this.config, linkFile.data);
                    }
                  }
                } else {
                  this.cache.addSpriteSheet(this.key, this.data, this.config);
                }
              }
            });
            FileTypesManager.register("spritesheet", function(key, url, frameConfig, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new SpriteSheetFile(this, key[i]));
                }
              } else {
                this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));
              }
              return this;
            });
            module2.exports = SpriteSheetFile;
          },
          86897: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var TextFile = new Class({
              Extends: File,
              initialize: function TextFile2(loader, key, url, xhrSettings) {
                var type = "text";
                var extension = "txt";
                var cache = loader.cacheManager.text;
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                  type = GetFastValue(config2, "type", type);
                  cache = GetFastValue(config2, "cache", cache);
                }
                var fileConfig = {
                  type,
                  cache,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = this.xhrLoader.responseText;
                this.onProcessComplete();
              }
            });
            FileTypesManager.register("text", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new TextFile(this, key[i]));
                }
              } else {
                this.addFile(new TextFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = TextFile;
          },
          58673: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var TILEMAP_FORMATS = __webpack_require__2(93560);
            var TilemapCSVFile = new Class({
              Extends: File,
              initialize: function TilemapCSVFile2(loader, key, url, xhrSettings) {
                var extension = "csv";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                }
                var fileConfig = {
                  type: "tilemapCSV",
                  cache: loader.cacheManager.tilemap,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings
                };
                File.call(this, loader, fileConfig);
                this.tilemapFormat = TILEMAP_FORMATS.CSV;
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = this.xhrLoader.responseText;
                this.onProcessComplete();
              },
              addToCache: function() {
                var tiledata = {format: this.tilemapFormat, data: this.data};
                this.cache.add(this.key, tiledata);
              }
            });
            FileTypesManager.register("tilemapCSV", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new TilemapCSVFile(this, key[i]));
                }
              } else {
                this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = TilemapCSVFile;
          },
          98896: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var JSONFile = __webpack_require__2(70806);
            var TILEMAP_FORMATS = __webpack_require__2(93560);
            var TilemapImpactFile = new Class({
              Extends: JSONFile,
              initialize: function TilemapImpactFile2(loader, key, url, xhrSettings) {
                JSONFile.call(this, loader, key, url, xhrSettings);
                this.type = "tilemapJSON";
                this.cache = loader.cacheManager.tilemap;
              },
              addToCache: function() {
                var tiledata = {format: TILEMAP_FORMATS.WELTMEISTER, data: this.data};
                this.cache.add(this.key, tiledata);
              }
            });
            FileTypesManager.register("tilemapImpact", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new TilemapImpactFile(this, key[i]));
                }
              } else {
                this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = TilemapImpactFile;
          },
          50563: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var JSONFile = __webpack_require__2(70806);
            var TILEMAP_FORMATS = __webpack_require__2(93560);
            var TilemapJSONFile = new Class({
              Extends: JSONFile,
              initialize: function TilemapJSONFile2(loader, key, url, xhrSettings) {
                JSONFile.call(this, loader, key, url, xhrSettings);
                this.type = "tilemapJSON";
                this.cache = loader.cacheManager.tilemap;
              },
              addToCache: function() {
                var tiledata = {format: TILEMAP_FORMATS.TILED_JSON, data: this.data};
                this.cache.add(this.key, tiledata);
              }
            });
            FileTypesManager.register("tilemapTiledJSON", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new TilemapJSONFile(this, key[i]));
                }
              } else {
                this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = TilemapJSONFile;
          },
          82857: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var ImageFile = __webpack_require__2(42927);
            var IsPlainObject = __webpack_require__2(42911);
            var MultiFile = __webpack_require__2(45176);
            var TextFile = __webpack_require__2(86897);
            var UnityAtlasFile = new Class({
              Extends: MultiFile,
              initialize: function UnityAtlasFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
                var image;
                var data;
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  image = new ImageFile(loader, {
                    key,
                    url: GetFastValue(config2, "textureURL"),
                    extension: GetFastValue(config2, "textureExtension", "png"),
                    normalMap: GetFastValue(config2, "normalMap"),
                    xhrSettings: GetFastValue(config2, "textureXhrSettings")
                  });
                  data = new TextFile(loader, {
                    key,
                    url: GetFastValue(config2, "atlasURL"),
                    extension: GetFastValue(config2, "atlasExtension", "txt"),
                    xhrSettings: GetFastValue(config2, "atlasXhrSettings")
                  });
                } else {
                  image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                  data = new TextFile(loader, key, atlasURL, atlasXhrSettings);
                }
                if (image.linkFile) {
                  MultiFile.call(this, loader, "unityatlas", key, [image, data, image.linkFile]);
                } else {
                  MultiFile.call(this, loader, "unityatlas", key, [image, data]);
                }
              },
              addToCache: function() {
                if (this.isReadyToProcess()) {
                  var image = this.files[0];
                  var text = this.files[1];
                  var normalMap = this.files[2] ? this.files[2].data : null;
                  this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);
                  this.complete = true;
                }
              }
            });
            FileTypesManager.register("unityAtlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var multifile;
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  multifile = new UnityAtlasFile(this, key[i]);
                  this.addFile(multifile.files);
                }
              } else {
                multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
                this.addFile(multifile.files);
              }
              return this;
            });
            module2.exports = UnityAtlasFile;
          },
          22833: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetURL = __webpack_require__2(30750);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var VideoFile = new Class({
              Extends: File,
              initialize: function VideoFile2(loader, key, url, noAudio) {
                if (noAudio === void 0) {
                  noAudio = false;
                }
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url", []);
                  noAudio = GetFastValue(config2, "noAudio", false);
                }
                var urlConfig = loader.systems.game.device.video.getVideoURL(url);
                if (!urlConfig) {
                  console.warn("VideoFile: No supported format for " + key);
                }
                var fileConfig = {
                  type: "video",
                  cache: loader.cacheManager.video,
                  extension: urlConfig.type,
                  key,
                  url: urlConfig.url,
                  config: {
                    noAudio
                  }
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.data = {
                  url: this.src,
                  noAudio: this.config.noAudio,
                  crossOrigin: this.crossOrigin
                };
                this.onProcessComplete();
              },
              load: function() {
                this.src = GetURL(this, this.loader.baseURL);
                this.state = CONST.FILE_LOADED;
                this.loader.nextFile(this, true);
              }
            });
            FileTypesManager.register("video", function(key, urls, noAudio) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new VideoFile(this, key[i]));
                }
              } else {
                this.addFile(new VideoFile(this, key, urls, noAudio));
              }
              return this;
            });
            module2.exports = VideoFile;
          },
          15297: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12117);
            var File = __webpack_require__2(98035);
            var FileTypesManager = __webpack_require__2(76846);
            var GetFastValue = __webpack_require__2(72632);
            var IsPlainObject = __webpack_require__2(42911);
            var ParseXML = __webpack_require__2(89200);
            var XMLFile = new Class({
              Extends: File,
              initialize: function XMLFile2(loader, key, url, xhrSettings) {
                var extension = "xml";
                if (IsPlainObject(key)) {
                  var config2 = key;
                  key = GetFastValue(config2, "key");
                  url = GetFastValue(config2, "url");
                  xhrSettings = GetFastValue(config2, "xhrSettings");
                  extension = GetFastValue(config2, "extension", extension);
                }
                var fileConfig = {
                  type: "xml",
                  cache: loader.cacheManager.xml,
                  extension,
                  responseType: "text",
                  key,
                  url,
                  xhrSettings
                };
                File.call(this, loader, fileConfig);
              },
              onProcess: function() {
                this.state = CONST.FILE_PROCESSING;
                this.data = ParseXML(this.xhrLoader.responseText);
                if (this.data) {
                  this.onProcessComplete();
                } else {
                  this.onProcessError();
                }
              }
            });
            FileTypesManager.register("xml", function(key, url, xhrSettings) {
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.addFile(new XMLFile(this, key[i]));
                }
              } else {
                this.addFile(new XMLFile(this, key, url, xhrSettings));
              }
              return this;
            });
            module2.exports = XMLFile;
          },
          34034: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              AnimationJSONFile: __webpack_require__2(46468),
              AsepriteFile: __webpack_require__2(31648),
              AtlasJSONFile: __webpack_require__2(73152),
              AtlasXMLFile: __webpack_require__2(24616),
              AudioFile: __webpack_require__2(67448),
              AudioSpriteFile: __webpack_require__2(66109),
              BinaryFile: __webpack_require__2(40612),
              BitmapFontFile: __webpack_require__2(54565),
              CompressedTextureFile: __webpack_require__2(47375),
              CSSFile: __webpack_require__2(99898),
              GLSLFile: __webpack_require__2(46568),
              HTML5AudioFile: __webpack_require__2(30929),
              HTMLFile: __webpack_require__2(77459),
              HTMLTextureFile: __webpack_require__2(9755),
              ImageFile: __webpack_require__2(42927),
              JSONFile: __webpack_require__2(70806),
              MultiAtlasFile: __webpack_require__2(80802),
              MultiScriptFile: __webpack_require__2(39034),
              OBJFile: __webpack_require__2(85527),
              PackFile: __webpack_require__2(3616),
              PluginFile: __webpack_require__2(12217),
              SceneFile: __webpack_require__2(95171),
              ScenePluginFile: __webpack_require__2(82458),
              ScriptFile: __webpack_require__2(55188),
              SpriteSheetFile: __webpack_require__2(33536),
              SVGFile: __webpack_require__2(4474),
              TextFile: __webpack_require__2(86897),
              TilemapCSVFile: __webpack_require__2(58673),
              TilemapImpactFile: __webpack_require__2(98896),
              TilemapJSONFile: __webpack_require__2(50563),
              UnityAtlasFile: __webpack_require__2(82857),
              VideoFile: __webpack_require__2(22833),
              XMLFile: __webpack_require__2(15297)
            };
          },
          95695: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12117);
            var Extend = __webpack_require__2(98611);
            var Loader = {
              Events: __webpack_require__2(683),
              FileTypes: __webpack_require__2(34034),
              File: __webpack_require__2(98035),
              FileTypesManager: __webpack_require__2(76846),
              GetURL: __webpack_require__2(30750),
              LoaderPlugin: __webpack_require__2(67285),
              MergeXHRSettings: __webpack_require__2(43531),
              MultiFile: __webpack_require__2(45176),
              XHRLoader: __webpack_require__2(88490),
              XHRSettings: __webpack_require__2(33868)
            };
            Loader = Extend(false, Loader, CONST);
            module2.exports = Loader;
          },
          26042: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Average = function(values) {
              var sum = 0;
              for (var i = 0; i < values.length; i++) {
                sum += +values[i];
              }
              return sum / values.length;
            };
            module2.exports = Average;
          },
          22824: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Factorial = __webpack_require__2(8034);
            var Bernstein = function(n, i) {
              return Factorial(n) / Factorial(i) / Factorial(n - i);
            };
            module2.exports = Bernstein;
          },
          17489: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Between = function(min, max) {
              return Math.floor(Math.random() * (max - min + 1) + min);
            };
            module2.exports = Between;
          },
          14976: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CatmullRom = function(t, p0, p1, p2, p3) {
              var v0 = (p2 - p0) * 0.5;
              var v1 = (p3 - p1) * 0.5;
              var t2 = t * t;
              var t3 = t * t2;
              return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            };
            module2.exports = CatmullRom;
          },
          89129: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CeilTo = function(value, place, base) {
              if (place === void 0) {
                place = 0;
              }
              if (base === void 0) {
                base = 10;
              }
              var p = Math.pow(base, -place);
              return Math.ceil(value * p) / p;
            };
            module2.exports = CeilTo;
          },
          82897: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = function(value, min, max) {
              return Math.max(min, Math.min(max, value));
            };
            module2.exports = Clamp;
          },
          75606: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(83392);
            var DegToRad = function(degrees) {
              return degrees * CONST.DEG_TO_RAD;
            };
            module2.exports = DegToRad;
          },
          767: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Difference = function(a, b) {
              return Math.abs(a - b);
            };
            module2.exports = Difference;
          },
          9849: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Matrix4 = __webpack_require__2(16650);
            var NOOP = __webpack_require__2(72283);
            var tempMatrix = new Matrix4();
            var Euler = new Class({
              initialize: function Euler2(x, y, z, order) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (z === void 0) {
                  z = 0;
                }
                if (order === void 0) {
                  order = Euler2.DefaultOrder;
                }
                this._x = x;
                this._y = y;
                this._z = z;
                this._order = order;
                this.onChangeCallback = NOOP;
              },
              x: {
                get: function() {
                  return this._x;
                },
                set: function(value) {
                  this._x = value;
                  this.onChangeCallback(this);
                }
              },
              y: {
                get: function() {
                  return this._y;
                },
                set: function(value) {
                  this._y = value;
                  this.onChangeCallback(this);
                }
              },
              z: {
                get: function() {
                  return this._z;
                },
                set: function(value) {
                  this._z = value;
                  this.onChangeCallback(this);
                }
              },
              order: {
                get: function() {
                  return this._order;
                },
                set: function(value) {
                  this._order = value;
                  this.onChangeCallback(this);
                }
              },
              set: function(x, y, z, order) {
                if (order === void 0) {
                  order = this._order;
                }
                this._x = x;
                this._y = y;
                this._z = z;
                this._order = order;
                this.onChangeCallback(this);
                return this;
              },
              copy: function(euler) {
                return this.set(euler.x, euler.y, euler.z, euler.order);
              },
              setFromQuaternion: function(quaternion, order, update) {
                if (order === void 0) {
                  order = this._order;
                }
                if (update === void 0) {
                  update = false;
                }
                tempMatrix.fromQuat(quaternion);
                return this.setFromRotationMatrix(tempMatrix, order, update);
              },
              setFromRotationMatrix: function(matrix, order, update) {
                if (order === void 0) {
                  order = this._order;
                }
                if (update === void 0) {
                  update = false;
                }
                var elements = matrix.val;
                var m11 = elements[0];
                var m12 = elements[4];
                var m13 = elements[8];
                var m21 = elements[1];
                var m22 = elements[5];
                var m23 = elements[9];
                var m31 = elements[2];
                var m32 = elements[6];
                var m33 = elements[10];
                var x = 0;
                var y = 0;
                var z = 0;
                var epsilon = 0.99999;
                switch (order) {
                  case "XYZ": {
                    y = Math.asin(Clamp(m13, -1, 1));
                    if (Math.abs(m13) < epsilon) {
                      x = Math.atan2(-m23, m33);
                      z = Math.atan2(-m12, m11);
                    } else {
                      x = Math.atan2(m32, m22);
                    }
                    break;
                  }
                  case "YXZ": {
                    x = Math.asin(-Clamp(m23, -1, 1));
                    if (Math.abs(m23) < epsilon) {
                      y = Math.atan2(m13, m33);
                      z = Math.atan2(m21, m22);
                    } else {
                      y = Math.atan2(-m31, m11);
                    }
                    break;
                  }
                  case "ZXY": {
                    x = Math.asin(Clamp(m32, -1, 1));
                    if (Math.abs(m32) < epsilon) {
                      y = Math.atan2(-m31, m33);
                      z = Math.atan2(-m12, m22);
                    } else {
                      z = Math.atan2(m21, m11);
                    }
                    break;
                  }
                  case "ZYX": {
                    y = Math.asin(-Clamp(m31, -1, 1));
                    if (Math.abs(m31) < epsilon) {
                      x = Math.atan2(m32, m33);
                      z = Math.atan2(m21, m11);
                    } else {
                      z = Math.atan2(-m12, m22);
                    }
                    break;
                  }
                  case "YZX": {
                    z = Math.asin(Clamp(m21, -1, 1));
                    if (Math.abs(m21) < epsilon) {
                      x = Math.atan2(-m23, m22);
                      y = Math.atan2(-m31, m11);
                    } else {
                      y = Math.atan2(m13, m33);
                    }
                    break;
                  }
                  case "XZY": {
                    z = Math.asin(-Clamp(m12, -1, 1));
                    if (Math.abs(m12) < epsilon) {
                      x = Math.atan2(m32, m22);
                      y = Math.atan2(m13, m11);
                    } else {
                      x = Math.atan2(-m23, m33);
                    }
                    break;
                  }
                }
                this._x = x;
                this._y = y;
                this._z = z;
                this._order = order;
                if (update) {
                  this.onChangeCallback(this);
                }
                return this;
              }
            });
            Euler.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"];
            Euler.DefaultOrder = "XYZ";
            module2.exports = Euler;
          },
          8034: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Factorial = function(value) {
              if (value === 0) {
                return 1;
              }
              var res = value;
              while (--value) {
                res *= value;
              }
              return res;
            };
            module2.exports = Factorial;
          },
          61616: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FloatBetween = function(min, max) {
              return Math.random() * (max - min) + min;
            };
            module2.exports = FloatBetween;
          },
          60679: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FloorTo = function(value, place, base) {
              if (place === void 0) {
                place = 0;
              }
              if (base === void 0) {
                base = 10;
              }
              var p = Math.pow(base, -place);
              return Math.floor(value * p) / p;
            };
            module2.exports = FloorTo;
          },
          91806: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var FromPercent = function(percent, min, max) {
              percent = Clamp(percent, 0, 1);
              return (max - min) * percent + min;
            };
            module2.exports = FromPercent;
          },
          79366: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetSpeed = function(distance, time) {
              return distance / time / 1e3;
            };
            module2.exports = GetSpeed;
          },
          43776: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsEven = function(value) {
              return value == parseFloat(value) ? !(value % 2) : void 0;
            };
            module2.exports = IsEven;
          },
          58442: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsEvenStrict = function(value) {
              return value === parseFloat(value) ? !(value % 2) : void 0;
            };
            module2.exports = IsEvenStrict;
          },
          42798: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Linear = function(p0, p1, t) {
              return (p1 - p0) * t + p0;
            };
            module2.exports = Linear;
          },
          61072: (module2) => {
            /**
             * @author       Greg McLean <GregDevProjects>
             * @copyright    2021 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LinearXY = function(vector1, vector2, t) {
              if (t === void 0) {
                t = 0;
              }
              return vector1.clone().lerp(vector2, t);
            };
            module2.exports = LinearXY;
          },
          5341: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Matrix3 = new Class({
              initialize: function Matrix32(m) {
                this.val = new Float32Array(9);
                if (m) {
                  this.copy(m);
                } else {
                  this.identity();
                }
              },
              clone: function() {
                return new Matrix3(this);
              },
              set: function(src) {
                return this.copy(src);
              },
              copy: function(src) {
                var out = this.val;
                var a = src.val;
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[8] = a[8];
                return this;
              },
              fromMat4: function(m) {
                var a = m.val;
                var out = this.val;
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[4];
                out[4] = a[5];
                out[5] = a[6];
                out[6] = a[8];
                out[7] = a[9];
                out[8] = a[10];
                return this;
              },
              fromArray: function(a) {
                var out = this.val;
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[8] = a[8];
                return this;
              },
              identity: function() {
                var out = this.val;
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 1;
                out[5] = 0;
                out[6] = 0;
                out[7] = 0;
                out[8] = 1;
                return this;
              },
              transpose: function() {
                var a = this.val;
                var a01 = a[1];
                var a02 = a[2];
                var a12 = a[5];
                a[1] = a[3];
                a[2] = a[6];
                a[3] = a01;
                a[5] = a[7];
                a[6] = a02;
                a[7] = a12;
                return this;
              },
              invert: function() {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a10 = a[3];
                var a11 = a[4];
                var a12 = a[5];
                var a20 = a[6];
                var a21 = a[7];
                var a22 = a[8];
                var b01 = a22 * a11 - a12 * a21;
                var b11 = -a22 * a10 + a12 * a20;
                var b21 = a21 * a10 - a11 * a20;
                var det = a00 * b01 + a01 * b11 + a02 * b21;
                if (!det) {
                  return null;
                }
                det = 1 / det;
                a[0] = b01 * det;
                a[1] = (-a22 * a01 + a02 * a21) * det;
                a[2] = (a12 * a01 - a02 * a11) * det;
                a[3] = b11 * det;
                a[4] = (a22 * a00 - a02 * a20) * det;
                a[5] = (-a12 * a00 + a02 * a10) * det;
                a[6] = b21 * det;
                a[7] = (-a21 * a00 + a01 * a20) * det;
                a[8] = (a11 * a00 - a01 * a10) * det;
                return this;
              },
              adjoint: function() {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a10 = a[3];
                var a11 = a[4];
                var a12 = a[5];
                var a20 = a[6];
                var a21 = a[7];
                var a22 = a[8];
                a[0] = a11 * a22 - a12 * a21;
                a[1] = a02 * a21 - a01 * a22;
                a[2] = a01 * a12 - a02 * a11;
                a[3] = a12 * a20 - a10 * a22;
                a[4] = a00 * a22 - a02 * a20;
                a[5] = a02 * a10 - a00 * a12;
                a[6] = a10 * a21 - a11 * a20;
                a[7] = a01 * a20 - a00 * a21;
                a[8] = a00 * a11 - a01 * a10;
                return this;
              },
              determinant: function() {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a10 = a[3];
                var a11 = a[4];
                var a12 = a[5];
                var a20 = a[6];
                var a21 = a[7];
                var a22 = a[8];
                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
              },
              multiply: function(src) {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a10 = a[3];
                var a11 = a[4];
                var a12 = a[5];
                var a20 = a[6];
                var a21 = a[7];
                var a22 = a[8];
                var b = src.val;
                var b00 = b[0];
                var b01 = b[1];
                var b02 = b[2];
                var b10 = b[3];
                var b11 = b[4];
                var b12 = b[5];
                var b20 = b[6];
                var b21 = b[7];
                var b22 = b[8];
                a[0] = b00 * a00 + b01 * a10 + b02 * a20;
                a[1] = b00 * a01 + b01 * a11 + b02 * a21;
                a[2] = b00 * a02 + b01 * a12 + b02 * a22;
                a[3] = b10 * a00 + b11 * a10 + b12 * a20;
                a[4] = b10 * a01 + b11 * a11 + b12 * a21;
                a[5] = b10 * a02 + b11 * a12 + b12 * a22;
                a[6] = b20 * a00 + b21 * a10 + b22 * a20;
                a[7] = b20 * a01 + b21 * a11 + b22 * a21;
                a[8] = b20 * a02 + b21 * a12 + b22 * a22;
                return this;
              },
              translate: function(v) {
                var a = this.val;
                var x = v.x;
                var y = v.y;
                a[6] = x * a[0] + y * a[3] + a[6];
                a[7] = x * a[1] + y * a[4] + a[7];
                a[8] = x * a[2] + y * a[5] + a[8];
                return this;
              },
              rotate: function(rad) {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a10 = a[3];
                var a11 = a[4];
                var a12 = a[5];
                var s = Math.sin(rad);
                var c = Math.cos(rad);
                a[0] = c * a00 + s * a10;
                a[1] = c * a01 + s * a11;
                a[2] = c * a02 + s * a12;
                a[3] = c * a10 - s * a00;
                a[4] = c * a11 - s * a01;
                a[5] = c * a12 - s * a02;
                return this;
              },
              scale: function(v) {
                var a = this.val;
                var x = v.x;
                var y = v.y;
                a[0] = x * a[0];
                a[1] = x * a[1];
                a[2] = x * a[2];
                a[3] = y * a[3];
                a[4] = y * a[4];
                a[5] = y * a[5];
                return this;
              },
              fromQuat: function(q) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var xy = x * y2;
                var xz = x * z2;
                var yy = y * y2;
                var yz = y * z2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                var out = this.val;
                out[0] = 1 - (yy + zz);
                out[3] = xy + wz;
                out[6] = xz - wy;
                out[1] = xy - wz;
                out[4] = 1 - (xx + zz);
                out[7] = yz + wx;
                out[2] = xz + wy;
                out[5] = yz - wx;
                out[8] = 1 - (xx + yy);
                return this;
              },
              normalFromMat4: function(m) {
                var a = m.val;
                var out = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                var a30 = a[12];
                var a31 = a[13];
                var a32 = a[14];
                var a33 = a[15];
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) {
                  return null;
                }
                det = 1 / det;
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                return this;
              }
            });
            module2.exports = Matrix3;
          },
          16650: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Vector3 = __webpack_require__2(70015);
            var EPSILON = 1e-6;
            var Matrix4 = new Class({
              initialize: function Matrix42(m) {
                this.val = new Float32Array(16);
                if (m) {
                  this.copy(m);
                } else {
                  this.identity();
                }
              },
              clone: function() {
                return new Matrix4(this);
              },
              set: function(src) {
                return this.copy(src);
              },
              setValues: function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                var out = this.val;
                out[0] = m00;
                out[1] = m01;
                out[2] = m02;
                out[3] = m03;
                out[4] = m10;
                out[5] = m11;
                out[6] = m12;
                out[7] = m13;
                out[8] = m20;
                out[9] = m21;
                out[10] = m22;
                out[11] = m23;
                out[12] = m30;
                out[13] = m31;
                out[14] = m32;
                out[15] = m33;
                return this;
              },
              copy: function(src) {
                var a = src.val;
                return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
              },
              fromArray: function(a) {
                return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
              },
              zero: function() {
                return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
              },
              transform: function(position, scale, rotation) {
                var rotMatrix = _tempMat1.fromQuat(rotation);
                var rm = rotMatrix.val;
                var sx = scale.x;
                var sy = scale.y;
                var sz = scale.z;
                return this.setValues(rm[0] * sx, rm[1] * sx, rm[2] * sx, 0, rm[4] * sy, rm[5] * sy, rm[6] * sy, 0, rm[8] * sz, rm[9] * sz, rm[10] * sz, 0, position.x, position.y, position.z, 1);
              },
              xyz: function(x, y, z) {
                this.identity();
                var out = this.val;
                out[12] = x;
                out[13] = y;
                out[14] = z;
                return this;
              },
              scaling: function(x, y, z) {
                this.zero();
                var out = this.val;
                out[0] = x;
                out[5] = y;
                out[10] = z;
                out[15] = 1;
                return this;
              },
              identity: function() {
                return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
              },
              transpose: function() {
                var a = this.val;
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a12 = a[6];
                var a13 = a[7];
                var a23 = a[11];
                a[1] = a[4];
                a[2] = a[8];
                a[3] = a[12];
                a[4] = a01;
                a[6] = a[9];
                a[7] = a[13];
                a[8] = a02;
                a[9] = a12;
                a[11] = a[14];
                a[12] = a03;
                a[13] = a13;
                a[14] = a23;
                return this;
              },
              getInverse: function(m) {
                this.copy(m);
                return this.invert();
              },
              invert: function() {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                var a30 = a[12];
                var a31 = a[13];
                var a32 = a[14];
                var a33 = a[15];
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) {
                  return this;
                }
                det = 1 / det;
                return this.setValues((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
              },
              adjoint: function() {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                var a30 = a[12];
                var a31 = a[13];
                var a32 = a[14];
                var a33 = a[15];
                return this.setValues(a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22), -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22)), a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12), -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12)), -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22)), a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22), -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12)), a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12), a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21), -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21)), a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11), -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11)), -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21)), a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21), -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11)), a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
              },
              determinant: function() {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                var a30 = a[12];
                var a31 = a[13];
                var a32 = a[14];
                var a33 = a[15];
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              },
              multiply: function(src) {
                var a = this.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                var a30 = a[12];
                var a31 = a[13];
                var a32 = a[14];
                var a33 = a[15];
                var b = src.val;
                var b0 = b[0];
                var b1 = b[1];
                var b2 = b[2];
                var b3 = b[3];
                a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[4];
                b1 = b[5];
                b2 = b[6];
                b3 = b[7];
                a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[8];
                b1 = b[9];
                b2 = b[10];
                b3 = b[11];
                a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[12];
                b1 = b[13];
                b2 = b[14];
                b3 = b[15];
                a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return this;
              },
              multiplyLocal: function(src) {
                var a = this.val;
                var b = src.val;
                return this.setValues(a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12], a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13], a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14], a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15], a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12], a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13], a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14], a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15], a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12], a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13], a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14], a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15], a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12], a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13], a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14], a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]);
              },
              premultiply: function(m) {
                return this.multiplyMatrices(m, this);
              },
              multiplyMatrices: function(a, b) {
                var am = a.val;
                var bm = b.val;
                var a11 = am[0];
                var a12 = am[4];
                var a13 = am[8];
                var a14 = am[12];
                var a21 = am[1];
                var a22 = am[5];
                var a23 = am[9];
                var a24 = am[13];
                var a31 = am[2];
                var a32 = am[6];
                var a33 = am[10];
                var a34 = am[14];
                var a41 = am[3];
                var a42 = am[7];
                var a43 = am[11];
                var a44 = am[15];
                var b11 = bm[0];
                var b12 = bm[4];
                var b13 = bm[8];
                var b14 = bm[12];
                var b21 = bm[1];
                var b22 = bm[5];
                var b23 = bm[9];
                var b24 = bm[13];
                var b31 = bm[2];
                var b32 = bm[6];
                var b33 = bm[10];
                var b34 = bm[14];
                var b41 = bm[3];
                var b42 = bm[7];
                var b43 = bm[11];
                var b44 = bm[15];
                return this.setValues(a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44);
              },
              translate: function(v) {
                return this.translateXYZ(v.x, v.y, v.z);
              },
              translateXYZ: function(x, y, z) {
                var a = this.val;
                a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                return this;
              },
              scale: function(v) {
                return this.scaleXYZ(v.x, v.y, v.z);
              },
              scaleXYZ: function(x, y, z) {
                var a = this.val;
                a[0] = a[0] * x;
                a[1] = a[1] * x;
                a[2] = a[2] * x;
                a[3] = a[3] * x;
                a[4] = a[4] * y;
                a[5] = a[5] * y;
                a[6] = a[6] * y;
                a[7] = a[7] * y;
                a[8] = a[8] * z;
                a[9] = a[9] * z;
                a[10] = a[10] * z;
                a[11] = a[11] * z;
                return this;
              },
              makeRotationAxis: function(axis, angle) {
                var c = Math.cos(angle);
                var s = Math.sin(angle);
                var t = 1 - c;
                var x = axis.x;
                var y = axis.y;
                var z = axis.z;
                var tx = t * x;
                var ty = t * y;
                return this.setValues(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
              },
              rotate: function(rad, axis) {
                var a = this.val;
                var x = axis.x;
                var y = axis.y;
                var z = axis.z;
                var len = Math.sqrt(x * x + y * y + z * z);
                if (Math.abs(len) < EPSILON) {
                  return this;
                }
                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                var s = Math.sin(rad);
                var c = Math.cos(rad);
                var t = 1 - c;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                var a30 = a[12];
                var a31 = a[13];
                var a32 = a[14];
                var a33 = a[15];
                var b00 = x * x * t + c;
                var b01 = y * x * t + z * s;
                var b02 = z * x * t - y * s;
                var b10 = x * y * t - z * s;
                var b11 = y * y * t + c;
                var b12 = z * y * t + x * s;
                var b20 = x * z * t + y * s;
                var b21 = y * z * t - x * s;
                var b22 = z * z * t + c;
                return this.setValues(a00 * b00 + a10 * b01 + a20 * b02, a01 * b00 + a11 * b01 + a21 * b02, a02 * b00 + a12 * b01 + a22 * b02, a03 * b00 + a13 * b01 + a23 * b02, a00 * b10 + a10 * b11 + a20 * b12, a01 * b10 + a11 * b11 + a21 * b12, a02 * b10 + a12 * b11 + a22 * b12, a03 * b10 + a13 * b11 + a23 * b12, a00 * b20 + a10 * b21 + a20 * b22, a01 * b20 + a11 * b21 + a21 * b22, a02 * b20 + a12 * b21 + a22 * b22, a03 * b20 + a13 * b21 + a23 * b22, a30, a31, a32, a33);
              },
              rotateX: function(rad) {
                var a = this.val;
                var s = Math.sin(rad);
                var c = Math.cos(rad);
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                a[4] = a10 * c + a20 * s;
                a[5] = a11 * c + a21 * s;
                a[6] = a12 * c + a22 * s;
                a[7] = a13 * c + a23 * s;
                a[8] = a20 * c - a10 * s;
                a[9] = a21 * c - a11 * s;
                a[10] = a22 * c - a12 * s;
                a[11] = a23 * c - a13 * s;
                return this;
              },
              rotateY: function(rad) {
                var a = this.val;
                var s = Math.sin(rad);
                var c = Math.cos(rad);
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                a[0] = a00 * c - a20 * s;
                a[1] = a01 * c - a21 * s;
                a[2] = a02 * c - a22 * s;
                a[3] = a03 * c - a23 * s;
                a[8] = a00 * s + a20 * c;
                a[9] = a01 * s + a21 * c;
                a[10] = a02 * s + a22 * c;
                a[11] = a03 * s + a23 * c;
                return this;
              },
              rotateZ: function(rad) {
                var a = this.val;
                var s = Math.sin(rad);
                var c = Math.cos(rad);
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                a[0] = a00 * c + a10 * s;
                a[1] = a01 * c + a11 * s;
                a[2] = a02 * c + a12 * s;
                a[3] = a03 * c + a13 * s;
                a[4] = a10 * c - a00 * s;
                a[5] = a11 * c - a01 * s;
                a[6] = a12 * c - a02 * s;
                a[7] = a13 * c - a03 * s;
                return this;
              },
              fromRotationTranslation: function(q, v) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var xy = x * y2;
                var xz = x * z2;
                var yy = y * y2;
                var yz = y * z2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, v.x, v.y, v.z, 1);
              },
              fromQuat: function(q) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var xy = x * y2;
                var xz = x * z2;
                var yy = y * y2;
                var yz = y * z2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
              },
              frustum: function(left, right, bottom, top, near, far) {
                var rl = 1 / (right - left);
                var tb = 1 / (top - bottom);
                var nf = 1 / (near - far);
                return this.setValues(near * 2 * rl, 0, 0, 0, 0, near * 2 * tb, 0, 0, (right + left) * rl, (top + bottom) * tb, (far + near) * nf, -1, 0, 0, far * near * 2 * nf, 0);
              },
              perspective: function(fovy, aspect, near, far) {
                var f = 1 / Math.tan(fovy / 2);
                var nf = 1 / (near - far);
                return this.setValues(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0);
              },
              perspectiveLH: function(width, height, near, far) {
                return this.setValues(2 * near / width, 0, 0, 0, 0, 2 * near / height, 0, 0, 0, 0, -far / (near - far), 1, 0, 0, near * far / (near - far), 0);
              },
              ortho: function(left, right, bottom, top, near, far) {
                var lr = left - right;
                var bt = bottom - top;
                var nf = near - far;
                lr = lr === 0 ? lr : 1 / lr;
                bt = bt === 0 ? bt : 1 / bt;
                nf = nf === 0 ? nf : 1 / nf;
                return this.setValues(-2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf, 0, (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1);
              },
              lookAtRH: function(eye, target, up) {
                var m = this.val;
                _z.subVectors(eye, target);
                if (_z.getLengthSquared() === 0) {
                  _z.z = 1;
                }
                _z.normalize();
                _x.crossVectors(up, _z);
                if (_x.getLengthSquared() === 0) {
                  if (Math.abs(up.z) === 1) {
                    _z.x += 1e-4;
                  } else {
                    _z.z += 1e-4;
                  }
                  _z.normalize();
                  _x.crossVectors(up, _z);
                }
                _x.normalize();
                _y.crossVectors(_z, _x);
                m[0] = _x.x;
                m[1] = _x.y;
                m[2] = _x.z;
                m[4] = _y.x;
                m[5] = _y.y;
                m[6] = _y.z;
                m[8] = _z.x;
                m[9] = _z.y;
                m[10] = _z.z;
                return this;
              },
              lookAt: function(eye, center, up) {
                var eyex = eye.x;
                var eyey = eye.y;
                var eyez = eye.z;
                var upx = up.x;
                var upy = up.y;
                var upz = up.z;
                var centerx = center.x;
                var centery = center.y;
                var centerz = center.z;
                if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
                  return this.identity();
                }
                var z0 = eyex - centerx;
                var z1 = eyey - centery;
                var z2 = eyez - centerz;
                var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len;
                z1 *= len;
                z2 *= len;
                var x0 = upy * z2 - upz * z1;
                var x1 = upz * z0 - upx * z2;
                var x2 = upx * z1 - upy * z0;
                len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                if (!len) {
                  x0 = 0;
                  x1 = 0;
                  x2 = 0;
                } else {
                  len = 1 / len;
                  x0 *= len;
                  x1 *= len;
                  x2 *= len;
                }
                var y0 = z1 * x2 - z2 * x1;
                var y1 = z2 * x0 - z0 * x2;
                var y2 = z0 * x1 - z1 * x0;
                len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                if (!len) {
                  y0 = 0;
                  y1 = 0;
                  y2 = 0;
                } else {
                  len = 1 / len;
                  y0 *= len;
                  y1 *= len;
                  y2 *= len;
                }
                return this.setValues(x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, -(x0 * eyex + x1 * eyey + x2 * eyez), -(y0 * eyex + y1 * eyey + y2 * eyez), -(z0 * eyex + z1 * eyey + z2 * eyez), 1);
              },
              yawPitchRoll: function(yaw, pitch, roll) {
                this.zero();
                _tempMat1.zero();
                _tempMat2.zero();
                var m0 = this.val;
                var m1 = _tempMat1.val;
                var m2 = _tempMat2.val;
                var s = Math.sin(roll);
                var c = Math.cos(roll);
                m0[10] = 1;
                m0[15] = 1;
                m0[0] = c;
                m0[1] = s;
                m0[4] = -s;
                m0[5] = c;
                s = Math.sin(pitch);
                c = Math.cos(pitch);
                m1[0] = 1;
                m1[15] = 1;
                m1[5] = c;
                m1[10] = c;
                m1[9] = -s;
                m1[6] = s;
                s = Math.sin(yaw);
                c = Math.cos(yaw);
                m2[5] = 1;
                m2[15] = 1;
                m2[0] = c;
                m2[2] = -s;
                m2[8] = s;
                m2[10] = c;
                this.multiplyLocal(_tempMat1);
                this.multiplyLocal(_tempMat2);
                return this;
              },
              setWorldMatrix: function(rotation, position, scale, viewMatrix, projectionMatrix) {
                this.yawPitchRoll(rotation.y, rotation.x, rotation.z);
                _tempMat1.scaling(scale.x, scale.y, scale.z);
                _tempMat2.xyz(position.x, position.y, position.z);
                this.multiplyLocal(_tempMat1);
                this.multiplyLocal(_tempMat2);
                if (viewMatrix) {
                  this.multiplyLocal(viewMatrix);
                }
                if (projectionMatrix) {
                  this.multiplyLocal(projectionMatrix);
                }
                return this;
              },
              multiplyToMat4: function(src, out) {
                var a = this.val;
                var b = src.val;
                var a00 = a[0];
                var a01 = a[1];
                var a02 = a[2];
                var a03 = a[3];
                var a10 = a[4];
                var a11 = a[5];
                var a12 = a[6];
                var a13 = a[7];
                var a20 = a[8];
                var a21 = a[9];
                var a22 = a[10];
                var a23 = a[11];
                var a30 = a[12];
                var a31 = a[13];
                var a32 = a[14];
                var a33 = a[15];
                var b00 = b[0];
                var b01 = b[1];
                var b02 = b[2];
                var b03 = b[3];
                var b10 = b[4];
                var b11 = b[5];
                var b12 = b[6];
                var b13 = b[7];
                var b20 = b[8];
                var b21 = b[9];
                var b22 = b[10];
                var b23 = b[11];
                var b30 = b[12];
                var b31 = b[13];
                var b32 = b[14];
                var b33 = b[15];
                return out.setValues(b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b01 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b02 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b03 * a03 + b01 * a13 + b02 * a23 + b03 * a33, b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30, b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31, b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32, b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33, b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30, b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31, b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32, b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33, b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30, b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31, b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32, b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33);
              },
              fromRotationXYTranslation: function(rotation, position, translateFirst) {
                var x = position.x;
                var y = position.y;
                var z = position.z;
                var sx = Math.sin(rotation.x);
                var cx = Math.cos(rotation.x);
                var sy = Math.sin(rotation.y);
                var cy = Math.cos(rotation.y);
                var a30 = x;
                var a31 = y;
                var a32 = z;
                var b21 = -sx;
                var c01 = 0 - b21 * sy;
                var c02 = 0 - cx * sy;
                var c21 = b21 * cy;
                var c22 = cx * cy;
                if (!translateFirst) {
                  a30 = cy * x + sy * z;
                  a31 = c01 * x + cx * y + c21 * z;
                  a32 = c02 * x + sx * y + c22 * z;
                }
                return this.setValues(cy, c01, c02, 0, 0, cx, sx, 0, sy, c21, c22, 0, a30, a31, a32, 1);
              },
              getMaxScaleOnAxis: function() {
                var m = this.val;
                var scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
                var scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
                var scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
                return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
              }
            });
            var _tempMat1 = new Matrix4();
            var _tempMat2 = new Matrix4();
            var _x = new Vector3();
            var _y = new Vector3();
            var _z = new Vector3();
            module2.exports = Matrix4;
          },
          69635: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MaxAdd = function(value, amount, max) {
              return Math.min(value + amount, max);
            };
            module2.exports = MaxAdd;
          },
          37394: (module2) => {
            /**
             * @author       Vladislav Forsh <vlad@robowhale.com>
             * @copyright    2021 RoboWhale
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Median = function(values) {
              var valuesNum = values.length;
              if (valuesNum === 0) {
                return 0;
              }
              values.sort(function(a, b) {
                return a - b;
              });
              var halfIndex = Math.floor(valuesNum / 2);
              return valuesNum % 2 === 0 ? (values[halfIndex] + values[halfIndex - 1]) / 2 : values[halfIndex];
            };
            module2.exports = Median;
          },
          17259: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MinSub = function(value, amount, min) {
              return Math.max(value - amount, min);
            };
            module2.exports = MinSub;
          },
          61820: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Percent = function(value, min, max, upperMax) {
              if (max === void 0) {
                max = min + 1;
              }
              var percentage = (value - min) / (max - min);
              if (percentage > 1) {
                if (upperMax !== void 0) {
                  percentage = (upperMax - value) / (upperMax - max);
                  if (percentage < 0) {
                    percentage = 0;
                  }
                } else {
                  percentage = 1;
                }
              } else if (percentage < 0) {
                percentage = 0;
              }
              return percentage;
            };
            module2.exports = Percent;
          },
          75003: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Matrix3 = __webpack_require__2(5341);
            var NOOP = __webpack_require__2(72283);
            var Vector3 = __webpack_require__2(70015);
            var EPSILON = 1e-6;
            var siNext = new Int8Array([1, 2, 0]);
            var tmp = new Float32Array([0, 0, 0]);
            var xUnitVec3 = new Vector3(1, 0, 0);
            var yUnitVec3 = new Vector3(0, 1, 0);
            var tmpvec = new Vector3();
            var tmpMat3 = new Matrix3();
            var Quaternion = new Class({
              initialize: function Quaternion2(x, y, z, w) {
                this.onChangeCallback = NOOP;
                this.set(x, y, z, w);
              },
              x: {
                get: function() {
                  return this._x;
                },
                set: function(value) {
                  this._x = value;
                  this.onChangeCallback(this);
                }
              },
              y: {
                get: function() {
                  return this._y;
                },
                set: function(value) {
                  this._y = value;
                  this.onChangeCallback(this);
                }
              },
              z: {
                get: function() {
                  return this._z;
                },
                set: function(value) {
                  this._z = value;
                  this.onChangeCallback(this);
                }
              },
              w: {
                get: function() {
                  return this._w;
                },
                set: function(value) {
                  this._w = value;
                  this.onChangeCallback(this);
                }
              },
              copy: function(src) {
                return this.set(src);
              },
              set: function(x, y, z, w, update) {
                if (update === void 0) {
                  update = true;
                }
                if (typeof x === "object") {
                  this._x = x.x || 0;
                  this._y = x.y || 0;
                  this._z = x.z || 0;
                  this._w = x.w || 0;
                } else {
                  this._x = x || 0;
                  this._y = y || 0;
                  this._z = z || 0;
                  this._w = w || 0;
                }
                if (update) {
                  this.onChangeCallback(this);
                }
                return this;
              },
              add: function(v) {
                this._x += v.x;
                this._y += v.y;
                this._z += v.z;
                this._w += v.w;
                this.onChangeCallback(this);
                return this;
              },
              subtract: function(v) {
                this._x -= v.x;
                this._y -= v.y;
                this._z -= v.z;
                this._w -= v.w;
                this.onChangeCallback(this);
                return this;
              },
              scale: function(scale) {
                this._x *= scale;
                this._y *= scale;
                this._z *= scale;
                this._w *= scale;
                this.onChangeCallback(this);
                return this;
              },
              length: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
              },
              lengthSq: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                return x * x + y * y + z * z + w * w;
              },
              normalize: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                var len = x * x + y * y + z * z + w * w;
                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this._x = x * len;
                  this._y = y * len;
                  this._z = z * len;
                  this._w = w * len;
                }
                this.onChangeCallback(this);
                return this;
              },
              dot: function(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
              },
              lerp: function(v, t) {
                if (t === void 0) {
                  t = 0;
                }
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                return this.set(ax + t * (v.x - ax), ay + t * (v.y - ay), az + t * (v.z - az), aw + t * (v.w - aw));
              },
              rotationTo: function(a, b) {
                var dot = a.x * b.x + a.y * b.y + a.z * b.z;
                if (dot < -0.999999) {
                  if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON) {
                    tmpvec.copy(yUnitVec3).cross(a);
                  }
                  tmpvec.normalize();
                  return this.setAxisAngle(tmpvec, Math.PI);
                } else if (dot > 0.999999) {
                  return this.set(0, 0, 0, 1);
                } else {
                  tmpvec.copy(a).cross(b);
                  this._x = tmpvec.x;
                  this._y = tmpvec.y;
                  this._z = tmpvec.z;
                  this._w = 1 + dot;
                  return this.normalize();
                }
              },
              setAxes: function(view, right, up) {
                var m = tmpMat3.val;
                m[0] = right.x;
                m[3] = right.y;
                m[6] = right.z;
                m[1] = up.x;
                m[4] = up.y;
                m[7] = up.z;
                m[2] = -view.x;
                m[5] = -view.y;
                m[8] = -view.z;
                return this.fromMat3(tmpMat3).normalize();
              },
              identity: function() {
                return this.set(0, 0, 0, 1);
              },
              setAxisAngle: function(axis, rad) {
                rad = rad * 0.5;
                var s = Math.sin(rad);
                return this.set(s * axis.x, s * axis.y, s * axis.z, Math.cos(rad));
              },
              multiply: function(b) {
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                var bx = b.x;
                var by = b.y;
                var bz = b.z;
                var bw = b.w;
                return this.set(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
              },
              slerp: function(b, t) {
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                var bx = b.x;
                var by = b.y;
                var bz = b.z;
                var bw = b.w;
                var cosom = ax * bx + ay * by + az * bz + aw * bw;
                if (cosom < 0) {
                  cosom = -cosom;
                  bx = -bx;
                  by = -by;
                  bz = -bz;
                  bw = -bw;
                }
                var scale0 = 1 - t;
                var scale1 = t;
                if (1 - cosom > EPSILON) {
                  var omega = Math.acos(cosom);
                  var sinom = Math.sin(omega);
                  scale0 = Math.sin((1 - t) * omega) / sinom;
                  scale1 = Math.sin(t * omega) / sinom;
                }
                return this.set(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
              },
              invert: function() {
                var a0 = this.x;
                var a1 = this.y;
                var a2 = this.z;
                var a3 = this.w;
                var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
                var invDot = dot ? 1 / dot : 0;
                return this.set(-a0 * invDot, -a1 * invDot, -a2 * invDot, a3 * invDot);
              },
              conjugate: function() {
                this._x = -this.x;
                this._y = -this.y;
                this._z = -this.z;
                this.onChangeCallback(this);
                return this;
              },
              rotateX: function(rad) {
                rad *= 0.5;
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                var bx = Math.sin(rad);
                var bw = Math.cos(rad);
                return this.set(ax * bw + aw * bx, ay * bw + az * bx, az * bw - ay * bx, aw * bw - ax * bx);
              },
              rotateY: function(rad) {
                rad *= 0.5;
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                var by = Math.sin(rad);
                var bw = Math.cos(rad);
                return this.set(ax * bw - az * by, ay * bw + aw * by, az * bw + ax * by, aw * bw - ay * by);
              },
              rotateZ: function(rad) {
                rad *= 0.5;
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                var bz = Math.sin(rad);
                var bw = Math.cos(rad);
                return this.set(ax * bw + ay * bz, ay * bw - ax * bz, az * bw + aw * bz, aw * bw - az * bz);
              },
              calculateW: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                this.w = -Math.sqrt(1 - x * x - y * y - z * z);
                return this;
              },
              setFromEuler: function(euler, update) {
                var x = euler.x / 2;
                var y = euler.y / 2;
                var z = euler.z / 2;
                var c1 = Math.cos(x);
                var c2 = Math.cos(y);
                var c3 = Math.cos(z);
                var s1 = Math.sin(x);
                var s2 = Math.sin(y);
                var s3 = Math.sin(z);
                switch (euler.order) {
                  case "XYZ": {
                    this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                    break;
                  }
                  case "YXZ": {
                    this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                    break;
                  }
                  case "ZXY": {
                    this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                    break;
                  }
                  case "ZYX": {
                    this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                    break;
                  }
                  case "YZX": {
                    this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                    break;
                  }
                  case "XZY": {
                    this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                    break;
                  }
                }
                return this;
              },
              setFromRotationMatrix: function(mat4) {
                var m = mat4.val;
                var m11 = m[0];
                var m12 = m[4];
                var m13 = m[8];
                var m21 = m[1];
                var m22 = m[5];
                var m23 = m[9];
                var m31 = m[2];
                var m32 = m[6];
                var m33 = m[10];
                var trace = m11 + m22 + m33;
                var s;
                if (trace > 0) {
                  s = 0.5 / Math.sqrt(trace + 1);
                  this.set((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s);
                } else if (m11 > m22 && m11 > m33) {
                  s = 2 * Math.sqrt(1 + m11 - m22 - m33);
                  this.set(0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s);
                } else if (m22 > m33) {
                  s = 2 * Math.sqrt(1 + m22 - m11 - m33);
                  this.set((m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s);
                } else {
                  s = 2 * Math.sqrt(1 + m33 - m11 - m22);
                  this.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
                }
                return this;
              },
              fromMat3: function(mat) {
                var m = mat.val;
                var fTrace = m[0] + m[4] + m[8];
                var fRoot;
                if (fTrace > 0) {
                  fRoot = Math.sqrt(fTrace + 1);
                  this.w = 0.5 * fRoot;
                  fRoot = 0.5 / fRoot;
                  this._x = (m[7] - m[5]) * fRoot;
                  this._y = (m[2] - m[6]) * fRoot;
                  this._z = (m[3] - m[1]) * fRoot;
                } else {
                  var i = 0;
                  if (m[4] > m[0]) {
                    i = 1;
                  }
                  if (m[8] > m[i * 3 + i]) {
                    i = 2;
                  }
                  var j = siNext[i];
                  var k = siNext[j];
                  fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
                  tmp[i] = 0.5 * fRoot;
                  fRoot = 0.5 / fRoot;
                  tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
                  tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
                  this._x = tmp[0];
                  this._y = tmp[1];
                  this._z = tmp[2];
                  this._w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
                }
                this.onChangeCallback(this);
                return this;
              }
            });
            module2.exports = Quaternion;
          },
          23701: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(83392);
            var RadToDeg = function(radians) {
              return radians * CONST.RAD_TO_DEG;
            };
            module2.exports = RadToDeg;
          },
          16906: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RandomXY = function(vector, scale) {
              if (scale === void 0) {
                scale = 1;
              }
              var r = Math.random() * 2 * Math.PI;
              vector.x = Math.cos(r) * scale;
              vector.y = Math.sin(r) * scale;
              return vector;
            };
            module2.exports = RandomXY;
          },
          52417: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RandomXYZ = function(vec3, radius) {
              if (radius === void 0) {
                radius = 1;
              }
              var r = Math.random() * 2 * Math.PI;
              var z = Math.random() * 2 - 1;
              var zScale = Math.sqrt(1 - z * z) * radius;
              vec3.x = Math.cos(r) * zScale;
              vec3.y = Math.sin(r) * zScale;
              vec3.z = z * radius;
              return vec3;
            };
            module2.exports = RandomXYZ;
          },
          17915: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RandomXYZW = function(vec4, scale) {
              if (scale === void 0) {
                scale = 1;
              }
              vec4.x = (Math.random() * 2 - 1) * scale;
              vec4.y = (Math.random() * 2 - 1) * scale;
              vec4.z = (Math.random() * 2 - 1) * scale;
              vec4.w = (Math.random() * 2 - 1) * scale;
              return vec4;
            };
            module2.exports = RandomXYZW;
          },
          52257: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rotate = function(point, angle) {
              var x = point.x;
              var y = point.y;
              point.x = x * Math.cos(angle) - y * Math.sin(angle);
              point.y = x * Math.sin(angle) + y * Math.cos(angle);
              return point;
            };
            module2.exports = Rotate;
          },
          2386: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAround = function(point, x, y, angle) {
              var c = Math.cos(angle);
              var s = Math.sin(angle);
              var tx = point.x - x;
              var ty = point.y - y;
              point.x = tx * c - ty * s + x;
              point.y = tx * s + ty * c + y;
              return point;
            };
            module2.exports = RotateAround;
          },
          72395: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateAroundDistance = function(point, x, y, angle, distance) {
              var t = angle + Math.atan2(point.y - y, point.x - x);
              point.x = x + distance * Math.cos(t);
              point.y = y + distance * Math.sin(t);
              return point;
            };
            module2.exports = RotateAroundDistance;
          },
          41061: (module2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateTo = function(point, x, y, angle, distance) {
              point.x = x + distance * Math.cos(angle);
              point.y = y + distance * Math.sin(angle);
              return point;
            };
            module2.exports = RotateTo;
          },
          93709: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector3 = __webpack_require__2(70015);
            var Matrix4 = __webpack_require__2(16650);
            var Quaternion = __webpack_require__2(75003);
            var tmpMat4 = new Matrix4();
            var tmpQuat = new Quaternion();
            var tmpVec3 = new Vector3();
            var RotateVec3 = function(vec, axis, radians) {
              tmpQuat.setAxisAngle(axis, radians);
              tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));
              return vec.transformMat4(tmpMat4);
            };
            module2.exports = RotateVec3;
          },
          67233: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RoundAwayFromZero = function(value) {
              return value > 0 ? Math.ceil(value) : Math.floor(value);
            };
            module2.exports = RoundAwayFromZero;
          },
          64333: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RoundTo = function(value, place, base) {
              if (place === void 0) {
                place = 0;
              }
              if (base === void 0) {
                base = 10;
              }
              var p = Math.pow(base, -place);
              return Math.round(value * p) / p;
            };
            module2.exports = RoundTo;
          },
          59533: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SinCosTableGenerator = function(length, sinAmp, cosAmp, frequency) {
              if (sinAmp === void 0) {
                sinAmp = 1;
              }
              if (cosAmp === void 0) {
                cosAmp = 1;
              }
              if (frequency === void 0) {
                frequency = 1;
              }
              frequency *= Math.PI / length;
              var cos = [];
              var sin = [];
              for (var c = 0; c < length; c++) {
                cosAmp -= sinAmp * frequency;
                sinAmp += cosAmp * frequency;
                cos[c] = cosAmp;
                sin[c] = sinAmp;
              }
              return {
                sin,
                cos,
                length
              };
            };
            module2.exports = SinCosTableGenerator;
          },
          5514: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SmoothStep = function(x, min, max) {
              if (x <= min) {
                return 0;
              }
              if (x >= max) {
                return 1;
              }
              x = (x - min) / (max - min);
              return x * x * (3 - 2 * x);
            };
            module2.exports = SmoothStep;
          },
          87736: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SmootherStep = function(x, min, max) {
              x = Math.max(0, Math.min(1, (x - min) / (max - min)));
              return x * x * x * (x * (x * 6 - 15) + 10);
            };
            module2.exports = SmootherStep;
          },
          55805: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var ToXY = function(index, width, height, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var x = 0;
              var y = 0;
              var total = width * height;
              if (index > 0 && index <= total) {
                if (index > width - 1) {
                  y = Math.floor(index / width);
                  x = index - y * width;
                } else {
                  x = index;
                }
              }
              return out.set(x, y);
            };
            module2.exports = ToXY;
          },
          64462: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var TransformXY = function(x, y, positionX, positionY, rotation, scaleX, scaleY, output) {
              if (output === void 0) {
                output = new Vector2();
              }
              var radianSin = Math.sin(rotation);
              var radianCos = Math.cos(rotation);
              var a = radianCos * scaleX;
              var b = radianSin * scaleX;
              var c = -radianSin * scaleY;
              var d = radianCos * scaleY;
              var id = 1 / (a * d + c * -b);
              output.x = d * id * x + -c * id * y + (positionY * c - positionX * d) * id;
              output.y = a * id * y + -b * id * x + (-positionY * a + positionX * b) * id;
              return output;
            };
            module2.exports = TransformXY;
          },
          93736: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FuzzyEqual = __webpack_require__2(88456);
            var Vector2 = new Class({
              initialize: function Vector22(x, y) {
                this.x = 0;
                this.y = 0;
                if (typeof x === "object") {
                  this.x = x.x || 0;
                  this.y = x.y || 0;
                } else {
                  if (y === void 0) {
                    y = x;
                  }
                  this.x = x || 0;
                  this.y = y || 0;
                }
              },
              clone: function() {
                return new Vector2(this.x, this.y);
              },
              copy: function(src) {
                this.x = src.x || 0;
                this.y = src.y || 0;
                return this;
              },
              setFromObject: function(obj) {
                this.x = obj.x || 0;
                this.y = obj.y || 0;
                return this;
              },
              set: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.x = x;
                this.y = y;
                return this;
              },
              setTo: function(x, y) {
                return this.set(x, y);
              },
              setToPolar: function(azimuth, radius) {
                if (radius == null) {
                  radius = 1;
                }
                this.x = Math.cos(azimuth) * radius;
                this.y = Math.sin(azimuth) * radius;
                return this;
              },
              equals: function(v) {
                return this.x === v.x && this.y === v.y;
              },
              fuzzyEquals: function(v, epsilon) {
                return FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon);
              },
              angle: function() {
                var angle = Math.atan2(this.y, this.x);
                if (angle < 0) {
                  angle += 2 * Math.PI;
                }
                return angle;
              },
              setAngle: function(angle) {
                return this.setToPolar(angle, this.length());
              },
              add: function(src) {
                this.x += src.x;
                this.y += src.y;
                return this;
              },
              subtract: function(src) {
                this.x -= src.x;
                this.y -= src.y;
                return this;
              },
              multiply: function(src) {
                this.x *= src.x;
                this.y *= src.y;
                return this;
              },
              scale: function(value) {
                if (isFinite(value)) {
                  this.x *= value;
                  this.y *= value;
                } else {
                  this.x = 0;
                  this.y = 0;
                }
                return this;
              },
              divide: function(src) {
                this.x /= src.x;
                this.y /= src.y;
                return this;
              },
              negate: function() {
                this.x = -this.x;
                this.y = -this.y;
                return this;
              },
              distance: function(src) {
                var dx = src.x - this.x;
                var dy = src.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
              },
              distanceSq: function(src) {
                var dx = src.x - this.x;
                var dy = src.y - this.y;
                return dx * dx + dy * dy;
              },
              length: function() {
                var x = this.x;
                var y = this.y;
                return Math.sqrt(x * x + y * y);
              },
              setLength: function(length) {
                return this.normalize().scale(length);
              },
              lengthSq: function() {
                var x = this.x;
                var y = this.y;
                return x * x + y * y;
              },
              normalize: function() {
                var x = this.x;
                var y = this.y;
                var len = x * x + y * y;
                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this.x = x * len;
                  this.y = y * len;
                }
                return this;
              },
              normalizeRightHand: function() {
                var x = this.x;
                this.x = this.y * -1;
                this.y = x;
                return this;
              },
              normalizeLeftHand: function() {
                var x = this.x;
                this.x = this.y;
                this.y = x * -1;
                return this;
              },
              dot: function(src) {
                return this.x * src.x + this.y * src.y;
              },
              cross: function(src) {
                return this.x * src.y - this.y * src.x;
              },
              lerp: function(src, t) {
                if (t === void 0) {
                  t = 0;
                }
                var ax = this.x;
                var ay = this.y;
                this.x = ax + t * (src.x - ax);
                this.y = ay + t * (src.y - ay);
                return this;
              },
              transformMat3: function(mat) {
                var x = this.x;
                var y = this.y;
                var m = mat.val;
                this.x = m[0] * x + m[3] * y + m[6];
                this.y = m[1] * x + m[4] * y + m[7];
                return this;
              },
              transformMat4: function(mat) {
                var x = this.x;
                var y = this.y;
                var m = mat.val;
                this.x = m[0] * x + m[4] * y + m[12];
                this.y = m[1] * x + m[5] * y + m[13];
                return this;
              },
              reset: function() {
                this.x = 0;
                this.y = 0;
                return this;
              },
              limit: function(max) {
                var len = this.length();
                if (len && len > max) {
                  this.scale(max / len);
                }
                return this;
              },
              reflect: function(normal) {
                normal = normal.clone().normalize();
                return this.subtract(normal.scale(2 * this.dot(normal)));
              },
              mirror: function(axis) {
                return this.reflect(axis).negate();
              },
              rotate: function(delta) {
                var cos = Math.cos(delta);
                var sin = Math.sin(delta);
                return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);
              },
              project: function(src) {
                var scalar = this.dot(src) / src.dot(src);
                return this.copy(src).scale(scalar);
              }
            });
            Vector2.ZERO = new Vector2();
            Vector2.RIGHT = new Vector2(1, 0);
            Vector2.LEFT = new Vector2(-1, 0);
            Vector2.UP = new Vector2(0, -1);
            Vector2.DOWN = new Vector2(0, 1);
            Vector2.ONE = new Vector2(1, 1);
            module2.exports = Vector2;
          },
          70015: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Vector3 = new Class({
              initialize: function Vector32(x, y, z) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                if (typeof x === "object") {
                  this.x = x.x || 0;
                  this.y = x.y || 0;
                  this.z = x.z || 0;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                }
              },
              up: function() {
                this.x = 0;
                this.y = 1;
                this.z = 0;
                return this;
              },
              min: function(v) {
                this.x = Math.min(this.x, v.x);
                this.y = Math.min(this.y, v.y);
                this.z = Math.min(this.z, v.z);
                return this;
              },
              max: function(v) {
                this.x = Math.max(this.x, v.x);
                this.y = Math.max(this.y, v.y);
                this.z = Math.max(this.z, v.z);
                return this;
              },
              clone: function() {
                return new Vector3(this.x, this.y, this.z);
              },
              addVectors: function(a, b) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;
                return this;
              },
              crossVectors: function(a, b) {
                var ax = a.x;
                var ay = a.y;
                var az = a.z;
                var bx = b.x;
                var by = b.y;
                var bz = b.z;
                this.x = ay * bz - az * by;
                this.y = az * bx - ax * bz;
                this.z = ax * by - ay * bx;
                return this;
              },
              equals: function(v) {
                return this.x === v.x && this.y === v.y && this.z === v.z;
              },
              copy: function(src) {
                this.x = src.x;
                this.y = src.y;
                this.z = src.z || 0;
                return this;
              },
              set: function(x, y, z) {
                if (typeof x === "object") {
                  this.x = x.x || 0;
                  this.y = x.y || 0;
                  this.z = x.z || 0;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                }
                return this;
              },
              setFromMatrixPosition: function(m) {
                return this.fromArray(m.val, 12);
              },
              setFromMatrixColumn: function(mat4, index) {
                return this.fromArray(mat4.val, index * 4);
              },
              fromArray: function(array, offset) {
                if (offset === void 0) {
                  offset = 0;
                }
                this.x = array[offset];
                this.y = array[offset + 1];
                this.z = array[offset + 2];
                return this;
              },
              add: function(v) {
                this.x += v.x;
                this.y += v.y;
                this.z += v.z || 0;
                return this;
              },
              addScalar: function(s) {
                this.x += s;
                this.y += s;
                this.z += s;
                return this;
              },
              addScale: function(v, scale) {
                this.x += v.x * scale;
                this.y += v.y * scale;
                this.z += v.z * scale || 0;
                return this;
              },
              subtract: function(v) {
                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z || 0;
                return this;
              },
              multiply: function(v) {
                this.x *= v.x;
                this.y *= v.y;
                this.z *= v.z || 1;
                return this;
              },
              scale: function(scale) {
                if (isFinite(scale)) {
                  this.x *= scale;
                  this.y *= scale;
                  this.z *= scale;
                } else {
                  this.x = 0;
                  this.y = 0;
                  this.z = 0;
                }
                return this;
              },
              divide: function(v) {
                this.x /= v.x;
                this.y /= v.y;
                this.z /= v.z || 1;
                return this;
              },
              negate: function() {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                return this;
              },
              distance: function(v) {
                var dx = v.x - this.x;
                var dy = v.y - this.y;
                var dz = v.z - this.z || 0;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
              },
              distanceSq: function(v) {
                var dx = v.x - this.x;
                var dy = v.y - this.y;
                var dz = v.z - this.z || 0;
                return dx * dx + dy * dy + dz * dz;
              },
              length: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                return Math.sqrt(x * x + y * y + z * z);
              },
              lengthSq: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                return x * x + y * y + z * z;
              },
              normalize: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var len = x * x + y * y + z * z;
                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this.x = x * len;
                  this.y = y * len;
                  this.z = z * len;
                }
                return this;
              },
              dot: function(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
              },
              cross: function(v) {
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var bx = v.x;
                var by = v.y;
                var bz = v.z;
                this.x = ay * bz - az * by;
                this.y = az * bx - ax * bz;
                this.z = ax * by - ay * bx;
                return this;
              },
              lerp: function(v, t) {
                if (t === void 0) {
                  t = 0;
                }
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                this.x = ax + t * (v.x - ax);
                this.y = ay + t * (v.y - ay);
                this.z = az + t * (v.z - az);
                return this;
              },
              applyMatrix3: function(mat3) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var m = mat3.val;
                this.x = m[0] * x + m[3] * y + m[6] * z;
                this.y = m[1] * x + m[4] * y + m[7] * z;
                this.z = m[2] * x + m[5] * y + m[8] * z;
                return this;
              },
              applyMatrix4: function(mat4) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var m = mat4.val;
                var w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);
                this.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;
                this.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;
                this.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;
                return this;
              },
              transformMat3: function(mat) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var m = mat.val;
                this.x = x * m[0] + y * m[3] + z * m[6];
                this.y = x * m[1] + y * m[4] + z * m[7];
                this.z = x * m[2] + y * m[5] + z * m[8];
                return this;
              },
              transformMat4: function(mat) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var m = mat.val;
                this.x = m[0] * x + m[4] * y + m[8] * z + m[12];
                this.y = m[1] * x + m[5] * y + m[9] * z + m[13];
                this.z = m[2] * x + m[6] * y + m[10] * z + m[14];
                return this;
              },
              transformCoordinates: function(mat) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var m = mat.val;
                var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
                var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
                var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
                var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
                this.x = tx / tw;
                this.y = ty / tw;
                this.z = tz / tw;
                return this;
              },
              transformQuat: function(q) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var qx = q.x;
                var qy = q.y;
                var qz = q.z;
                var qw = q.w;
                var ix = qw * x + qy * z - qz * y;
                var iy = qw * y + qz * x - qx * z;
                var iz = qw * z + qx * y - qy * x;
                var iw = -qx * x - qy * y - qz * z;
                this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                return this;
              },
              project: function(mat) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var m = mat.val;
                var a00 = m[0];
                var a01 = m[1];
                var a02 = m[2];
                var a03 = m[3];
                var a10 = m[4];
                var a11 = m[5];
                var a12 = m[6];
                var a13 = m[7];
                var a20 = m[8];
                var a21 = m[9];
                var a22 = m[10];
                var a23 = m[11];
                var a30 = m[12];
                var a31 = m[13];
                var a32 = m[14];
                var a33 = m[15];
                var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);
                this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;
                this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;
                this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;
                return this;
              },
              projectViewMatrix: function(viewMatrix, projectionMatrix) {
                return this.applyMatrix4(viewMatrix).applyMatrix4(projectionMatrix);
              },
              unprojectViewMatrix: function(projectionMatrix, worldMatrix) {
                return this.applyMatrix4(projectionMatrix).applyMatrix4(worldMatrix);
              },
              unproject: function(viewport, invProjectionView) {
                var viewX = viewport.x;
                var viewY = viewport.y;
                var viewWidth = viewport.z;
                var viewHeight = viewport.w;
                var x = this.x - viewX;
                var y = viewHeight - this.y - 1 - viewY;
                var z = this.z;
                this.x = 2 * x / viewWidth - 1;
                this.y = 2 * y / viewHeight - 1;
                this.z = 2 * z - 1;
                return this.project(invProjectionView);
              },
              reset: function() {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                return this;
              }
            });
            Vector3.ZERO = new Vector3();
            Vector3.RIGHT = new Vector3(1, 0, 0);
            Vector3.LEFT = new Vector3(-1, 0, 0);
            Vector3.UP = new Vector3(0, -1, 0);
            Vector3.DOWN = new Vector3(0, 1, 0);
            Vector3.FORWARD = new Vector3(0, 0, 1);
            Vector3.BACK = new Vector3(0, 0, -1);
            Vector3.ONE = new Vector3(1, 1, 1);
            module2.exports = Vector3;
          },
          51729: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Vector4 = new Class({
              initialize: function Vector42(x, y, z, w) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
                if (typeof x === "object") {
                  this.x = x.x || 0;
                  this.y = x.y || 0;
                  this.z = x.z || 0;
                  this.w = x.w || 0;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w || 0;
                }
              },
              clone: function() {
                return new Vector4(this.x, this.y, this.z, this.w);
              },
              copy: function(src) {
                this.x = src.x;
                this.y = src.y;
                this.z = src.z || 0;
                this.w = src.w || 0;
                return this;
              },
              equals: function(v) {
                return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
              },
              set: function(x, y, z, w) {
                if (typeof x === "object") {
                  this.x = x.x || 0;
                  this.y = x.y || 0;
                  this.z = x.z || 0;
                  this.w = x.w || 0;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w || 0;
                }
                return this;
              },
              add: function(v) {
                this.x += v.x;
                this.y += v.y;
                this.z += v.z || 0;
                this.w += v.w || 0;
                return this;
              },
              subtract: function(v) {
                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z || 0;
                this.w -= v.w || 0;
                return this;
              },
              scale: function(scale) {
                this.x *= scale;
                this.y *= scale;
                this.z *= scale;
                this.w *= scale;
                return this;
              },
              length: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
              },
              lengthSq: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                return x * x + y * y + z * z + w * w;
              },
              normalize: function() {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                var len = x * x + y * y + z * z + w * w;
                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this.x = x * len;
                  this.y = y * len;
                  this.z = z * len;
                  this.w = w * len;
                }
                return this;
              },
              dot: function(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
              },
              lerp: function(v, t) {
                if (t === void 0) {
                  t = 0;
                }
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                this.x = ax + t * (v.x - ax);
                this.y = ay + t * (v.y - ay);
                this.z = az + t * (v.z - az);
                this.w = aw + t * (v.w - aw);
                return this;
              },
              multiply: function(v) {
                this.x *= v.x;
                this.y *= v.y;
                this.z *= v.z || 1;
                this.w *= v.w || 1;
                return this;
              },
              divide: function(v) {
                this.x /= v.x;
                this.y /= v.y;
                this.z /= v.z || 1;
                this.w /= v.w || 1;
                return this;
              },
              distance: function(v) {
                var dx = v.x - this.x;
                var dy = v.y - this.y;
                var dz = v.z - this.z || 0;
                var dw = v.w - this.w || 0;
                return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
              },
              distanceSq: function(v) {
                var dx = v.x - this.x;
                var dy = v.y - this.y;
                var dz = v.z - this.z || 0;
                var dw = v.w - this.w || 0;
                return dx * dx + dy * dy + dz * dz + dw * dw;
              },
              negate: function() {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                this.w = -this.w;
                return this;
              },
              transformMat4: function(mat) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                var m = mat.val;
                this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
                this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
                this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
                this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
                return this;
              },
              transformQuat: function(q) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var qx = q.x;
                var qy = q.y;
                var qz = q.z;
                var qw = q.w;
                var ix = qw * x + qy * z - qz * y;
                var iy = qw * y + qz * x - qx * z;
                var iz = qw * z + qx * y - qy * x;
                var iw = -qx * x - qy * y - qz * z;
                this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                return this;
              },
              reset: function() {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
                return this;
              }
            });
            Vector4.prototype.sub = Vector4.prototype.subtract;
            Vector4.prototype.mul = Vector4.prototype.multiply;
            Vector4.prototype.div = Vector4.prototype.divide;
            Vector4.prototype.dist = Vector4.prototype.distance;
            Vector4.prototype.distSq = Vector4.prototype.distanceSq;
            Vector4.prototype.len = Vector4.prototype.length;
            Vector4.prototype.lenSq = Vector4.prototype.lengthSq;
            module2.exports = Vector4;
          },
          9557: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Within = function(a, b, tolerance) {
              return Math.abs(a - b) <= tolerance;
            };
            module2.exports = Within;
          },
          1071: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Wrap = function(value, min, max) {
              var range = max - min;
              return min + ((value - min) % range + range) % range;
            };
            module2.exports = Wrap;
          },
          90447: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Between = function(x1, y1, x2, y2) {
              return Math.atan2(y2 - y1, x2 - x1);
            };
            module2.exports = Between;
          },
          94240: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BetweenPoints = function(point1, point2) {
              return Math.atan2(point2.y - point1.y, point2.x - point1.x);
            };
            module2.exports = BetweenPoints;
          },
          84066: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BetweenPointsY = function(point1, point2) {
              return Math.atan2(point2.x - point1.x, point2.y - point1.y);
            };
            module2.exports = BetweenPointsY;
          },
          9678: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BetweenY = function(x1, y1, x2, y2) {
              return Math.atan2(x2 - x1, y2 - y1);
            };
            module2.exports = BetweenY;
          },
          76861: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(83392);
            var CounterClockwise = function(angle) {
              if (angle > Math.PI) {
                angle -= CONST.PI2;
              }
              return Math.abs(((angle + CONST.TAU) % CONST.PI2 - CONST.PI2) % CONST.PI2);
            };
            module2.exports = CounterClockwise;
          },
          37570: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Normalize = function(angle) {
              angle = angle % (2 * Math.PI);
              if (angle >= 0) {
                return angle;
              } else {
                return angle + 2 * Math.PI;
              }
            };
            module2.exports = Normalize;
          },
          87597: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       @samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FloatBetween = __webpack_require__2(61616);
            var Random = function() {
              return FloatBetween(-Math.PI, Math.PI);
            };
            module2.exports = Random;
          },
          74493: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       @samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FloatBetween = __webpack_require__2(61616);
            var RandomDegrees = function() {
              return FloatBetween(-180, 180);
            };
            module2.exports = RandomDegrees;
          },
          19049: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Normalize = __webpack_require__2(37570);
            var Reverse = function(angle) {
              return Normalize(angle + Math.PI);
            };
            module2.exports = Reverse;
          },
          90612: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MATH_CONST = __webpack_require__2(83392);
            var RotateTo = function(currentAngle, targetAngle, lerp) {
              if (lerp === void 0) {
                lerp = 0.05;
              }
              if (currentAngle === targetAngle) {
                return currentAngle;
              }
              if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= MATH_CONST.PI2 - lerp) {
                currentAngle = targetAngle;
              } else {
                if (Math.abs(targetAngle - currentAngle) > Math.PI) {
                  if (targetAngle < currentAngle) {
                    targetAngle += MATH_CONST.PI2;
                  } else {
                    targetAngle -= MATH_CONST.PI2;
                  }
                }
                if (targetAngle > currentAngle) {
                  currentAngle += lerp;
                } else if (targetAngle < currentAngle) {
                  currentAngle -= lerp;
                }
              }
              return currentAngle;
            };
            module2.exports = RotateTo;
          },
          93954: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ShortestBetween = function(angle1, angle2) {
              var difference = angle2 - angle1;
              if (difference === 0) {
                return 0;
              }
              var times = Math.floor((difference - -180) / 360);
              return difference - times * 360;
            };
            module2.exports = ShortestBetween;
          },
          35786: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MathWrap = __webpack_require__2(1071);
            var Wrap = function(angle) {
              return MathWrap(angle, -Math.PI, Math.PI);
            };
            module2.exports = Wrap;
          },
          62138: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Wrap = __webpack_require__2(1071);
            var WrapDegrees = function(angle) {
              return Wrap(angle, -180, 180);
            };
            module2.exports = WrapDegrees;
          },
          22153: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Between: __webpack_require__2(90447),
              BetweenPoints: __webpack_require__2(94240),
              BetweenPointsY: __webpack_require__2(84066),
              BetweenY: __webpack_require__2(9678),
              CounterClockwise: __webpack_require__2(76861),
              Normalize: __webpack_require__2(37570),
              Random: __webpack_require__2(87597),
              RandomDegrees: __webpack_require__2(74493),
              Reverse: __webpack_require__2(19049),
              RotateTo: __webpack_require__2(90612),
              ShortestBetween: __webpack_require__2(93954),
              Wrap: __webpack_require__2(35786),
              WrapDegrees: __webpack_require__2(62138)
            };
          },
          83392: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MATH_CONST = {
              PI2: Math.PI * 2,
              TAU: Math.PI * 0.5,
              EPSILON: 1e-6,
              DEG_TO_RAD: Math.PI / 180,
              RAD_TO_DEG: 180 / Math.PI,
              RND: null,
              MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
              MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
            };
            module2.exports = MATH_CONST;
          },
          53996: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DistanceBetween = function(x1, y1, x2, y2) {
              var dx = x1 - x2;
              var dy = y1 - y2;
              return Math.sqrt(dx * dx + dy * dy);
            };
            module2.exports = DistanceBetween;
          },
          92951: (module2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DistanceBetweenPoints = function(a, b) {
              var dx = a.x - b.x;
              var dy = a.y - b.y;
              return Math.sqrt(dx * dx + dy * dy);
            };
            module2.exports = DistanceBetweenPoints;
          },
          12161: (module2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DistanceBetweenPointsSquared = function(a, b) {
              var dx = a.x - b.x;
              var dy = a.y - b.y;
              return dx * dx + dy * dy;
            };
            module2.exports = DistanceBetweenPointsSquared;
          },
          38057: (module2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ChebyshevDistance = function(x1, y1, x2, y2) {
              return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
            };
            module2.exports = ChebyshevDistance;
          },
          33297: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DistancePower = function(x1, y1, x2, y2, pow) {
              if (pow === void 0) {
                pow = 2;
              }
              return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
            };
            module2.exports = DistancePower;
          },
          90366: (module2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SnakeDistance = function(x1, y1, x2, y2) {
              return Math.abs(x1 - x2) + Math.abs(y1 - y2);
            };
            module2.exports = SnakeDistance;
          },
          35032: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DistanceSquared = function(x1, y1, x2, y2) {
              var dx = x1 - x2;
              var dy = y1 - y2;
              return dx * dx + dy * dy;
            };
            module2.exports = DistanceSquared;
          },
          10130: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Between: __webpack_require__2(53996),
              BetweenPoints: __webpack_require__2(92951),
              BetweenPointsSquared: __webpack_require__2(12161),
              Chebyshev: __webpack_require__2(38057),
              Power: __webpack_require__2(33297),
              Snake: __webpack_require__2(90366),
              Squared: __webpack_require__2(35032)
            };
          },
          35060: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Back = __webpack_require__2(25265);
            var Bounce = __webpack_require__2(57428);
            var Circular = __webpack_require__2(73214);
            var Cubic = __webpack_require__2(71778);
            var Elastic = __webpack_require__2(36468);
            var Expo = __webpack_require__2(88258);
            var Linear = __webpack_require__2(52910);
            var Quadratic = __webpack_require__2(67799);
            var Quartic = __webpack_require__2(74083);
            var Quintic = __webpack_require__2(92284);
            var Sine = __webpack_require__2(28035);
            var Stepped = __webpack_require__2(8754);
            module2.exports = {
              Power0: Linear,
              Power1: Quadratic.Out,
              Power2: Cubic.Out,
              Power3: Quartic.Out,
              Power4: Quintic.Out,
              Linear,
              Quad: Quadratic.Out,
              Cubic: Cubic.Out,
              Quart: Quartic.Out,
              Quint: Quintic.Out,
              Sine: Sine.Out,
              Expo: Expo.Out,
              Circ: Circular.Out,
              Elastic: Elastic.Out,
              Back: Back.Out,
              Bounce: Bounce.Out,
              Stepped,
              "Quad.easeIn": Quadratic.In,
              "Cubic.easeIn": Cubic.In,
              "Quart.easeIn": Quartic.In,
              "Quint.easeIn": Quintic.In,
              "Sine.easeIn": Sine.In,
              "Expo.easeIn": Expo.In,
              "Circ.easeIn": Circular.In,
              "Elastic.easeIn": Elastic.In,
              "Back.easeIn": Back.In,
              "Bounce.easeIn": Bounce.In,
              "Quad.easeOut": Quadratic.Out,
              "Cubic.easeOut": Cubic.Out,
              "Quart.easeOut": Quartic.Out,
              "Quint.easeOut": Quintic.Out,
              "Sine.easeOut": Sine.Out,
              "Expo.easeOut": Expo.Out,
              "Circ.easeOut": Circular.Out,
              "Elastic.easeOut": Elastic.Out,
              "Back.easeOut": Back.Out,
              "Bounce.easeOut": Bounce.Out,
              "Quad.easeInOut": Quadratic.InOut,
              "Cubic.easeInOut": Cubic.InOut,
              "Quart.easeInOut": Quartic.InOut,
              "Quint.easeInOut": Quintic.InOut,
              "Sine.easeInOut": Sine.InOut,
              "Expo.easeInOut": Expo.InOut,
              "Circ.easeInOut": Circular.InOut,
              "Elastic.easeInOut": Elastic.InOut,
              "Back.easeInOut": Back.InOut,
              "Bounce.easeInOut": Bounce.InOut
            };
          },
          25860: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v, overshoot) {
              if (overshoot === void 0) {
                overshoot = 1.70158;
              }
              return v * v * ((overshoot + 1) * v - overshoot);
            };
            module2.exports = In;
          },
          45264: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v, overshoot) {
              if (overshoot === void 0) {
                overshoot = 1.70158;
              }
              var s = overshoot * 1.525;
              if ((v *= 2) < 1) {
                return 0.5 * (v * v * ((s + 1) * v - s));
              } else {
                return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
              }
            };
            module2.exports = InOut;
          },
          36699: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v, overshoot) {
              if (overshoot === void 0) {
                overshoot = 1.70158;
              }
              return --v * v * ((overshoot + 1) * v + overshoot) + 1;
            };
            module2.exports = Out;
          },
          25265: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(25860),
              Out: __webpack_require__2(36699),
              InOut: __webpack_require__2(45264)
            };
          },
          62191: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v) {
              v = 1 - v;
              if (v < 1 / 2.75) {
                return 1 - 7.5625 * v * v;
              } else if (v < 2 / 2.75) {
                return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
              } else if (v < 2.5 / 2.75) {
                return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
              } else {
                return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
              }
            };
            module2.exports = In;
          },
          24799: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v) {
              var reverse = false;
              if (v < 0.5) {
                v = 1 - v * 2;
                reverse = true;
              } else {
                v = v * 2 - 1;
              }
              if (v < 1 / 2.75) {
                v = 7.5625 * v * v;
              } else if (v < 2 / 2.75) {
                v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
              } else if (v < 2.5 / 2.75) {
                v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
              } else {
                v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
              }
              if (reverse) {
                return (1 - v) * 0.5;
              } else {
                return v * 0.5 + 0.5;
              }
            };
            module2.exports = InOut;
          },
          60819: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v) {
              if (v < 1 / 2.75) {
                return 7.5625 * v * v;
              } else if (v < 2 / 2.75) {
                return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
              } else if (v < 2.5 / 2.75) {
                return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
              } else {
                return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
              }
            };
            module2.exports = Out;
          },
          57428: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(62191),
              Out: __webpack_require__2(60819),
              InOut: __webpack_require__2(24799)
            };
          },
          86855: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v) {
              return 1 - Math.sqrt(1 - v * v);
            };
            module2.exports = In;
          },
          7280: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v) {
              if ((v *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - v * v) - 1);
              } else {
                return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
              }
            };
            module2.exports = InOut;
          },
          18058: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v) {
              return Math.sqrt(1 - --v * v);
            };
            module2.exports = Out;
          },
          73214: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(86855),
              Out: __webpack_require__2(18058),
              InOut: __webpack_require__2(7280)
            };
          },
          91532: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v) {
              return v * v * v;
            };
            module2.exports = In;
          },
          63180: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v) {
              if ((v *= 2) < 1) {
                return 0.5 * v * v * v;
              } else {
                return 0.5 * ((v -= 2) * v * v + 2);
              }
            };
            module2.exports = InOut;
          },
          16518: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v) {
              return --v * v * v + 1;
            };
            module2.exports = Out;
          },
          71778: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(91532),
              Out: __webpack_require__2(16518),
              InOut: __webpack_require__2(63180)
            };
          },
          24729: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v, amplitude, period) {
              if (amplitude === void 0) {
                amplitude = 0.1;
              }
              if (period === void 0) {
                period = 0.1;
              }
              if (v === 0) {
                return 0;
              } else if (v === 1) {
                return 1;
              } else {
                var s = period / 4;
                if (amplitude < 1) {
                  amplitude = 1;
                } else {
                  s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
                }
                return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
              }
            };
            module2.exports = In;
          },
          50325: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v, amplitude, period) {
              if (amplitude === void 0) {
                amplitude = 0.1;
              }
              if (period === void 0) {
                period = 0.1;
              }
              if (v === 0) {
                return 0;
              } else if (v === 1) {
                return 1;
              } else {
                var s = period / 4;
                if (amplitude < 1) {
                  amplitude = 1;
                } else {
                  s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
                }
                if ((v *= 2) < 1) {
                  return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
                } else {
                  return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
                }
              }
            };
            module2.exports = InOut;
          },
          84074: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v, amplitude, period) {
              if (amplitude === void 0) {
                amplitude = 0.1;
              }
              if (period === void 0) {
                period = 0.1;
              }
              if (v === 0) {
                return 0;
              } else if (v === 1) {
                return 1;
              } else {
                var s = period / 4;
                if (amplitude < 1) {
                  amplitude = 1;
                } else {
                  s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
                }
                return amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1;
              }
            };
            module2.exports = Out;
          },
          36468: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(24729),
              Out: __webpack_require__2(84074),
              InOut: __webpack_require__2(50325)
            };
          },
          95638: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v) {
              return Math.pow(2, 10 * (v - 1)) - 1e-3;
            };
            module2.exports = In;
          },
          10357: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v) {
              if ((v *= 2) < 1) {
                return 0.5 * Math.pow(2, 10 * (v - 1));
              } else {
                return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
              }
            };
            module2.exports = InOut;
          },
          14894: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v) {
              return 1 - Math.pow(2, -10 * v);
            };
            module2.exports = Out;
          },
          88258: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(95638),
              Out: __webpack_require__2(14894),
              InOut: __webpack_require__2(10357)
            };
          },
          33063: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Back: __webpack_require__2(25265),
              Bounce: __webpack_require__2(57428),
              Circular: __webpack_require__2(73214),
              Cubic: __webpack_require__2(71778),
              Elastic: __webpack_require__2(36468),
              Expo: __webpack_require__2(88258),
              Linear: __webpack_require__2(52910),
              Quadratic: __webpack_require__2(67799),
              Quartic: __webpack_require__2(74083),
              Quintic: __webpack_require__2(92284),
              Sine: __webpack_require__2(28035),
              Stepped: __webpack_require__2(8754)
            };
          },
          43927: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Linear = function(v) {
              return v;
            };
            module2.exports = Linear;
          },
          52910: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = __webpack_require__2(43927);
          },
          77471: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v) {
              return v * v;
            };
            module2.exports = In;
          },
          83863: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v) {
              if ((v *= 2) < 1) {
                return 0.5 * v * v;
              } else {
                return -0.5 * (--v * (v - 2) - 1);
              }
            };
            module2.exports = InOut;
          },
          44383: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v) {
              return v * (2 - v);
            };
            module2.exports = Out;
          },
          67799: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(77471),
              Out: __webpack_require__2(44383),
              InOut: __webpack_require__2(83863)
            };
          },
          48311: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v) {
              return v * v * v * v;
            };
            module2.exports = In;
          },
          55248: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v) {
              if ((v *= 2) < 1) {
                return 0.5 * v * v * v * v;
              } else {
                return -0.5 * ((v -= 2) * v * v * v - 2);
              }
            };
            module2.exports = InOut;
          },
          23135: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v) {
              return 1 - --v * v * v * v;
            };
            module2.exports = Out;
          },
          74083: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(48311),
              Out: __webpack_require__2(23135),
              InOut: __webpack_require__2(55248)
            };
          },
          7313: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v) {
              return v * v * v * v * v;
            };
            module2.exports = In;
          },
          98759: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v) {
              if ((v *= 2) < 1) {
                return 0.5 * v * v * v * v * v;
              } else {
                return 0.5 * ((v -= 2) * v * v * v * v + 2);
              }
            };
            module2.exports = InOut;
          },
          26670: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v) {
              return --v * v * v * v * v + 1;
            };
            module2.exports = Out;
          },
          92284: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(7313),
              Out: __webpack_require__2(26670),
              InOut: __webpack_require__2(98759)
            };
          },
          52929: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var In = function(v) {
              if (v === 0) {
                return 0;
              } else if (v === 1) {
                return 1;
              } else {
                return 1 - Math.cos(v * Math.PI / 2);
              }
            };
            module2.exports = In;
          },
          66333: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InOut = function(v) {
              if (v === 0) {
                return 0;
              } else if (v === 1) {
                return 1;
              } else {
                return 0.5 * (1 - Math.cos(Math.PI * v));
              }
            };
            module2.exports = InOut;
          },
          37255: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Out = function(v) {
              if (v === 0) {
                return 0;
              } else if (v === 1) {
                return 1;
              } else {
                return Math.sin(v * Math.PI / 2);
              }
            };
            module2.exports = Out;
          },
          28035: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              In: __webpack_require__2(52929),
              Out: __webpack_require__2(37255),
              InOut: __webpack_require__2(66333)
            };
          },
          52770: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Stepped = function(v, steps) {
              if (steps === void 0) {
                steps = 1;
              }
              if (v <= 0) {
                return 0;
              } else if (v >= 1) {
                return 1;
              } else {
                return ((steps * v | 0) + 1) * (1 / steps);
              }
            };
            module2.exports = Stepped;
          },
          8754: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = __webpack_require__2(52770);
          },
          17247: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Ceil = function(value, epsilon) {
              if (epsilon === void 0) {
                epsilon = 1e-4;
              }
              return Math.ceil(value - epsilon);
            };
            module2.exports = Ceil;
          },
          88456: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Equal = function(a, b, epsilon) {
              if (epsilon === void 0) {
                epsilon = 1e-4;
              }
              return Math.abs(a - b) < epsilon;
            };
            module2.exports = Equal;
          },
          61824: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Floor = function(value, epsilon) {
              if (epsilon === void 0) {
                epsilon = 1e-4;
              }
              return Math.floor(value + epsilon);
            };
            module2.exports = Floor;
          },
          41935: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GreaterThan = function(a, b, epsilon) {
              if (epsilon === void 0) {
                epsilon = 1e-4;
              }
              return a > b - epsilon;
            };
            module2.exports = GreaterThan;
          },
          54726: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LessThan = function(a, b, epsilon) {
              if (epsilon === void 0) {
                epsilon = 1e-4;
              }
              return a < b + epsilon;
            };
            module2.exports = LessThan;
          },
          52778: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Ceil: __webpack_require__2(17247),
              Equal: __webpack_require__2(88456),
              Floor: __webpack_require__2(61824),
              GreaterThan: __webpack_require__2(41935),
              LessThan: __webpack_require__2(54726)
            };
          },
          5923: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(83392);
            var Extend = __webpack_require__2(98611);
            var PhaserMath = {
              Angle: __webpack_require__2(22153),
              Distance: __webpack_require__2(10130),
              Easing: __webpack_require__2(33063),
              Fuzzy: __webpack_require__2(52778),
              Interpolation: __webpack_require__2(48528),
              Pow2: __webpack_require__2(73773),
              Snap: __webpack_require__2(23679),
              RandomDataGenerator: __webpack_require__2(81429),
              Average: __webpack_require__2(26042),
              Bernstein: __webpack_require__2(22824),
              Between: __webpack_require__2(17489),
              CatmullRom: __webpack_require__2(14976),
              CeilTo: __webpack_require__2(89129),
              Clamp: __webpack_require__2(82897),
              DegToRad: __webpack_require__2(75606),
              Difference: __webpack_require__2(767),
              Euler: __webpack_require__2(9849),
              Factorial: __webpack_require__2(8034),
              FloatBetween: __webpack_require__2(61616),
              FloorTo: __webpack_require__2(60679),
              FromPercent: __webpack_require__2(91806),
              GetSpeed: __webpack_require__2(79366),
              IsEven: __webpack_require__2(43776),
              IsEvenStrict: __webpack_require__2(58442),
              Linear: __webpack_require__2(42798),
              LinearXY: __webpack_require__2(61072),
              MaxAdd: __webpack_require__2(69635),
              Median: __webpack_require__2(37394),
              MinSub: __webpack_require__2(17259),
              Percent: __webpack_require__2(61820),
              RadToDeg: __webpack_require__2(23701),
              RandomXY: __webpack_require__2(16906),
              RandomXYZ: __webpack_require__2(52417),
              RandomXYZW: __webpack_require__2(17915),
              Rotate: __webpack_require__2(52257),
              RotateAround: __webpack_require__2(2386),
              RotateAroundDistance: __webpack_require__2(72395),
              RotateTo: __webpack_require__2(41061),
              RoundAwayFromZero: __webpack_require__2(67233),
              RoundTo: __webpack_require__2(64333),
              SinCosTableGenerator: __webpack_require__2(59533),
              SmootherStep: __webpack_require__2(87736),
              SmoothStep: __webpack_require__2(5514),
              ToXY: __webpack_require__2(55805),
              TransformXY: __webpack_require__2(64462),
              Within: __webpack_require__2(9557),
              Wrap: __webpack_require__2(1071),
              Vector2: __webpack_require__2(93736),
              Vector3: __webpack_require__2(70015),
              Vector4: __webpack_require__2(51729),
              Matrix3: __webpack_require__2(5341),
              Matrix4: __webpack_require__2(16650),
              Quaternion: __webpack_require__2(75003),
              RotateVec3: __webpack_require__2(93709)
            };
            PhaserMath = Extend(false, PhaserMath, CONST);
            module2.exports = PhaserMath;
          },
          63210: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bernstein = __webpack_require__2(22824);
            var BezierInterpolation = function(v, k) {
              var b = 0;
              var n = v.length - 1;
              for (var i = 0; i <= n; i++) {
                b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
              }
              return b;
            };
            module2.exports = BezierInterpolation;
          },
          88332: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CatmullRom = __webpack_require__2(14976);
            var CatmullRomInterpolation = function(v, k) {
              var m = v.length - 1;
              var f = m * k;
              var i = Math.floor(f);
              if (v[0] === v[m]) {
                if (k < 0) {
                  i = Math.floor(f = m * (1 + k));
                }
                return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);
              } else {
                if (k < 0) {
                  return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);
                }
                if (k > 1) {
                  return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);
                }
                return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);
              }
            };
            module2.exports = CatmullRomInterpolation;
          },
          34631: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            function P0(t, p) {
              var k = 1 - t;
              return k * k * k * p;
            }
            function P1(t, p) {
              var k = 1 - t;
              return 3 * k * k * t * p;
            }
            function P2(t, p) {
              return 3 * (1 - t) * t * t * p;
            }
            function P3(t, p) {
              return t * t * t * p;
            }
            var CubicBezierInterpolation = function(t, p0, p1, p2, p3) {
              return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);
            };
            module2.exports = CubicBezierInterpolation;
          },
          47614: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Linear = __webpack_require__2(42798);
            var LinearInterpolation = function(v, k) {
              var m = v.length - 1;
              var f = m * k;
              var i = Math.floor(f);
              if (k < 0) {
                return Linear(v[0], v[1], f);
              } else if (k > 1) {
                return Linear(v[m], v[m - 1], m - f);
              } else {
                return Linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
              }
            };
            module2.exports = LinearInterpolation;
          },
          16252: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            function P0(t, p) {
              var k = 1 - t;
              return k * k * p;
            }
            function P1(t, p) {
              return 2 * (1 - t) * t * p;
            }
            function P2(t, p) {
              return t * t * p;
            }
            var QuadraticBezierInterpolation = function(t, p0, p1, p2) {
              return P0(t, p0) + P1(t, p1) + P2(t, p2);
            };
            module2.exports = QuadraticBezierInterpolation;
          },
          44521: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SmoothStep = __webpack_require__2(5514);
            var SmoothStepInterpolation = function(t, min, max) {
              return min + (max - min) * SmoothStep(t, 0, 1);
            };
            module2.exports = SmoothStepInterpolation;
          },
          45507: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SmootherStep = __webpack_require__2(87736);
            var SmootherStepInterpolation = function(t, min, max) {
              return min + (max - min) * SmootherStep(t, 0, 1);
            };
            module2.exports = SmootherStepInterpolation;
          },
          48528: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Bezier: __webpack_require__2(63210),
              CatmullRom: __webpack_require__2(88332),
              CubicBezier: __webpack_require__2(34631),
              Linear: __webpack_require__2(47614),
              QuadraticBezier: __webpack_require__2(16252),
              SmoothStep: __webpack_require__2(44521),
              SmootherStep: __webpack_require__2(45507)
            };
          },
          3504: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetPowerOfTwo = function(value) {
              var index = Math.log(value) / 0.6931471805599453;
              return 1 << Math.ceil(index);
            };
            module2.exports = GetPowerOfTwo;
          },
          28621: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsSizePowerOfTwo = function(width, height) {
              return width > 0 && (width & width - 1) === 0 && height > 0 && (height & height - 1) === 0;
            };
            module2.exports = IsSizePowerOfTwo;
          },
          2018: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsValuePowerOfTwo = function(value) {
              return value > 0 && (value & value - 1) === 0;
            };
            module2.exports = IsValuePowerOfTwo;
          },
          73773: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              GetNext: __webpack_require__2(3504),
              IsSize: __webpack_require__2(28621),
              IsValue: __webpack_require__2(2018)
            };
          },
          81429: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var RandomDataGenerator = new Class({
              initialize: function RandomDataGenerator2(seeds) {
                if (seeds === void 0) {
                  seeds = [(Date.now() * Math.random()).toString()];
                }
                this.c = 1;
                this.s0 = 0;
                this.s1 = 0;
                this.s2 = 0;
                this.n = 0;
                this.signs = [-1, 1];
                if (seeds) {
                  this.init(seeds);
                }
              },
              rnd: function() {
                var t = 2091639 * this.s0 + this.c * 23283064365386963e-26;
                this.c = t | 0;
                this.s0 = this.s1;
                this.s1 = this.s2;
                this.s2 = t - this.c;
                return this.s2;
              },
              hash: function(data) {
                var h;
                var n = this.n;
                data = data.toString();
                for (var i = 0; i < data.length; i++) {
                  n += data.charCodeAt(i);
                  h = 0.02519603282416938 * n;
                  n = h >>> 0;
                  h -= n;
                  h *= n;
                  n = h >>> 0;
                  h -= n;
                  n += h * 4294967296;
                }
                this.n = n;
                return (n >>> 0) * 23283064365386963e-26;
              },
              init: function(seeds) {
                if (typeof seeds === "string") {
                  this.state(seeds);
                } else {
                  this.sow(seeds);
                }
              },
              sow: function(seeds) {
                this.n = 4022871197;
                this.s0 = this.hash(" ");
                this.s1 = this.hash(" ");
                this.s2 = this.hash(" ");
                this.c = 1;
                if (!seeds) {
                  return;
                }
                for (var i = 0; i < seeds.length && seeds[i] != null; i++) {
                  var seed = seeds[i];
                  this.s0 -= this.hash(seed);
                  this.s0 += ~~(this.s0 < 0);
                  this.s1 -= this.hash(seed);
                  this.s1 += ~~(this.s1 < 0);
                  this.s2 -= this.hash(seed);
                  this.s2 += ~~(this.s2 < 0);
                }
              },
              integer: function() {
                return this.rnd() * 4294967296;
              },
              frac: function() {
                return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32;
              },
              real: function() {
                return this.integer() + this.frac();
              },
              integerInRange: function(min, max) {
                return Math.floor(this.realInRange(0, max - min + 1) + min);
              },
              between: function(min, max) {
                return Math.floor(this.realInRange(0, max - min + 1) + min);
              },
              realInRange: function(min, max) {
                return this.frac() * (max - min) + min;
              },
              normal: function() {
                return 1 - 2 * this.frac();
              },
              uuid: function() {
                var a = "";
                var b = "";
                for (b = a = ""; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
                }
                return b;
              },
              pick: function(array) {
                return array[this.integerInRange(0, array.length - 1)];
              },
              sign: function() {
                return this.pick(this.signs);
              },
              weightedPick: function(array) {
                return array[~~(Math.pow(this.frac(), 2) * array.length + 0.5)];
              },
              timestamp: function(min, max) {
                return this.realInRange(min || 9466848e5, max || 1577862e6);
              },
              angle: function() {
                return this.integerInRange(-180, 180);
              },
              rotation: function() {
                return this.realInRange(-3.1415926, 3.1415926);
              },
              state: function(state) {
                if (typeof state === "string" && state.match(/^!rnd/)) {
                  state = state.split(",");
                  this.c = parseFloat(state[1]);
                  this.s0 = parseFloat(state[2]);
                  this.s1 = parseFloat(state[3]);
                  this.s2 = parseFloat(state[4]);
                }
                return ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
              },
              shuffle: function(array) {
                var len = array.length - 1;
                for (var i = len; i > 0; i--) {
                  var randomIndex = Math.floor(this.frac() * (i + 1));
                  var itemAtIndex = array[randomIndex];
                  array[randomIndex] = array[i];
                  array[i] = itemAtIndex;
                }
                return array;
              }
            });
            module2.exports = RandomDataGenerator;
          },
          82127: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SnapCeil = function(value, gap, start, divide) {
              if (start === void 0) {
                start = 0;
              }
              if (gap === 0) {
                return value;
              }
              value -= start;
              value = gap * Math.ceil(value / gap);
              return divide ? (start + value) / gap : start + value;
            };
            module2.exports = SnapCeil;
          },
          84314: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SnapFloor = function(value, gap, start, divide) {
              if (start === void 0) {
                start = 0;
              }
              if (gap === 0) {
                return value;
              }
              value -= start;
              value = gap * Math.floor(value / gap);
              return divide ? (start + value) / gap : start + value;
            };
            module2.exports = SnapFloor;
          },
          88462: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SnapTo = function(value, gap, start, divide) {
              if (start === void 0) {
                start = 0;
              }
              if (gap === 0) {
                return value;
              }
              value -= start;
              value = gap * Math.round(value / gap);
              return divide ? (start + value) / gap : start + value;
            };
            module2.exports = SnapTo;
          },
          23679: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Ceil: __webpack_require__2(82127),
              Floor: __webpack_require__2(84314),
              To: __webpack_require__2(88462)
            };
          },
          92491: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            __webpack_require__2(75205);
            var CONST = __webpack_require__2(86459);
            var Extend = __webpack_require__2(98611);
            var Phaser2 = {
              Actions: __webpack_require__2(83979),
              Animations: __webpack_require__2(13517),
              BlendModes: __webpack_require__2(95723),
              Cache: __webpack_require__2(45820),
              Cameras: __webpack_require__2(44143),
              Core: __webpack_require__2(80293),
              Class: __webpack_require__2(56694),
              Create: __webpack_require__2(84106),
              Curves: __webpack_require__2(73962),
              Data: __webpack_require__2(1999),
              Display: __webpack_require__2(24816),
              DOM: __webpack_require__2(3590),
              Events: __webpack_require__2(95146),
              FX: __webpack_require__2(96910),
              Game: __webpack_require__2(15213),
              GameObjects: __webpack_require__2(48013),
              Geom: __webpack_require__2(84068),
              Input: __webpack_require__2(20873),
              Loader: __webpack_require__2(95695),
              Math: __webpack_require__2(5923),
              Physics: __webpack_require__2(53954),
              Plugins: __webpack_require__2(45615),
              Renderer: __webpack_require__2(42069),
              Scale: __webpack_require__2(86754),
              ScaleModes: __webpack_require__2(27394),
              Scene: __webpack_require__2(87157),
              Scenes: __webpack_require__2(20436),
              Structs: __webpack_require__2(20010),
              Textures: __webpack_require__2(87499),
              Tilemaps: __webpack_require__2(52678),
              Time: __webpack_require__2(97121),
              Tweens: __webpack_require__2(75193),
              Utils: __webpack_require__2(22178)
            };
            if (true) {
              Phaser2.Sound = __webpack_require__2(56751);
            }
            if (false) {
            }
            if (false) {
            }
            Phaser2 = Extend(false, Phaser2, CONST);
            module2.exports = Phaser2;
            __webpack_require__2.g.Phaser = Phaser2;
          },
          62832: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(7864);
            var Image2 = __webpack_require__2(1539);
            var ArcadeImage = new Class({
              Extends: Image2,
              Mixins: [
                Components.Acceleration,
                Components.Angular,
                Components.Bounce,
                Components.Collision,
                Components.Debug,
                Components.Drag,
                Components.Enable,
                Components.Friction,
                Components.Gravity,
                Components.Immovable,
                Components.Mass,
                Components.Pushable,
                Components.Size,
                Components.Velocity
              ],
              initialize: function ArcadeImage2(scene, x, y, texture, frame) {
                Image2.call(this, scene, x, y, texture, frame);
                this.body = null;
              }
            });
            module2.exports = ArcadeImage;
          },
          66150: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var DegToRad = __webpack_require__2(75606);
            var DistanceBetween = __webpack_require__2(53996);
            var DistanceSquared = __webpack_require__2(35032);
            var Factory = __webpack_require__2(99523);
            var GetFastValue = __webpack_require__2(72632);
            var Merge = __webpack_require__2(30657);
            var OverlapCirc = __webpack_require__2(2732);
            var OverlapRect = __webpack_require__2(15147);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var Vector2 = __webpack_require__2(93736);
            var World = __webpack_require__2(85233);
            var ArcadePhysics = new Class({
              initialize: function ArcadePhysics2(scene) {
                this.scene = scene;
                this.systems = scene.sys;
                this.config = this.getConfig();
                this.world;
                this.add;
                this._category = 1;
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                scene.sys.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.world = new World(this.scene, this.config);
                this.add = new Factory(this.world);
                this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                if (!this.world) {
                  this.world = new World(this.scene, this.config);
                  this.add = new Factory(this.world);
                }
                var eventEmitter = this.systems.events;
                if (!GetFastValue(this.config, "customUpdate", false)) {
                  eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
                }
                eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
                eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              enableUpdate: function() {
                this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world);
              },
              disableUpdate: function() {
                this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world);
              },
              getConfig: function() {
                var gameConfig = this.systems.game.config.physics;
                var sceneConfig = this.systems.settings.physics;
                var config2 = Merge(GetFastValue(sceneConfig, "arcade", {}), GetFastValue(gameConfig, "arcade", {}));
                return config2;
              },
              nextCategory: function() {
                this._category = this._category << 1;
                return this._category;
              },
              overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
                if (overlapCallback === void 0) {
                  overlapCallback = null;
                }
                if (processCallback === void 0) {
                  processCallback = null;
                }
                if (callbackContext === void 0) {
                  callbackContext = overlapCallback;
                }
                return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
              },
              collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
                if (collideCallback === void 0) {
                  collideCallback = null;
                }
                if (processCallback === void 0) {
                  processCallback = null;
                }
                if (callbackContext === void 0) {
                  callbackContext = collideCallback;
                }
                return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
              },
              collideTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
                return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
              },
              overlapTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
                return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
              },
              pause: function() {
                return this.world.pause();
              },
              resume: function() {
                return this.world.resume();
              },
              accelerateTo: function(gameObject, x, y, speed, xSpeedMax, ySpeedMax) {
                if (speed === void 0) {
                  speed = 60;
                }
                var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
                gameObject.body.acceleration.setToPolar(angle, speed);
                if (xSpeedMax !== void 0 && ySpeedMax !== void 0) {
                  gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);
                }
                return angle;
              },
              accelerateToObject: function(gameObject, destination, speed, xSpeedMax, ySpeedMax) {
                return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);
              },
              closest: function(source, targets) {
                if (!targets) {
                  targets = this.world.bodies.entries;
                }
                var min = Number.MAX_VALUE;
                var closest = null;
                var x = source.x;
                var y = source.y;
                var len = targets.length;
                for (var i = 0; i < len; i++) {
                  var target = targets[i];
                  var body = target.body || target;
                  if (source === target || source === body || source === body.gameObject || source === body.center) {
                    continue;
                  }
                  var distance = DistanceSquared(x, y, body.center.x, body.center.y);
                  if (distance < min) {
                    closest = target;
                    min = distance;
                  }
                }
                return closest;
              },
              furthest: function(source, targets) {
                if (!targets) {
                  targets = this.world.bodies.entries;
                }
                var max = -1;
                var farthest = null;
                var x = source.x;
                var y = source.y;
                var len = targets.length;
                for (var i = 0; i < len; i++) {
                  var target = targets[i];
                  var body = target.body || target;
                  if (source === target || source === body || source === body.gameObject || source === body.center) {
                    continue;
                  }
                  var distance = DistanceSquared(x, y, body.center.x, body.center.y);
                  if (distance > max) {
                    farthest = target;
                    max = distance;
                  }
                }
                return farthest;
              },
              moveTo: function(gameObject, x, y, speed, maxTime) {
                if (speed === void 0) {
                  speed = 60;
                }
                if (maxTime === void 0) {
                  maxTime = 0;
                }
                var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
                if (maxTime > 0) {
                  speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1e3);
                }
                gameObject.body.velocity.setToPolar(angle, speed);
                return angle;
              },
              moveToObject: function(gameObject, destination, speed, maxTime) {
                return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);
              },
              velocityFromAngle: function(angle, speed, vec2) {
                if (speed === void 0) {
                  speed = 60;
                }
                if (vec2 === void 0) {
                  vec2 = new Vector2();
                }
                return vec2.setToPolar(DegToRad(angle), speed);
              },
              velocityFromRotation: function(rotation, speed, vec2) {
                if (speed === void 0) {
                  speed = 60;
                }
                if (vec2 === void 0) {
                  vec2 = new Vector2();
                }
                return vec2.setToPolar(rotation, speed);
              },
              overlapRect: function(x, y, width, height, includeDynamic, includeStatic) {
                return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);
              },
              overlapCirc: function(x, y, radius, includeDynamic, includeStatic) {
                return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);
              },
              shutdown: function() {
                if (!this.world) {
                  return;
                }
                var eventEmitter = this.systems.events;
                eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
                eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
                eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
                this.add.destroy();
                this.world.destroy();
                this.add = null;
                this.world = null;
                this._category = 1;
              },
              destroy: function() {
                this.shutdown();
                this.scene.sys.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.systems = null;
              }
            });
            PluginCache.register("ArcadePhysics", ArcadePhysics, "arcadePhysics");
            module2.exports = ArcadePhysics;
          },
          25084: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(7864);
            var Sprite = __webpack_require__2(13747);
            var ArcadeSprite = new Class({
              Extends: Sprite,
              Mixins: [
                Components.Acceleration,
                Components.Angular,
                Components.Bounce,
                Components.Collision,
                Components.Debug,
                Components.Drag,
                Components.Enable,
                Components.Friction,
                Components.Gravity,
                Components.Immovable,
                Components.Mass,
                Components.Pushable,
                Components.Size,
                Components.Velocity
              ],
              initialize: function ArcadeSprite2(scene, x, y, texture, frame) {
                Sprite.call(this, scene, x, y, texture, frame);
                this.body = null;
              }
            });
            module2.exports = ArcadeSprite;
          },
          97602: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CollisionComponent = __webpack_require__2(95239);
            var CONST = __webpack_require__2(47401);
            var Events = __webpack_require__2(27037);
            var RadToDeg = __webpack_require__2(23701);
            var Rectangle = __webpack_require__2(74118);
            var RectangleContains = __webpack_require__2(94287);
            var SetCollisionObject = __webpack_require__2(15084);
            var Vector2 = __webpack_require__2(93736);
            var Body = new Class({
              Mixins: [
                CollisionComponent
              ],
              initialize: function Body2(world, gameObject) {
                var width = 64;
                var height = 64;
                var dummyGameObject = {
                  x: 0,
                  y: 0,
                  angle: 0,
                  rotation: 0,
                  scaleX: 1,
                  scaleY: 1,
                  displayOriginX: 0,
                  displayOriginY: 0
                };
                var hasGameObject = gameObject !== void 0;
                if (hasGameObject && gameObject.displayWidth) {
                  width = gameObject.displayWidth;
                  height = gameObject.displayHeight;
                }
                if (!hasGameObject) {
                  gameObject = dummyGameObject;
                }
                this.world = world;
                this.gameObject = hasGameObject ? gameObject : void 0;
                this.isBody = true;
                this.transform = {
                  x: gameObject.x,
                  y: gameObject.y,
                  rotation: gameObject.angle,
                  scaleX: gameObject.scaleX,
                  scaleY: gameObject.scaleY,
                  displayOriginX: gameObject.displayOriginX,
                  displayOriginY: gameObject.displayOriginY
                };
                this.debugShowBody = world.defaults.debugShowBody;
                this.debugShowVelocity = world.defaults.debugShowVelocity;
                this.debugBodyColor = world.defaults.bodyDebugColor;
                this.enable = true;
                this.isCircle = false;
                this.radius = 0;
                this.offset = new Vector2();
                this.position = new Vector2(gameObject.x - gameObject.scaleX * gameObject.displayOriginX, gameObject.y - gameObject.scaleY * gameObject.displayOriginY);
                this.prev = this.position.clone();
                this.prevFrame = this.position.clone();
                this.allowRotation = true;
                this.rotation = gameObject.angle;
                this.preRotation = gameObject.angle;
                this.width = width;
                this.height = height;
                this.sourceWidth = width;
                this.sourceHeight = height;
                if (gameObject.frame) {
                  this.sourceWidth = gameObject.frame.realWidth;
                  this.sourceHeight = gameObject.frame.realHeight;
                }
                this.halfWidth = Math.abs(width / 2);
                this.halfHeight = Math.abs(height / 2);
                this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
                this.velocity = new Vector2();
                this.newVelocity = new Vector2();
                this.deltaMax = new Vector2();
                this.acceleration = new Vector2();
                this.allowDrag = true;
                this.drag = new Vector2();
                this.allowGravity = true;
                this.gravity = new Vector2();
                this.bounce = new Vector2();
                this.worldBounce = null;
                this.customBoundsRectangle = world.bounds;
                this.onWorldBounds = false;
                this.onCollide = false;
                this.onOverlap = false;
                this.maxVelocity = new Vector2(1e4, 1e4);
                this.maxSpeed = -1;
                this.friction = new Vector2(1, 0);
                this.useDamping = false;
                this.angularVelocity = 0;
                this.angularAcceleration = 0;
                this.angularDrag = 0;
                this.maxAngular = 1e3;
                this.mass = 1;
                this.angle = 0;
                this.speed = 0;
                this.facing = CONST.FACING_NONE;
                this.immovable = false;
                this.pushable = true;
                this.slideFactor = new Vector2(1, 1);
                this.moves = true;
                this.customSeparateX = false;
                this.customSeparateY = false;
                this.overlapX = 0;
                this.overlapY = 0;
                this.overlapR = 0;
                this.embedded = false;
                this.collideWorldBounds = false;
                this.checkCollision = SetCollisionObject(false);
                this.touching = SetCollisionObject(true);
                this.wasTouching = SetCollisionObject(true);
                this.blocked = SetCollisionObject(true);
                this.syncBounds = false;
                this.physicsType = CONST.DYNAMIC_BODY;
                this.collisionCategory = 1;
                this.collisionMask = 1;
                this._sx = gameObject.scaleX;
                this._sy = gameObject.scaleY;
                this._dx = 0;
                this._dy = 0;
                this._tx = 0;
                this._ty = 0;
                this._bounds = new Rectangle();
                this.directControl = false;
                this.autoFrame = this.position.clone();
              },
              updateBounds: function() {
                var sprite = this.gameObject;
                var transform = this.transform;
                if (sprite.parentContainer) {
                  var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);
                  transform.x = matrix.tx;
                  transform.y = matrix.ty;
                  transform.rotation = RadToDeg(matrix.rotation);
                  transform.scaleX = matrix.scaleX;
                  transform.scaleY = matrix.scaleY;
                  transform.displayOriginX = sprite.displayOriginX;
                  transform.displayOriginY = sprite.displayOriginY;
                } else {
                  transform.x = sprite.x;
                  transform.y = sprite.y;
                  transform.rotation = sprite.angle;
                  transform.scaleX = sprite.scaleX;
                  transform.scaleY = sprite.scaleY;
                  transform.displayOriginX = sprite.displayOriginX;
                  transform.displayOriginY = sprite.displayOriginY;
                }
                var recalc = false;
                if (this.syncBounds) {
                  var b = sprite.getBounds(this._bounds);
                  this.width = b.width;
                  this.height = b.height;
                  recalc = true;
                } else {
                  var asx = Math.abs(transform.scaleX);
                  var asy = Math.abs(transform.scaleY);
                  if (this._sx !== asx || this._sy !== asy) {
                    this.width = this.sourceWidth * asx;
                    this.height = this.sourceHeight * asy;
                    this._sx = asx;
                    this._sy = asy;
                    recalc = true;
                  }
                }
                if (recalc) {
                  this.halfWidth = Math.floor(this.width / 2);
                  this.halfHeight = Math.floor(this.height / 2);
                  this.updateCenter();
                }
              },
              updateCenter: function() {
                this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
              },
              updateFromGameObject: function() {
                this.updateBounds();
                var transform = this.transform;
                this.position.x = transform.x + transform.scaleX * (this.offset.x - transform.displayOriginX);
                this.position.y = transform.y + transform.scaleY * (this.offset.y - transform.displayOriginY);
                this.updateCenter();
              },
              resetFlags: function(clear) {
                if (clear === void 0) {
                  clear = false;
                }
                var wasTouching = this.wasTouching;
                var touching = this.touching;
                var blocked = this.blocked;
                if (clear) {
                  SetCollisionObject(true, wasTouching);
                } else {
                  wasTouching.none = touching.none;
                  wasTouching.up = touching.up;
                  wasTouching.down = touching.down;
                  wasTouching.left = touching.left;
                  wasTouching.right = touching.right;
                }
                SetCollisionObject(true, touching);
                SetCollisionObject(true, blocked);
                this.overlapR = 0;
                this.overlapX = 0;
                this.overlapY = 0;
                this.embedded = false;
              },
              preUpdate: function(willStep, delta) {
                if (willStep) {
                  this.resetFlags();
                }
                if (this.gameObject) {
                  this.updateFromGameObject();
                }
                this.rotation = this.transform.rotation;
                this.preRotation = this.rotation;
                if (this.moves) {
                  var pos = this.position;
                  this.prev.x = pos.x;
                  this.prev.y = pos.y;
                  this.prevFrame.x = pos.x;
                  this.prevFrame.y = pos.y;
                }
                if (willStep) {
                  this.update(delta);
                }
              },
              update: function(delta) {
                var prev = this.prev;
                var pos = this.position;
                var vel = this.velocity;
                prev.set(pos.x, pos.y);
                if (!this.moves) {
                  this._dx = pos.x - prev.x;
                  this._dy = pos.y - prev.y;
                  return;
                }
                if (this.directControl) {
                  var autoFrame = this.autoFrame;
                  vel.set((pos.x - autoFrame.x) / delta, (pos.y - autoFrame.y) / delta);
                  this.world.updateMotion(this, delta);
                  this._dx = pos.x - autoFrame.x;
                  this._dy = pos.y - autoFrame.y;
                } else {
                  this.world.updateMotion(this, delta);
                  this.newVelocity.set(vel.x * delta, vel.y * delta);
                  pos.add(this.newVelocity);
                  this._dx = pos.x - prev.x;
                  this._dy = pos.y - prev.y;
                }
                var vx = vel.x;
                var vy = vel.y;
                this.updateCenter();
                this.angle = Math.atan2(vy, vx);
                this.speed = Math.sqrt(vx * vx + vy * vy);
                if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {
                  var blocked = this.blocked;
                  this.world.emit(Events.WORLD_BOUNDS, this, blocked.up, blocked.down, blocked.left, blocked.right);
                }
              },
              postUpdate: function() {
                var pos = this.position;
                var dx = pos.x - this.prevFrame.x;
                var dy = pos.y - this.prevFrame.y;
                var gameObject = this.gameObject;
                if (this.moves) {
                  var mx = this.deltaMax.x;
                  var my = this.deltaMax.y;
                  if (mx !== 0 && dx !== 0) {
                    if (dx < 0 && dx < -mx) {
                      dx = -mx;
                    } else if (dx > 0 && dx > mx) {
                      dx = mx;
                    }
                  }
                  if (my !== 0 && dy !== 0) {
                    if (dy < 0 && dy < -my) {
                      dy = -my;
                    } else if (dy > 0 && dy > my) {
                      dy = my;
                    }
                  }
                  if (gameObject) {
                    gameObject.x += dx;
                    gameObject.y += dy;
                  }
                }
                if (dx < 0) {
                  this.facing = CONST.FACING_LEFT;
                } else if (dx > 0) {
                  this.facing = CONST.FACING_RIGHT;
                }
                if (dy < 0) {
                  this.facing = CONST.FACING_UP;
                } else if (dy > 0) {
                  this.facing = CONST.FACING_DOWN;
                }
                if (this.allowRotation && gameObject) {
                  gameObject.angle += this.deltaZ();
                }
                this._tx = dx;
                this._ty = dy;
                this.autoFrame.set(pos.x, pos.y);
              },
              setBoundsRectangle: function(bounds) {
                this.customBoundsRectangle = !bounds ? this.world.bounds : bounds;
                return this;
              },
              checkWorldBounds: function() {
                var pos = this.position;
                var vel = this.velocity;
                var blocked = this.blocked;
                var bounds = this.customBoundsRectangle;
                var check = this.world.checkCollision;
                var bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;
                var by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                var wasSet = false;
                if (pos.x < bounds.x && check.left) {
                  pos.x = bounds.x;
                  vel.x *= bx;
                  blocked.left = true;
                  wasSet = true;
                } else if (this.right > bounds.right && check.right) {
                  pos.x = bounds.right - this.width;
                  vel.x *= bx;
                  blocked.right = true;
                  wasSet = true;
                }
                if (pos.y < bounds.y && check.up) {
                  pos.y = bounds.y;
                  vel.y *= by;
                  blocked.up = true;
                  wasSet = true;
                } else if (this.bottom > bounds.bottom && check.down) {
                  pos.y = bounds.bottom - this.height;
                  vel.y *= by;
                  blocked.down = true;
                  wasSet = true;
                }
                if (wasSet) {
                  this.blocked.none = false;
                  this.updateCenter();
                }
                return wasSet;
              },
              setOffset: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.offset.set(x, y);
                return this;
              },
              setGameObject: function(gameObject, enable) {
                if (enable === void 0) {
                  enable = true;
                }
                this.world.remove(this);
                if (this.gameObject && this.gameObject.body) {
                  this.gameObject.body = null;
                }
                this.gameObject = gameObject;
                if (gameObject.body) {
                  gameObject.body = this;
                }
                this.setSize();
                this.world.add(this);
                this.enable = enable;
                return this;
              },
              setSize: function(width, height, center) {
                if (center === void 0) {
                  center = true;
                }
                var gameObject = this.gameObject;
                if (gameObject) {
                  if (!width && gameObject.frame) {
                    width = gameObject.frame.realWidth;
                  }
                  if (!height && gameObject.frame) {
                    height = gameObject.frame.realHeight;
                  }
                }
                this.sourceWidth = width;
                this.sourceHeight = height;
                this.width = this.sourceWidth * this._sx;
                this.height = this.sourceHeight * this._sy;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this.updateCenter();
                if (center && gameObject && gameObject.getCenter) {
                  var ox = (gameObject.width - width) / 2;
                  var oy = (gameObject.height - height) / 2;
                  this.offset.set(ox, oy);
                }
                this.isCircle = false;
                this.radius = 0;
                return this;
              },
              setCircle: function(radius, offsetX, offsetY) {
                if (offsetX === void 0) {
                  offsetX = this.offset.x;
                }
                if (offsetY === void 0) {
                  offsetY = this.offset.y;
                }
                if (radius > 0) {
                  this.isCircle = true;
                  this.radius = radius;
                  this.sourceWidth = radius * 2;
                  this.sourceHeight = radius * 2;
                  this.width = this.sourceWidth * this._sx;
                  this.height = this.sourceHeight * this._sy;
                  this.halfWidth = Math.floor(this.width / 2);
                  this.halfHeight = Math.floor(this.height / 2);
                  this.offset.set(offsetX, offsetY);
                  this.updateCenter();
                } else {
                  this.isCircle = false;
                }
                return this;
              },
              reset: function(x, y) {
                this.stop();
                var gameObject = this.gameObject;
                if (gameObject) {
                  gameObject.setPosition(x, y);
                  this.rotation = gameObject.angle;
                  this.preRotation = gameObject.angle;
                }
                var pos = this.position;
                if (gameObject && gameObject.getTopLeft) {
                  gameObject.getTopLeft(pos);
                } else {
                  pos.set(x, y);
                }
                this.prev.copy(pos);
                this.prevFrame.copy(pos);
                this.autoFrame.copy(pos);
                if (gameObject) {
                  this.updateBounds();
                }
                this.updateCenter();
                if (this.collideWorldBounds) {
                  this.checkWorldBounds();
                }
                this.resetFlags(true);
              },
              stop: function() {
                this.velocity.set(0);
                this.acceleration.set(0);
                this.speed = 0;
                this.angularVelocity = 0;
                this.angularAcceleration = 0;
                return this;
              },
              getBounds: function(obj) {
                obj.x = this.x;
                obj.y = this.y;
                obj.right = this.right;
                obj.bottom = this.bottom;
                return obj;
              },
              hitTest: function(x, y) {
                if (!this.isCircle) {
                  return RectangleContains(this, x, y);
                }
                if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom) {
                  var dx = (this.center.x - x) * (this.center.x - x);
                  var dy = (this.center.y - y) * (this.center.y - y);
                  return dx + dy <= this.radius * this.radius;
                }
                return false;
              },
              onFloor: function() {
                return this.blocked.down;
              },
              onCeiling: function() {
                return this.blocked.up;
              },
              onWall: function() {
                return this.blocked.left || this.blocked.right;
              },
              deltaAbsX: function() {
                return this._dx > 0 ? this._dx : -this._dx;
              },
              deltaAbsY: function() {
                return this._dy > 0 ? this._dy : -this._dy;
              },
              deltaX: function() {
                return this._dx;
              },
              deltaY: function() {
                return this._dy;
              },
              deltaXFinal: function() {
                return this._tx;
              },
              deltaYFinal: function() {
                return this._ty;
              },
              deltaZ: function() {
                return this.rotation - this.preRotation;
              },
              destroy: function() {
                this.enable = false;
                if (this.world) {
                  this.world.pendingDestroy.set(this);
                }
              },
              drawDebug: function(graphic) {
                var pos = this.position;
                var x = pos.x + this.halfWidth;
                var y = pos.y + this.halfHeight;
                if (this.debugShowBody) {
                  graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);
                  if (this.isCircle) {
                    graphic.strokeCircle(x, y, this.width / 2);
                  } else {
                    if (this.checkCollision.up) {
                      graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);
                    }
                    if (this.checkCollision.right) {
                      graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);
                    }
                    if (this.checkCollision.down) {
                      graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);
                    }
                    if (this.checkCollision.left) {
                      graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);
                    }
                  }
                }
                if (this.debugShowVelocity) {
                  graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);
                  graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);
                }
              },
              willDrawDebug: function() {
                return this.debugShowBody || this.debugShowVelocity;
              },
              setDirectControl: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.directControl = value;
                return this;
              },
              setCollideWorldBounds: function(value, bounceX, bounceY, onWorldBounds) {
                if (value === void 0) {
                  value = true;
                }
                this.collideWorldBounds = value;
                var setBounceX = bounceX !== void 0;
                var setBounceY = bounceY !== void 0;
                if (setBounceX || setBounceY) {
                  if (!this.worldBounce) {
                    this.worldBounce = new Vector2();
                  }
                  if (setBounceX) {
                    this.worldBounce.x = bounceX;
                  }
                  if (setBounceY) {
                    this.worldBounce.y = bounceY;
                  }
                }
                if (onWorldBounds !== void 0) {
                  this.onWorldBounds = onWorldBounds;
                }
                return this;
              },
              setVelocity: function(x, y) {
                this.velocity.set(x, y);
                x = this.velocity.x;
                y = this.velocity.y;
                this.speed = Math.sqrt(x * x + y * y);
                return this;
              },
              setVelocityX: function(value) {
                return this.setVelocity(value, this.velocity.y);
              },
              setVelocityY: function(value) {
                return this.setVelocity(this.velocity.x, value);
              },
              setMaxVelocity: function(x, y) {
                this.maxVelocity.set(x, y);
                return this;
              },
              setMaxVelocityX: function(value) {
                this.maxVelocity.x = value;
                return this;
              },
              setMaxVelocityY: function(value) {
                this.maxVelocity.y = value;
                return this;
              },
              setMaxSpeed: function(value) {
                this.maxSpeed = value;
                return this;
              },
              setSlideFactor: function(x, y) {
                this.slideFactor.set(x, y);
                return this;
              },
              setBounce: function(x, y) {
                this.bounce.set(x, y);
                return this;
              },
              setBounceX: function(value) {
                this.bounce.x = value;
                return this;
              },
              setBounceY: function(value) {
                this.bounce.y = value;
                return this;
              },
              setAcceleration: function(x, y) {
                this.acceleration.set(x, y);
                return this;
              },
              setAccelerationX: function(value) {
                this.acceleration.x = value;
                return this;
              },
              setAccelerationY: function(value) {
                this.acceleration.y = value;
                return this;
              },
              setAllowDrag: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.allowDrag = value;
                return this;
              },
              setAllowGravity: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.allowGravity = value;
                return this;
              },
              setAllowRotation: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.allowRotation = value;
                return this;
              },
              setDrag: function(x, y) {
                this.drag.set(x, y);
                return this;
              },
              setDamping: function(value) {
                this.useDamping = value;
                return this;
              },
              setDragX: function(value) {
                this.drag.x = value;
                return this;
              },
              setDragY: function(value) {
                this.drag.y = value;
                return this;
              },
              setGravity: function(x, y) {
                this.gravity.set(x, y);
                return this;
              },
              setGravityX: function(value) {
                this.gravity.x = value;
                return this;
              },
              setGravityY: function(value) {
                this.gravity.y = value;
                return this;
              },
              setFriction: function(x, y) {
                this.friction.set(x, y);
                return this;
              },
              setFrictionX: function(value) {
                this.friction.x = value;
                return this;
              },
              setFrictionY: function(value) {
                this.friction.y = value;
                return this;
              },
              setAngularVelocity: function(value) {
                this.angularVelocity = value;
                return this;
              },
              setAngularAcceleration: function(value) {
                this.angularAcceleration = value;
                return this;
              },
              setAngularDrag: function(value) {
                this.angularDrag = value;
                return this;
              },
              setMass: function(value) {
                this.mass = value;
                return this;
              },
              setImmovable: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.immovable = value;
                return this;
              },
              setEnable: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.enable = value;
                return this;
              },
              processX: function(x, vx, left, right) {
                this.x += x;
                this.updateCenter();
                if (vx !== null) {
                  this.velocity.x = vx * this.slideFactor.x;
                }
                var blocked = this.blocked;
                if (left) {
                  blocked.left = true;
                  blocked.none = false;
                }
                if (right) {
                  blocked.right = true;
                  blocked.none = false;
                }
              },
              processY: function(y, vy, up, down) {
                this.y += y;
                this.updateCenter();
                if (vy !== null) {
                  this.velocity.y = vy * this.slideFactor.y;
                }
                var blocked = this.blocked;
                if (up) {
                  blocked.up = true;
                  blocked.none = false;
                }
                if (down) {
                  blocked.down = true;
                  blocked.none = false;
                }
              },
              x: {
                get: function() {
                  return this.position.x;
                },
                set: function(value) {
                  this.position.x = value;
                }
              },
              y: {
                get: function() {
                  return this.position.y;
                },
                set: function(value) {
                  this.position.y = value;
                }
              },
              left: {
                get: function() {
                  return this.position.x;
                }
              },
              right: {
                get: function() {
                  return this.position.x + this.width;
                }
              },
              top: {
                get: function() {
                  return this.position.y;
                }
              },
              bottom: {
                get: function() {
                  return this.position.y + this.height;
                }
              }
            });
            module2.exports = Body;
          },
          3909: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Collider = new Class({
              initialize: function Collider2(world, overlapOnly, object1, object2, collideCallback, processCallback, callbackContext) {
                this.world = world;
                this.name = "";
                this.active = true;
                this.overlapOnly = overlapOnly;
                this.object1 = object1;
                this.object2 = object2;
                this.collideCallback = collideCallback;
                this.processCallback = processCallback;
                this.callbackContext = callbackContext;
              },
              setName: function(name) {
                this.name = name;
                return this;
              },
              update: function() {
                this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly);
              },
              destroy: function() {
                this.world.removeCollider(this);
                this.active = false;
                this.world = null;
                this.object1 = null;
                this.object2 = null;
                this.collideCallback = null;
                this.processCallback = null;
                this.callbackContext = null;
              }
            });
            module2.exports = Collider;
          },
          99523: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArcadeImage = __webpack_require__2(62832);
            var ArcadeSprite = __webpack_require__2(25084);
            var Body = __webpack_require__2(97602);
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(47401);
            var PhysicsGroup = __webpack_require__2(10481);
            var StaticBody = __webpack_require__2(66634);
            var StaticPhysicsGroup = __webpack_require__2(46346);
            var Factory = new Class({
              initialize: function Factory2(world) {
                this.world = world;
                this.scene = world.scene;
                this.sys = world.scene.sys;
              },
              collider: function(object1, object2, collideCallback, processCallback, callbackContext) {
                return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);
              },
              overlap: function(object1, object2, collideCallback, processCallback, callbackContext) {
                return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);
              },
              existing: function(gameObject, isStatic) {
                var type = isStatic ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;
                this.world.enableBody(gameObject, type);
                return gameObject;
              },
              staticImage: function(x, y, key, frame) {
                var image = new ArcadeImage(this.scene, x, y, key, frame);
                this.sys.displayList.add(image);
                this.world.enableBody(image, CONST.STATIC_BODY);
                return image;
              },
              image: function(x, y, key, frame) {
                var image = new ArcadeImage(this.scene, x, y, key, frame);
                this.sys.displayList.add(image);
                this.world.enableBody(image, CONST.DYNAMIC_BODY);
                return image;
              },
              staticSprite: function(x, y, key, frame) {
                var sprite = new ArcadeSprite(this.scene, x, y, key, frame);
                this.sys.displayList.add(sprite);
                this.sys.updateList.add(sprite);
                this.world.enableBody(sprite, CONST.STATIC_BODY);
                return sprite;
              },
              sprite: function(x, y, key, frame) {
                var sprite = new ArcadeSprite(this.scene, x, y, key, frame);
                this.sys.displayList.add(sprite);
                this.sys.updateList.add(sprite);
                this.world.enableBody(sprite, CONST.DYNAMIC_BODY);
                return sprite;
              },
              staticGroup: function(children, config2) {
                return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config2));
              },
              group: function(children, config2) {
                return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config2));
              },
              body: function(x, y, width, height) {
                var body = new Body(this.world);
                body.position.set(x, y);
                if (width && height) {
                  body.setSize(width, height);
                }
                this.world.add(body, CONST.DYNAMIC_BODY);
                return body;
              },
              staticBody: function(x, y, width, height) {
                var body = new StaticBody(this.world);
                body.position.set(x, y);
                if (width && height) {
                  body.setSize(width, height);
                }
                this.world.add(body, CONST.STATIC_BODY);
                return body;
              },
              destroy: function() {
                this.world = null;
                this.scene = null;
                this.sys = null;
              }
            });
            module2.exports = Factory;
          },
          44880: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCollidesWith = function(categories) {
              var flags = 0;
              if (!Array.isArray(categories)) {
                flags = categories;
              } else {
                for (var i = 0; i < categories.length; i++) {
                  flags |= categories[i];
                }
              }
              return flags;
            };
            module2.exports = GetCollidesWith;
          },
          75671: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(47401);
            var GetOverlapX = function(body1, body2, overlapOnly, bias) {
              var overlap = 0;
              var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;
              if (body1._dx === 0 && body2._dx === 0) {
                body1.embedded = true;
                body2.embedded = true;
              } else if (body1._dx > body2._dx) {
                overlap = body1.right - body2.x;
                if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.right === false || body2.checkCollision.left === false) {
                  overlap = 0;
                } else {
                  body1.touching.none = false;
                  body1.touching.right = true;
                  body2.touching.none = false;
                  body2.touching.left = true;
                  if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                    body1.blocked.none = false;
                    body1.blocked.right = true;
                  }
                  if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                    body2.blocked.none = false;
                    body2.blocked.left = true;
                  }
                }
              } else if (body1._dx < body2._dx) {
                overlap = body1.x - body2.width - body2.x;
                if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.left === false || body2.checkCollision.right === false) {
                  overlap = 0;
                } else {
                  body1.touching.none = false;
                  body1.touching.left = true;
                  body2.touching.none = false;
                  body2.touching.right = true;
                  if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                    body1.blocked.none = false;
                    body1.blocked.left = true;
                  }
                  if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                    body2.blocked.none = false;
                    body2.blocked.right = true;
                  }
                }
              }
              body1.overlapX = overlap;
              body2.overlapX = overlap;
              return overlap;
            };
            module2.exports = GetOverlapX;
          },
          66185: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(47401);
            var GetOverlapY = function(body1, body2, overlapOnly, bias) {
              var overlap = 0;
              var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;
              if (body1._dy === 0 && body2._dy === 0) {
                body1.embedded = true;
                body2.embedded = true;
              } else if (body1._dy > body2._dy) {
                overlap = body1.bottom - body2.y;
                if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.down === false || body2.checkCollision.up === false) {
                  overlap = 0;
                } else {
                  body1.touching.none = false;
                  body1.touching.down = true;
                  body2.touching.none = false;
                  body2.touching.up = true;
                  if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                    body1.blocked.none = false;
                    body1.blocked.down = true;
                  }
                  if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                    body2.blocked.none = false;
                    body2.blocked.up = true;
                  }
                }
              } else if (body1._dy < body2._dy) {
                overlap = body1.y - body2.bottom;
                if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.up === false || body2.checkCollision.down === false) {
                  overlap = 0;
                } else {
                  body1.touching.none = false;
                  body1.touching.up = true;
                  body2.touching.none = false;
                  body2.touching.down = true;
                  if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                    body1.blocked.none = false;
                    body1.blocked.up = true;
                  }
                  if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                    body2.blocked.none = false;
                    body2.blocked.down = true;
                  }
                }
              }
              body1.overlapY = overlap;
              body2.overlapY = overlap;
              return overlap;
            };
            module2.exports = GetOverlapY;
          },
          10481: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArcadeSprite = __webpack_require__2(25084);
            var Class = __webpack_require__2(56694);
            var CollisionComponent = __webpack_require__2(95239);
            var CONST = __webpack_require__2(47401);
            var GetFastValue = __webpack_require__2(72632);
            var Group = __webpack_require__2(59192);
            var IsPlainObject = __webpack_require__2(42911);
            var PhysicsGroup = new Class({
              Extends: Group,
              Mixins: [
                CollisionComponent
              ],
              initialize: function PhysicsGroup2(world, scene, children, config2) {
                if (!children && !config2) {
                  config2 = {
                    internalCreateCallback: this.createCallbackHandler,
                    internalRemoveCallback: this.removeCallbackHandler
                  };
                } else if (IsPlainObject(children)) {
                  config2 = children;
                  children = null;
                  config2.internalCreateCallback = this.createCallbackHandler;
                  config2.internalRemoveCallback = this.removeCallbackHandler;
                } else if (Array.isArray(children) && IsPlainObject(children[0])) {
                  var _this = this;
                  children.forEach(function(singleConfig) {
                    singleConfig.internalCreateCallback = _this.createCallbackHandler;
                    singleConfig.internalRemoveCallback = _this.removeCallbackHandler;
                    singleConfig.classType = GetFastValue(singleConfig, "classType", ArcadeSprite);
                  });
                  config2 = null;
                } else {
                  config2 = {
                    internalCreateCallback: this.createCallbackHandler,
                    internalRemoveCallback: this.removeCallbackHandler
                  };
                }
                this.world = world;
                if (config2) {
                  config2.classType = GetFastValue(config2, "classType", ArcadeSprite);
                }
                this.physicsType = CONST.DYNAMIC_BODY;
                this.collisionCategory = 1;
                this.collisionMask = 1;
                this.defaults = {
                  setCollideWorldBounds: GetFastValue(config2, "collideWorldBounds", false),
                  setBoundsRectangle: GetFastValue(config2, "customBoundsRectangle", null),
                  setAccelerationX: GetFastValue(config2, "accelerationX", 0),
                  setAccelerationY: GetFastValue(config2, "accelerationY", 0),
                  setAllowDrag: GetFastValue(config2, "allowDrag", true),
                  setAllowGravity: GetFastValue(config2, "allowGravity", true),
                  setAllowRotation: GetFastValue(config2, "allowRotation", true),
                  setDamping: GetFastValue(config2, "useDamping", false),
                  setBounceX: GetFastValue(config2, "bounceX", 0),
                  setBounceY: GetFastValue(config2, "bounceY", 0),
                  setDragX: GetFastValue(config2, "dragX", 0),
                  setDragY: GetFastValue(config2, "dragY", 0),
                  setEnable: GetFastValue(config2, "enable", true),
                  setGravityX: GetFastValue(config2, "gravityX", 0),
                  setGravityY: GetFastValue(config2, "gravityY", 0),
                  setFrictionX: GetFastValue(config2, "frictionX", 0),
                  setFrictionY: GetFastValue(config2, "frictionY", 0),
                  setMaxSpeed: GetFastValue(config2, "maxSpeed", -1),
                  setMaxVelocityX: GetFastValue(config2, "maxVelocityX", 1e4),
                  setMaxVelocityY: GetFastValue(config2, "maxVelocityY", 1e4),
                  setVelocityX: GetFastValue(config2, "velocityX", 0),
                  setVelocityY: GetFastValue(config2, "velocityY", 0),
                  setAngularVelocity: GetFastValue(config2, "angularVelocity", 0),
                  setAngularAcceleration: GetFastValue(config2, "angularAcceleration", 0),
                  setAngularDrag: GetFastValue(config2, "angularDrag", 0),
                  setMass: GetFastValue(config2, "mass", 1),
                  setImmovable: GetFastValue(config2, "immovable", false)
                };
                Group.call(this, scene, children, config2);
                this.type = "PhysicsGroup";
              },
              createCallbackHandler: function(child) {
                if (!child.body) {
                  this.world.enableBody(child, CONST.DYNAMIC_BODY);
                }
                var body = child.body;
                for (var key in this.defaults) {
                  body[key](this.defaults[key]);
                }
              },
              removeCallbackHandler: function(child) {
                if (child.body) {
                  this.world.disableBody(child);
                }
              },
              setVelocity: function(x, y, step) {
                if (step === void 0) {
                  step = 0;
                }
                var items = this.getChildren();
                for (var i = 0; i < items.length; i++) {
                  items[i].body.velocity.set(x + i * step, y + i * step);
                }
                return this;
              },
              setVelocityX: function(value, step) {
                if (step === void 0) {
                  step = 0;
                }
                var items = this.getChildren();
                for (var i = 0; i < items.length; i++) {
                  items[i].body.velocity.x = value + i * step;
                }
                return this;
              },
              setVelocityY: function(value, step) {
                if (step === void 0) {
                  step = 0;
                }
                var items = this.getChildren();
                for (var i = 0; i < items.length; i++) {
                  items[i].body.velocity.y = value + i * step;
                }
                return this;
              }
            });
            module2.exports = PhysicsGroup;
          },
          22916: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var body1;
            var body2;
            var body1Pushable;
            var body2Pushable;
            var body1MassImpact;
            var body2MassImpact;
            var body1FullImpact;
            var body2FullImpact;
            var body1MovingLeft;
            var body1MovingRight;
            var body1Stationary;
            var body2MovingLeft;
            var body2MovingRight;
            var body2Stationary;
            var body1OnLeft;
            var body2OnLeft;
            var overlap;
            var Set = function(b1, b2, ov) {
              body1 = b1;
              body2 = b2;
              var v1 = body1.velocity.x;
              var v2 = body2.velocity.x;
              body1Pushable = body1.pushable;
              body1MovingLeft = body1._dx < 0;
              body1MovingRight = body1._dx > 0;
              body1Stationary = body1._dx === 0;
              body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x);
              body1FullImpact = v2 - v1 * body1.bounce.x;
              body2Pushable = body2.pushable;
              body2MovingLeft = body2._dx < 0;
              body2MovingRight = body2._dx > 0;
              body2Stationary = body2._dx === 0;
              body2OnLeft = !body1OnLeft;
              body2FullImpact = v1 - v2 * body2.bounce.x;
              overlap = Math.abs(ov);
              return BlockCheck();
            };
            var BlockCheck = function() {
              if (body1MovingRight && body1OnLeft && body2.blocked.right) {
                body1.processX(-overlap, body1FullImpact, false, true);
                return 1;
              }
              if (body1MovingLeft && body2OnLeft && body2.blocked.left) {
                body1.processX(overlap, body1FullImpact, true);
                return 1;
              }
              if (body2MovingRight && body2OnLeft && body1.blocked.right) {
                body2.processX(-overlap, body2FullImpact, false, true);
                return 2;
              }
              if (body2MovingLeft && body1OnLeft && body1.blocked.left) {
                body2.processX(overlap, body2FullImpact, true);
                return 2;
              }
              return 0;
            };
            var Check = function() {
              var v1 = body1.velocity.x;
              var v2 = body2.velocity.x;
              var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
              var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
              var avg = (nv1 + nv2) * 0.5;
              nv1 -= avg;
              nv2 -= avg;
              body1MassImpact = avg + nv1 * body1.bounce.x;
              body2MassImpact = avg + nv2 * body2.bounce.x;
              if (body1MovingLeft && body2OnLeft) {
                return Run(0);
              }
              if (body2MovingLeft && body1OnLeft) {
                return Run(1);
              }
              if (body1MovingRight && body1OnLeft) {
                return Run(2);
              }
              if (body2MovingRight && body2OnLeft) {
                return Run(3);
              }
              return false;
            };
            var Run = function(side) {
              if (body1Pushable && body2Pushable) {
                overlap *= 0.5;
                if (side === 0 || side === 3) {
                  body1.processX(overlap, body1MassImpact);
                  body2.processX(-overlap, body2MassImpact);
                } else {
                  body1.processX(-overlap, body1MassImpact);
                  body2.processX(overlap, body2MassImpact);
                }
              } else if (body1Pushable && !body2Pushable) {
                if (side === 0 || side === 3) {
                  body1.processX(overlap, body1FullImpact, true);
                } else {
                  body1.processX(-overlap, body1FullImpact, false, true);
                }
              } else if (!body1Pushable && body2Pushable) {
                if (side === 0 || side === 3) {
                  body2.processX(-overlap, body2FullImpact, false, true);
                } else {
                  body2.processX(overlap, body2FullImpact, true);
                }
              } else {
                var halfOverlap = overlap * 0.5;
                if (side === 0) {
                  if (body2Stationary) {
                    body1.processX(overlap, 0, true);
                    body2.processX(0, null, false, true);
                  } else if (body2MovingRight) {
                    body1.processX(halfOverlap, 0, true);
                    body2.processX(-halfOverlap, 0, false, true);
                  } else {
                    body1.processX(halfOverlap, body2.velocity.x, true);
                    body2.processX(-halfOverlap, null, false, true);
                  }
                } else if (side === 1) {
                  if (body1Stationary) {
                    body1.processX(0, null, false, true);
                    body2.processX(overlap, 0, true);
                  } else if (body1MovingRight) {
                    body1.processX(-halfOverlap, 0, false, true);
                    body2.processX(halfOverlap, 0, true);
                  } else {
                    body1.processX(-halfOverlap, null, false, true);
                    body2.processX(halfOverlap, body1.velocity.x, true);
                  }
                } else if (side === 2) {
                  if (body2Stationary) {
                    body1.processX(-overlap, 0, false, true);
                    body2.processX(0, null, true);
                  } else if (body2MovingLeft) {
                    body1.processX(-halfOverlap, 0, false, true);
                    body2.processX(halfOverlap, 0, true);
                  } else {
                    body1.processX(-halfOverlap, body2.velocity.x, false, true);
                    body2.processX(halfOverlap, null, true);
                  }
                } else if (side === 3) {
                  if (body1Stationary) {
                    body1.processX(0, null, true);
                    body2.processX(-overlap, 0, false, true);
                  } else if (body1MovingLeft) {
                    body1.processX(halfOverlap, 0, true);
                    body2.processX(-halfOverlap, 0, false, true);
                  } else {
                    body1.processX(halfOverlap, body2.velocity.y, true);
                    body2.processX(-halfOverlap, null, false, true);
                  }
                }
              }
              return true;
            };
            var RunImmovableBody1 = function(blockedState) {
              if (blockedState === 1) {
                body2.velocity.x = 0;
              } else if (body1OnLeft) {
                body2.processX(overlap, body2FullImpact, true);
              } else {
                body2.processX(-overlap, body2FullImpact, false, true);
              }
              if (body1.moves) {
                body2.y += (body1.y - body1.prev.y) * body1.friction.y;
                body2._dy = body2.y - body2.prev.y;
              }
            };
            var RunImmovableBody2 = function(blockedState) {
              if (blockedState === 2) {
                body1.velocity.x = 0;
              } else if (body2OnLeft) {
                body1.processX(overlap, body1FullImpact, true);
              } else {
                body1.processX(-overlap, body1FullImpact, false, true);
              }
              if (body2.moves) {
                body1.y += (body2.y - body2.prev.y) * body2.friction.y;
                body1._dy = body1.y - body1.prev.y;
              }
            };
            module2.exports = {
              BlockCheck,
              Check,
              Set,
              Run,
              RunImmovableBody1,
              RunImmovableBody2
            };
          },
          67050: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var body1;
            var body2;
            var body1Pushable;
            var body2Pushable;
            var body1MassImpact;
            var body2MassImpact;
            var body1FullImpact;
            var body2FullImpact;
            var body1MovingUp;
            var body1MovingDown;
            var body1Stationary;
            var body2MovingUp;
            var body2MovingDown;
            var body2Stationary;
            var body1OnTop;
            var body2OnTop;
            var overlap;
            var Set = function(b1, b2, ov) {
              body1 = b1;
              body2 = b2;
              var v1 = body1.velocity.y;
              var v2 = body2.velocity.y;
              body1Pushable = body1.pushable;
              body1MovingUp = body1._dy < 0;
              body1MovingDown = body1._dy > 0;
              body1Stationary = body1._dy === 0;
              body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y);
              body1FullImpact = v2 - v1 * body1.bounce.y;
              body2Pushable = body2.pushable;
              body2MovingUp = body2._dy < 0;
              body2MovingDown = body2._dy > 0;
              body2Stationary = body2._dy === 0;
              body2OnTop = !body1OnTop;
              body2FullImpact = v1 - v2 * body2.bounce.y;
              overlap = Math.abs(ov);
              return BlockCheck();
            };
            var BlockCheck = function() {
              if (body1MovingDown && body1OnTop && body2.blocked.down) {
                body1.processY(-overlap, body1FullImpact, false, true);
                return 1;
              }
              if (body1MovingUp && body2OnTop && body2.blocked.up) {
                body1.processY(overlap, body1FullImpact, true);
                return 1;
              }
              if (body2MovingDown && body2OnTop && body1.blocked.down) {
                body2.processY(-overlap, body2FullImpact, false, true);
                return 2;
              }
              if (body2MovingUp && body1OnTop && body1.blocked.up) {
                body2.processY(overlap, body2FullImpact, true);
                return 2;
              }
              return 0;
            };
            var Check = function() {
              var v1 = body1.velocity.y;
              var v2 = body2.velocity.y;
              var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
              var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
              var avg = (nv1 + nv2) * 0.5;
              nv1 -= avg;
              nv2 -= avg;
              body1MassImpact = avg + nv1 * body1.bounce.y;
              body2MassImpact = avg + nv2 * body2.bounce.y;
              if (body1MovingUp && body2OnTop) {
                return Run(0);
              }
              if (body2MovingUp && body1OnTop) {
                return Run(1);
              }
              if (body1MovingDown && body1OnTop) {
                return Run(2);
              }
              if (body2MovingDown && body2OnTop) {
                return Run(3);
              }
              return false;
            };
            var Run = function(side) {
              if (body1Pushable && body2Pushable) {
                overlap *= 0.5;
                if (side === 0 || side === 3) {
                  body1.processY(overlap, body1MassImpact);
                  body2.processY(-overlap, body2MassImpact);
                } else {
                  body1.processY(-overlap, body1MassImpact);
                  body2.processY(overlap, body2MassImpact);
                }
              } else if (body1Pushable && !body2Pushable) {
                if (side === 0 || side === 3) {
                  body1.processY(overlap, body1FullImpact, true);
                } else {
                  body1.processY(-overlap, body1FullImpact, false, true);
                }
              } else if (!body1Pushable && body2Pushable) {
                if (side === 0 || side === 3) {
                  body2.processY(-overlap, body2FullImpact, false, true);
                } else {
                  body2.processY(overlap, body2FullImpact, true);
                }
              } else {
                var halfOverlap = overlap * 0.5;
                if (side === 0) {
                  if (body2Stationary) {
                    body1.processY(overlap, 0, true);
                    body2.processY(0, null, false, true);
                  } else if (body2MovingDown) {
                    body1.processY(halfOverlap, 0, true);
                    body2.processY(-halfOverlap, 0, false, true);
                  } else {
                    body1.processY(halfOverlap, body2.velocity.y, true);
                    body2.processY(-halfOverlap, null, false, true);
                  }
                } else if (side === 1) {
                  if (body1Stationary) {
                    body1.processY(0, null, false, true);
                    body2.processY(overlap, 0, true);
                  } else if (body1MovingDown) {
                    body1.processY(-halfOverlap, 0, false, true);
                    body2.processY(halfOverlap, 0, true);
                  } else {
                    body1.processY(-halfOverlap, null, false, true);
                    body2.processY(halfOverlap, body1.velocity.y, true);
                  }
                } else if (side === 2) {
                  if (body2Stationary) {
                    body1.processY(-overlap, 0, false, true);
                    body2.processY(0, null, true);
                  } else if (body2MovingUp) {
                    body1.processY(-halfOverlap, 0, false, true);
                    body2.processY(halfOverlap, 0, true);
                  } else {
                    body1.processY(-halfOverlap, body2.velocity.y, false, true);
                    body2.processY(halfOverlap, null, true);
                  }
                } else if (side === 3) {
                  if (body1Stationary) {
                    body1.processY(0, null, true);
                    body2.processY(-overlap, 0, false, true);
                  } else if (body1MovingUp) {
                    body1.processY(halfOverlap, 0, true);
                    body2.processY(-halfOverlap, 0, false, true);
                  } else {
                    body1.processY(halfOverlap, body2.velocity.y, true);
                    body2.processY(-halfOverlap, null, false, true);
                  }
                }
              }
              return true;
            };
            var RunImmovableBody1 = function(blockedState) {
              if (blockedState === 1) {
                body2.velocity.y = 0;
              } else if (body1OnTop) {
                body2.processY(overlap, body2FullImpact, true);
              } else {
                body2.processY(-overlap, body2FullImpact, false, true);
              }
              if (body1.moves) {
                body2.x += (body1.x - body1.prev.x) * body1.friction.x;
                body2._dx = body2.x - body2.prev.x;
              }
            };
            var RunImmovableBody2 = function(blockedState) {
              if (blockedState === 2) {
                body1.velocity.y = 0;
              } else if (body2OnTop) {
                body1.processY(overlap, body1FullImpact, true);
              } else {
                body1.processY(-overlap, body1FullImpact, false, true);
              }
              if (body2.moves) {
                body1.x += (body2.x - body2.prev.x) * body2.friction.x;
                body1._dx = body1.x - body1.prev.x;
              }
            };
            module2.exports = {
              BlockCheck,
              Check,
              Set,
              Run,
              RunImmovableBody1,
              RunImmovableBody2
            };
          },
          61777: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetOverlapX = __webpack_require__2(75671);
            var ProcessX = __webpack_require__2(22916);
            var SeparateX = function(body1, body2, overlapOnly, bias, overlap) {
              if (overlap === void 0) {
                overlap = GetOverlapX(body1, body2, overlapOnly, bias);
              }
              var body1Immovable = body1.immovable;
              var body2Immovable = body2.immovable;
              if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateX || body2.customSeparateX) {
                return overlap !== 0 || body1.embedded && body2.embedded;
              }
              var blockedState = ProcessX.Set(body1, body2, overlap);
              if (!body1Immovable && !body2Immovable) {
                if (blockedState > 0) {
                  return true;
                }
                return ProcessX.Check();
              } else if (body1Immovable) {
                ProcessX.RunImmovableBody1(blockedState);
              } else if (body2Immovable) {
                ProcessX.RunImmovableBody2(blockedState);
              }
              return true;
            };
            module2.exports = SeparateX;
          },
          25299: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetOverlapY = __webpack_require__2(66185);
            var ProcessY = __webpack_require__2(67050);
            var SeparateY = function(body1, body2, overlapOnly, bias, overlap) {
              if (overlap === void 0) {
                overlap = GetOverlapY(body1, body2, overlapOnly, bias);
              }
              var body1Immovable = body1.immovable;
              var body2Immovable = body2.immovable;
              if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateY || body2.customSeparateY) {
                return overlap !== 0 || body1.embedded && body2.embedded;
              }
              var blockedState = ProcessY.Set(body1, body2, overlap);
              if (!body1Immovable && !body2Immovable) {
                if (blockedState > 0) {
                  return true;
                }
                return ProcessY.Check();
              } else if (body1Immovable) {
                ProcessY.RunImmovableBody1(blockedState);
              } else if (body2Immovable) {
                ProcessY.RunImmovableBody2(blockedState);
              }
              return true;
            };
            module2.exports = SeparateY;
          },
          15084: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetCollisionObject = function(noneFlip, data) {
              if (data === void 0) {
                data = {};
              }
              data.none = noneFlip;
              data.up = false;
              data.down = false;
              data.left = false;
              data.right = false;
              if (!noneFlip) {
                data.up = true;
                data.down = true;
                data.left = true;
                data.right = true;
              }
              return data;
            };
            module2.exports = SetCollisionObject;
          },
          66634: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CircleContains = __webpack_require__2(65650);
            var Class = __webpack_require__2(56694);
            var CollisionComponent = __webpack_require__2(95239);
            var CONST = __webpack_require__2(47401);
            var RectangleContains = __webpack_require__2(94287);
            var SetCollisionObject = __webpack_require__2(15084);
            var Vector2 = __webpack_require__2(93736);
            var StaticBody = new Class({
              Mixins: [
                CollisionComponent
              ],
              initialize: function StaticBody2(world, gameObject) {
                var width = 64;
                var height = 64;
                var dummyGameObject = {
                  x: 0,
                  y: 0,
                  angle: 0,
                  rotation: 0,
                  scaleX: 1,
                  scaleY: 1,
                  displayOriginX: 0,
                  displayOriginY: 0
                };
                var hasGameObject = gameObject !== void 0;
                if (hasGameObject && gameObject.displayWidth) {
                  width = gameObject.displayWidth;
                  height = gameObject.displayHeight;
                }
                if (!hasGameObject) {
                  gameObject = dummyGameObject;
                }
                this.world = world;
                this.gameObject = hasGameObject ? gameObject : void 0;
                this.isBody = true;
                this.debugShowBody = world.defaults.debugShowStaticBody;
                this.debugBodyColor = world.defaults.staticBodyDebugColor;
                this.enable = true;
                this.isCircle = false;
                this.radius = 0;
                this.offset = new Vector2();
                this.position = new Vector2(gameObject.x - width * gameObject.originX, gameObject.y - height * gameObject.originY);
                this.width = width;
                this.height = height;
                this.halfWidth = Math.abs(this.width / 2);
                this.halfHeight = Math.abs(this.height / 2);
                this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
                this.velocity = Vector2.ZERO;
                this.allowGravity = false;
                this.gravity = Vector2.ZERO;
                this.bounce = Vector2.ZERO;
                this.onWorldBounds = false;
                this.onCollide = false;
                this.onOverlap = false;
                this.mass = 1;
                this.immovable = true;
                this.pushable = false;
                this.customSeparateX = false;
                this.customSeparateY = false;
                this.overlapX = 0;
                this.overlapY = 0;
                this.overlapR = 0;
                this.embedded = false;
                this.collideWorldBounds = false;
                this.checkCollision = SetCollisionObject(false);
                this.touching = SetCollisionObject(true);
                this.wasTouching = SetCollisionObject(true);
                this.blocked = SetCollisionObject(true);
                this.physicsType = CONST.STATIC_BODY;
                this.collisionCategory = 1;
                this.collisionMask = 1;
                this._dx = 0;
                this._dy = 0;
              },
              setGameObject: function(gameObject, update) {
                if (gameObject && gameObject !== this.gameObject) {
                  this.gameObject.body = null;
                  gameObject.body = this;
                  this.gameObject = gameObject;
                }
                if (update) {
                  this.updateFromGameObject();
                }
                return this;
              },
              updateFromGameObject: function() {
                this.world.staticTree.remove(this);
                var gameObject = this.gameObject;
                gameObject.getTopLeft(this.position);
                this.width = gameObject.displayWidth;
                this.height = gameObject.displayHeight;
                this.halfWidth = Math.abs(this.width / 2);
                this.halfHeight = Math.abs(this.height / 2);
                this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
                this.world.staticTree.insert(this);
                return this;
              },
              setOffset: function(x, y) {
                if (y === void 0) {
                  y = x;
                }
                this.world.staticTree.remove(this);
                this.position.x -= this.offset.x;
                this.position.y -= this.offset.y;
                this.offset.set(x, y);
                this.position.x += this.offset.x;
                this.position.y += this.offset.y;
                this.updateCenter();
                this.world.staticTree.insert(this);
                return this;
              },
              setSize: function(width, height, center) {
                if (center === void 0) {
                  center = true;
                }
                var gameObject = this.gameObject;
                if (gameObject && gameObject.frame) {
                  if (!width) {
                    width = gameObject.frame.realWidth;
                  }
                  if (!height) {
                    height = gameObject.frame.realHeight;
                  }
                }
                this.world.staticTree.remove(this);
                this.width = width;
                this.height = height;
                this.halfWidth = Math.floor(width / 2);
                this.halfHeight = Math.floor(height / 2);
                if (center && gameObject && gameObject.getCenter) {
                  var ox = gameObject.displayWidth / 2;
                  var oy = gameObject.displayHeight / 2;
                  this.position.x -= this.offset.x;
                  this.position.y -= this.offset.y;
                  this.offset.set(ox - this.halfWidth, oy - this.halfHeight);
                  this.position.x += this.offset.x;
                  this.position.y += this.offset.y;
                }
                this.updateCenter();
                this.isCircle = false;
                this.radius = 0;
                this.world.staticTree.insert(this);
                return this;
              },
              setCircle: function(radius, offsetX, offsetY) {
                if (offsetX === void 0) {
                  offsetX = this.offset.x;
                }
                if (offsetY === void 0) {
                  offsetY = this.offset.y;
                }
                if (radius > 0) {
                  this.world.staticTree.remove(this);
                  this.isCircle = true;
                  this.radius = radius;
                  this.width = radius * 2;
                  this.height = radius * 2;
                  this.halfWidth = Math.floor(this.width / 2);
                  this.halfHeight = Math.floor(this.height / 2);
                  this.offset.set(offsetX, offsetY);
                  this.updateCenter();
                  this.world.staticTree.insert(this);
                } else {
                  this.isCircle = false;
                }
                return this;
              },
              updateCenter: function() {
                this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
              },
              reset: function(x, y) {
                var gameObject = this.gameObject;
                if (x === void 0) {
                  x = gameObject.x;
                }
                if (y === void 0) {
                  y = gameObject.y;
                }
                this.world.staticTree.remove(this);
                gameObject.setPosition(x, y);
                gameObject.getTopLeft(this.position);
                this.updateCenter();
                this.world.staticTree.insert(this);
              },
              stop: function() {
                return this;
              },
              getBounds: function(obj) {
                obj.x = this.x;
                obj.y = this.y;
                obj.right = this.right;
                obj.bottom = this.bottom;
                return obj;
              },
              hitTest: function(x, y) {
                return this.isCircle ? CircleContains(this, x, y) : RectangleContains(this, x, y);
              },
              postUpdate: function() {
              },
              deltaAbsX: function() {
                return 0;
              },
              deltaAbsY: function() {
                return 0;
              },
              deltaX: function() {
                return 0;
              },
              deltaY: function() {
                return 0;
              },
              deltaZ: function() {
                return 0;
              },
              destroy: function() {
                this.enable = false;
                this.world.pendingDestroy.set(this);
              },
              drawDebug: function(graphic) {
                var pos = this.position;
                var x = pos.x + this.halfWidth;
                var y = pos.y + this.halfHeight;
                if (this.debugShowBody) {
                  graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor, 1);
                  if (this.isCircle) {
                    graphic.strokeCircle(x, y, this.width / 2);
                  } else {
                    graphic.strokeRect(pos.x, pos.y, this.width, this.height);
                  }
                }
              },
              willDrawDebug: function() {
                return this.debugShowBody;
              },
              setMass: function(value) {
                if (value <= 0) {
                  value = 0.1;
                }
                this.mass = value;
                return this;
              },
              x: {
                get: function() {
                  return this.position.x;
                },
                set: function(value) {
                  this.world.staticTree.remove(this);
                  this.position.x = value;
                  this.world.staticTree.insert(this);
                }
              },
              y: {
                get: function() {
                  return this.position.y;
                },
                set: function(value) {
                  this.world.staticTree.remove(this);
                  this.position.y = value;
                  this.world.staticTree.insert(this);
                }
              },
              left: {
                get: function() {
                  return this.position.x;
                }
              },
              right: {
                get: function() {
                  return this.position.x + this.width;
                }
              },
              top: {
                get: function() {
                  return this.position.y;
                }
              },
              bottom: {
                get: function() {
                  return this.position.y + this.height;
                }
              }
            });
            module2.exports = StaticBody;
          },
          46346: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArcadeSprite = __webpack_require__2(25084);
            var Class = __webpack_require__2(56694);
            var CollisionComponent = __webpack_require__2(95239);
            var CONST = __webpack_require__2(47401);
            var GetFastValue = __webpack_require__2(72632);
            var Group = __webpack_require__2(59192);
            var IsPlainObject = __webpack_require__2(42911);
            var StaticPhysicsGroup = new Class({
              Extends: Group,
              Mixins: [
                CollisionComponent
              ],
              initialize: function StaticPhysicsGroup2(world, scene, children, config2) {
                if (!children && !config2) {
                  config2 = {
                    internalCreateCallback: this.createCallbackHandler,
                    internalRemoveCallback: this.removeCallbackHandler,
                    createMultipleCallback: this.createMultipleCallbackHandler,
                    classType: ArcadeSprite
                  };
                } else if (IsPlainObject(children)) {
                  config2 = children;
                  children = null;
                  config2.internalCreateCallback = this.createCallbackHandler;
                  config2.internalRemoveCallback = this.removeCallbackHandler;
                  config2.createMultipleCallback = this.createMultipleCallbackHandler;
                  config2.classType = GetFastValue(config2, "classType", ArcadeSprite);
                } else if (Array.isArray(children) && IsPlainObject(children[0])) {
                  config2 = children;
                  children = null;
                  config2.forEach(function(singleConfig) {
                    singleConfig.internalCreateCallback = this.createCallbackHandler;
                    singleConfig.internalRemoveCallback = this.removeCallbackHandler;
                    singleConfig.createMultipleCallback = this.createMultipleCallbackHandler;
                    singleConfig.classType = GetFastValue(singleConfig, "classType", ArcadeSprite);
                  });
                } else {
                  config2 = {
                    internalCreateCallback: this.createCallbackHandler,
                    internalRemoveCallback: this.removeCallbackHandler
                  };
                }
                this.world = world;
                this.physicsType = CONST.STATIC_BODY;
                this.collisionCategory = 1;
                this.collisionMask = 1;
                Group.call(this, scene, children, config2);
                this.type = "StaticPhysicsGroup";
              },
              createCallbackHandler: function(child) {
                if (!child.body) {
                  this.world.enableBody(child, CONST.STATIC_BODY);
                }
              },
              removeCallbackHandler: function(child) {
                if (child.body) {
                  this.world.disableBody(child);
                }
              },
              createMultipleCallbackHandler: function() {
                this.refresh();
              },
              refresh: function() {
                var children = this.children.entries;
                for (var i = 0; i < children.length; i++) {
                  children[i].body.reset();
                }
                return this;
              }
            });
            module2.exports = StaticPhysicsGroup;
          },
          85233: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AngleBetweenPoints = __webpack_require__2(94240);
            var Body = __webpack_require__2(97602);
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Collider = __webpack_require__2(3909);
            var CONST = __webpack_require__2(47401);
            var DistanceBetween = __webpack_require__2(53996);
            var DistanceBetweenPoints = __webpack_require__2(92951);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(27037);
            var FuzzyEqual = __webpack_require__2(88456);
            var FuzzyGreaterThan = __webpack_require__2(41935);
            var FuzzyLessThan = __webpack_require__2(54726);
            var GetOverlapX = __webpack_require__2(75671);
            var GetOverlapY = __webpack_require__2(66185);
            var GetTilesWithinWorldXY = __webpack_require__2(44662);
            var GetValue = __webpack_require__2(10850);
            var MATH_CONST = __webpack_require__2(83392);
            var ProcessQueue = __webpack_require__2(74623);
            var ProcessTileCallbacks = __webpack_require__2(25163);
            var Rectangle = __webpack_require__2(74118);
            var RTree = __webpack_require__2(68687);
            var SeparateTile = __webpack_require__2(27354);
            var SeparateX = __webpack_require__2(61777);
            var SeparateY = __webpack_require__2(25299);
            var Set = __webpack_require__2(58403);
            var StaticBody = __webpack_require__2(66634);
            var TileIntersectsBody = __webpack_require__2(28808);
            var TransformMatrix = __webpack_require__2(69360);
            var Vector2 = __webpack_require__2(93736);
            var Wrap = __webpack_require__2(1071);
            var World = new Class({
              Extends: EventEmitter,
              initialize: function World2(scene, config2) {
                EventEmitter.call(this);
                this.scene = scene;
                this.bodies = new Set();
                this.staticBodies = new Set();
                this.pendingDestroy = new Set();
                this.colliders = new ProcessQueue();
                this.gravity = new Vector2(GetValue(config2, "gravity.x", 0), GetValue(config2, "gravity.y", 0));
                this.bounds = new Rectangle(GetValue(config2, "x", 0), GetValue(config2, "y", 0), GetValue(config2, "width", scene.sys.scale.width), GetValue(config2, "height", scene.sys.scale.height));
                this.checkCollision = {
                  up: GetValue(config2, "checkCollision.up", true),
                  down: GetValue(config2, "checkCollision.down", true),
                  left: GetValue(config2, "checkCollision.left", true),
                  right: GetValue(config2, "checkCollision.right", true)
                };
                this.fps = GetValue(config2, "fps", 60);
                this.fixedStep = GetValue(config2, "fixedStep", true);
                this._elapsed = 0;
                this._frameTime = 1 / this.fps;
                this._frameTimeMS = 1e3 * this._frameTime;
                this.stepsLastFrame = 0;
                this.timeScale = GetValue(config2, "timeScale", 1);
                this.OVERLAP_BIAS = GetValue(config2, "overlapBias", 4);
                this.TILE_BIAS = GetValue(config2, "tileBias", 16);
                this.forceX = GetValue(config2, "forceX", false);
                this.isPaused = GetValue(config2, "isPaused", false);
                this._total = 0;
                this.drawDebug = GetValue(config2, "debug", false);
                this.debugGraphic;
                this.defaults = {
                  debugShowBody: GetValue(config2, "debugShowBody", true),
                  debugShowStaticBody: GetValue(config2, "debugShowStaticBody", true),
                  debugShowVelocity: GetValue(config2, "debugShowVelocity", true),
                  bodyDebugColor: GetValue(config2, "debugBodyColor", 16711935),
                  staticBodyDebugColor: GetValue(config2, "debugStaticBodyColor", 255),
                  velocityDebugColor: GetValue(config2, "debugVelocityColor", 65280)
                };
                this.maxEntries = GetValue(config2, "maxEntries", 16);
                this.useTree = GetValue(config2, "useTree", true);
                this.tree = new RTree(this.maxEntries);
                this.staticTree = new RTree(this.maxEntries);
                this.treeMinMax = {minX: 0, minY: 0, maxX: 0, maxY: 0};
                this._tempMatrix = new TransformMatrix();
                this._tempMatrix2 = new TransformMatrix();
                this.tileFilterOptions = {isColliding: true, isNotEmpty: true, hasInterestingFace: true};
                if (this.drawDebug) {
                  this.createDebugGraphic();
                }
              },
              enable: function(object, bodyType) {
                if (bodyType === void 0) {
                  bodyType = CONST.DYNAMIC_BODY;
                }
                if (!Array.isArray(object)) {
                  object = [object];
                }
                for (var i = 0; i < object.length; i++) {
                  var entry = object[i];
                  if (entry.isParent) {
                    var children = entry.getChildren();
                    for (var c = 0; c < children.length; c++) {
                      var child = children[c];
                      if (child.isParent) {
                        this.enable(child, bodyType);
                      } else {
                        this.enableBody(child, bodyType);
                      }
                    }
                  } else {
                    this.enableBody(entry, bodyType);
                  }
                }
              },
              enableBody: function(object, bodyType) {
                if (bodyType === void 0) {
                  bodyType = CONST.DYNAMIC_BODY;
                }
                if (object.hasTransformComponent) {
                  if (!object.body) {
                    if (bodyType === CONST.DYNAMIC_BODY) {
                      object.body = new Body(this, object);
                    } else if (bodyType === CONST.STATIC_BODY) {
                      object.body = new StaticBody(this, object);
                    }
                  }
                  this.add(object.body);
                }
                return object;
              },
              add: function(body) {
                if (body.physicsType === CONST.DYNAMIC_BODY) {
                  this.bodies.set(body);
                } else if (body.physicsType === CONST.STATIC_BODY) {
                  this.staticBodies.set(body);
                  this.staticTree.insert(body);
                }
                body.enable = true;
                return body;
              },
              disable: function(object) {
                if (!Array.isArray(object)) {
                  object = [object];
                }
                for (var i = 0; i < object.length; i++) {
                  var entry = object[i];
                  if (entry.isParent) {
                    var children = entry.getChildren();
                    for (var c = 0; c < children.length; c++) {
                      var child = children[c];
                      if (child.isParent) {
                        this.disable(child);
                      } else {
                        this.disableBody(child.body);
                      }
                    }
                  } else {
                    this.disableBody(entry.body);
                  }
                }
              },
              disableBody: function(body) {
                this.remove(body);
                body.enable = false;
              },
              remove: function(body) {
                if (body.physicsType === CONST.DYNAMIC_BODY) {
                  this.tree.remove(body);
                  this.bodies.delete(body);
                } else if (body.physicsType === CONST.STATIC_BODY) {
                  this.staticBodies.delete(body);
                  this.staticTree.remove(body);
                }
              },
              createDebugGraphic: function() {
                var graphic = this.scene.sys.add.graphics({x: 0, y: 0});
                graphic.setDepth(Number.MAX_VALUE);
                this.debugGraphic = graphic;
                this.drawDebug = true;
                return graphic;
              },
              setBounds: function(x, y, width, height, checkLeft, checkRight, checkUp, checkDown) {
                this.bounds.setTo(x, y, width, height);
                if (checkLeft !== void 0) {
                  this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);
                }
                return this;
              },
              setBoundsCollision: function(left, right, up, down) {
                if (left === void 0) {
                  left = true;
                }
                if (right === void 0) {
                  right = true;
                }
                if (up === void 0) {
                  up = true;
                }
                if (down === void 0) {
                  down = true;
                }
                this.checkCollision.left = left;
                this.checkCollision.right = right;
                this.checkCollision.up = up;
                this.checkCollision.down = down;
                return this;
              },
              pause: function() {
                this.isPaused = true;
                this.emit(Events.PAUSE);
                return this;
              },
              resume: function() {
                this.isPaused = false;
                this.emit(Events.RESUME);
                return this;
              },
              addCollider: function(object1, object2, collideCallback, processCallback, callbackContext) {
                if (collideCallback === void 0) {
                  collideCallback = null;
                }
                if (processCallback === void 0) {
                  processCallback = null;
                }
                if (callbackContext === void 0) {
                  callbackContext = collideCallback;
                }
                var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);
                this.colliders.add(collider);
                return collider;
              },
              addOverlap: function(object1, object2, collideCallback, processCallback, callbackContext) {
                if (collideCallback === void 0) {
                  collideCallback = null;
                }
                if (processCallback === void 0) {
                  processCallback = null;
                }
                if (callbackContext === void 0) {
                  callbackContext = collideCallback;
                }
                var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);
                this.colliders.add(collider);
                return collider;
              },
              removeCollider: function(collider) {
                this.colliders.remove(collider);
                return this;
              },
              setFPS: function(framerate) {
                this.fps = framerate;
                this._frameTime = 1 / this.fps;
                this._frameTimeMS = 1e3 * this._frameTime;
                return this;
              },
              update: function(time, delta) {
                if (this.isPaused || this.bodies.size === 0) {
                  return;
                }
                var i;
                var fixedDelta = this._frameTime;
                var msPerFrame = this._frameTimeMS * this.timeScale;
                this._elapsed += delta;
                var body;
                var bodies = this.bodies.entries;
                var willStep = this._elapsed >= msPerFrame;
                if (!this.fixedStep) {
                  fixedDelta = delta * 1e-3;
                  willStep = true;
                  this._elapsed = 0;
                }
                for (i = 0; i < bodies.length; i++) {
                  body = bodies[i];
                  if (body.enable) {
                    body.preUpdate(willStep, fixedDelta);
                  }
                }
                if (willStep) {
                  this._elapsed -= msPerFrame;
                  this.stepsLastFrame = 1;
                  if (this.useTree) {
                    this.tree.clear();
                    this.tree.load(bodies);
                  }
                  var colliders = this.colliders.update();
                  for (i = 0; i < colliders.length; i++) {
                    var collider = colliders[i];
                    if (collider.active) {
                      collider.update();
                    }
                  }
                  this.emit(Events.WORLD_STEP, fixedDelta);
                }
                while (this._elapsed >= msPerFrame) {
                  this._elapsed -= msPerFrame;
                  this.step(fixedDelta);
                }
              },
              step: function(delta) {
                var i;
                var body;
                var bodies = this.bodies.entries;
                var len = bodies.length;
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.enable) {
                    body.update(delta);
                  }
                }
                if (this.useTree) {
                  this.tree.clear();
                  this.tree.load(bodies);
                }
                var colliders = this.colliders.update();
                for (i = 0; i < colliders.length; i++) {
                  var collider = colliders[i];
                  if (collider.active) {
                    collider.update();
                  }
                }
                this.emit(Events.WORLD_STEP, delta);
                this.stepsLastFrame++;
              },
              singleStep: function() {
                this.update(0, this._frameTimeMS);
                this.postUpdate();
              },
              postUpdate: function() {
                var i;
                var body;
                var bodies = this.bodies.entries;
                var len = bodies.length;
                var dynamic = this.bodies;
                var staticBodies = this.staticBodies;
                if (this.stepsLastFrame) {
                  this.stepsLastFrame = 0;
                  for (i = 0; i < len; i++) {
                    body = bodies[i];
                    if (body.enable) {
                      body.postUpdate();
                    }
                  }
                }
                if (this.drawDebug) {
                  var graphics = this.debugGraphic;
                  graphics.clear();
                  for (i = 0; i < len; i++) {
                    body = bodies[i];
                    if (body.willDrawDebug()) {
                      body.drawDebug(graphics);
                    }
                  }
                  bodies = staticBodies.entries;
                  len = bodies.length;
                  for (i = 0; i < len; i++) {
                    body = bodies[i];
                    if (body.willDrawDebug()) {
                      body.drawDebug(graphics);
                    }
                  }
                }
                var pending = this.pendingDestroy;
                if (pending.size > 0) {
                  var dynamicTree = this.tree;
                  var staticTree = this.staticTree;
                  bodies = pending.entries;
                  len = bodies.length;
                  for (i = 0; i < len; i++) {
                    body = bodies[i];
                    if (body.physicsType === CONST.DYNAMIC_BODY) {
                      dynamicTree.remove(body);
                      dynamic.delete(body);
                    } else if (body.physicsType === CONST.STATIC_BODY) {
                      staticTree.remove(body);
                      staticBodies.delete(body);
                    }
                    body.world = void 0;
                    body.gameObject = void 0;
                  }
                  pending.clear();
                }
              },
              updateMotion: function(body, delta) {
                if (body.allowRotation) {
                  this.computeAngularVelocity(body, delta);
                }
                this.computeVelocity(body, delta);
              },
              computeAngularVelocity: function(body, delta) {
                var velocity = body.angularVelocity;
                var acceleration = body.angularAcceleration;
                var drag = body.angularDrag;
                var max = body.maxAngular;
                if (acceleration) {
                  velocity += acceleration * delta;
                } else if (body.allowDrag && drag) {
                  drag *= delta;
                  if (FuzzyGreaterThan(velocity - drag, 0, 0.1)) {
                    velocity -= drag;
                  } else if (FuzzyLessThan(velocity + drag, 0, 0.1)) {
                    velocity += drag;
                  } else {
                    velocity = 0;
                  }
                }
                velocity = Clamp(velocity, -max, max);
                var velocityDelta = velocity - body.angularVelocity;
                body.angularVelocity += velocityDelta;
                body.rotation += body.angularVelocity * delta;
              },
              computeVelocity: function(body, delta) {
                var velocityX = body.velocity.x;
                var accelerationX = body.acceleration.x;
                var dragX = body.drag.x;
                var maxX = body.maxVelocity.x;
                var velocityY = body.velocity.y;
                var accelerationY = body.acceleration.y;
                var dragY = body.drag.y;
                var maxY = body.maxVelocity.y;
                var speed = body.speed;
                var maxSpeed = body.maxSpeed;
                var allowDrag = body.allowDrag;
                var useDamping = body.useDamping;
                if (body.allowGravity) {
                  velocityX += (this.gravity.x + body.gravity.x) * delta;
                  velocityY += (this.gravity.y + body.gravity.y) * delta;
                }
                if (accelerationX) {
                  velocityX += accelerationX * delta;
                } else if (allowDrag && dragX) {
                  if (useDamping) {
                    dragX = Math.pow(dragX, delta);
                    velocityX *= dragX;
                    speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                    if (FuzzyEqual(speed, 0, 1e-3)) {
                      velocityX = 0;
                    }
                  } else {
                    dragX *= delta;
                    if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01)) {
                      velocityX -= dragX;
                    } else if (FuzzyLessThan(velocityX + dragX, 0, 0.01)) {
                      velocityX += dragX;
                    } else {
                      velocityX = 0;
                    }
                  }
                }
                if (accelerationY) {
                  velocityY += accelerationY * delta;
                } else if (allowDrag && dragY) {
                  if (useDamping) {
                    dragY = Math.pow(dragY, delta);
                    velocityY *= dragY;
                    speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                    if (FuzzyEqual(speed, 0, 1e-3)) {
                      velocityY = 0;
                    }
                  } else {
                    dragY *= delta;
                    if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01)) {
                      velocityY -= dragY;
                    } else if (FuzzyLessThan(velocityY + dragY, 0, 0.01)) {
                      velocityY += dragY;
                    } else {
                      velocityY = 0;
                    }
                  }
                }
                velocityX = Clamp(velocityX, -maxX, maxX);
                velocityY = Clamp(velocityY, -maxY, maxY);
                body.velocity.set(velocityX, velocityY);
                if (maxSpeed > -1 && body.velocity.length() > maxSpeed) {
                  body.velocity.normalize().scale(maxSpeed);
                  speed = maxSpeed;
                }
                body.speed = speed;
              },
              separate: function(body1, body2, processCallback, callbackContext, overlapOnly) {
                var overlapX;
                var overlapY;
                var result = false;
                var runSeparation = true;
                if (!body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) {
                  return result;
                }
                if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false) {
                  return result;
                }
                if (body1.isCircle || body2.isCircle) {
                  var circleResults = this.separateCircle(body1, body2, overlapOnly);
                  if (circleResults.result) {
                    result = true;
                    runSeparation = false;
                  } else {
                    overlapX = circleResults.x;
                    overlapY = circleResults.y;
                    runSeparation = true;
                  }
                }
                if (runSeparation) {
                  var resultX = false;
                  var resultY = false;
                  var bias = this.OVERLAP_BIAS;
                  if (overlapOnly) {
                    resultX = SeparateX(body1, body2, overlapOnly, bias, overlapX);
                    resultY = SeparateY(body1, body2, overlapOnly, bias, overlapY);
                  } else if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {
                    resultX = SeparateX(body1, body2, overlapOnly, bias, overlapX);
                    if (this.intersects(body1, body2)) {
                      resultY = SeparateY(body1, body2, overlapOnly, bias, overlapY);
                    }
                  } else {
                    resultY = SeparateY(body1, body2, overlapOnly, bias, overlapY);
                    if (this.intersects(body1, body2)) {
                      resultX = SeparateX(body1, body2, overlapOnly, bias, overlapX);
                    }
                  }
                  result = resultX || resultY;
                }
                if (result) {
                  if (overlapOnly) {
                    if (body1.onOverlap || body2.onOverlap) {
                      this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
                    }
                  } else if (body1.onCollide || body2.onCollide) {
                    this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
                  }
                }
                return result;
              },
              separateCircle: function(body1, body2, overlapOnly) {
                GetOverlapX(body1, body2, false, 0);
                GetOverlapY(body1, body2, false, 0);
                var body1IsCircle = body1.isCircle;
                var body2IsCircle = body2.isCircle;
                var body1Center = body1.center;
                var body2Center = body2.center;
                var body1Immovable = body1.immovable;
                var body2Immovable = body2.immovable;
                var body1Velocity = body1.velocity;
                var body2Velocity = body2.velocity;
                var overlap = 0;
                var twoCircles = true;
                if (body1IsCircle !== body2IsCircle) {
                  twoCircles = false;
                  var circleX = body1Center.x;
                  var circleY = body1Center.y;
                  var circleRadius = body1.halfWidth;
                  var rectX = body2.position.x;
                  var rectY = body2.position.y;
                  var rectRight = body2.right;
                  var rectBottom = body2.bottom;
                  if (body2IsCircle) {
                    circleX = body2Center.x;
                    circleY = body2Center.y;
                    circleRadius = body2.halfWidth;
                    rectX = body1.position.x;
                    rectY = body1.position.y;
                    rectRight = body1.right;
                    rectBottom = body1.bottom;
                  }
                  if (circleY < rectY) {
                    if (circleX < rectX) {
                      overlap = DistanceBetween(circleX, circleY, rectX, rectY) - circleRadius;
                    } else if (circleX > rectRight) {
                      overlap = DistanceBetween(circleX, circleY, rectRight, rectY) - circleRadius;
                    }
                  } else if (circleY > rectBottom) {
                    if (circleX < rectX) {
                      overlap = DistanceBetween(circleX, circleY, rectX, rectBottom) - circleRadius;
                    } else if (circleX > rectRight) {
                      overlap = DistanceBetween(circleX, circleY, rectRight, rectBottom) - circleRadius;
                    }
                  }
                  overlap *= -1;
                } else {
                  overlap = body1.halfWidth + body2.halfWidth - DistanceBetweenPoints(body1Center, body2Center);
                }
                body1.overlapR = overlap;
                body2.overlapR = overlap;
                var angle = AngleBetweenPoints(body1Center, body2Center);
                var overlapX = (overlap + MATH_CONST.EPSILON) * Math.cos(angle);
                var overlapY = (overlap + MATH_CONST.EPSILON) * Math.sin(angle);
                var results = {overlap, result: false, x: overlapX, y: overlapY};
                if (overlapOnly && (!twoCircles || twoCircles && overlap !== 0)) {
                  results.result = true;
                  return results;
                }
                if (!twoCircles && overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateX || body2.customSeparateX) {
                  results.x = void 0;
                  results.y = void 0;
                  return results;
                }
                var deadlock = !body1.pushable && !body2.pushable;
                if (twoCircles) {
                  var dx = body1Center.x - body2Center.x;
                  var dy = body1Center.y - body2Center.y;
                  var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                  var nx = (body2Center.x - body1Center.x) / d || 0;
                  var ny = (body2Center.y - body1Center.y) / d || 0;
                  var p = 2 * (body1Velocity.x * nx + body1Velocity.y * ny - body2Velocity.x * nx - body2Velocity.y * ny) / (body1.mass + body2.mass);
                  if (body1Immovable || body2Immovable) {
                    p *= 2;
                  }
                  if (!body1Immovable) {
                    body1Velocity.x = body1Velocity.x - p / body1.mass * nx;
                    body1Velocity.y = body1Velocity.y - p / body1.mass * ny;
                    body1Velocity.multiply(body1.bounce);
                  }
                  if (!body2Immovable) {
                    body2Velocity.x = body2Velocity.x + p / body2.mass * nx;
                    body2Velocity.y = body2Velocity.y + p / body2.mass * ny;
                    body2Velocity.multiply(body2.bounce);
                  }
                  if (!body1Immovable && !body2Immovable) {
                    overlapX *= 0.5;
                    overlapY *= 0.5;
                  }
                  if (!body1Immovable) {
                    body1.x -= overlapX;
                    body1.y -= overlapY;
                    body1.updateCenter();
                  }
                  if (!body2Immovable) {
                    body2.x += overlapX;
                    body2.y += overlapY;
                    body2.updateCenter();
                  }
                  results.result = true;
                } else {
                  if (!body1Immovable || body1.pushable || deadlock) {
                    body1.x -= overlapX;
                    body1.y -= overlapY;
                    body1.updateCenter();
                  } else if (!body2Immovable || body2.pushable || deadlock) {
                    body2.x += overlapX;
                    body2.y += overlapY;
                    body2.updateCenter();
                  }
                  results.x = void 0;
                  results.y = void 0;
                }
                return results;
              },
              intersects: function(body1, body2) {
                if (body1 === body2) {
                  return false;
                }
                if (!body1.isCircle && !body2.isCircle) {
                  return !(body1.right <= body2.left || body1.bottom <= body2.top || body1.left >= body2.right || body1.top >= body2.bottom);
                } else if (body1.isCircle) {
                  if (body2.isCircle) {
                    return DistanceBetweenPoints(body1.center, body2.center) <= body1.halfWidth + body2.halfWidth;
                  } else {
                    return this.circleBodyIntersects(body1, body2);
                  }
                } else {
                  return this.circleBodyIntersects(body2, body1);
                }
              },
              circleBodyIntersects: function(circle, body) {
                var x = Clamp(circle.center.x, body.left, body.right);
                var y = Clamp(circle.center.y, body.top, body.bottom);
                var dx = (circle.center.x - x) * (circle.center.x - x);
                var dy = (circle.center.y - y) * (circle.center.y - y);
                return dx + dy <= circle.halfWidth * circle.halfWidth;
              },
              overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
                if (overlapCallback === void 0) {
                  overlapCallback = null;
                }
                if (processCallback === void 0) {
                  processCallback = null;
                }
                if (callbackContext === void 0) {
                  callbackContext = overlapCallback;
                }
                return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
              },
              collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
                if (collideCallback === void 0) {
                  collideCallback = null;
                }
                if (processCallback === void 0) {
                  processCallback = null;
                }
                if (callbackContext === void 0) {
                  callbackContext = collideCallback;
                }
                return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
              },
              collideObjects: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
                var i;
                var j;
                if (object1.isParent && (object1.physicsType === void 0 || object2 === void 0 || object1 === object2)) {
                  object1 = object1.children.entries;
                }
                if (object2 && object2.isParent && object2.physicsType === void 0) {
                  object2 = object2.children.entries;
                }
                var object1isArray = Array.isArray(object1);
                var object2isArray = Array.isArray(object2);
                this._total = 0;
                if (!object1isArray && !object2isArray) {
                  this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (!object1isArray && object2isArray) {
                  for (i = 0; i < object2.length; i++) {
                    this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                } else if (object1isArray && !object2isArray) {
                  if (!object2) {
                    for (i = 0; i < object1.length; i++) {
                      var child = object1[i];
                      for (j = i + 1; j < object1.length; j++) {
                        if (i === j) {
                          continue;
                        }
                        this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);
                      }
                    }
                  } else {
                    for (i = 0; i < object1.length; i++) {
                      this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                  }
                } else {
                  for (i = 0; i < object1.length; i++) {
                    for (j = 0; j < object2.length; j++) {
                      this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                  }
                }
                return this._total > 0;
              },
              collideHandler: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
                if (object2 === void 0 && object1.isParent) {
                  return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                }
                if (!object1 || !object2) {
                  return false;
                }
                if (object1.body || object1.isBody) {
                  if (object2.body || object2.isBody) {
                    return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                  } else if (object2.isParent) {
                    return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                  } else if (object2.isTilemap) {
                    return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                } else if (object1.isParent) {
                  if (object2.body || object2.isBody) {
                    return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                  } else if (object2.isParent) {
                    return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                  } else if (object2.isTilemap) {
                    return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                } else if (object1.isTilemap) {
                  if (object2.body || object2.isBody) {
                    return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                  } else if (object2.isParent) {
                    return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                }
              },
              canCollide: function(body1, body2) {
                return body1 && body2 && (body1.collisionMask & body2.collisionCategory) !== 0 && (body2.collisionMask & body1.collisionCategory) !== 0;
              },
              collideSpriteVsSprite: function(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
                var body1 = sprite1.isBody ? sprite1 : sprite1.body;
                var body2 = sprite2.isBody ? sprite2 : sprite2.body;
                if (!this.canCollide(body1, body2)) {
                  return false;
                }
                if (this.separate(body1, body2, processCallback, callbackContext, overlapOnly)) {
                  if (collideCallback) {
                    collideCallback.call(callbackContext, sprite1, sprite2);
                  }
                  this._total++;
                }
                return true;
              },
              collideSpriteVsGroup: function(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
                var bodyA = sprite.isBody ? sprite : sprite.body;
                if (group.length === 0 || !bodyA || !bodyA.enable || bodyA.checkCollision.none || !this.canCollide(bodyA, group)) {
                  return;
                }
                var i;
                var len;
                var bodyB;
                if (this.useTree || group.physicsType === CONST.STATIC_BODY) {
                  var minMax = this.treeMinMax;
                  minMax.minX = bodyA.left;
                  minMax.minY = bodyA.top;
                  minMax.maxX = bodyA.right;
                  minMax.maxY = bodyA.bottom;
                  var results = group.physicsType === CONST.DYNAMIC_BODY ? this.tree.search(minMax) : this.staticTree.search(minMax);
                  len = results.length;
                  for (i = 0; i < len; i++) {
                    bodyB = results[i];
                    if (bodyA === bodyB || !bodyB.enable || bodyB.checkCollision.none || !group.contains(bodyB.gameObject)) {
                      continue;
                    }
                    if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {
                      if (collideCallback) {
                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
                      }
                      this._total++;
                    }
                  }
                } else {
                  var children = group.getChildren();
                  var skipIndex = group.children.entries.indexOf(sprite);
                  len = children.length;
                  for (i = 0; i < len; i++) {
                    bodyB = children[i].body;
                    if (!bodyB || i === skipIndex || !bodyB.enable) {
                      continue;
                    }
                    if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {
                      if (collideCallback) {
                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
                      }
                      this._total++;
                    }
                  }
                }
              },
              collideGroupVsTilemapLayer: function(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
                if (!this.canCollide(group, tilemapLayer)) {
                  return false;
                }
                var children = group.getChildren();
                if (children.length === 0) {
                  return false;
                }
                var didCollide = false;
                for (var i = 0; i < children.length; i++) {
                  if (children[i].body || children[i].isBody) {
                    if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)) {
                      didCollide = true;
                    }
                  }
                }
                return didCollide;
              },
              collideTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
                if (tiles.length === 0 || sprite.body && !sprite.body.enable || sprite.isBody && !sprite.enable) {
                  return false;
                } else {
                  return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);
                }
              },
              overlapTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
                if (tiles.length === 0 || sprite.body && !sprite.body.enable || sprite.isBody && !sprite.enable) {
                  return false;
                } else {
                  return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, true, false);
                }
              },
              collideSpriteVsTilemapLayer: function(sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
                var body = sprite.isBody ? sprite : sprite.body;
                if (!body.enable || body.checkCollision.none || !this.canCollide(body, tilemapLayer)) {
                  return false;
                }
                var x = body.x;
                var y = body.y;
                var w = body.width;
                var h = body.height;
                var layerData = tilemapLayer.layer;
                if (layerData.tileWidth > layerData.baseTileWidth) {
                  var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;
                  x -= xDiff;
                  w += xDiff;
                }
                if (layerData.tileHeight > layerData.baseTileHeight) {
                  var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;
                  h += yDiff;
                }
                var options = overlapOnly ? null : this.tileFilterOptions;
                var mapData = GetTilesWithinWorldXY(x, y, w, h, options, tilemapLayer.scene.cameras.main, tilemapLayer.layer);
                if (mapData.length === 0) {
                  return false;
                } else {
                  return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);
                }
              },
              collideSpriteVsTilesHandler: function(sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer) {
                var body = sprite.isBody ? sprite : sprite.body;
                var tile;
                var tileWorldRect = {left: 0, right: 0, top: 0, bottom: 0};
                var tilemapLayer;
                var collision = false;
                for (var i = 0; i < tiles.length; i++) {
                  tile = tiles[i];
                  tilemapLayer = tile.tilemapLayer;
                  var point = tilemapLayer.tileToWorldXY(tile.x, tile.y);
                  tileWorldRect.left = point.x;
                  tileWorldRect.top = point.y;
                  if (tile.baseHeight !== tile.height) {
                    tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;
                  }
                  tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;
                  tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;
                  if (TileIntersectsBody(tileWorldRect, body) && (!processCallback || processCallback.call(callbackContext, sprite, tile)) && ProcessTileCallbacks(tile, sprite) && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer))) {
                    this._total++;
                    collision = true;
                    if (collideCallback) {
                      collideCallback.call(callbackContext, sprite, tile);
                    }
                    if (overlapOnly && body.onOverlap) {
                      this.emit(Events.TILE_OVERLAP, sprite, tile, body);
                    } else if (body.onCollide) {
                      this.emit(Events.TILE_COLLIDE, sprite, tile, body);
                    }
                  }
                }
                return collision;
              },
              collideGroupVsGroup: function(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
                if (group1.length === 0 || group2.length === 0 || !this.canCollide(group1, group2)) {
                  return;
                }
                var children = group1.getChildren();
                for (var i = 0; i < children.length; i++) {
                  this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
              },
              wrap: function(object, padding) {
                if (object.body) {
                  this.wrapObject(object, padding);
                } else if (object.getChildren) {
                  this.wrapArray(object.getChildren(), padding);
                } else if (Array.isArray(object)) {
                  this.wrapArray(object, padding);
                } else {
                  this.wrapObject(object, padding);
                }
              },
              wrapArray: function(objects, padding) {
                for (var i = 0; i < objects.length; i++) {
                  this.wrapObject(objects[i], padding);
                }
              },
              wrapObject: function(object, padding) {
                if (padding === void 0) {
                  padding = 0;
                }
                object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);
                object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);
              },
              shutdown: function() {
                this.tree.clear();
                this.staticTree.clear();
                this.bodies.clear();
                this.staticBodies.clear();
                this.colliders.destroy();
                this.removeAllListeners();
              },
              destroy: function() {
                this.shutdown();
                this.scene = null;
                if (this.debugGraphic) {
                  this.debugGraphic.destroy();
                  this.debugGraphic = null;
                }
              }
            });
            module2.exports = World;
          },
          5321: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Acceleration = {
              setAcceleration: function(x, y) {
                this.body.acceleration.set(x, y);
                return this;
              },
              setAccelerationX: function(value) {
                this.body.acceleration.x = value;
                return this;
              },
              setAccelerationY: function(value) {
                this.body.acceleration.y = value;
                return this;
              }
            };
            module2.exports = Acceleration;
          },
          29257: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Angular = {
              setAngularVelocity: function(value) {
                this.body.angularVelocity = value;
                return this;
              },
              setAngularAcceleration: function(value) {
                this.body.angularAcceleration = value;
                return this;
              },
              setAngularDrag: function(value) {
                this.body.angularDrag = value;
                return this;
              }
            };
            module2.exports = Angular;
          },
          62122: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bounce = {
              setBounce: function(x, y) {
                this.body.bounce.set(x, y);
                return this;
              },
              setBounceX: function(value) {
                this.body.bounce.x = value;
                return this;
              },
              setBounceY: function(value) {
                this.body.bounce.y = value;
                return this;
              },
              setCollideWorldBounds: function(value, bounceX, bounceY, onWorldBounds) {
                this.body.setCollideWorldBounds(value, bounceX, bounceY, onWorldBounds);
                return this;
              }
            };
            module2.exports = Bounce;
          },
          95239: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCollidesWith = __webpack_require__2(44880);
            var Collision = {
              setCollisionCategory: function(category) {
                var target = this.body ? this.body : this;
                target.collisionCategory = category;
                return this;
              },
              willCollideWith: function(category) {
                var target = this.body ? this.body : this;
                return (target.collisionMask & category) !== 0;
              },
              addCollidesWith: function(category) {
                var target = this.body ? this.body : this;
                target.collisionMask = target.collisionMask | category;
                return this;
              },
              removeCollidesWith: function(category) {
                var target = this.body ? this.body : this;
                target.collisionMask = target.collisionMask & ~category;
                return this;
              },
              setCollidesWith: function(categories) {
                var target = this.body ? this.body : this;
                target.collisionMask = GetCollidesWith(categories);
                return this;
              },
              resetCollisionCategory: function() {
                var target = this.body ? this.body : this;
                target.collisionCategory = 1;
                target.collisionMask = 1;
                return this;
              }
            };
            module2.exports = Collision;
          },
          99803: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Debug = {
              setDebug: function(showBody, showVelocity, bodyColor) {
                this.debugShowBody = showBody;
                this.debugShowVelocity = showVelocity;
                this.debugBodyColor = bodyColor;
                return this;
              },
              setDebugBodyColor: function(value) {
                this.body.debugBodyColor = value;
                return this;
              },
              debugShowBody: {
                get: function() {
                  return this.body.debugShowBody;
                },
                set: function(value) {
                  this.body.debugShowBody = value;
                }
              },
              debugShowVelocity: {
                get: function() {
                  return this.body.debugShowVelocity;
                },
                set: function(value) {
                  this.body.debugShowVelocity = value;
                }
              },
              debugBodyColor: {
                get: function() {
                  return this.body.debugBodyColor;
                },
                set: function(value) {
                  this.body.debugBodyColor = value;
                }
              }
            };
            module2.exports = Debug;
          },
          87145: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Drag = {
              setDrag: function(x, y) {
                this.body.drag.set(x, y);
                return this;
              },
              setDragX: function(value) {
                this.body.drag.x = value;
                return this;
              },
              setDragY: function(value) {
                this.body.drag.y = value;
                return this;
              },
              setDamping: function(value) {
                this.body.useDamping = value;
                return this;
              }
            };
            module2.exports = Drag;
          },
          96174: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Enable = {
              setDirectControl: function(value) {
                this.body.setDirectControl(value);
                return this;
              },
              enableBody: function(reset, x, y, enableGameObject, showGameObject) {
                if (reset) {
                  this.body.reset(x, y);
                }
                if (enableGameObject) {
                  this.body.gameObject.active = true;
                }
                if (showGameObject) {
                  this.body.gameObject.visible = true;
                }
                this.body.enable = true;
                return this;
              },
              disableBody: function(disableGameObject, hideGameObject) {
                if (disableGameObject === void 0) {
                  disableGameObject = false;
                }
                if (hideGameObject === void 0) {
                  hideGameObject = false;
                }
                this.body.stop();
                this.body.enable = false;
                if (disableGameObject) {
                  this.body.gameObject.active = false;
                }
                if (hideGameObject) {
                  this.body.gameObject.visible = false;
                }
                return this;
              },
              refreshBody: function() {
                this.body.updateFromGameObject();
                return this;
              }
            };
            module2.exports = Enable;
          },
          51702: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Friction = {
              setFriction: function(x, y) {
                this.body.friction.set(x, y);
                return this;
              },
              setFrictionX: function(x) {
                this.body.friction.x = x;
                return this;
              },
              setFrictionY: function(y) {
                this.body.friction.y = y;
                return this;
              }
            };
            module2.exports = Friction;
          },
          25578: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Gravity = {
              setGravity: function(x, y) {
                this.body.gravity.set(x, y);
                return this;
              },
              setGravityX: function(x) {
                this.body.gravity.x = x;
                return this;
              },
              setGravityY: function(y) {
                this.body.gravity.y = y;
                return this;
              }
            };
            module2.exports = Gravity;
          },
          72029: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Immovable = {
              setImmovable: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.body.immovable = value;
                return this;
              }
            };
            module2.exports = Immovable;
          },
          34566: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Mass = {
              setMass: function(value) {
                this.body.mass = value;
                return this;
              }
            };
            module2.exports = Mass;
          },
          2732: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var OverlapRect = __webpack_require__2(15147);
            var Circle = __webpack_require__2(26673);
            var CircleToCircle = __webpack_require__2(22184);
            var CircleToRectangle = __webpack_require__2(26535);
            var OverlapCirc = function(world, x, y, radius, includeDynamic, includeStatic) {
              var bodiesInRect = OverlapRect(world, x - radius, y - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);
              if (bodiesInRect.length === 0) {
                return bodiesInRect;
              }
              var area = new Circle(x, y, radius);
              var circFromBody = new Circle();
              var bodiesInArea = [];
              for (var i = 0; i < bodiesInRect.length; i++) {
                var body = bodiesInRect[i];
                if (body.isCircle) {
                  circFromBody.setTo(body.center.x, body.center.y, body.halfWidth);
                  if (CircleToCircle(area, circFromBody)) {
                    bodiesInArea.push(body);
                  }
                } else if (CircleToRectangle(area, body)) {
                  bodiesInArea.push(body);
                }
              }
              return bodiesInArea;
            };
            module2.exports = OverlapCirc;
          },
          15147: (module2) => {
            var OverlapRect = function(world, x, y, width, height, includeDynamic, includeStatic) {
              if (includeDynamic === void 0) {
                includeDynamic = true;
              }
              if (includeStatic === void 0) {
                includeStatic = false;
              }
              var dynamicBodies = [];
              var staticBodies = [];
              var minMax = world.treeMinMax;
              minMax.minX = x;
              minMax.minY = y;
              minMax.maxX = x + width;
              minMax.maxY = y + height;
              if (includeStatic) {
                staticBodies = world.staticTree.search(minMax);
              }
              if (includeDynamic && world.useTree) {
                dynamicBodies = world.tree.search(minMax);
              } else if (includeDynamic) {
                var bodies = world.bodies;
                var fakeBody = {
                  position: {
                    x,
                    y
                  },
                  left: x,
                  top: y,
                  right: x + width,
                  bottom: y + height,
                  isCircle: false
                };
                var intersects = world.intersects;
                bodies.iterate(function(target) {
                  if (intersects(target, fakeBody)) {
                    dynamicBodies.push(target);
                  }
                });
              }
              return staticBodies.concat(dynamicBodies);
            };
            module2.exports = OverlapRect;
          },
          57527: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Pushable = {
              setPushable: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.body.pushable = value;
                return this;
              }
            };
            module2.exports = Pushable;
          },
          77687: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Size = {
              setOffset: function(x, y) {
                this.body.setOffset(x, y);
                return this;
              },
              setSize: function(width, height, center) {
                this.body.setSize(width, height, center);
                return this;
              },
              setBodySize: function(width, height, center) {
                this.body.setSize(width, height, center);
                return this;
              },
              setCircle: function(radius, offsetX, offsetY) {
                this.body.setCircle(radius, offsetX, offsetY);
                return this;
              }
            };
            module2.exports = Size;
          },
          66536: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Velocity = {
              setVelocity: function(x, y) {
                this.body.setVelocity(x, y);
                return this;
              },
              setVelocityX: function(x) {
                this.body.setVelocityX(x);
                return this;
              },
              setVelocityY: function(y) {
                this.body.setVelocityY(y);
                return this;
              },
              setMaxVelocity: function(x, y) {
                this.body.maxVelocity.set(x, y);
                return this;
              }
            };
            module2.exports = Velocity;
          },
          7864: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Acceleration: __webpack_require__2(5321),
              Angular: __webpack_require__2(29257),
              Bounce: __webpack_require__2(62122),
              Collision: __webpack_require__2(95239),
              Debug: __webpack_require__2(99803),
              Drag: __webpack_require__2(87145),
              Enable: __webpack_require__2(96174),
              Friction: __webpack_require__2(51702),
              Gravity: __webpack_require__2(25578),
              Immovable: __webpack_require__2(72029),
              Mass: __webpack_require__2(34566),
              OverlapCirc: __webpack_require__2(2732),
              OverlapRect: __webpack_require__2(15147),
              Pushable: __webpack_require__2(57527),
              Size: __webpack_require__2(77687),
              Velocity: __webpack_require__2(66536)
            };
          },
          47401: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = {
              DYNAMIC_BODY: 0,
              STATIC_BODY: 1,
              GROUP: 2,
              TILEMAPLAYER: 3,
              FACING_NONE: 10,
              FACING_UP: 11,
              FACING_DOWN: 12,
              FACING_LEFT: 13,
              FACING_RIGHT: 14
            };
            module2.exports = CONST;
          },
          22346: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "collide";
          },
          95092: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "overlap";
          },
          15775: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pause";
          },
          74142: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resume";
          },
          22825: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "tilecollide";
          },
          10851: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "tileoverlap";
          },
          7543: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "worldbounds";
          },
          1487: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "worldstep";
          },
          27037: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              COLLIDE: __webpack_require__2(22346),
              OVERLAP: __webpack_require__2(95092),
              PAUSE: __webpack_require__2(15775),
              RESUME: __webpack_require__2(74142),
              TILE_COLLIDE: __webpack_require__2(22825),
              TILE_OVERLAP: __webpack_require__2(10851),
              WORLD_BOUNDS: __webpack_require__2(7543),
              WORLD_STEP: __webpack_require__2(1487)
            };
          },
          39977: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(47401);
            var Extend = __webpack_require__2(98611);
            var Arcade = {
              ArcadePhysics: __webpack_require__2(66150),
              Body: __webpack_require__2(97602),
              Collider: __webpack_require__2(3909),
              Components: __webpack_require__2(7864),
              Events: __webpack_require__2(27037),
              Factory: __webpack_require__2(99523),
              GetCollidesWith: __webpack_require__2(44880),
              GetOverlapX: __webpack_require__2(75671),
              GetOverlapY: __webpack_require__2(66185),
              SeparateX: __webpack_require__2(61777),
              SeparateY: __webpack_require__2(25299),
              Group: __webpack_require__2(10481),
              Image: __webpack_require__2(62832),
              Sprite: __webpack_require__2(25084),
              StaticBody: __webpack_require__2(66634),
              StaticGroup: __webpack_require__2(46346),
              Tilemap: __webpack_require__2(8413),
              World: __webpack_require__2(85233)
            };
            Arcade = Extend(false, Arcade, CONST);
            module2.exports = Arcade;
          },
          25163: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ProcessTileCallbacks = function(tile, sprite) {
              if (tile.collisionCallback) {
                return !tile.collisionCallback.call(tile.collisionCallbackContext, sprite, tile);
              } else if (tile.layer.callbacks[tile.index]) {
                return !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, sprite, tile);
              }
              return true;
            };
            module2.exports = ProcessTileCallbacks;
          },
          98209: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ProcessTileSeparationX = function(body, x) {
              if (x < 0) {
                body.blocked.none = false;
                body.blocked.left = true;
              } else if (x > 0) {
                body.blocked.none = false;
                body.blocked.right = true;
              }
              body.position.x -= x;
              body.updateCenter();
              if (body.bounce.x === 0) {
                body.velocity.x = 0;
              } else {
                body.velocity.x = -body.velocity.x * body.bounce.x;
              }
            };
            module2.exports = ProcessTileSeparationX;
          },
          72792: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ProcessTileSeparationY = function(body, y) {
              if (y < 0) {
                body.blocked.none = false;
                body.blocked.up = true;
              } else if (y > 0) {
                body.blocked.none = false;
                body.blocked.down = true;
              }
              body.position.y -= y;
              body.updateCenter();
              if (body.bounce.y === 0) {
                body.velocity.y = 0;
              } else {
                body.velocity.y = -body.velocity.y * body.bounce.y;
              }
            };
            module2.exports = ProcessTileSeparationY;
          },
          27354: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TileCheckX = __webpack_require__2(14405);
            var TileCheckY = __webpack_require__2(52926);
            var TileIntersectsBody = __webpack_require__2(28808);
            var SeparateTile = function(i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer) {
              var tileLeft = tileWorldRect.left;
              var tileTop = tileWorldRect.top;
              var tileRight = tileWorldRect.right;
              var tileBottom = tileWorldRect.bottom;
              var faceHorizontal = tile.faceLeft || tile.faceRight;
              var faceVertical = tile.faceTop || tile.faceBottom;
              if (!isLayer) {
                faceHorizontal = true;
                faceVertical = true;
              }
              if (!faceHorizontal && !faceVertical) {
                return false;
              }
              var ox = 0;
              var oy = 0;
              var minX = 0;
              var minY = 1;
              if (body.deltaAbsX() > body.deltaAbsY()) {
                minX = -1;
              } else if (body.deltaAbsX() < body.deltaAbsY()) {
                minY = -1;
              }
              if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical) {
                minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));
                minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));
              }
              if (minX < minY) {
                if (faceHorizontal) {
                  ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
                  if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
                    return true;
                  }
                }
                if (faceVertical) {
                  oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
                }
              } else {
                if (faceVertical) {
                  oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
                  if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
                    return true;
                  }
                }
                if (faceHorizontal) {
                  ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
                }
              }
              return ox !== 0 || oy !== 0;
            };
            module2.exports = SeparateTile;
          },
          14405: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ProcessTileSeparationX = __webpack_require__2(98209);
            var TileCheckX = function(body, tile, tileLeft, tileRight, tileBias, isLayer) {
              var ox = 0;
              var faceLeft = tile.faceLeft;
              var faceRight = tile.faceRight;
              var collideLeft = tile.collideLeft;
              var collideRight = tile.collideRight;
              if (!isLayer) {
                faceLeft = true;
                faceRight = true;
                collideLeft = true;
                collideRight = true;
              }
              if (body.deltaX() < 0 && collideRight && body.checkCollision.left) {
                if (faceRight && body.x < tileRight) {
                  ox = body.x - tileRight;
                  if (ox < -tileBias) {
                    ox = 0;
                  }
                }
              } else if (body.deltaX() > 0 && collideLeft && body.checkCollision.right) {
                if (faceLeft && body.right > tileLeft) {
                  ox = body.right - tileLeft;
                  if (ox > tileBias) {
                    ox = 0;
                  }
                }
              }
              if (ox !== 0) {
                if (body.customSeparateX) {
                  body.overlapX = ox;
                } else {
                  ProcessTileSeparationX(body, ox);
                }
              }
              return ox;
            };
            module2.exports = TileCheckX;
          },
          52926: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ProcessTileSeparationY = __webpack_require__2(72792);
            var TileCheckY = function(body, tile, tileTop, tileBottom, tileBias, isLayer) {
              var oy = 0;
              var faceTop = tile.faceTop;
              var faceBottom = tile.faceBottom;
              var collideUp = tile.collideUp;
              var collideDown = tile.collideDown;
              if (!isLayer) {
                faceTop = true;
                faceBottom = true;
                collideUp = true;
                collideDown = true;
              }
              if (body.deltaY() < 0 && collideDown && body.checkCollision.up) {
                if (faceBottom && body.y < tileBottom) {
                  oy = body.y - tileBottom;
                  if (oy < -tileBias) {
                    oy = 0;
                  }
                }
              } else if (body.deltaY() > 0 && collideUp && body.checkCollision.down) {
                if (faceTop && body.bottom > tileTop) {
                  oy = body.bottom - tileTop;
                  if (oy > tileBias) {
                    oy = 0;
                  }
                }
              }
              if (oy !== 0) {
                if (body.customSeparateY) {
                  body.overlapY = oy;
                } else {
                  ProcessTileSeparationY(body, oy);
                }
              }
              return oy;
            };
            module2.exports = TileCheckY;
          },
          28808: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TileIntersectsBody = function(tileWorldRect, body) {
              return !(body.right <= tileWorldRect.left || body.bottom <= tileWorldRect.top || body.position.x >= tileWorldRect.right || body.position.y >= tileWorldRect.bottom);
            };
            module2.exports = TileIntersectsBody;
          },
          8413: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Tilemap = {
              ProcessTileCallbacks: __webpack_require__2(25163),
              ProcessTileSeparationX: __webpack_require__2(98209),
              ProcessTileSeparationY: __webpack_require__2(72792),
              SeparateTile: __webpack_require__2(27354),
              TileCheckX: __webpack_require__2(14405),
              TileCheckY: __webpack_require__2(52926),
              TileIntersectsBody: __webpack_require__2(28808)
            };
            module2.exports = Tilemap;
          },
          53954: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Arcade: __webpack_require__2(39977),
              Matter: __webpack_require__2(45949)
            };
          },
          63568: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Vector2 = __webpack_require__2(93736);
            var BodyBounds = new Class({
              initialize: function BodyBounds2() {
                this.boundsCenter = new Vector2();
                this.centerDiff = new Vector2();
              },
              parseBody: function(body) {
                body = body.hasOwnProperty("body") ? body.body : body;
                if (!body.hasOwnProperty("bounds") || !body.hasOwnProperty("centerOfMass")) {
                  return false;
                }
                var boundsCenter = this.boundsCenter;
                var centerDiff = this.centerDiff;
                var boundsWidth = body.bounds.max.x - body.bounds.min.x;
                var boundsHeight = body.bounds.max.y - body.bounds.min.y;
                var bodyCenterX = boundsWidth * body.centerOfMass.x;
                var bodyCenterY = boundsHeight * body.centerOfMass.y;
                boundsCenter.set(boundsWidth / 2, boundsHeight / 2);
                centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y);
                return true;
              },
              getTopLeft: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var center = this.boundsCenter;
                  var diff = this.centerDiff;
                  return new Vector2(x + center.x + diff.x, y + center.y + diff.y);
                }
                return false;
              },
              getTopCenter: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var center = this.boundsCenter;
                  var diff = this.centerDiff;
                  return new Vector2(x + diff.x, y + center.y + diff.y);
                }
                return false;
              },
              getTopRight: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var center = this.boundsCenter;
                  var diff = this.centerDiff;
                  return new Vector2(x - (center.x - diff.x), y + center.y + diff.y);
                }
                return false;
              },
              getLeftCenter: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var center = this.boundsCenter;
                  var diff = this.centerDiff;
                  return new Vector2(x + center.x + diff.x, y + diff.y);
                }
                return false;
              },
              getCenter: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var diff = this.centerDiff;
                  return new Vector2(x + diff.x, y + diff.y);
                }
                return false;
              },
              getRightCenter: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var center = this.boundsCenter;
                  var diff = this.centerDiff;
                  return new Vector2(x - (center.x - diff.x), y + diff.y);
                }
                return false;
              },
              getBottomLeft: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var center = this.boundsCenter;
                  var diff = this.centerDiff;
                  return new Vector2(x + center.x + diff.x, y - (center.y - diff.y));
                }
                return false;
              },
              getBottomCenter: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var center = this.boundsCenter;
                  var diff = this.centerDiff;
                  return new Vector2(x + diff.x, y - (center.y - diff.y));
                }
                return false;
              },
              getBottomRight: function(body, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (this.parseBody(body)) {
                  var center = this.boundsCenter;
                  var diff = this.centerDiff;
                  return new Vector2(x - (center.x - diff.x), y - (center.y - diff.y));
                }
                return false;
              }
            });
            module2.exports = BodyBounds;
          },
          18171: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Matter = __webpack_require__2(16929);
            Matter.Body = __webpack_require__2(84125);
            Matter.Composite = __webpack_require__2(11299);
            Matter.World = __webpack_require__2(72005);
            Matter.Collision = __webpack_require__2(63454);
            Matter.Detector = __webpack_require__2(13657);
            Matter.Pairs = __webpack_require__2(91327);
            Matter.Pair = __webpack_require__2(70584);
            Matter.Query = __webpack_require__2(13390);
            Matter.Resolver = __webpack_require__2(44272);
            Matter.Constraint = __webpack_require__2(52838);
            Matter.Common = __webpack_require__2(68758);
            Matter.Engine = __webpack_require__2(45775);
            Matter.Events = __webpack_require__2(39073);
            Matter.Sleeping = __webpack_require__2(22806);
            Matter.Plugin = __webpack_require__2(84474);
            Matter.Bodies = __webpack_require__2(68516);
            Matter.Composites = __webpack_require__2(56643);
            Matter.Axes = __webpack_require__2(50658);
            Matter.Bounds = __webpack_require__2(84091);
            Matter.Svg = __webpack_require__2(92765);
            Matter.Vector = __webpack_require__2(10438);
            Matter.Vertices = __webpack_require__2(39745);
            Matter.World.add = Matter.Composite.add;
            Matter.World.remove = Matter.Composite.remove;
            Matter.World.addComposite = Matter.Composite.addComposite;
            Matter.World.addBody = Matter.Composite.addBody;
            Matter.World.addConstraint = Matter.Composite.addConstraint;
            Matter.World.clear = Matter.Composite.clear;
            module2.exports = Matter;
          },
          72653: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bodies = __webpack_require__2(68516);
            var Class = __webpack_require__2(56694);
            var Composites = __webpack_require__2(56643);
            var Constraint = __webpack_require__2(52838);
            var Svg = __webpack_require__2(92765);
            var MatterGameObject = __webpack_require__2(3860);
            var MatterImage = __webpack_require__2(7030);
            var MatterSprite = __webpack_require__2(73658);
            var MatterTileBody = __webpack_require__2(84720);
            var PhysicsEditorParser = __webpack_require__2(10998);
            var PhysicsJSONParser = __webpack_require__2(72829);
            var PointerConstraint = __webpack_require__2(88596);
            var Vertices = __webpack_require__2(39745);
            var Factory = new Class({
              initialize: function Factory2(world) {
                this.world = world;
                this.scene = world.scene;
                this.sys = world.scene.sys;
              },
              rectangle: function(x, y, width, height, options) {
                var body = Bodies.rectangle(x, y, width, height, options);
                this.world.add(body);
                return body;
              },
              trapezoid: function(x, y, width, height, slope, options) {
                var body = Bodies.trapezoid(x, y, width, height, slope, options);
                this.world.add(body);
                return body;
              },
              circle: function(x, y, radius, options, maxSides) {
                var body = Bodies.circle(x, y, radius, options, maxSides);
                this.world.add(body);
                return body;
              },
              polygon: function(x, y, sides, radius, options) {
                var body = Bodies.polygon(x, y, sides, radius, options);
                this.world.add(body);
                return body;
              },
              fromVertices: function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
                if (typeof vertexSets === "string") {
                  vertexSets = Vertices.fromPath(vertexSets);
                }
                var body = Bodies.fromVertices(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea);
                this.world.add(body);
                return body;
              },
              fromPhysicsEditor: function(x, y, config2, options, addToWorld) {
                if (addToWorld === void 0) {
                  addToWorld = true;
                }
                var body = PhysicsEditorParser.parseBody(x, y, config2, options);
                if (addToWorld && !this.world.has(body)) {
                  this.world.add(body);
                }
                return body;
              },
              fromSVG: function(x, y, xml, scale, options, addToWorld) {
                if (scale === void 0) {
                  scale = 1;
                }
                if (options === void 0) {
                  options = {};
                }
                if (addToWorld === void 0) {
                  addToWorld = true;
                }
                var path = xml.getElementsByTagName("path");
                var vertexSets = [];
                for (var i = 0; i < path.length; i++) {
                  var points = Svg.pathToVertices(path[i], 30);
                  if (scale !== 1) {
                    Vertices.scale(points, scale, scale);
                  }
                  vertexSets.push(points);
                }
                var body = Bodies.fromVertices(x, y, vertexSets, options);
                if (addToWorld) {
                  this.world.add(body);
                }
                return body;
              },
              fromJSON: function(x, y, config2, options, addToWorld) {
                if (options === void 0) {
                  options = {};
                }
                if (addToWorld === void 0) {
                  addToWorld = true;
                }
                var body = PhysicsJSONParser.parseBody(x, y, config2, options);
                if (body && addToWorld) {
                  this.world.add(body);
                }
                return body;
              },
              imageStack: function(key, frame, x, y, columns, rows, columnGap, rowGap, options) {
                if (columnGap === void 0) {
                  columnGap = 0;
                }
                if (rowGap === void 0) {
                  rowGap = 0;
                }
                if (options === void 0) {
                  options = {};
                }
                var world = this.world;
                var displayList = this.sys.displayList;
                options.addToWorld = false;
                var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, function(x2, y2) {
                  var image = new MatterImage(world, x2, y2, key, frame, options);
                  displayList.add(image);
                  return image.body;
                });
                world.add(stack);
                return stack;
              },
              stack: function(x, y, columns, rows, columnGap, rowGap, callback) {
                var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, callback);
                this.world.add(stack);
                return stack;
              },
              pyramid: function(x, y, columns, rows, columnGap, rowGap, callback) {
                var stack = Composites.pyramid(x, y, columns, rows, columnGap, rowGap, callback);
                this.world.add(stack);
                return stack;
              },
              chain: function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
                return Composites.chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options);
              },
              mesh: function(composite, columns, rows, crossBrace, options) {
                return Composites.mesh(composite, columns, rows, crossBrace, options);
              },
              newtonsCradle: function(x, y, number, size, length) {
                var composite = Composites.newtonsCradle(x, y, number, size, length);
                this.world.add(composite);
                return composite;
              },
              car: function(x, y, width, height, wheelSize) {
                var composite = Composites.car(x, y, width, height, wheelSize);
                this.world.add(composite);
                return composite;
              },
              softBody: function(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
                var composite = Composites.softBody(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions);
                this.world.add(composite);
                return composite;
              },
              joint: function(bodyA, bodyB, length, stiffness, options) {
                return this.constraint(bodyA, bodyB, length, stiffness, options);
              },
              spring: function(bodyA, bodyB, length, stiffness, options) {
                return this.constraint(bodyA, bodyB, length, stiffness, options);
              },
              constraint: function(bodyA, bodyB, length, stiffness, options) {
                if (stiffness === void 0) {
                  stiffness = 1;
                }
                if (options === void 0) {
                  options = {};
                }
                options.bodyA = bodyA.type === "body" ? bodyA : bodyA.body;
                options.bodyB = bodyB.type === "body" ? bodyB : bodyB.body;
                if (!isNaN(length)) {
                  options.length = length;
                }
                options.stiffness = stiffness;
                var constraint = Constraint.create(options);
                this.world.add(constraint);
                return constraint;
              },
              worldConstraint: function(body, length, stiffness, options) {
                if (stiffness === void 0) {
                  stiffness = 1;
                }
                if (options === void 0) {
                  options = {};
                }
                options.bodyB = body.type === "body" ? body : body.body;
                if (!isNaN(length)) {
                  options.length = length;
                }
                options.stiffness = stiffness;
                var constraint = Constraint.create(options);
                this.world.add(constraint);
                return constraint;
              },
              mouseSpring: function(options) {
                return this.pointerConstraint(options);
              },
              pointerConstraint: function(options) {
                if (options === void 0) {
                  options = {};
                }
                if (!options.hasOwnProperty("render")) {
                  options.render = {visible: false};
                }
                var pointerConstraint = new PointerConstraint(this.scene, this.world, options);
                this.world.add(pointerConstraint.constraint);
                return pointerConstraint;
              },
              image: function(x, y, key, frame, options) {
                var image = new MatterImage(this.world, x, y, key, frame, options);
                this.sys.displayList.add(image);
                return image;
              },
              tileBody: function(tile, options) {
                return new MatterTileBody(this.world, tile, options);
              },
              sprite: function(x, y, key, frame, options) {
                var sprite = new MatterSprite(this.world, x, y, key, frame, options);
                this.sys.displayList.add(sprite);
                this.sys.updateList.add(sprite);
                return sprite;
              },
              gameObject: function(gameObject, options, addToWorld) {
                return MatterGameObject(this.world, gameObject, options, addToWorld);
              },
              destroy: function() {
                this.world = null;
                this.scene = null;
                this.sys = null;
              }
            });
            module2.exports = Factory;
          },
          3860: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Components = __webpack_require__2(74527);
            var GetFastValue = __webpack_require__2(72632);
            var Vector2 = __webpack_require__2(93736);
            function hasGetterOrSetter(def) {
              return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
            }
            var MatterGameObject = function(world, gameObject, options, addToWorld) {
              if (options === void 0) {
                options = {};
              }
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              var x = gameObject.x;
              var y = gameObject.y;
              gameObject.body = {
                temp: true,
                position: {
                  x,
                  y
                }
              };
              var mixins = [
                Components.Bounce,
                Components.Collision,
                Components.Force,
                Components.Friction,
                Components.Gravity,
                Components.Mass,
                Components.Sensor,
                Components.SetBody,
                Components.Sleep,
                Components.Static,
                Components.Transform,
                Components.Velocity
              ];
              mixins.forEach(function(mixin) {
                for (var key in mixin) {
                  if (hasGetterOrSetter(mixin[key])) {
                    Object.defineProperty(gameObject, key, {
                      get: mixin[key].get,
                      set: mixin[key].set
                    });
                  } else {
                    Object.defineProperty(gameObject, key, {value: mixin[key]});
                  }
                }
              });
              gameObject.world = world;
              gameObject._tempVec2 = new Vector2(x, y);
              if (options.hasOwnProperty("type") && options.type === "body") {
                gameObject.setExistingBody(options, addToWorld);
              } else {
                var shape = GetFastValue(options, "shape", null);
                if (!shape) {
                  shape = "rectangle";
                }
                options.addToWorld = addToWorld;
                gameObject.setBody(shape, options);
              }
              return gameObject;
            };
            module2.exports = MatterGameObject;
          },
          7030: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(74527);
            var GameObject = __webpack_require__2(89980);
            var GetFastValue = __webpack_require__2(72632);
            var Image2 = __webpack_require__2(1539);
            var Pipeline = __webpack_require__2(58210);
            var Vector2 = __webpack_require__2(93736);
            var MatterImage = new Class({
              Extends: Image2,
              Mixins: [
                Components.Bounce,
                Components.Collision,
                Components.Force,
                Components.Friction,
                Components.Gravity,
                Components.Mass,
                Components.Sensor,
                Components.SetBody,
                Components.Sleep,
                Components.Static,
                Components.Transform,
                Components.Velocity,
                Pipeline
              ],
              initialize: function MatterImage2(world, x, y, texture, frame, options) {
                GameObject.call(this, world.scene, "Image");
                this._crop = this.resetCropObject();
                this.setTexture(texture, frame);
                this.setSizeToFrame();
                this.setOrigin();
                this.world = world;
                this._tempVec2 = new Vector2(x, y);
                var shape = GetFastValue(options, "shape", null);
                if (shape) {
                  this.setBody(shape, options);
                } else {
                  this.setRectangle(this.width, this.height, options);
                }
                this.setPosition(x, y);
                this.initPipeline();
                this.initPostPipeline(true);
              }
            });
            module2.exports = MatterImage;
          },
          50583: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ALIGN_CONST = __webpack_require__2(84093);
            var Axes = __webpack_require__2(50658);
            var Bodies = __webpack_require__2(68516);
            var Body = __webpack_require__2(84125);
            var BodyBounds = __webpack_require__2(63568);
            var Bounds = __webpack_require__2(84091);
            var Class = __webpack_require__2(56694);
            var Collision = __webpack_require__2(63454);
            var Common = __webpack_require__2(68758);
            var Composite = __webpack_require__2(11299);
            var Composites = __webpack_require__2(56643);
            var Constraint = __webpack_require__2(52838);
            var Detector = __webpack_require__2(13657);
            var DistanceBetween = __webpack_require__2(53996);
            var Factory = __webpack_require__2(72653);
            var GetFastValue = __webpack_require__2(72632);
            var GetValue = __webpack_require__2(10850);
            var MatterAttractors = __webpack_require__2(1675);
            var MatterCollisionEvents = __webpack_require__2(80391);
            var MatterLib = __webpack_require__2(16929);
            var MatterWrap = __webpack_require__2(44097);
            var Merge = __webpack_require__2(30657);
            var Pair = __webpack_require__2(70584);
            var Pairs = __webpack_require__2(91327);
            var Plugin = __webpack_require__2(84474);
            var PluginCache = __webpack_require__2(91963);
            var Query = __webpack_require__2(13390);
            var Resolver = __webpack_require__2(44272);
            var SceneEvents = __webpack_require__2(7599);
            var Svg = __webpack_require__2(92765);
            var Vector = __webpack_require__2(10438);
            var Vertices = __webpack_require__2(39745);
            var World = __webpack_require__2(31468);
            Common.setDecomp(__webpack_require__2(81084));
            var MatterPhysics = new Class({
              initialize: function MatterPhysics2(scene) {
                this.scene = scene;
                this.systems = scene.sys;
                this.config = this.getConfig();
                this.world;
                this.add;
                this.bodyBounds;
                this.body = Body;
                this.composite = Composite;
                this.collision = Collision;
                this.detector = Detector;
                this.pair = Pair;
                this.pairs = Pairs;
                this.query = Query;
                this.resolver = Resolver;
                this.constraint = Constraint;
                this.bodies = Bodies;
                this.composites = Composites;
                this.axes = Axes;
                this.bounds = Bounds;
                this.svg = Svg;
                this.vector = Vector;
                this.vertices = Vertices;
                this.verts = Vertices;
                this._tempVec2 = Vector.create();
                if (GetValue(this.config, "plugins.collisionevents", true)) {
                  this.enableCollisionEventsPlugin();
                }
                if (GetValue(this.config, "plugins.attractors", false)) {
                  this.enableAttractorPlugin();
                }
                if (GetValue(this.config, "plugins.wrap", false)) {
                  this.enableWrapPlugin();
                }
                Resolver._restingThresh = GetValue(this.config, "restingThresh", 4);
                Resolver._restingThreshTangent = GetValue(this.config, "restingThreshTangent", 6);
                Resolver._positionDampen = GetValue(this.config, "positionDampen", 0.9);
                Resolver._positionWarming = GetValue(this.config, "positionWarming", 0.8);
                Resolver._frictionNormalMultiplier = GetValue(this.config, "frictionNormalMultiplier", 5);
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                scene.sys.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.world = new World(this.scene, this.config);
                this.add = new Factory(this.world);
                this.bodyBounds = new BodyBounds();
                this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                if (!this.world) {
                  this.world = new World(this.scene, this.config);
                  this.add = new Factory(this.world);
                }
                var eventEmitter = this.systems.events;
                eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
                eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
                eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              getConfig: function() {
                var gameConfig = this.systems.game.config.physics;
                var sceneConfig = this.systems.settings.physics;
                var config2 = Merge(GetFastValue(sceneConfig, "matter", {}), GetFastValue(gameConfig, "matter", {}));
                return config2;
              },
              enableAttractorPlugin: function() {
                Plugin.register(MatterAttractors);
                Plugin.use(MatterLib, MatterAttractors);
                return this;
              },
              enableWrapPlugin: function() {
                Plugin.register(MatterWrap);
                Plugin.use(MatterLib, MatterWrap);
                return this;
              },
              enableCollisionEventsPlugin: function() {
                Plugin.register(MatterCollisionEvents);
                Plugin.use(MatterLib, MatterCollisionEvents);
                return this;
              },
              pause: function() {
                return this.world.pause();
              },
              resume: function() {
                return this.world.resume();
              },
              set60Hz: function() {
                this.world.getDelta = this.world.update60Hz;
                this.world.autoUpdate = true;
                return this;
              },
              set30Hz: function() {
                this.world.getDelta = this.world.update30Hz;
                this.world.autoUpdate = true;
                return this;
              },
              step: function(delta, correction) {
                this.world.step(delta, correction);
              },
              containsPoint: function(body, x, y) {
                body = this.getMatterBodies(body);
                var position = Vector.create(x, y);
                var result = Query.point(body, position);
                return result.length > 0 ? true : false;
              },
              intersectPoint: function(x, y, bodies) {
                bodies = this.getMatterBodies(bodies);
                var position = Vector.create(x, y);
                var output = [];
                var result = Query.point(bodies, position);
                result.forEach(function(body) {
                  if (output.indexOf(body) === -1) {
                    output.push(body);
                  }
                });
                return output;
              },
              intersectRect: function(x, y, width, height, outside, bodies) {
                if (outside === void 0) {
                  outside = false;
                }
                bodies = this.getMatterBodies(bodies);
                var bounds = {
                  min: {x, y},
                  max: {x: x + width, y: y + height}
                };
                var output = [];
                var result = Query.region(bodies, bounds, outside);
                result.forEach(function(body) {
                  if (output.indexOf(body) === -1) {
                    output.push(body);
                  }
                });
                return output;
              },
              intersectRay: function(x1, y1, x2, y2, rayWidth, bodies) {
                if (rayWidth === void 0) {
                  rayWidth = 1;
                }
                bodies = this.getMatterBodies(bodies);
                var result = [];
                var collisions = Query.ray(bodies, Vector.create(x1, y1), Vector.create(x2, y2), rayWidth);
                for (var i = 0; i < collisions.length; i++) {
                  result.push(collisions[i].body);
                }
                return result;
              },
              intersectBody: function(body, bodies) {
                bodies = this.getMatterBodies(bodies);
                var result = [];
                var collisions = Query.collides(body, bodies);
                for (var i = 0; i < collisions.length; i++) {
                  var pair = collisions[i];
                  if (pair.bodyA === body) {
                    result.push(pair.bodyB);
                  } else {
                    result.push(pair.bodyA);
                  }
                }
                return result;
              },
              overlap: function(target, bodies, overlapCallback, processCallback, callbackContext) {
                if (overlapCallback === void 0) {
                  overlapCallback = null;
                }
                if (processCallback === void 0) {
                  processCallback = null;
                }
                if (callbackContext === void 0) {
                  callbackContext = overlapCallback;
                }
                if (!Array.isArray(target)) {
                  target = [target];
                }
                target = this.getMatterBodies(target);
                bodies = this.getMatterBodies(bodies);
                var match = false;
                for (var i = 0; i < target.length; i++) {
                  var entry = target[i];
                  var collisions = Query.collides(entry, bodies);
                  for (var c = 0; c < collisions.length; c++) {
                    var info = collisions[c];
                    var bodyB = info.bodyA.id === entry.id ? info.bodyB : info.bodyA;
                    if (!processCallback || processCallback.call(callbackContext, entry, bodyB, info)) {
                      match = true;
                      if (overlapCallback) {
                        overlapCallback.call(callbackContext, entry, bodyB, info);
                      } else if (!processCallback) {
                        return true;
                      }
                    }
                  }
                }
                return match;
              },
              setCollisionCategory: function(bodies, value) {
                bodies = this.getMatterBodies(bodies);
                bodies.forEach(function(body) {
                  body.collisionFilter.category = value;
                });
                return this;
              },
              setCollisionGroup: function(bodies, value) {
                bodies = this.getMatterBodies(bodies);
                bodies.forEach(function(body) {
                  body.collisionFilter.group = value;
                });
                return this;
              },
              setCollidesWith: function(bodies, categories) {
                bodies = this.getMatterBodies(bodies);
                var flags = 0;
                if (!Array.isArray(categories)) {
                  flags = categories;
                } else {
                  for (var i = 0; i < categories.length; i++) {
                    flags |= categories[i];
                  }
                }
                bodies.forEach(function(body) {
                  body.collisionFilter.mask = flags;
                });
                return this;
              },
              getMatterBodies: function(bodies) {
                if (!bodies) {
                  return this.world.getAllBodies();
                }
                if (!Array.isArray(bodies)) {
                  bodies = [bodies];
                }
                var output = [];
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i].hasOwnProperty("body") ? bodies[i].body : bodies[i];
                  output.push(body);
                }
                return output;
              },
              setVelocity: function(bodies, x, y) {
                bodies = this.getMatterBodies(bodies);
                var vec2 = this._tempVec2;
                vec2.x = x;
                vec2.y = y;
                bodies.forEach(function(body) {
                  Body.setVelocity(body, vec2);
                });
                return this;
              },
              setVelocityX: function(bodies, x) {
                bodies = this.getMatterBodies(bodies);
                var vec2 = this._tempVec2;
                vec2.x = x;
                bodies.forEach(function(body) {
                  vec2.y = body.velocity.y;
                  Body.setVelocity(body, vec2);
                });
                return this;
              },
              setVelocityY: function(bodies, y) {
                bodies = this.getMatterBodies(bodies);
                var vec2 = this._tempVec2;
                vec2.y = y;
                bodies.forEach(function(body) {
                  vec2.x = body.velocity.x;
                  Body.setVelocity(body, vec2);
                });
                return this;
              },
              setAngularVelocity: function(bodies, value) {
                bodies = this.getMatterBodies(bodies);
                bodies.forEach(function(body) {
                  Body.setAngularVelocity(body, value);
                });
                return this;
              },
              applyForce: function(bodies, force) {
                bodies = this.getMatterBodies(bodies);
                var vec2 = this._tempVec2;
                bodies.forEach(function(body) {
                  vec2.x = body.position.x;
                  vec2.y = body.position.y;
                  Body.applyForce(body, vec2, force);
                });
                return this;
              },
              applyForceFromPosition: function(bodies, position, speed, angle) {
                bodies = this.getMatterBodies(bodies);
                var vec2 = this._tempVec2;
                bodies.forEach(function(body) {
                  if (angle === void 0) {
                    angle = body.angle;
                  }
                  vec2.x = speed * Math.cos(angle);
                  vec2.y = speed * Math.sin(angle);
                  Body.applyForce(body, position, vec2);
                });
                return this;
              },
              applyForceFromAngle: function(bodies, speed, angle) {
                bodies = this.getMatterBodies(bodies);
                var vec2 = this._tempVec2;
                bodies.forEach(function(body) {
                  if (angle === void 0) {
                    angle = body.angle;
                  }
                  vec2.x = speed * Math.cos(angle);
                  vec2.y = speed * Math.sin(angle);
                  Body.applyForce(body, {x: body.position.x, y: body.position.y}, vec2);
                });
                return this;
              },
              getConstraintLength: function(constraint) {
                var aX = constraint.pointA.x;
                var aY = constraint.pointA.y;
                var bX = constraint.pointB.x;
                var bY = constraint.pointB.y;
                if (constraint.bodyA) {
                  aX += constraint.bodyA.position.x;
                  aY += constraint.bodyA.position.y;
                }
                if (constraint.bodyB) {
                  bX += constraint.bodyB.position.x;
                  bY += constraint.bodyB.position.y;
                }
                return DistanceBetween(aX, aY, bX, bY);
              },
              alignBody: function(body, x, y, align) {
                body = body.hasOwnProperty("body") ? body.body : body;
                var pos;
                switch (align) {
                  case ALIGN_CONST.TOP_LEFT:
                  case ALIGN_CONST.LEFT_TOP:
                    pos = this.bodyBounds.getTopLeft(body, x, y);
                    break;
                  case ALIGN_CONST.TOP_CENTER:
                    pos = this.bodyBounds.getTopCenter(body, x, y);
                    break;
                  case ALIGN_CONST.TOP_RIGHT:
                  case ALIGN_CONST.RIGHT_TOP:
                    pos = this.bodyBounds.getTopRight(body, x, y);
                    break;
                  case ALIGN_CONST.LEFT_CENTER:
                    pos = this.bodyBounds.getLeftCenter(body, x, y);
                    break;
                  case ALIGN_CONST.CENTER:
                    pos = this.bodyBounds.getCenter(body, x, y);
                    break;
                  case ALIGN_CONST.RIGHT_CENTER:
                    pos = this.bodyBounds.getRightCenter(body, x, y);
                    break;
                  case ALIGN_CONST.LEFT_BOTTOM:
                  case ALIGN_CONST.BOTTOM_LEFT:
                    pos = this.bodyBounds.getBottomLeft(body, x, y);
                    break;
                  case ALIGN_CONST.BOTTOM_CENTER:
                    pos = this.bodyBounds.getBottomCenter(body, x, y);
                    break;
                  case ALIGN_CONST.BOTTOM_RIGHT:
                  case ALIGN_CONST.RIGHT_BOTTOM:
                    pos = this.bodyBounds.getBottomRight(body, x, y);
                    break;
                }
                if (pos) {
                  Body.setPosition(body, pos);
                }
                return this;
              },
              shutdown: function() {
                var eventEmitter = this.systems.events;
                if (this.world) {
                  eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
                  eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
                }
                eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
                if (this.add) {
                  this.add.destroy();
                }
                if (this.world) {
                  this.world.destroy();
                }
                this.add = null;
                this.world = null;
              },
              destroy: function() {
                this.shutdown();
                this.scene.sys.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.systems = null;
              }
            });
            PluginCache.register("MatterPhysics", MatterPhysics, "matterPhysics");
            module2.exports = MatterPhysics;
          },
          73658: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AnimationState = __webpack_require__2(16569);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(74527);
            var GameObject = __webpack_require__2(89980);
            var GetFastValue = __webpack_require__2(72632);
            var Pipeline = __webpack_require__2(58210);
            var Sprite = __webpack_require__2(13747);
            var Vector2 = __webpack_require__2(93736);
            var MatterSprite = new Class({
              Extends: Sprite,
              Mixins: [
                Components.Bounce,
                Components.Collision,
                Components.Force,
                Components.Friction,
                Components.Gravity,
                Components.Mass,
                Components.Sensor,
                Components.SetBody,
                Components.Sleep,
                Components.Static,
                Components.Transform,
                Components.Velocity,
                Pipeline
              ],
              initialize: function MatterSprite2(world, x, y, texture, frame, options) {
                GameObject.call(this, world.scene, "Sprite");
                this._crop = this.resetCropObject();
                this.anims = new AnimationState(this);
                this.setTexture(texture, frame);
                this.setSizeToFrame();
                this.setOrigin();
                this.world = world;
                this._tempVec2 = new Vector2(x, y);
                var shape = GetFastValue(options, "shape", null);
                if (shape) {
                  this.setBody(shape, options);
                } else {
                  this.setRectangle(this.width, this.height, options);
                }
                this.setPosition(x, y);
                this.initPipeline();
                this.initPostPipeline(true);
              }
            });
            module2.exports = MatterSprite;
          },
          84720: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bodies = __webpack_require__2(68516);
            var Body = __webpack_require__2(84125);
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(74527);
            var DeepCopy = __webpack_require__2(28699);
            var EventEmitter = __webpack_require__2(6659);
            var GetFastValue = __webpack_require__2(72632);
            var HasValue = __webpack_require__2(19256);
            var Vertices = __webpack_require__2(39745);
            var MatterTileBody = new Class({
              Extends: EventEmitter,
              Mixins: [
                Components.Bounce,
                Components.Collision,
                Components.Friction,
                Components.Gravity,
                Components.Mass,
                Components.Sensor,
                Components.Sleep,
                Components.Static
              ],
              initialize: function MatterTileBody2(world, tile, options) {
                EventEmitter.call(this);
                this.tile = tile;
                this.world = world;
                if (tile.physics.matterBody) {
                  tile.physics.matterBody.destroy();
                }
                tile.physics.matterBody = this;
                var body = GetFastValue(options, "body", null);
                var addToWorld = GetFastValue(options, "addToWorld", true);
                if (!body) {
                  var collisionGroup = tile.getCollisionGroup();
                  var collisionObjects = GetFastValue(collisionGroup, "objects", []);
                  if (collisionObjects.length > 0) {
                    this.setFromTileCollision(options);
                  } else {
                    this.setFromTileRectangle(options);
                  }
                } else {
                  this.setBody(body, addToWorld);
                }
                if (tile.flipX || tile.flipY) {
                  var rotationPoint = {x: tile.getCenterX(), y: tile.getCenterY()};
                  var scaleX = tile.flipX ? -1 : 1;
                  var scaleY = tile.flipY ? -1 : 1;
                  Body.scale(body, scaleX, scaleY, rotationPoint);
                }
              },
              setFromTileRectangle: function(options) {
                if (options === void 0) {
                  options = {};
                }
                if (!HasValue(options, "isStatic")) {
                  options.isStatic = true;
                }
                if (!HasValue(options, "addToWorld")) {
                  options.addToWorld = true;
                }
                var bounds = this.tile.getBounds();
                var cx = bounds.x + bounds.width / 2;
                var cy = bounds.y + bounds.height / 2;
                var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);
                this.setBody(body, options.addToWorld);
                return this;
              },
              setFromTileCollision: function(options) {
                if (options === void 0) {
                  options = {};
                }
                if (!HasValue(options, "isStatic")) {
                  options.isStatic = true;
                }
                if (!HasValue(options, "addToWorld")) {
                  options.addToWorld = true;
                }
                var sx = this.tile.tilemapLayer.scaleX;
                var sy = this.tile.tilemapLayer.scaleY;
                var tileX = this.tile.getLeft();
                var tileY = this.tile.getTop();
                var collisionGroup = this.tile.getCollisionGroup();
                var collisionObjects = GetFastValue(collisionGroup, "objects", []);
                var parts = [];
                for (var i = 0; i < collisionObjects.length; i++) {
                  var object = collisionObjects[i];
                  var ox = tileX + object.x * sx;
                  var oy = tileY + object.y * sy;
                  var ow = object.width * sx;
                  var oh = object.height * sy;
                  var body = null;
                  if (object.rectangle) {
                    body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);
                  } else if (object.ellipse) {
                    body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);
                  } else if (object.polygon || object.polyline) {
                    var originalPoints = object.polygon ? object.polygon : object.polyline;
                    var points = originalPoints.map(function(p) {
                      return {x: p.x * sx, y: p.y * sy};
                    });
                    var vertices = Vertices.create(points);
                    var center = Vertices.centre(vertices);
                    ox += center.x;
                    oy += center.y;
                    body = Bodies.fromVertices(ox, oy, vertices, options);
                  }
                  if (body) {
                    parts.push(body);
                  }
                }
                if (parts.length === 1) {
                  this.setBody(parts[0], options.addToWorld);
                } else if (parts.length > 1) {
                  var tempOptions = DeepCopy(options);
                  tempOptions.parts = parts;
                  this.setBody(Body.create(tempOptions), tempOptions.addToWorld);
                }
                return this;
              },
              setBody: function(body, addToWorld) {
                if (addToWorld === void 0) {
                  addToWorld = true;
                }
                if (this.body) {
                  this.removeBody();
                }
                this.body = body;
                this.body.gameObject = this;
                if (addToWorld) {
                  this.world.add(this.body);
                }
                return this;
              },
              removeBody: function() {
                if (this.body) {
                  this.world.remove(this.body);
                  this.body.gameObject = void 0;
                  this.body = void 0;
                }
                return this;
              },
              destroy: function() {
                this.removeBody();
                this.tile.physics.matterBody = void 0;
                this.removeAllListeners();
              }
            });
            module2.exports = MatterTileBody;
          },
          10998: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Joachim Grill <joachim@codeandweb.com>
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2018 CodeAndWeb GmbH
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bodies = __webpack_require__2(68516);
            var Body = __webpack_require__2(84125);
            var Common = __webpack_require__2(68758);
            var GetFastValue = __webpack_require__2(72632);
            var Vertices = __webpack_require__2(39745);
            var PhysicsEditorParser = {
              parseBody: function(x, y, config2, options) {
                if (options === void 0) {
                  options = {};
                }
                var fixtureConfigs = GetFastValue(config2, "fixtures", []);
                var fixtures = [];
                for (var fc = 0; fc < fixtureConfigs.length; fc++) {
                  var fixtureParts = this.parseFixture(fixtureConfigs[fc]);
                  for (var i = 0; i < fixtureParts.length; i++) {
                    fixtures.push(fixtureParts[i]);
                  }
                }
                var matterConfig = Common.clone(config2, true);
                Common.extend(matterConfig, options, true);
                delete matterConfig.fixtures;
                delete matterConfig.type;
                var body = Body.create(matterConfig);
                Body.setParts(body, fixtures);
                Body.setPosition(body, {x, y});
                return body;
              },
              parseFixture: function(fixtureConfig) {
                var matterConfig = Common.extend({}, false, fixtureConfig);
                delete matterConfig.circle;
                delete matterConfig.vertices;
                var fixtures;
                if (fixtureConfig.circle) {
                  var x = GetFastValue(fixtureConfig.circle, "x");
                  var y = GetFastValue(fixtureConfig.circle, "y");
                  var r = GetFastValue(fixtureConfig.circle, "radius");
                  fixtures = [Bodies.circle(x, y, r, matterConfig)];
                } else if (fixtureConfig.vertices) {
                  fixtures = this.parseVertices(fixtureConfig.vertices, matterConfig);
                }
                return fixtures;
              },
              parseVertices: function(vertexSets, options) {
                if (options === void 0) {
                  options = {};
                }
                var parts = [];
                for (var v = 0; v < vertexSets.length; v++) {
                  Vertices.clockwiseSort(vertexSets[v]);
                  parts.push(Body.create(Common.extend({
                    position: Vertices.centre(vertexSets[v]),
                    vertices: vertexSets[v]
                  }, options)));
                }
                return Bodies.flagCoincidentParts(parts);
              }
            };
            module2.exports = PhysicsEditorParser;
          },
          72829: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bodies = __webpack_require__2(68516);
            var Body = __webpack_require__2(84125);
            var PhysicsJSONParser = {
              parseBody: function(x, y, config2, options) {
                if (options === void 0) {
                  options = {};
                }
                var body;
                var vertexSets = config2.vertices;
                if (vertexSets.length === 1) {
                  options.vertices = vertexSets[0];
                  body = Body.create(options);
                  Bodies.flagCoincidentParts(body.parts);
                } else {
                  var parts = [];
                  for (var i = 0; i < vertexSets.length; i++) {
                    var part = Body.create({
                      vertices: vertexSets[i]
                    });
                    parts.push(part);
                  }
                  Bodies.flagCoincidentParts(parts);
                  options.parts = parts;
                  body = Body.create(options);
                }
                body.label = config2.label;
                Body.setPosition(body, {x, y});
                return body;
              }
            };
            module2.exports = PhysicsJSONParser;
          },
          88596: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bounds = __webpack_require__2(84091);
            var Class = __webpack_require__2(56694);
            var Composite = __webpack_require__2(11299);
            var Constraint = __webpack_require__2(52838);
            var Detector = __webpack_require__2(13657);
            var Events = __webpack_require__2(35416);
            var InputEvents = __webpack_require__2(33963);
            var Merge = __webpack_require__2(30657);
            var Sleeping = __webpack_require__2(22806);
            var Vector2 = __webpack_require__2(93736);
            var Vertices = __webpack_require__2(39745);
            var PointerConstraint = new Class({
              initialize: function PointerConstraint2(scene, world, options) {
                if (options === void 0) {
                  options = {};
                }
                var defaults = {
                  label: "Pointer Constraint",
                  pointA: {x: 0, y: 0},
                  pointB: {x: 0, y: 0},
                  length: 0.01,
                  stiffness: 0.1,
                  angularStiffness: 1,
                  collisionFilter: {
                    category: 1,
                    mask: 4294967295,
                    group: 0
                  }
                };
                this.scene = scene;
                this.world = world;
                this.camera = null;
                this.pointer = null;
                this.active = true;
                this.position = new Vector2();
                this.body = null;
                this.part = null;
                this.constraint = Constraint.create(Merge(options, defaults));
                this.world.on(Events.BEFORE_UPDATE, this.update, this);
                scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);
                scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);
              },
              onDown: function(pointer) {
                if (!this.pointer) {
                  this.pointer = pointer;
                  this.camera = pointer.camera;
                }
              },
              onUp: function(pointer) {
                if (pointer === this.pointer) {
                  this.pointer = null;
                }
              },
              getBody: function(pointer) {
                var pos = this.position;
                var constraint = this.constraint;
                this.camera.getWorldPoint(pointer.x, pointer.y, pos);
                var bodies = Composite.allBodies(this.world.localWorld);
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (!body.ignorePointer && Bounds.contains(body.bounds, pos) && Detector.canCollide(body.collisionFilter, constraint.collisionFilter)) {
                    if (this.hitTestBody(body, pos)) {
                      this.world.emit(Events.DRAG_START, body, this.part, this);
                      return true;
                    }
                  }
                }
                return false;
              },
              hitTestBody: function(body, position) {
                var constraint = this.constraint;
                var partsLength = body.parts.length;
                var start = partsLength > 1 ? 1 : 0;
                for (var i = start; i < partsLength; i++) {
                  var part = body.parts[i];
                  if (Vertices.contains(part.vertices, position)) {
                    constraint.pointA = position;
                    constraint.pointB = {x: position.x - body.position.x, y: position.y - body.position.y};
                    constraint.bodyB = body;
                    constraint.angleB = body.angle;
                    Sleeping.set(body, false);
                    this.part = part;
                    this.body = body;
                    return true;
                  }
                }
                return false;
              },
              update: function() {
                var pointer = this.pointer;
                var body = this.body;
                if (!this.active || !pointer) {
                  if (body) {
                    this.stopDrag();
                  }
                  return;
                }
                if (!pointer.isDown && body) {
                  this.stopDrag();
                  return;
                } else if (pointer.isDown) {
                  if (!body && !this.getBody(pointer)) {
                    return;
                  }
                  body = this.body;
                  var pos = this.position;
                  var constraint = this.constraint;
                  this.camera.getWorldPoint(pointer.x, pointer.y, pos);
                  constraint.pointA.x = pos.x;
                  constraint.pointA.y = pos.y;
                  Sleeping.set(body, false);
                  this.world.emit(Events.DRAG, body, this);
                }
              },
              stopDrag: function() {
                var body = this.body;
                var constraint = this.constraint;
                constraint.bodyB = null;
                constraint.pointB = null;
                this.pointer = null;
                this.body = null;
                this.part = null;
                if (body) {
                  this.world.emit(Events.DRAG_END, body, this);
                }
              },
              destroy: function() {
                this.world.removeConstraint(this.constraint);
                this.pointer = null;
                this.constraint = null;
                this.body = null;
                this.part = null;
                this.world.off(Events.BEFORE_UPDATE, this.update);
                this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);
                this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);
              }
            });
            module2.exports = PointerConstraint;
          },
          31468: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bodies = __webpack_require__2(68516);
            var Body = __webpack_require__2(84125);
            var Class = __webpack_require__2(56694);
            var Common = __webpack_require__2(68758);
            var Composite = __webpack_require__2(11299);
            var Engine = __webpack_require__2(45775);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(35416);
            var GetFastValue = __webpack_require__2(72632);
            var GetValue = __webpack_require__2(10850);
            var MatterBody = __webpack_require__2(84125);
            var MatterEvents = __webpack_require__2(39073);
            var MatterTileBody = __webpack_require__2(84720);
            var MatterWorld = __webpack_require__2(72005);
            var Vector = __webpack_require__2(10438);
            var World = new Class({
              Extends: EventEmitter,
              initialize: function World2(scene, config2) {
                EventEmitter.call(this);
                this.scene = scene;
                this.engine = Engine.create(config2);
                this.localWorld = this.engine.world;
                var gravity = GetValue(config2, "gravity", null);
                if (gravity) {
                  this.setGravity(gravity.x, gravity.y, gravity.scale);
                } else if (gravity === false) {
                  this.setGravity(0, 0, 0);
                }
                this.walls = {left: null, right: null, top: null, bottom: null};
                this.enabled = GetValue(config2, "enabled", true);
                this.getDelta = GetValue(config2, "getDelta", this.update60Hz);
                var runnerConfig = GetFastValue(config2, "runner", {});
                var hasFPS = GetFastValue(runnerConfig, "fps", false);
                var fps = GetFastValue(runnerConfig, "fps", 60);
                var delta = GetFastValue(runnerConfig, "delta", 1e3 / fps);
                var deltaMin = GetFastValue(runnerConfig, "deltaMin", 1e3 / fps);
                var deltaMax = GetFastValue(runnerConfig, "deltaMax", 1e3 / (fps * 0.5));
                if (!hasFPS) {
                  fps = 1e3 / delta;
                }
                this.runner = {
                  fps,
                  deltaSampleSize: GetFastValue(runnerConfig, "deltaSampleSize", 60),
                  counterTimestamp: 0,
                  frameCounter: 0,
                  deltaHistory: [],
                  timePrev: null,
                  timeScalePrev: 1,
                  frameRequestId: null,
                  isFixed: GetFastValue(runnerConfig, "isFixed", false),
                  delta,
                  deltaMin,
                  deltaMax
                };
                this.autoUpdate = GetValue(config2, "autoUpdate", true);
                var debugConfig = GetValue(config2, "debug", false);
                this.drawDebug = typeof debugConfig === "object" ? true : debugConfig;
                this.debugGraphic;
                this.debugConfig = {
                  showAxes: GetFastValue(debugConfig, "showAxes", false),
                  showAngleIndicator: GetFastValue(debugConfig, "showAngleIndicator", false),
                  angleColor: GetFastValue(debugConfig, "angleColor", 15208787),
                  showBroadphase: GetFastValue(debugConfig, "showBroadphase", false),
                  broadphaseColor: GetFastValue(debugConfig, "broadphaseColor", 16757760),
                  showBounds: GetFastValue(debugConfig, "showBounds", false),
                  boundsColor: GetFastValue(debugConfig, "boundsColor", 16777215),
                  showVelocity: GetFastValue(debugConfig, "showVelocity", false),
                  velocityColor: GetFastValue(debugConfig, "velocityColor", 44783),
                  showCollisions: GetFastValue(debugConfig, "showCollisions", false),
                  collisionColor: GetFastValue(debugConfig, "collisionColor", 16094476),
                  showSeparations: GetFastValue(debugConfig, "showSeparations", false),
                  separationColor: GetFastValue(debugConfig, "separationColor", 16753920),
                  showBody: GetFastValue(debugConfig, "showBody", true),
                  showStaticBody: GetFastValue(debugConfig, "showStaticBody", true),
                  showInternalEdges: GetFastValue(debugConfig, "showInternalEdges", false),
                  renderFill: GetFastValue(debugConfig, "renderFill", false),
                  renderLine: GetFastValue(debugConfig, "renderLine", true),
                  fillColor: GetFastValue(debugConfig, "fillColor", 1075465),
                  fillOpacity: GetFastValue(debugConfig, "fillOpacity", 1),
                  lineColor: GetFastValue(debugConfig, "lineColor", 2678297),
                  lineOpacity: GetFastValue(debugConfig, "lineOpacity", 1),
                  lineThickness: GetFastValue(debugConfig, "lineThickness", 1),
                  staticFillColor: GetFastValue(debugConfig, "staticFillColor", 857979),
                  staticLineColor: GetFastValue(debugConfig, "staticLineColor", 1255396),
                  showSleeping: GetFastValue(debugConfig, "showSleeping", false),
                  staticBodySleepOpacity: GetFastValue(debugConfig, "staticBodySleepOpacity", 0.7),
                  sleepFillColor: GetFastValue(debugConfig, "sleepFillColor", 4605510),
                  sleepLineColor: GetFastValue(debugConfig, "sleepLineColor", 10066585),
                  showSensors: GetFastValue(debugConfig, "showSensors", true),
                  sensorFillColor: GetFastValue(debugConfig, "sensorFillColor", 857979),
                  sensorLineColor: GetFastValue(debugConfig, "sensorLineColor", 1255396),
                  showPositions: GetFastValue(debugConfig, "showPositions", true),
                  positionSize: GetFastValue(debugConfig, "positionSize", 4),
                  positionColor: GetFastValue(debugConfig, "positionColor", 14697178),
                  showJoint: GetFastValue(debugConfig, "showJoint", true),
                  jointColor: GetFastValue(debugConfig, "jointColor", 14737474),
                  jointLineOpacity: GetFastValue(debugConfig, "jointLineOpacity", 1),
                  jointLineThickness: GetFastValue(debugConfig, "jointLineThickness", 2),
                  pinSize: GetFastValue(debugConfig, "pinSize", 4),
                  pinColor: GetFastValue(debugConfig, "pinColor", 4382944),
                  springColor: GetFastValue(debugConfig, "springColor", 14697184),
                  anchorColor: GetFastValue(debugConfig, "anchorColor", 15724527),
                  anchorSize: GetFastValue(debugConfig, "anchorSize", 4),
                  showConvexHulls: GetFastValue(debugConfig, "showConvexHulls", false),
                  hullColor: GetFastValue(debugConfig, "hullColor", 14091216)
                };
                if (this.drawDebug) {
                  this.createDebugGraphic();
                }
                this.setEventsProxy();
                if (GetFastValue(config2, "setBounds", false)) {
                  var boundsConfig = config2["setBounds"];
                  if (typeof boundsConfig === "boolean") {
                    this.setBounds();
                  } else {
                    var x = GetFastValue(boundsConfig, "x", 0);
                    var y = GetFastValue(boundsConfig, "y", 0);
                    var width = GetFastValue(boundsConfig, "width", scene.sys.scale.width);
                    var height = GetFastValue(boundsConfig, "height", scene.sys.scale.height);
                    var thickness = GetFastValue(boundsConfig, "thickness", 64);
                    var left = GetFastValue(boundsConfig, "left", true);
                    var right = GetFastValue(boundsConfig, "right", true);
                    var top = GetFastValue(boundsConfig, "top", true);
                    var bottom = GetFastValue(boundsConfig, "bottom", true);
                    this.setBounds(x, y, width, height, thickness, left, right, top, bottom);
                  }
                }
              },
              setCompositeRenderStyle: function(composite) {
                var bodies = composite.bodies;
                var constraints = composite.constraints;
                var composites = composite.composites;
                var i;
                var obj;
                var render;
                for (i = 0; i < bodies.length; i++) {
                  obj = bodies[i];
                  render = obj.render;
                  this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
                }
                for (i = 0; i < constraints.length; i++) {
                  obj = constraints[i];
                  render = obj.render;
                  this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
                }
                for (i = 0; i < composites.length; i++) {
                  obj = composites[i];
                  this.setCompositeRenderStyle(obj);
                }
                return this;
              },
              setBodyRenderStyle: function(body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
                var render = body.render;
                var config2 = this.debugConfig;
                if (!render) {
                  return this;
                }
                if (lineColor === void 0 || lineColor === null) {
                  lineColor = body.isStatic ? config2.staticLineColor : config2.lineColor;
                }
                if (lineOpacity === void 0 || lineOpacity === null) {
                  lineOpacity = config2.lineOpacity;
                }
                if (lineThickness === void 0 || lineThickness === null) {
                  lineThickness = config2.lineThickness;
                }
                if (fillColor === void 0 || fillColor === null) {
                  fillColor = body.isStatic ? config2.staticFillColor : config2.fillColor;
                }
                if (fillOpacity === void 0 || fillOpacity === null) {
                  fillOpacity = config2.fillOpacity;
                }
                if (lineColor !== false) {
                  render.lineColor = lineColor;
                }
                if (lineOpacity !== false) {
                  render.lineOpacity = lineOpacity;
                }
                if (lineThickness !== false) {
                  render.lineThickness = lineThickness;
                }
                if (fillColor !== false) {
                  render.fillColor = fillColor;
                }
                if (fillOpacity !== false) {
                  render.fillOpacity = fillOpacity;
                }
                return this;
              },
              setConstraintRenderStyle: function(constraint, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
                var render = constraint.render;
                var config2 = this.debugConfig;
                if (!render) {
                  return this;
                }
                if (lineColor === void 0 || lineColor === null) {
                  var type = render.type;
                  if (type === "line") {
                    lineColor = config2.jointColor;
                  } else if (type === "pin") {
                    lineColor = config2.pinColor;
                  } else if (type === "spring") {
                    lineColor = config2.springColor;
                  }
                }
                if (lineOpacity === void 0 || lineOpacity === null) {
                  lineOpacity = config2.jointLineOpacity;
                }
                if (lineThickness === void 0 || lineThickness === null) {
                  lineThickness = config2.jointLineThickness;
                }
                if (pinSize === void 0 || pinSize === null) {
                  pinSize = config2.pinSize;
                }
                if (anchorColor === void 0 || anchorColor === null) {
                  anchorColor = config2.anchorColor;
                }
                if (anchorSize === void 0 || anchorSize === null) {
                  anchorSize = config2.anchorSize;
                }
                if (lineColor !== false) {
                  render.lineColor = lineColor;
                }
                if (lineOpacity !== false) {
                  render.lineOpacity = lineOpacity;
                }
                if (lineThickness !== false) {
                  render.lineThickness = lineThickness;
                }
                if (pinSize !== false) {
                  render.pinSize = pinSize;
                }
                if (anchorColor !== false) {
                  render.anchorColor = anchorColor;
                }
                if (anchorSize !== false) {
                  render.anchorSize = anchorSize;
                }
                return this;
              },
              setEventsProxy: function() {
                var _this = this;
                var engine = this.engine;
                var world = this.localWorld;
                if (this.drawDebug) {
                  MatterEvents.on(world, "compositeModified", function(composite) {
                    _this.setCompositeRenderStyle(composite);
                  });
                  MatterEvents.on(world, "beforeAdd", function(event) {
                    var objects = [].concat(event.object);
                    for (var i = 0; i < objects.length; i++) {
                      var obj = objects[i];
                      var render = obj.render;
                      if (obj.type === "body") {
                        _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
                      } else if (obj.type === "composite") {
                        _this.setCompositeRenderStyle(obj);
                      } else if (obj.type === "constraint") {
                        _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
                      }
                    }
                  });
                }
                MatterEvents.on(world, "beforeAdd", function(event) {
                  _this.emit(Events.BEFORE_ADD, event);
                });
                MatterEvents.on(world, "afterAdd", function(event) {
                  _this.emit(Events.AFTER_ADD, event);
                });
                MatterEvents.on(world, "beforeRemove", function(event) {
                  _this.emit(Events.BEFORE_REMOVE, event);
                });
                MatterEvents.on(world, "afterRemove", function(event) {
                  _this.emit(Events.AFTER_REMOVE, event);
                });
                MatterEvents.on(engine, "beforeUpdate", function(event) {
                  _this.emit(Events.BEFORE_UPDATE, event);
                });
                MatterEvents.on(engine, "afterUpdate", function(event) {
                  _this.emit(Events.AFTER_UPDATE, event);
                });
                MatterEvents.on(engine, "collisionStart", function(event) {
                  var pairs = event.pairs;
                  var bodyA;
                  var bodyB;
                  if (pairs.length > 0) {
                    bodyA = pairs[0].bodyA;
                    bodyB = pairs[0].bodyB;
                  }
                  _this.emit(Events.COLLISION_START, event, bodyA, bodyB);
                });
                MatterEvents.on(engine, "collisionActive", function(event) {
                  var pairs = event.pairs;
                  var bodyA;
                  var bodyB;
                  if (pairs.length > 0) {
                    bodyA = pairs[0].bodyA;
                    bodyB = pairs[0].bodyB;
                  }
                  _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);
                });
                MatterEvents.on(engine, "collisionEnd", function(event) {
                  var pairs = event.pairs;
                  var bodyA;
                  var bodyB;
                  if (pairs.length > 0) {
                    bodyA = pairs[0].bodyA;
                    bodyB = pairs[0].bodyB;
                  }
                  _this.emit(Events.COLLISION_END, event, bodyA, bodyB);
                });
              },
              setBounds: function(x, y, width, height, thickness, left, right, top, bottom) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = this.scene.sys.scale.width;
                }
                if (height === void 0) {
                  height = this.scene.sys.scale.height;
                }
                if (thickness === void 0) {
                  thickness = 64;
                }
                if (left === void 0) {
                  left = true;
                }
                if (right === void 0) {
                  right = true;
                }
                if (top === void 0) {
                  top = true;
                }
                if (bottom === void 0) {
                  bottom = true;
                }
                this.updateWall(left, "left", x - thickness, y - thickness, thickness, height + thickness * 2);
                this.updateWall(right, "right", x + width, y - thickness, thickness, height + thickness * 2);
                this.updateWall(top, "top", x, y - thickness, width, thickness);
                this.updateWall(bottom, "bottom", x, y + height, width, thickness);
                return this;
              },
              updateWall: function(add, position, x, y, width, height) {
                var wall = this.walls[position];
                if (add) {
                  if (wall) {
                    MatterWorld.remove(this.localWorld, wall);
                  }
                  x += width / 2;
                  y += height / 2;
                  this.walls[position] = this.create(x, y, width, height, {isStatic: true, friction: 0, frictionStatic: 0});
                } else {
                  if (wall) {
                    MatterWorld.remove(this.localWorld, wall);
                  }
                  this.walls[position] = null;
                }
              },
              createDebugGraphic: function() {
                var graphic = this.scene.sys.add.graphics({x: 0, y: 0});
                graphic.setDepth(Number.MAX_VALUE);
                this.debugGraphic = graphic;
                this.drawDebug = true;
                return graphic;
              },
              disableGravity: function() {
                this.localWorld.gravity.x = 0;
                this.localWorld.gravity.y = 0;
                this.localWorld.gravity.scale = 0;
                return this;
              },
              setGravity: function(x, y, scale) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 1;
                }
                if (scale === void 0) {
                  scale = 1e-3;
                }
                this.localWorld.gravity.x = x;
                this.localWorld.gravity.y = y;
                this.localWorld.gravity.scale = scale;
                return this;
              },
              create: function(x, y, width, height, options) {
                var body = Bodies.rectangle(x, y, width, height, options);
                MatterWorld.add(this.localWorld, body);
                return body;
              },
              add: function(object) {
                MatterWorld.add(this.localWorld, object);
                return this;
              },
              remove: function(object, deep) {
                if (!Array.isArray(object)) {
                  object = [object];
                }
                for (var i = 0; i < object.length; i++) {
                  var entity = object[i];
                  var body = entity.body ? entity.body : entity;
                  Composite.remove(this.localWorld, body, deep);
                }
                return this;
              },
              removeConstraint: function(constraint, deep) {
                Composite.remove(this.localWorld, constraint, deep);
                return this;
              },
              convertTilemapLayer: function(tilemapLayer, options) {
                var layerData = tilemapLayer.layer;
                var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, {isColliding: true});
                this.convertTiles(tiles, options);
                return this;
              },
              convertTiles: function(tiles, options) {
                if (tiles.length === 0) {
                  return this;
                }
                for (var i = 0; i < tiles.length; i++) {
                  new MatterTileBody(this, tiles[i], options);
                }
                return this;
              },
              nextGroup: function(isNonColliding) {
                return MatterBody.nextGroup(isNonColliding);
              },
              nextCategory: function() {
                return MatterBody.nextCategory();
              },
              pause: function() {
                this.enabled = false;
                this.emit(Events.PAUSE);
                return this;
              },
              resume: function() {
                this.enabled = true;
                this.emit(Events.RESUME);
                return this;
              },
              update: function(time, delta) {
                if (!this.enabled || !this.autoUpdate) {
                  return;
                }
                var engine = this.engine;
                var runner = this.runner;
                var timing = engine.timing;
                if (runner.isFixed) {
                  delta = this.getDelta(time, delta);
                } else {
                  delta = time - runner.timePrev || runner.delta;
                  runner.timePrev = time;
                  runner.deltaHistory.push(delta);
                  runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
                  delta = Math.min.apply(null, runner.deltaHistory);
                  delta = delta < runner.deltaMin ? runner.deltaMin : delta;
                  delta = delta > runner.deltaMax ? runner.deltaMax : delta;
                  runner.delta = delta;
                }
                runner.timeScalePrev = timing.timeScale;
                runner.frameCounter += 1;
                if (time - runner.counterTimestamp >= 1e3) {
                  runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1e3);
                  runner.counterTimestamp = time;
                  runner.frameCounter = 0;
                }
                Engine.update(engine, delta);
              },
              step: function(delta) {
                Engine.update(this.engine, delta);
              },
              update60Hz: function() {
                return 1e3 / 60;
              },
              update30Hz: function() {
                return 1e3 / 30;
              },
              has: function(body) {
                var src = body.hasOwnProperty("body") ? body.body : body;
                return Composite.get(this.localWorld, src.id, src.type) !== null;
              },
              getAllBodies: function() {
                return Composite.allBodies(this.localWorld);
              },
              getAllConstraints: function() {
                return Composite.allConstraints(this.localWorld);
              },
              getAllComposites: function() {
                return Composite.allComposites(this.localWorld);
              },
              postUpdate: function() {
                if (!this.drawDebug) {
                  return;
                }
                var config2 = this.debugConfig;
                var engine = this.engine;
                var graphics = this.debugGraphic;
                var bodies = Composite.allBodies(this.localWorld);
                this.debugGraphic.clear();
                if (config2.showBroadphase && engine.broadphase.controller) {
                  this.renderGrid(engine.broadphase, graphics, config2.broadphaseColor, 0.5);
                }
                if (config2.showBounds) {
                  this.renderBodyBounds(bodies, graphics, config2.boundsColor, 0.5);
                }
                if (config2.showBody || config2.showStaticBody) {
                  this.renderBodies(bodies);
                }
                if (config2.showJoint) {
                  this.renderJoints();
                }
                if (config2.showAxes || config2.showAngleIndicator) {
                  this.renderBodyAxes(bodies, graphics, config2.showAxes, config2.angleColor, 0.5);
                }
                if (config2.showVelocity) {
                  this.renderBodyVelocity(bodies, graphics, config2.velocityColor, 1, 2);
                }
                if (config2.showSeparations) {
                  this.renderSeparations(engine.pairs.list, graphics, config2.separationColor);
                }
                if (config2.showCollisions) {
                  this.renderCollisions(engine.pairs.list, graphics, config2.collisionColor);
                }
              },
              renderGrid: function(grid, graphics, lineColor, lineOpacity) {
                graphics.lineStyle(1, lineColor, lineOpacity);
                var bucketKeys = Common.keys(grid.buckets);
                for (var i = 0; i < bucketKeys.length; i++) {
                  var bucketId = bucketKeys[i];
                  if (grid.buckets[bucketId].length < 2) {
                    continue;
                  }
                  var region = bucketId.split(/C|R/);
                  graphics.strokeRect(parseInt(region[1], 10) * grid.bucketWidth, parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight);
                }
                return this;
              },
              renderSeparations: function(pairs, graphics, lineColor) {
                graphics.lineStyle(1, lineColor, 1);
                for (var i = 0; i < pairs.length; i++) {
                  var pair = pairs[i];
                  if (!pair.isActive) {
                    continue;
                  }
                  var collision = pair.collision;
                  var bodyA = collision.bodyA;
                  var bodyB = collision.bodyB;
                  var posA = bodyA.position;
                  var posB = bodyB.position;
                  var penetration = collision.penetration;
                  var k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
                  if (bodyB.isStatic) {
                    k = 0;
                  }
                  graphics.lineBetween(posB.x, posB.y, posB.x - penetration.x * k, posB.y - penetration.y * k);
                  k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
                  if (bodyA.isStatic) {
                    k = 0;
                  }
                  graphics.lineBetween(posA.x, posA.y, posA.x - penetration.x * k, posA.y - penetration.y * k);
                }
                return this;
              },
              renderCollisions: function(pairs, graphics, lineColor) {
                graphics.lineStyle(1, lineColor, 0.5);
                graphics.fillStyle(lineColor, 1);
                var i;
                var pair;
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive) {
                    continue;
                  }
                  for (var j = 0; j < pair.activeContacts.length; j++) {
                    var contact = pair.activeContacts[j];
                    var vertex = contact.vertex;
                    graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);
                  }
                }
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive) {
                    continue;
                  }
                  var collision = pair.collision;
                  var contacts = pair.activeContacts;
                  if (contacts.length > 0) {
                    var normalPosX = contacts[0].vertex.x;
                    var normalPosY = contacts[0].vertex.y;
                    if (contacts.length === 2) {
                      normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2;
                      normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2;
                    }
                    if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic) {
                      graphics.lineBetween(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8, normalPosX, normalPosY);
                    } else {
                      graphics.lineBetween(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8, normalPosX, normalPosY);
                    }
                  }
                }
                return this;
              },
              renderBodyBounds: function(bodies, graphics, lineColor, lineOpacity) {
                graphics.lineStyle(1, lineColor, lineOpacity);
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (!body.render.visible) {
                    continue;
                  }
                  var bounds = body.bounds;
                  if (bounds) {
                    graphics.strokeRect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
                  } else {
                    var parts = body.parts;
                    for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                      var part = parts[j];
                      graphics.strokeRect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                    }
                  }
                }
                return this;
              },
              renderBodyAxes: function(bodies, graphics, showAxes, lineColor, lineOpacity) {
                graphics.lineStyle(1, lineColor, lineOpacity);
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  var parts = body.parts;
                  if (!body.render.visible) {
                    continue;
                  }
                  var part;
                  var j;
                  var k;
                  if (showAxes) {
                    for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                      part = parts[j];
                      for (k = 0; k < part.axes.length; k++) {
                        var axis = part.axes[k];
                        graphics.lineBetween(part.position.x, part.position.y, part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                      }
                    }
                  } else {
                    for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                      part = parts[j];
                      for (k = 0; k < part.axes.length; k++) {
                        graphics.lineBetween(part.position.x, part.position.y, (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
                      }
                    }
                  }
                }
                return this;
              },
              renderBodyVelocity: function(bodies, graphics, lineColor, lineOpacity, lineThickness) {
                graphics.lineStyle(lineThickness, lineColor, lineOpacity);
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (!body.render.visible) {
                    continue;
                  }
                  graphics.lineBetween(body.position.x, body.position.y, body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
                }
                return this;
              },
              renderBodies: function(bodies) {
                var graphics = this.debugGraphic;
                var config2 = this.debugConfig;
                var showBody = config2.showBody;
                var showStaticBody = config2.showStaticBody;
                var showSleeping = config2.showSleeping;
                var showInternalEdges = config2.showInternalEdges;
                var showConvexHulls = config2.showConvexHulls;
                var renderFill = config2.renderFill;
                var renderLine = config2.renderLine;
                var staticBodySleepOpacity = config2.staticBodySleepOpacity;
                var sleepFillColor = config2.sleepFillColor;
                var sleepLineColor = config2.sleepLineColor;
                var hullColor = config2.hullColor;
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (!body.render.visible) {
                    continue;
                  }
                  if (!showStaticBody && body.isStatic || !showBody && !body.isStatic) {
                    continue;
                  }
                  var lineColor = body.render.lineColor;
                  var lineOpacity = body.render.lineOpacity;
                  var lineThickness = body.render.lineThickness;
                  var fillColor = body.render.fillColor;
                  var fillOpacity = body.render.fillOpacity;
                  if (showSleeping && body.isSleeping) {
                    if (body.isStatic) {
                      lineOpacity *= staticBodySleepOpacity;
                      fillOpacity *= staticBodySleepOpacity;
                    } else {
                      lineColor = sleepLineColor;
                      fillColor = sleepFillColor;
                    }
                  }
                  if (!renderFill) {
                    fillColor = null;
                  }
                  if (!renderLine) {
                    lineColor = null;
                  }
                  this.renderBody(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity);
                  var partsLength = body.parts.length;
                  if (showConvexHulls && partsLength > 1) {
                    this.renderConvexHull(body, graphics, hullColor, lineThickness);
                  }
                }
              },
              renderBody: function(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
                if (lineColor === void 0) {
                  lineColor = null;
                }
                if (lineOpacity === void 0) {
                  lineOpacity = null;
                }
                if (lineThickness === void 0) {
                  lineThickness = 1;
                }
                if (fillColor === void 0) {
                  fillColor = null;
                }
                if (fillOpacity === void 0) {
                  fillOpacity = null;
                }
                var config2 = this.debugConfig;
                var sensorFillColor = config2.sensorFillColor;
                var sensorLineColor = config2.sensorLineColor;
                var parts = body.parts;
                var partsLength = parts.length;
                for (var k = partsLength > 1 ? 1 : 0; k < partsLength; k++) {
                  var part = parts[k];
                  var render = part.render;
                  var opacity = render.opacity;
                  if (!render.visible || opacity === 0 || part.isSensor && !config2.showSensors) {
                    continue;
                  }
                  var circleRadius = part.circleRadius;
                  graphics.beginPath();
                  if (part.isSensor) {
                    if (fillColor !== null) {
                      graphics.fillStyle(sensorFillColor, fillOpacity * opacity);
                    }
                    if (lineColor !== null) {
                      graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity);
                    }
                  } else {
                    if (fillColor !== null) {
                      graphics.fillStyle(fillColor, fillOpacity * opacity);
                    }
                    if (lineColor !== null) {
                      graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity);
                    }
                  }
                  if (circleRadius) {
                    graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);
                  } else {
                    var vertices = part.vertices;
                    var vertLength = vertices.length;
                    graphics.moveTo(vertices[0].x, vertices[0].y);
                    for (var j = 1; j < vertLength; j++) {
                      var vert = vertices[j];
                      if (!vertices[j - 1].isInternal || showInternalEdges) {
                        graphics.lineTo(vert.x, vert.y);
                      } else {
                        graphics.moveTo(vert.x, vert.y);
                      }
                      if (j < vertLength && vert.isInternal && !showInternalEdges) {
                        var nextIndex = (j + 1) % vertLength;
                        graphics.moveTo(vertices[nextIndex].x, vertices[nextIndex].y);
                      }
                    }
                    graphics.closePath();
                  }
                  if (fillColor !== null) {
                    graphics.fillPath();
                  }
                  if (lineColor !== null) {
                    graphics.strokePath();
                  }
                }
                if (config2.showPositions && !body.isStatic) {
                  var px = body.position.x;
                  var py = body.position.y;
                  var hs = Math.ceil(config2.positionSize / 2);
                  graphics.fillStyle(config2.positionColor, 1);
                  graphics.fillRect(px - hs, py - hs, config2.positionSize, config2.positionSize);
                }
                return this;
              },
              renderConvexHull: function(body, graphics, hullColor, lineThickness) {
                if (lineThickness === void 0) {
                  lineThickness = 1;
                }
                var parts = body.parts;
                var partsLength = parts.length;
                if (partsLength > 1) {
                  var verts = body.vertices;
                  graphics.lineStyle(lineThickness, hullColor);
                  graphics.beginPath();
                  graphics.moveTo(verts[0].x, verts[0].y);
                  for (var v = 1; v < verts.length; v++) {
                    graphics.lineTo(verts[v].x, verts[v].y);
                  }
                  graphics.lineTo(verts[0].x, verts[0].y);
                  graphics.strokePath();
                }
                return this;
              },
              renderJoints: function() {
                var graphics = this.debugGraphic;
                var constraints = Composite.allConstraints(this.localWorld);
                for (var i = 0; i < constraints.length; i++) {
                  var config2 = constraints[i].render;
                  var lineColor = config2.lineColor;
                  var lineOpacity = config2.lineOpacity;
                  var lineThickness = config2.lineThickness;
                  var pinSize = config2.pinSize;
                  var anchorColor = config2.anchorColor;
                  var anchorSize = config2.anchorSize;
                  this.renderConstraint(constraints[i], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);
                }
              },
              renderConstraint: function(constraint, graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
                var render = constraint.render;
                if (!render.visible || !constraint.pointA || !constraint.pointB) {
                  return this;
                }
                graphics.lineStyle(lineThickness, lineColor, lineOpacity);
                var bodyA = constraint.bodyA;
                var bodyB = constraint.bodyB;
                var start;
                var end;
                if (bodyA) {
                  start = Vector.add(bodyA.position, constraint.pointA);
                } else {
                  start = constraint.pointA;
                }
                if (render.type === "pin") {
                  graphics.strokeCircle(start.x, start.y, pinSize);
                } else {
                  if (bodyB) {
                    end = Vector.add(bodyB.position, constraint.pointB);
                  } else {
                    end = constraint.pointB;
                  }
                  graphics.beginPath();
                  graphics.moveTo(start.x, start.y);
                  if (render.type === "spring") {
                    var delta = Vector.sub(end, start);
                    var normal = Vector.perp(Vector.normalise(delta));
                    var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));
                    var offset;
                    for (var j = 1; j < coils; j += 1) {
                      offset = j % 2 === 0 ? 1 : -1;
                      graphics.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);
                    }
                  }
                  graphics.lineTo(end.x, end.y);
                }
                graphics.strokePath();
                if (render.anchors && anchorSize > 0) {
                  graphics.fillStyle(anchorColor);
                  graphics.fillCircle(start.x, start.y, anchorSize);
                  graphics.fillCircle(end.x, end.y, anchorSize);
                }
                return this;
              },
              resetCollisionIDs: function() {
                Body._nextCollidingGroupId = 1;
                Body._nextNonCollidingGroupId = -1;
                Body._nextCategory = 1;
                return this;
              },
              shutdown: function() {
                MatterEvents.off(this.engine);
                this.removeAllListeners();
                MatterWorld.clear(this.localWorld, false);
                Engine.clear(this.engine);
                if (this.drawDebug) {
                  this.debugGraphic.destroy();
                }
              },
              destroy: function() {
                this.shutdown();
              }
            });
            module2.exports = World;
          },
          95349: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bounce = {
              setBounce: function(value) {
                this.body.restitution = value;
                return this;
              }
            };
            module2.exports = Bounce;
          },
          70679: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Collision = {
              setCollisionCategory: function(value) {
                this.body.collisionFilter.category = value;
                return this;
              },
              setCollisionGroup: function(value) {
                this.body.collisionFilter.group = value;
                return this;
              },
              setCollidesWith: function(categories) {
                var flags = 0;
                if (!Array.isArray(categories)) {
                  flags = categories;
                } else {
                  for (var i = 0; i < categories.length; i++) {
                    flags |= categories[i];
                  }
                }
                this.body.collisionFilter.mask = flags;
                return this;
              },
              setOnCollide: function(callback) {
                this.body.onCollideCallback = callback;
                return this;
              },
              setOnCollideEnd: function(callback) {
                this.body.onCollideEndCallback = callback;
                return this;
              },
              setOnCollideActive: function(callback) {
                this.body.onCollideActiveCallback = callback;
                return this;
              },
              setOnCollideWith: function(body, callback) {
                if (!Array.isArray(body)) {
                  body = [body];
                }
                for (var i = 0; i < body.length; i++) {
                  var src = body[i].hasOwnProperty("body") ? body[i].body : body[i];
                  this.body.setOnCollideWith(src, callback);
                }
                return this;
              }
            };
            module2.exports = Collision;
          },
          77178: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Body = __webpack_require__2(84125);
            var Force = {
              applyForce: function(force) {
                this._tempVec2.set(this.body.position.x, this.body.position.y);
                Body.applyForce(this.body, this._tempVec2, force);
                return this;
              },
              applyForceFrom: function(position, force) {
                Body.applyForce(this.body, position, force);
                return this;
              },
              thrust: function(speed) {
                var angle = this.body.angle;
                this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
                Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
                return this;
              },
              thrustLeft: function(speed) {
                var angle = this.body.angle - Math.PI / 2;
                this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
                Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
                return this;
              },
              thrustRight: function(speed) {
                var angle = this.body.angle + Math.PI / 2;
                this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
                Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
                return this;
              },
              thrustBack: function(speed) {
                var angle = this.body.angle - Math.PI;
                this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
                Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
                return this;
              }
            };
            module2.exports = Force;
          },
          74015: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Friction = {
              setFriction: function(value, air, fstatic) {
                this.body.friction = value;
                if (air !== void 0) {
                  this.body.frictionAir = air;
                }
                if (fstatic !== void 0) {
                  this.body.frictionStatic = fstatic;
                }
                return this;
              },
              setFrictionAir: function(value) {
                this.body.frictionAir = value;
                return this;
              },
              setFrictionStatic: function(value) {
                this.body.frictionStatic = value;
                return this;
              }
            };
            module2.exports = Friction;
          },
          11535: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Gravity = {
              setIgnoreGravity: function(value) {
                this.body.ignoreGravity = value;
                return this;
              }
            };
            module2.exports = Gravity;
          },
          74497: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Body = __webpack_require__2(84125);
            var Vector2 = __webpack_require__2(93736);
            var Mass = {
              setMass: function(value) {
                Body.setMass(this.body, value);
                return this;
              },
              setDensity: function(value) {
                Body.setDensity(this.body, value);
                return this;
              },
              centerOfMass: {
                get: function() {
                  return new Vector2(this.body.centerOfMass.x, this.body.centerOfMass.y);
                }
              }
            };
            module2.exports = Mass;
          },
          75529: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Sensor = {
              setSensor: function(value) {
                this.body.isSensor = value;
                return this;
              },
              isSensor: function() {
                return this.body.isSensor;
              }
            };
            module2.exports = Sensor;
          },
          64024: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bodies = __webpack_require__2(68516);
            var Body = __webpack_require__2(84125);
            var FuzzyEquals = __webpack_require__2(88456);
            var GetFastValue = __webpack_require__2(72632);
            var PhysicsEditorParser = __webpack_require__2(10998);
            var PhysicsJSONParser = __webpack_require__2(72829);
            var Vertices = __webpack_require__2(39745);
            var SetBody = {
              setRectangle: function(width, height, options) {
                return this.setBody({type: "rectangle", width, height}, options);
              },
              setCircle: function(radius, options) {
                return this.setBody({type: "circle", radius}, options);
              },
              setPolygon: function(radius, sides, options) {
                return this.setBody({type: "polygon", sides, radius}, options);
              },
              setTrapezoid: function(width, height, slope, options) {
                return this.setBody({type: "trapezoid", width, height, slope}, options);
              },
              setExistingBody: function(body, addToWorld) {
                if (addToWorld === void 0) {
                  addToWorld = true;
                }
                if (this.body) {
                  this.world.remove(this.body, true);
                }
                this.body = body;
                for (var i = 0; i < body.parts.length; i++) {
                  body.parts[i].gameObject = this;
                }
                var _this = this;
                body.destroy = function destroy() {
                  _this.world.remove(_this.body, true);
                  _this.body.gameObject = null;
                };
                if (addToWorld) {
                  if (this.world.has(body)) {
                    this.world.remove(body, true);
                  }
                  this.world.add(body);
                }
                if (this._originComponent) {
                  var rx = body.render.sprite.xOffset;
                  var ry = body.render.sprite.yOffset;
                  var comx = body.centerOfMass.x;
                  var comy = body.centerOfMass.y;
                  if (FuzzyEquals(comx, 0.5) && FuzzyEquals(comy, 0.5)) {
                    this.setOrigin(rx + 0.5, ry + 0.5);
                  } else {
                    var cx = body.centerOffset.x;
                    var cy = body.centerOffset.y;
                    this.setOrigin(rx + cx / this.displayWidth, ry + cy / this.displayHeight);
                  }
                }
                return this;
              },
              setBody: function(config2, options) {
                if (!config2) {
                  return this;
                }
                var body;
                if (typeof config2 === "string") {
                  config2 = {type: config2};
                }
                var shapeType = GetFastValue(config2, "type", "rectangle");
                var bodyX = GetFastValue(config2, "x", this._tempVec2.x);
                var bodyY = GetFastValue(config2, "y", this._tempVec2.y);
                var bodyWidth = GetFastValue(config2, "width", this.width);
                var bodyHeight = GetFastValue(config2, "height", this.height);
                switch (shapeType) {
                  case "rectangle":
                    body = Bodies.rectangle(bodyX, bodyY, bodyWidth, bodyHeight, options);
                    break;
                  case "circle":
                    var radius = GetFastValue(config2, "radius", Math.max(bodyWidth, bodyHeight) / 2);
                    var maxSides = GetFastValue(config2, "maxSides", 25);
                    body = Bodies.circle(bodyX, bodyY, radius, options, maxSides);
                    break;
                  case "trapezoid":
                    var slope = GetFastValue(config2, "slope", 0.5);
                    body = Bodies.trapezoid(bodyX, bodyY, bodyWidth, bodyHeight, slope, options);
                    break;
                  case "polygon":
                    var sides = GetFastValue(config2, "sides", 5);
                    var pRadius = GetFastValue(config2, "radius", Math.max(bodyWidth, bodyHeight) / 2);
                    body = Bodies.polygon(bodyX, bodyY, sides, pRadius, options);
                    break;
                  case "fromVertices":
                  case "fromVerts":
                    var verts = GetFastValue(config2, "verts", null);
                    if (verts) {
                      if (typeof verts === "string") {
                        verts = Vertices.fromPath(verts);
                      }
                      if (this.body && !this.body.hasOwnProperty("temp")) {
                        Body.setVertices(this.body, verts);
                        body = this.body;
                      } else {
                        var flagInternal = GetFastValue(config2, "flagInternal", false);
                        var removeCollinear = GetFastValue(config2, "removeCollinear", 0.01);
                        var minimumArea = GetFastValue(config2, "minimumArea", 10);
                        body = Bodies.fromVertices(bodyX, bodyY, verts, options, flagInternal, removeCollinear, minimumArea);
                      }
                    }
                    break;
                  case "fromPhysicsEditor":
                    body = PhysicsEditorParser.parseBody(bodyX, bodyY, config2, options);
                    break;
                  case "fromPhysicsTracer":
                    body = PhysicsJSONParser.parseBody(bodyX, bodyY, config2, options);
                    break;
                }
                if (body) {
                  this.setExistingBody(body, config2.addToWorld);
                }
                return this;
              }
            };
            module2.exports = SetBody;
          },
          25106: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Events = __webpack_require__2(35416);
            var Sleeping = __webpack_require__2(22806);
            var MatterEvents = __webpack_require__2(39073);
            var Sleep = {
              setToSleep: function() {
                Sleeping.set(this.body, true);
                return this;
              },
              setAwake: function() {
                Sleeping.set(this.body, false);
                return this;
              },
              setSleepThreshold: function(value) {
                if (value === void 0) {
                  value = 60;
                }
                this.body.sleepThreshold = value;
                return this;
              },
              setSleepEvents: function(start, end) {
                this.setSleepStartEvent(start);
                this.setSleepEndEvent(end);
                return this;
              },
              setSleepStartEvent: function(value) {
                if (value) {
                  var world = this.world;
                  MatterEvents.on(this.body, "sleepStart", function(event) {
                    world.emit(Events.SLEEP_START, event, this);
                  });
                } else {
                  MatterEvents.off(this.body, "sleepStart");
                }
                return this;
              },
              setSleepEndEvent: function(value) {
                if (value) {
                  var world = this.world;
                  MatterEvents.on(this.body, "sleepEnd", function(event) {
                    world.emit(Events.SLEEP_END, event, this);
                  });
                } else {
                  MatterEvents.off(this.body, "sleepEnd");
                }
                return this;
              }
            };
            module2.exports = Sleep;
          },
          82884: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Body = __webpack_require__2(84125);
            var Static = {
              setStatic: function(value) {
                Body.setStatic(this.body, value);
                return this;
              },
              isStatic: function() {
                return this.body.isStatic;
              }
            };
            module2.exports = Static;
          },
          4753: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Body = __webpack_require__2(84125);
            var MATH_CONST = __webpack_require__2(83392);
            var WrapAngle = __webpack_require__2(35786);
            var WrapAngleDegrees = __webpack_require__2(62138);
            var _FLAG = 4;
            var Transform = {
              x: {
                get: function() {
                  return this.body.position.x;
                },
                set: function(value) {
                  this._tempVec2.set(value, this.y);
                  Body.setPosition(this.body, this._tempVec2);
                }
              },
              y: {
                get: function() {
                  return this.body.position.y;
                },
                set: function(value) {
                  this._tempVec2.set(this.x, value);
                  Body.setPosition(this.body, this._tempVec2);
                }
              },
              scaleX: {
                get: function() {
                  return this._scaleX;
                },
                set: function(value) {
                  var factorX = 1 / this._scaleX;
                  var factorY = 1 / this._scaleY;
                  this._scaleX = value;
                  if (this._scaleX === 0) {
                    this.renderFlags &= ~_FLAG;
                  } else {
                    this.renderFlags |= _FLAG;
                  }
                  Body.scale(this.body, factorX, factorY);
                  Body.scale(this.body, value, this._scaleY);
                }
              },
              scaleY: {
                get: function() {
                  return this._scaleY;
                },
                set: function(value) {
                  var factorX = 1 / this._scaleX;
                  var factorY = 1 / this._scaleY;
                  this._scaleY = value;
                  if (this._scaleY === 0) {
                    this.renderFlags &= ~_FLAG;
                  } else {
                    this.renderFlags |= _FLAG;
                  }
                  Body.scale(this.body, factorX, factorY);
                  Body.scale(this.body, this._scaleX, value);
                }
              },
              angle: {
                get: function() {
                  return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);
                },
                set: function(value) {
                  this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
                }
              },
              rotation: {
                get: function() {
                  return this.body.angle;
                },
                set: function(value) {
                  this._rotation = WrapAngle(value);
                  Body.setAngle(this.body, this._rotation);
                }
              },
              setPosition: function(x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = x;
                }
                this._tempVec2.set(x, y);
                Body.setPosition(this.body, this._tempVec2);
                return this;
              },
              setRotation: function(radians) {
                if (radians === void 0) {
                  radians = 0;
                }
                this._rotation = WrapAngle(radians);
                Body.setAngle(this.body, radians);
                return this;
              },
              setFixedRotation: function() {
                Body.setInertia(this.body, Infinity);
                return this;
              },
              setAngle: function(degrees) {
                if (degrees === void 0) {
                  degrees = 0;
                }
                this.angle = degrees;
                Body.setAngle(this.body, this.rotation);
                return this;
              },
              setScale: function(x, y, point) {
                if (x === void 0) {
                  x = 1;
                }
                if (y === void 0) {
                  y = x;
                }
                var factorX = 1 / this._scaleX;
                var factorY = 1 / this._scaleY;
                this._scaleX = x;
                this._scaleY = y;
                Body.scale(this.body, factorX, factorY, point);
                Body.scale(this.body, x, y, point);
                return this;
              }
            };
            module2.exports = Transform;
          },
          37268: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Body = __webpack_require__2(84125);
            var Velocity = {
              setVelocityX: function(x) {
                this._tempVec2.set(x, this.body.velocity.y);
                Body.setVelocity(this.body, this._tempVec2);
                return this;
              },
              setVelocityY: function(y) {
                this._tempVec2.set(this.body.velocity.x, y);
                Body.setVelocity(this.body, this._tempVec2);
                return this;
              },
              setVelocity: function(x, y) {
                this._tempVec2.set(x, y);
                Body.setVelocity(this.body, this._tempVec2);
                return this;
              },
              getVelocity: function() {
                return Body.getVelocity(this.body);
              },
              setAngularVelocity: function(velocity) {
                Body.setAngularVelocity(this.body, velocity);
                return this;
              },
              getAngularVelocity: function() {
                return Body.getAngularVelocity(this.body);
              },
              setAngularSpeed: function(speed) {
                Body.setAngularSpeed(this.body, speed);
                return this;
              },
              getAngularSpeed: function() {
                return Body.getAngularSpeed(this.body);
              }
            };
            module2.exports = Velocity;
          },
          74527: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Bounce: __webpack_require__2(95349),
              Collision: __webpack_require__2(70679),
              Force: __webpack_require__2(77178),
              Friction: __webpack_require__2(74015),
              Gravity: __webpack_require__2(11535),
              Mass: __webpack_require__2(74497),
              Sensor: __webpack_require__2(75529),
              SetBody: __webpack_require__2(64024),
              Sleep: __webpack_require__2(25106),
              Static: __webpack_require__2(82884),
              Transform: __webpack_require__2(4753),
              Velocity: __webpack_require__2(37268)
            };
          },
          63201: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "afteradd";
          },
          30474: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "afterremove";
          },
          44822: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "afterupdate";
          },
          88820: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "beforeadd";
          },
          94849: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "beforeremove";
          },
          6391: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "beforeupdate";
          },
          96738: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "collisionactive";
          },
          7916: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "collisionend";
          },
          59529: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "collisionstart";
          },
          10219: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragend";
          },
          183: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "drag";
          },
          39143: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "dragstart";
          },
          16483: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pause";
          },
          35806: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resume";
          },
          22106: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "sleepend";
          },
          5803: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "sleepstart";
          },
          35416: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              AFTER_ADD: __webpack_require__2(63201),
              AFTER_REMOVE: __webpack_require__2(30474),
              AFTER_UPDATE: __webpack_require__2(44822),
              BEFORE_ADD: __webpack_require__2(88820),
              BEFORE_REMOVE: __webpack_require__2(94849),
              BEFORE_UPDATE: __webpack_require__2(6391),
              COLLISION_ACTIVE: __webpack_require__2(96738),
              COLLISION_END: __webpack_require__2(7916),
              COLLISION_START: __webpack_require__2(59529),
              DRAG_END: __webpack_require__2(10219),
              DRAG: __webpack_require__2(183),
              DRAG_START: __webpack_require__2(39143),
              PAUSE: __webpack_require__2(16483),
              RESUME: __webpack_require__2(35806),
              SLEEP_END: __webpack_require__2(22106),
              SLEEP_START: __webpack_require__2(5803)
            };
          },
          45949: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BodyBounds: __webpack_require__2(63568),
              Components: __webpack_require__2(74527),
              Events: __webpack_require__2(35416),
              Factory: __webpack_require__2(72653),
              MatterGameObject: __webpack_require__2(3860),
              Image: __webpack_require__2(7030),
              Matter: __webpack_require__2(18171),
              MatterPhysics: __webpack_require__2(50583),
              PolyDecomp: __webpack_require__2(81084),
              Sprite: __webpack_require__2(73658),
              TileBody: __webpack_require__2(84720),
              PhysicsEditorParser: __webpack_require__2(10998),
              PhysicsJSONParser: __webpack_require__2(72829),
              PointerConstraint: __webpack_require__2(88596),
              World: __webpack_require__2(31468)
            };
          },
          84125: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Body = {};
            module2.exports = Body;
            var Vertices = __webpack_require__2(39745);
            var Vector = __webpack_require__2(10438);
            var Sleeping = __webpack_require__2(22806);
            var Common = __webpack_require__2(68758);
            var Bounds = __webpack_require__2(84091);
            var Axes = __webpack_require__2(50658);
            (function() {
              Body._timeCorrection = true;
              Body._inertiaScale = 4;
              Body._nextCollidingGroupId = 1;
              Body._nextNonCollidingGroupId = -1;
              Body._nextCategory = 1;
              Body._baseDelta = 1e3 / 60;
              Body.create = function(options) {
                var defaults = {
                  id: Common.nextId(),
                  type: "body",
                  label: "Body",
                  parts: [],
                  plugin: {},
                  angle: 0,
                  vertices: null,
                  position: {x: 0, y: 0},
                  force: {x: 0, y: 0},
                  torque: 0,
                  positionImpulse: {x: 0, y: 0},
                  constraintImpulse: {x: 0, y: 0, angle: 0},
                  totalContacts: 0,
                  speed: 0,
                  angularSpeed: 0,
                  velocity: {x: 0, y: 0},
                  angularVelocity: 0,
                  isSensor: false,
                  isStatic: false,
                  isSleeping: false,
                  motion: 0,
                  sleepThreshold: 60,
                  density: 1e-3,
                  restitution: 0,
                  friction: 0.1,
                  frictionStatic: 0.5,
                  frictionAir: 0.01,
                  collisionFilter: {
                    category: 1,
                    mask: 4294967295,
                    group: 0
                  },
                  slop: 0.05,
                  timeScale: 1,
                  events: null,
                  bounds: null,
                  chamfer: null,
                  circleRadius: 0,
                  positionPrev: null,
                  anglePrev: 0,
                  parent: null,
                  axes: null,
                  area: 0,
                  mass: 0,
                  inverseMass: 0,
                  inertia: 0,
                  deltaTime: 1e3 / 60,
                  inverseInertia: 0,
                  _original: null,
                  render: {
                    visible: true,
                    opacity: 1,
                    sprite: {
                      xOffset: 0,
                      yOffset: 0
                    },
                    fillColor: null,
                    fillOpacity: null,
                    lineColor: null,
                    lineOpacity: null,
                    lineThickness: null
                  },
                  gameObject: null,
                  scale: {x: 1, y: 1},
                  centerOfMass: {x: 0, y: 0},
                  centerOffset: {x: 0, y: 0},
                  gravityScale: {x: 1, y: 1},
                  ignoreGravity: false,
                  ignorePointer: false,
                  onCollideCallback: null,
                  onCollideEndCallback: null,
                  onCollideActiveCallback: null,
                  onCollideWith: {}
                };
                if (!options.hasOwnProperty("position") && options.hasOwnProperty("vertices")) {
                  options.position = Vertices.centre(options.vertices);
                } else if (!options.hasOwnProperty("vertices")) {
                  defaults.vertices = Vertices.fromPath("L 0 0 L 40 0 L 40 40 L 0 40");
                }
                var body = Common.extend(defaults, options);
                _initProperties(body, options);
                body.setOnCollideWith = function(body2, callback) {
                  if (callback) {
                    this.onCollideWith[body2.id] = callback;
                  } else {
                    delete this.onCollideWith[body2.id];
                  }
                  return this;
                };
                return body;
              };
              Body.nextGroup = function(isNonColliding) {
                if (isNonColliding)
                  return Body._nextNonCollidingGroupId--;
                return Body._nextCollidingGroupId++;
              };
              Body.nextCategory = function() {
                Body._nextCategory = Body._nextCategory << 1;
                return Body._nextCategory;
              };
              var _initProperties = function(body, options) {
                options = options || {};
                Body.set(body, {
                  bounds: body.bounds || Bounds.create(body.vertices),
                  positionPrev: body.positionPrev || Vector.clone(body.position),
                  anglePrev: body.anglePrev || body.angle,
                  vertices: body.vertices,
                  parts: body.parts || [body],
                  isStatic: body.isStatic,
                  isSleeping: body.isSleeping,
                  parent: body.parent || body
                });
                Vertices.rotate(body.vertices, body.angle, body.position);
                Axes.rotate(body.axes, body.angle);
                Bounds.update(body.bounds, body.vertices, body.velocity);
                Body.set(body, {
                  axes: options.axes || body.axes,
                  area: options.area || body.area,
                  mass: options.mass || body.mass,
                  inertia: options.inertia || body.inertia
                });
                if (body.parts.length === 1) {
                  var bounds = body.bounds;
                  var centerOfMass = body.centerOfMass;
                  var centerOffset = body.centerOffset;
                  var bodyWidth = bounds.max.x - bounds.min.x;
                  var bodyHeight = bounds.max.y - bounds.min.y;
                  centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth;
                  centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight;
                  centerOffset.x = bodyWidth * centerOfMass.x;
                  centerOffset.y = bodyHeight * centerOfMass.y;
                }
              };
              Body.set = function(body, settings, value) {
                var property;
                if (typeof settings === "string") {
                  property = settings;
                  settings = {};
                  settings[property] = value;
                }
                for (property in settings) {
                  if (!Object.prototype.hasOwnProperty.call(settings, property))
                    continue;
                  value = settings[property];
                  switch (property) {
                    case "isStatic":
                      Body.setStatic(body, value);
                      break;
                    case "isSleeping":
                      Sleeping.set(body, value);
                      break;
                    case "mass":
                      Body.setMass(body, value);
                      break;
                    case "density":
                      Body.setDensity(body, value);
                      break;
                    case "inertia":
                      Body.setInertia(body, value);
                      break;
                    case "vertices":
                      Body.setVertices(body, value);
                      break;
                    case "position":
                      Body.setPosition(body, value);
                      break;
                    case "angle":
                      Body.setAngle(body, value);
                      break;
                    case "velocity":
                      Body.setVelocity(body, value);
                      break;
                    case "angularVelocity":
                      Body.setAngularVelocity(body, value);
                      break;
                    case "speed":
                      Body.setSpeed(body, value);
                      break;
                    case "angularSpeed":
                      Body.setAngularSpeed(body, value);
                      break;
                    case "parts":
                      Body.setParts(body, value);
                      break;
                    case "centre":
                      Body.setCentre(body, value);
                      break;
                    default:
                      body[property] = value;
                  }
                }
              };
              Body.setStatic = function(body, isStatic) {
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  if (isStatic) {
                    if (!part.isStatic) {
                      part._original = {
                        restitution: part.restitution,
                        friction: part.friction,
                        mass: part.mass,
                        inertia: part.inertia,
                        density: part.density,
                        inverseMass: part.inverseMass,
                        inverseInertia: part.inverseInertia
                      };
                    }
                    part.restitution = 0;
                    part.friction = 1;
                    part.mass = part.inertia = part.density = Infinity;
                    part.inverseMass = part.inverseInertia = 0;
                    part.positionPrev.x = part.position.x;
                    part.positionPrev.y = part.position.y;
                    part.anglePrev = part.angle;
                    part.angularVelocity = 0;
                    part.speed = 0;
                    part.angularSpeed = 0;
                    part.motion = 0;
                  } else if (part._original) {
                    part.restitution = part._original.restitution;
                    part.friction = part._original.friction;
                    part.mass = part._original.mass;
                    part.inertia = part._original.inertia;
                    part.density = part._original.density;
                    part.inverseMass = part._original.inverseMass;
                    part.inverseInertia = part._original.inverseInertia;
                    part._original = null;
                  }
                  part.isStatic = isStatic;
                }
              };
              Body.setMass = function(body, mass) {
                var moment = body.inertia / (body.mass / 6);
                body.inertia = moment * (mass / 6);
                body.inverseInertia = 1 / body.inertia;
                body.mass = mass;
                body.inverseMass = 1 / body.mass;
                body.density = body.mass / body.area;
              };
              Body.setDensity = function(body, density) {
                Body.setMass(body, density * body.area);
                body.density = density;
              };
              Body.setInertia = function(body, inertia) {
                body.inertia = inertia;
                body.inverseInertia = 1 / body.inertia;
              };
              Body.setVertices = function(body, vertices) {
                if (vertices[0].body === body) {
                  body.vertices = vertices;
                } else {
                  body.vertices = Vertices.create(vertices, body);
                }
                body.axes = Axes.fromVertices(body.vertices);
                body.area = Vertices.area(body.vertices);
                Body.setMass(body, body.density * body.area);
                var centre = Vertices.centre(body.vertices);
                Vertices.translate(body.vertices, centre, -1);
                Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));
                Vertices.translate(body.vertices, body.position);
                Bounds.update(body.bounds, body.vertices, body.velocity);
              };
              Body.setParts = function(body, parts, autoHull) {
                var i;
                parts = parts.slice(0);
                body.parts.length = 0;
                body.parts.push(body);
                body.parent = body;
                for (i = 0; i < parts.length; i++) {
                  var part = parts[i];
                  if (part !== body) {
                    part.parent = body;
                    body.parts.push(part);
                  }
                }
                if (body.parts.length === 1)
                  return;
                autoHull = typeof autoHull !== "undefined" ? autoHull : true;
                if (autoHull) {
                  var vertices = [];
                  for (i = 0; i < parts.length; i++) {
                    vertices = vertices.concat(parts[i].vertices);
                  }
                  Vertices.clockwiseSort(vertices);
                  var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);
                  Body.setVertices(body, hull);
                  Vertices.translate(body.vertices, hullCentre);
                }
                var total = Body._totalProperties(body);
                var cx = total.centre.x;
                var cy = total.centre.y;
                var bounds = body.bounds;
                var centerOfMass = body.centerOfMass;
                var centerOffset = body.centerOffset;
                Bounds.update(bounds, body.vertices, body.velocity);
                centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x);
                centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y);
                centerOffset.x = cx;
                centerOffset.y = cy;
                body.area = total.area;
                body.parent = body;
                body.position.x = cx;
                body.position.y = cy;
                body.positionPrev.x = cx;
                body.positionPrev.y = cy;
                Body.setMass(body, total.mass);
                Body.setInertia(body, total.inertia);
                Body.setPosition(body, total.centre);
              };
              Body.setCentre = function(body, centre, relative) {
                if (!relative) {
                  body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);
                  body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);
                  body.position.x = centre.x;
                  body.position.y = centre.y;
                } else {
                  body.positionPrev.x += centre.x;
                  body.positionPrev.y += centre.y;
                  body.position.x += centre.x;
                  body.position.y += centre.y;
                }
              };
              Body.setPosition = function(body, position, updateVelocity) {
                var delta = Vector.sub(position, body.position);
                if (updateVelocity) {
                  body.positionPrev.x = body.position.x;
                  body.positionPrev.y = body.position.y;
                  body.velocity.x = delta.x;
                  body.velocity.y = delta.y;
                  body.speed = Vector.magnitude(delta);
                } else {
                  body.positionPrev.x += delta.x;
                  body.positionPrev.y += delta.y;
                }
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  part.position.x += delta.x;
                  part.position.y += delta.y;
                  Vertices.translate(part.vertices, delta);
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                }
              };
              Body.setAngle = function(body, angle, updateVelocity) {
                var delta = angle - body.angle;
                if (updateVelocity) {
                  body.anglePrev = body.angle;
                  body.angularVelocity = delta;
                  body.angularSpeed = Math.abs(delta);
                } else {
                  body.anglePrev += delta;
                }
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  part.angle += delta;
                  Vertices.rotate(part.vertices, delta, body.position);
                  Axes.rotate(part.axes, delta);
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                  if (i > 0) {
                    Vector.rotateAbout(part.position, delta, body.position, part.position);
                  }
                }
              };
              Body.setVelocity = function(body, velocity) {
                var timeScale = body.deltaTime / Body._baseDelta;
                body.positionPrev.x = body.position.x - velocity.x * timeScale;
                body.positionPrev.y = body.position.y - velocity.y * timeScale;
                body.velocity.x = (body.position.x - body.positionPrev.x) / timeScale;
                body.velocity.y = (body.position.y - body.positionPrev.y) / timeScale;
                body.speed = Vector.magnitude(body.velocity);
              };
              Body.getVelocity = function(body) {
                var timeScale = Body._baseDelta / body.deltaTime;
                return {
                  x: (body.position.x - body.positionPrev.x) * timeScale,
                  y: (body.position.y - body.positionPrev.y) * timeScale
                };
              };
              Body.getSpeed = function(body) {
                return Vector.magnitude(Body.getVelocity(body));
              };
              Body.setSpeed = function(body, speed) {
                Body.setVelocity(body, Vector.mult(Vector.normalise(Body.getVelocity(body)), speed));
              };
              Body.setAngularVelocity = function(body, velocity) {
                var timeScale = body.deltaTime / Body._baseDelta;
                body.anglePrev = body.angle - velocity * timeScale;
                body.angularVelocity = (body.angle - body.anglePrev) / timeScale;
                body.angularSpeed = Math.abs(body.angularVelocity);
              };
              Body.getAngularVelocity = function(body) {
                return (body.angle - body.anglePrev) * Body._baseDelta / body.deltaTime;
              };
              Body.getAngularSpeed = function(body) {
                return Math.abs(Body.getAngularVelocity(body));
              };
              Body.setAngularSpeed = function(body, speed) {
                Body.setAngularVelocity(body, Common.sign(Body.getAngularVelocity(body)) * speed);
              };
              Body.translate = function(body, translation, updateVelocity) {
                Body.setPosition(body, Vector.add(body.position, translation), updateVelocity);
              };
              Body.rotate = function(body, rotation, point, updateVelocity) {
                if (!point) {
                  Body.setAngle(body, body.angle + rotation, updateVelocity);
                } else {
                  var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;
                  Body.setPosition(body, {
                    x: point.x + (dx * cos - dy * sin),
                    y: point.y + (dx * sin + dy * cos)
                  }, updateVelocity);
                  Body.setAngle(body, body.angle + rotation, updateVelocity);
                }
              };
              Body.scale = function(body, scaleX, scaleY, point) {
                var totalArea = 0, totalInertia = 0;
                point = point || body.position;
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  part.scale.x = scaleX;
                  part.scale.y = scaleY;
                  Vertices.scale(part.vertices, scaleX, scaleY, point);
                  part.axes = Axes.fromVertices(part.vertices);
                  part.area = Vertices.area(part.vertices);
                  Body.setMass(part, body.density * part.area);
                  Vertices.translate(part.vertices, {x: -part.position.x, y: -part.position.y});
                  Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));
                  Vertices.translate(part.vertices, {x: part.position.x, y: part.position.y});
                  if (i > 0) {
                    totalArea += part.area;
                    totalInertia += part.inertia;
                  }
                  part.position.x = point.x + (part.position.x - point.x) * scaleX;
                  part.position.y = point.y + (part.position.y - point.y) * scaleY;
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                }
                if (body.parts.length > 1) {
                  body.area = totalArea;
                  if (!body.isStatic) {
                    Body.setMass(body, body.density * totalArea);
                    Body.setInertia(body, totalInertia);
                  }
                }
                if (body.circleRadius) {
                  if (scaleX === scaleY) {
                    body.circleRadius *= scaleX;
                  } else {
                    body.circleRadius = null;
                  }
                }
              };
              Body.update = function(body, deltaTime) {
                deltaTime = (typeof deltaTime !== "undefined" ? deltaTime : 1e3 / 60) * body.timeScale;
                var deltaTimeSquared = deltaTime * deltaTime, correction = Body._timeCorrection ? deltaTime / (body.deltaTime || deltaTime) : 1;
                var frictionAir = 1 - body.frictionAir * (deltaTime / Common._baseDelta), velocityPrevX = (body.position.x - body.positionPrev.x) * correction, velocityPrevY = (body.position.y - body.positionPrev.y) * correction;
                body.velocity.x = velocityPrevX * frictionAir + body.force.x / body.mass * deltaTimeSquared;
                body.velocity.y = velocityPrevY * frictionAir + body.force.y / body.mass * deltaTimeSquared;
                body.positionPrev.x = body.position.x;
                body.positionPrev.y = body.position.y;
                body.position.x += body.velocity.x;
                body.position.y += body.velocity.y;
                body.deltaTime = deltaTime;
                body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;
                body.anglePrev = body.angle;
                body.angle += body.angularVelocity;
                body.speed = Vector.magnitude(body.velocity);
                body.angularSpeed = Math.abs(body.angularVelocity);
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  Vertices.translate(part.vertices, body.velocity);
                  if (i > 0) {
                    part.position.x += body.velocity.x;
                    part.position.y += body.velocity.y;
                  }
                  if (body.angularVelocity !== 0) {
                    Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                    Axes.rotate(part.axes, body.angularVelocity);
                    if (i > 0) {
                      Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                    }
                  }
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                }
              };
              Body.updateVelocities = function(body) {
                var timeScale = Body._baseDelta / body.deltaTime, bodyVelocity = body.velocity;
                bodyVelocity.x = (body.position.x - body.positionPrev.x) * timeScale;
                bodyVelocity.y = (body.position.y - body.positionPrev.y) * timeScale;
                body.speed = Math.sqrt(bodyVelocity.x * bodyVelocity.x + bodyVelocity.y * bodyVelocity.y);
                body.angularVelocity = (body.angle - body.anglePrev) * timeScale;
                body.angularSpeed = Math.abs(body.angularVelocity);
              };
              Body.applyForce = function(body, position, force) {
                var offset = {x: position.x - body.position.x, y: position.y - body.position.y};
                body.force.x += force.x;
                body.force.y += force.y;
                body.torque += offset.x * force.y - offset.y * force.x;
              };
              Body._totalProperties = function(body) {
                var properties = {
                  mass: 0,
                  area: 0,
                  inertia: 0,
                  centre: {x: 0, y: 0}
                };
                for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
                  var part = body.parts[i], mass = part.mass !== Infinity ? part.mass : 1;
                  properties.mass += mass;
                  properties.area += part.area;
                  properties.inertia += part.inertia;
                  properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
                }
                properties.centre = Vector.div(properties.centre, properties.mass);
                return properties;
              };
            })();
          },
          11299: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Composite = {};
            module2.exports = Composite;
            var Events = __webpack_require__2(39073);
            var Common = __webpack_require__2(68758);
            var Bounds = __webpack_require__2(84091);
            var Body = __webpack_require__2(84125);
            (function() {
              Composite.create = function(options) {
                return Common.extend({
                  id: Common.nextId(),
                  type: "composite",
                  parent: null,
                  isModified: false,
                  bodies: [],
                  constraints: [],
                  composites: [],
                  label: "Composite",
                  plugin: {},
                  cache: {
                    allBodies: null,
                    allConstraints: null,
                    allComposites: null
                  }
                }, options);
              };
              Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
                Events.trigger(composite, "compositeModified", composite);
                composite.isModified = isModified;
                if (isModified && composite.cache) {
                  composite.cache.allBodies = null;
                  composite.cache.allConstraints = null;
                  composite.cache.allComposites = null;
                }
                if (updateParents && composite.parent) {
                  Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
                }
                if (updateChildren) {
                  for (var i = 0; i < composite.composites.length; i++) {
                    var childComposite = composite.composites[i];
                    Composite.setModified(childComposite, isModified, updateParents, updateChildren);
                  }
                }
              };
              Composite.add = function(composite, object) {
                var objects = [].concat(object);
                Events.trigger(composite, "beforeAdd", {object});
                for (var i = 0; i < objects.length; i++) {
                  var obj = objects[i];
                  switch (obj.type) {
                    case "body":
                      if (obj.parent !== obj) {
                        Common.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                        break;
                      }
                      Composite.addBody(composite, obj);
                      break;
                    case "constraint":
                      Composite.addConstraint(composite, obj);
                      break;
                    case "composite":
                      Composite.addComposite(composite, obj);
                      break;
                    case "mouseConstraint":
                      Composite.addConstraint(composite, obj.constraint);
                      break;
                  }
                }
                Events.trigger(composite, "afterAdd", {object});
                return composite;
              };
              Composite.remove = function(composite, object, deep) {
                var objects = [].concat(object);
                Events.trigger(composite, "beforeRemove", {object});
                for (var i = 0; i < objects.length; i++) {
                  var obj = objects[i];
                  switch (obj.type) {
                    case "body":
                      Composite.removeBody(composite, obj, deep);
                      break;
                    case "constraint":
                      Composite.removeConstraint(composite, obj, deep);
                      break;
                    case "composite":
                      Composite.removeComposite(composite, obj, deep);
                      break;
                    case "mouseConstraint":
                      Composite.removeConstraint(composite, obj.constraint);
                      break;
                  }
                }
                Events.trigger(composite, "afterRemove", {object});
                return composite;
              };
              Composite.addComposite = function(compositeA, compositeB) {
                compositeA.composites.push(compositeB);
                compositeB.parent = compositeA;
                Composite.setModified(compositeA, true, true, false);
                return compositeA;
              };
              Composite.removeComposite = function(compositeA, compositeB, deep) {
                var position = Common.indexOf(compositeA.composites, compositeB);
                if (position !== -1) {
                  Composite.removeCompositeAt(compositeA, position);
                }
                if (deep) {
                  for (var i = 0; i < compositeA.composites.length; i++) {
                    Composite.removeComposite(compositeA.composites[i], compositeB, true);
                  }
                }
                return compositeA;
              };
              Composite.removeCompositeAt = function(composite, position) {
                composite.composites.splice(position, 1);
                Composite.setModified(composite, true, true, false);
                return composite;
              };
              Composite.addBody = function(composite, body) {
                composite.bodies.push(body);
                Composite.setModified(composite, true, true, false);
                return composite;
              };
              Composite.removeBody = function(composite, body, deep) {
                var position = Common.indexOf(composite.bodies, body);
                if (position !== -1) {
                  Composite.removeBodyAt(composite, position);
                }
                if (deep) {
                  for (var i = 0; i < composite.composites.length; i++) {
                    Composite.removeBody(composite.composites[i], body, true);
                  }
                }
                return composite;
              };
              Composite.removeBodyAt = function(composite, position) {
                composite.bodies.splice(position, 1);
                Composite.setModified(composite, true, true, false);
                return composite;
              };
              Composite.addConstraint = function(composite, constraint) {
                composite.constraints.push(constraint);
                Composite.setModified(composite, true, true, false);
                return composite;
              };
              Composite.removeConstraint = function(composite, constraint, deep) {
                var position = Common.indexOf(composite.constraints, constraint);
                if (position !== -1) {
                  Composite.removeConstraintAt(composite, position);
                }
                if (deep) {
                  for (var i = 0; i < composite.composites.length; i++) {
                    Composite.removeConstraint(composite.composites[i], constraint, true);
                  }
                }
                return composite;
              };
              Composite.removeConstraintAt = function(composite, position) {
                composite.constraints.splice(position, 1);
                Composite.setModified(composite, true, true, false);
                return composite;
              };
              Composite.clear = function(composite, keepStatic, deep) {
                if (deep) {
                  for (var i = 0; i < composite.composites.length; i++) {
                    Composite.clear(composite.composites[i], keepStatic, true);
                  }
                }
                if (keepStatic) {
                  composite.bodies = composite.bodies.filter(function(body) {
                    return body.isStatic;
                  });
                } else {
                  composite.bodies.length = 0;
                }
                composite.constraints.length = 0;
                composite.composites.length = 0;
                Composite.setModified(composite, true, true, false);
                return composite;
              };
              Composite.allBodies = function(composite) {
                if (composite.cache && composite.cache.allBodies) {
                  return composite.cache.allBodies;
                }
                var bodies = [].concat(composite.bodies);
                for (var i = 0; i < composite.composites.length; i++)
                  bodies = bodies.concat(Composite.allBodies(composite.composites[i]));
                if (composite.cache) {
                  composite.cache.allBodies = bodies;
                }
                return bodies;
              };
              Composite.allConstraints = function(composite) {
                if (composite.cache && composite.cache.allConstraints) {
                  return composite.cache.allConstraints;
                }
                var constraints = [].concat(composite.constraints);
                for (var i = 0; i < composite.composites.length; i++)
                  constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));
                if (composite.cache) {
                  composite.cache.allConstraints = constraints;
                }
                return constraints;
              };
              Composite.allComposites = function(composite) {
                if (composite.cache && composite.cache.allComposites) {
                  return composite.cache.allComposites;
                }
                var composites = [].concat(composite.composites);
                for (var i = 0; i < composite.composites.length; i++)
                  composites = composites.concat(Composite.allComposites(composite.composites[i]));
                if (composite.cache) {
                  composite.cache.allComposites = composites;
                }
                return composites;
              };
              Composite.get = function(composite, id, type) {
                var objects, object;
                switch (type) {
                  case "body":
                    objects = Composite.allBodies(composite);
                    break;
                  case "constraint":
                    objects = Composite.allConstraints(composite);
                    break;
                  case "composite":
                    objects = Composite.allComposites(composite).concat(composite);
                    break;
                }
                if (!objects)
                  return null;
                object = objects.filter(function(object2) {
                  return object2.id.toString() === id.toString();
                });
                return object.length === 0 ? null : object[0];
              };
              Composite.move = function(compositeA, objects, compositeB) {
                Composite.remove(compositeA, objects);
                Composite.add(compositeB, objects);
                return compositeA;
              };
              Composite.rebase = function(composite) {
                var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));
                for (var i = 0; i < objects.length; i++) {
                  objects[i].id = Common.nextId();
                }
                return composite;
              };
              Composite.translate = function(composite, translation, recursive) {
                var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
                for (var i = 0; i < bodies.length; i++) {
                  Body.translate(bodies[i], translation);
                }
                return composite;
              };
              Composite.rotate = function(composite, rotation, point, recursive) {
                var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                  Body.setPosition(body, {
                    x: point.x + (dx * cos - dy * sin),
                    y: point.y + (dx * sin + dy * cos)
                  });
                  Body.rotate(body, rotation);
                }
                return composite;
              };
              Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
                var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                  Body.setPosition(body, {
                    x: point.x + dx * scaleX,
                    y: point.y + dy * scaleY
                  });
                  Body.scale(body, scaleX, scaleY);
                }
                return composite;
              };
              Composite.bounds = function(composite) {
                var bodies = Composite.allBodies(composite), vertices = [];
                for (var i = 0; i < bodies.length; i += 1) {
                  var body = bodies[i];
                  vertices.push(body.bounds.min, body.bounds.max);
                }
                return Bounds.create(vertices);
              };
            })();
          },
          72005: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var World = {};
            module2.exports = World;
            var Composite = __webpack_require__2(11299);
            (function() {
              World.create = Composite.create;
              World.add = Composite.add;
              World.remove = Composite.remove;
              World.clear = Composite.clear;
              World.addComposite = Composite.addComposite;
              World.addBody = Composite.addBody;
              World.addConstraint = Composite.addConstraint;
            })();
          },
          63454: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Collision = {};
            module2.exports = Collision;
            var Vertices = __webpack_require__2(39745);
            var Pair = __webpack_require__2(70584);
            (function() {
              var _supports = [];
              var _overlapAB = {
                overlap: 0,
                axis: null
              };
              var _overlapBA = {
                overlap: 0,
                axis: null
              };
              Collision.create = function(bodyA, bodyB) {
                return {
                  pair: null,
                  collided: false,
                  bodyA,
                  bodyB,
                  parentA: bodyA.parent,
                  parentB: bodyB.parent,
                  depth: 0,
                  normal: {x: 0, y: 0},
                  tangent: {x: 0, y: 0},
                  penetration: {x: 0, y: 0},
                  supports: []
                };
              };
              Collision.collides = function(bodyA, bodyB, pairs) {
                Collision._overlapAxes(_overlapAB, bodyA.vertices, bodyB.vertices, bodyA.axes);
                if (_overlapAB.overlap <= 0) {
                  return null;
                }
                Collision._overlapAxes(_overlapBA, bodyB.vertices, bodyA.vertices, bodyB.axes);
                if (_overlapBA.overlap <= 0) {
                  return null;
                }
                var pair = pairs && pairs.table[Pair.id(bodyA, bodyB)], collision;
                if (!pair) {
                  collision = Collision.create(bodyA, bodyB);
                  collision.collided = true;
                  collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
                  collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
                  collision.parentA = collision.bodyA.parent;
                  collision.parentB = collision.bodyB.parent;
                } else {
                  collision = pair.collision;
                }
                bodyA = collision.bodyA;
                bodyB = collision.bodyB;
                var minOverlap;
                if (_overlapAB.overlap < _overlapBA.overlap) {
                  minOverlap = _overlapAB;
                } else {
                  minOverlap = _overlapBA;
                }
                var normal = collision.normal, supports = collision.supports, minAxis = minOverlap.axis, minAxisX = minAxis.x, minAxisY = minAxis.y;
                if (minAxisX * (bodyB.position.x - bodyA.position.x) + minAxisY * (bodyB.position.y - bodyA.position.y) < 0) {
                  normal.x = minAxisX;
                  normal.y = minAxisY;
                } else {
                  normal.x = -minAxisX;
                  normal.y = -minAxisY;
                }
                collision.tangent.x = -normal.y;
                collision.tangent.y = normal.x;
                collision.depth = minOverlap.overlap;
                collision.penetration.x = normal.x * collision.depth;
                collision.penetration.y = normal.y * collision.depth;
                var supportsB = Collision._findSupports(bodyA, bodyB, normal, 1), supportCount = 0;
                if (Vertices.contains(bodyA.vertices, supportsB[0])) {
                  supports[supportCount++] = supportsB[0];
                }
                if (Vertices.contains(bodyA.vertices, supportsB[1])) {
                  supports[supportCount++] = supportsB[1];
                }
                if (supportCount < 2) {
                  var supportsA = Collision._findSupports(bodyB, bodyA, normal, -1);
                  if (Vertices.contains(bodyB.vertices, supportsA[0])) {
                    supports[supportCount++] = supportsA[0];
                  }
                  if (supportCount < 2 && Vertices.contains(bodyB.vertices, supportsA[1])) {
                    supports[supportCount++] = supportsA[1];
                  }
                }
                if (supportCount === 0) {
                  supports[supportCount++] = supportsB[0];
                }
                supports.length = supportCount;
                return collision;
              };
              Collision._overlapAxes = function(result, verticesA, verticesB, axes) {
                var verticesALength = verticesA.length, verticesBLength = verticesB.length, verticesAX = verticesA[0].x, verticesAY = verticesA[0].y, verticesBX = verticesB[0].x, verticesBY = verticesB[0].y, axesLength = axes.length, overlapMin = Number.MAX_VALUE, overlapAxisNumber = 0, overlap, overlapAB, overlapBA, dot, i, j;
                for (i = 0; i < axesLength; i++) {
                  var axis = axes[i], axisX = axis.x, axisY = axis.y, minA = verticesAX * axisX + verticesAY * axisY, minB = verticesBX * axisX + verticesBY * axisY, maxA = minA, maxB = minB;
                  for (j = 1; j < verticesALength; j += 1) {
                    dot = verticesA[j].x * axisX + verticesA[j].y * axisY;
                    if (dot > maxA) {
                      maxA = dot;
                    } else if (dot < minA) {
                      minA = dot;
                    }
                  }
                  for (j = 1; j < verticesBLength; j += 1) {
                    dot = verticesB[j].x * axisX + verticesB[j].y * axisY;
                    if (dot > maxB) {
                      maxB = dot;
                    } else if (dot < minB) {
                      minB = dot;
                    }
                  }
                  overlapAB = maxA - minB;
                  overlapBA = maxB - minA;
                  overlap = overlapAB < overlapBA ? overlapAB : overlapBA;
                  if (overlap < overlapMin) {
                    overlapMin = overlap;
                    overlapAxisNumber = i;
                    if (overlap <= 0) {
                      break;
                    }
                  }
                }
                result.axis = axes[overlapAxisNumber];
                result.overlap = overlapMin;
              };
              Collision._projectToAxis = function(projection, vertices, axis) {
                var min = vertices[0].x * axis.x + vertices[0].y * axis.y, max = min;
                for (var i = 1; i < vertices.length; i += 1) {
                  var dot = vertices[i].x * axis.x + vertices[i].y * axis.y;
                  if (dot > max) {
                    max = dot;
                  } else if (dot < min) {
                    min = dot;
                  }
                }
                projection.min = min;
                projection.max = max;
              };
              Collision._findSupports = function(bodyA, bodyB, normal, direction) {
                var vertices = bodyB.vertices, verticesLength = vertices.length, bodyAPositionX = bodyA.position.x, bodyAPositionY = bodyA.position.y, normalX = normal.x * direction, normalY = normal.y * direction, nearestDistance = Number.MAX_VALUE, vertexA, vertexB, vertexC, distance, j;
                for (j = 0; j < verticesLength; j += 1) {
                  vertexB = vertices[j];
                  distance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y);
                  if (distance < nearestDistance) {
                    nearestDistance = distance;
                    vertexA = vertexB;
                  }
                }
                vertexC = vertices[(verticesLength + vertexA.index - 1) % verticesLength];
                nearestDistance = normalX * (bodyAPositionX - vertexC.x) + normalY * (bodyAPositionY - vertexC.y);
                vertexB = vertices[(vertexA.index + 1) % verticesLength];
                if (normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y) < nearestDistance) {
                  _supports[0] = vertexA;
                  _supports[1] = vertexB;
                  return _supports;
                }
                _supports[0] = vertexA;
                _supports[1] = vertexC;
                return _supports;
              };
            })();
          },
          17319: (module2) => {
            var Contact = {};
            module2.exports = Contact;
            (function() {
              Contact.create = function(vertex) {
                return {
                  vertex,
                  normalImpulse: 0,
                  tangentImpulse: 0
                };
              };
            })();
          },
          13657: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Detector = {};
            module2.exports = Detector;
            var Common = __webpack_require__2(68758);
            var Collision = __webpack_require__2(63454);
            (function() {
              Detector.create = function(options) {
                var defaults = {
                  bodies: [],
                  pairs: null
                };
                return Common.extend(defaults, options);
              };
              Detector.setBodies = function(detector, bodies) {
                detector.bodies = bodies.slice(0);
              };
              Detector.clear = function(detector) {
                detector.bodies = [];
              };
              Detector.collisions = function(detector) {
                var collisions = [], pairs = detector.pairs, bodies = detector.bodies, bodiesLength = bodies.length, canCollide = Detector.canCollide, collides = Collision.collides, i, j;
                bodies.sort(Detector._compareBoundsX);
                for (i = 0; i < bodiesLength; i++) {
                  var bodyA = bodies[i], boundsA = bodyA.bounds, boundXMax = bodyA.bounds.max.x, boundYMax = bodyA.bounds.max.y, boundYMin = bodyA.bounds.min.y, bodyAStatic = bodyA.isStatic || bodyA.isSleeping, partsALength = bodyA.parts.length, partsASingle = partsALength === 1;
                  for (j = i + 1; j < bodiesLength; j++) {
                    var bodyB = bodies[j], boundsB = bodyB.bounds;
                    if (boundsB.min.x > boundXMax) {
                      break;
                    }
                    if (boundYMax < boundsB.min.y || boundYMin > boundsB.max.y) {
                      continue;
                    }
                    if (bodyAStatic && (bodyB.isStatic || bodyB.isSleeping)) {
                      continue;
                    }
                    if (!canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) {
                      continue;
                    }
                    var partsBLength = bodyB.parts.length;
                    if (partsASingle && partsBLength === 1) {
                      var collision = collides(bodyA, bodyB, pairs);
                      if (collision) {
                        collisions.push(collision);
                      }
                    } else {
                      var partsAStart = partsALength > 1 ? 1 : 0, partsBStart = partsBLength > 1 ? 1 : 0;
                      for (var k = partsAStart; k < partsALength; k++) {
                        var partA = bodyA.parts[k], boundsA = partA.bounds;
                        for (var z = partsBStart; z < partsBLength; z++) {
                          var partB = bodyB.parts[z], boundsB = partB.bounds;
                          if (boundsA.min.x > boundsB.max.x || boundsA.max.x < boundsB.min.x || boundsA.max.y < boundsB.min.y || boundsA.min.y > boundsB.max.y) {
                            continue;
                          }
                          var collision = collides(partA, partB, pairs);
                          if (collision) {
                            collisions.push(collision);
                          }
                        }
                      }
                    }
                  }
                }
                return collisions;
              };
              Detector.canCollide = function(filterA, filterB) {
                if (filterA.group === filterB.group && filterA.group !== 0)
                  return filterA.group > 0;
                return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
              };
              Detector._compareBoundsX = function(bodyA, bodyB) {
                return bodyA.bounds.min.x - bodyB.bounds.min.x;
              };
            })();
          },
          70584: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Pair = {};
            module2.exports = Pair;
            var Contact = __webpack_require__2(17319);
            (function() {
              Pair.create = function(collision, timestamp) {
                var bodyA = collision.bodyA, bodyB = collision.bodyB;
                var pair = {
                  id: Pair.id(bodyA, bodyB),
                  bodyA,
                  bodyB,
                  collision,
                  contacts: [],
                  activeContacts: [],
                  separation: 0,
                  isActive: true,
                  confirmedActive: true,
                  isSensor: bodyA.isSensor || bodyB.isSensor,
                  timeCreated: timestamp,
                  timeUpdated: timestamp,
                  inverseMass: 0,
                  friction: 0,
                  frictionStatic: 0,
                  restitution: 0,
                  slop: 0
                };
                Pair.update(pair, collision, timestamp);
                return pair;
              };
              Pair.update = function(pair, collision, timestamp) {
                var contacts = pair.contacts, supports = collision.supports, activeContacts = pair.activeContacts, parentA = collision.parentA, parentB = collision.parentB, parentAVerticesLength = parentA.vertices.length;
                pair.isActive = true;
                pair.timeUpdated = timestamp;
                pair.collision = collision;
                pair.separation = collision.depth;
                pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
                pair.friction = parentA.friction < parentB.friction ? parentA.friction : parentB.friction;
                pair.frictionStatic = parentA.frictionStatic > parentB.frictionStatic ? parentA.frictionStatic : parentB.frictionStatic;
                pair.restitution = parentA.restitution > parentB.restitution ? parentA.restitution : parentB.restitution;
                pair.slop = parentA.slop > parentB.slop ? parentA.slop : parentB.slop;
                collision.pair = pair;
                activeContacts.length = 0;
                for (var i = 0; i < supports.length; i++) {
                  var support = supports[i], contactId = support.body === parentA ? support.index : parentAVerticesLength + support.index, contact = contacts[contactId];
                  if (contact) {
                    activeContacts.push(contact);
                  } else {
                    activeContacts.push(contacts[contactId] = Contact.create(support));
                  }
                }
              };
              Pair.setActive = function(pair, isActive, timestamp) {
                if (isActive) {
                  pair.isActive = true;
                  pair.timeUpdated = timestamp;
                } else {
                  pair.isActive = false;
                  pair.activeContacts.length = 0;
                }
              };
              Pair.id = function(bodyA, bodyB) {
                if (bodyA.id < bodyB.id) {
                  return "A" + bodyA.id + "B" + bodyB.id;
                } else {
                  return "A" + bodyB.id + "B" + bodyA.id;
                }
              };
            })();
          },
          91327: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Pairs = {};
            module2.exports = Pairs;
            var Pair = __webpack_require__2(70584);
            var Common = __webpack_require__2(68758);
            (function() {
              Pairs.create = function(options) {
                return Common.extend({
                  table: {},
                  list: [],
                  collisionStart: [],
                  collisionActive: [],
                  collisionEnd: []
                }, options);
              };
              Pairs.update = function(pairs, collisions, timestamp) {
                var pairsList = pairs.list, pairsListLength = pairsList.length, pairsTable = pairs.table, collisionsLength = collisions.length, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collision, pairIndex, pair, i;
                collisionStart.length = 0;
                collisionEnd.length = 0;
                collisionActive.length = 0;
                for (i = 0; i < pairsListLength; i++) {
                  pairsList[i].confirmedActive = false;
                }
                for (i = 0; i < collisionsLength; i++) {
                  collision = collisions[i];
                  pair = collision.pair;
                  if (pair) {
                    if (pair.isActive) {
                      collisionActive.push(pair);
                    } else {
                      collisionStart.push(pair);
                    }
                    Pair.update(pair, collision, timestamp);
                    pair.confirmedActive = true;
                  } else {
                    pair = Pair.create(collision, timestamp);
                    pairsTable[pair.id] = pair;
                    collisionStart.push(pair);
                    pairsList.push(pair);
                  }
                }
                var removePairIndex = [];
                pairsListLength = pairsList.length;
                for (i = 0; i < pairsListLength; i++) {
                  pair = pairsList[i];
                  if (!pair.confirmedActive) {
                    Pair.setActive(pair, false, timestamp);
                    collisionEnd.push(pair);
                    if (!pair.collision.bodyA.isSleeping && !pair.collision.bodyB.isSleeping) {
                      removePairIndex.push(i);
                    }
                  }
                }
                for (i = 0; i < removePairIndex.length; i++) {
                  pairIndex = removePairIndex[i] - i;
                  pair = pairsList[pairIndex];
                  pairsList.splice(pairIndex, 1);
                  delete pairsTable[pair.id];
                }
              };
              Pairs.clear = function(pairs) {
                pairs.table = {};
                pairs.list.length = 0;
                pairs.collisionStart.length = 0;
                pairs.collisionActive.length = 0;
                pairs.collisionEnd.length = 0;
                return pairs;
              };
            })();
          },
          13390: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Query = {};
            module2.exports = Query;
            var Vector = __webpack_require__2(10438);
            var Collision = __webpack_require__2(63454);
            var Bounds = __webpack_require__2(84091);
            var Bodies = __webpack_require__2(68516);
            var Vertices = __webpack_require__2(39745);
            (function() {
              Query.collides = function(body, bodies) {
                var collisions = [], bodiesLength = bodies.length, bounds = body.bounds, collides = Collision.collides, overlaps = Bounds.overlaps;
                for (var i = 0; i < bodiesLength; i++) {
                  var bodyA = bodies[i], partsALength = bodyA.parts.length, partsAStart = partsALength === 1 ? 0 : 1;
                  if (body === bodyA) {
                    continue;
                  }
                  if (overlaps(bodyA.bounds, bounds)) {
                    for (var j = partsAStart; j < partsALength; j++) {
                      var part = bodyA.parts[j];
                      if (overlaps(part.bounds, bounds)) {
                        var collision = collides(part, body);
                        if (collision) {
                          collisions.push(collision);
                          break;
                        }
                      }
                    }
                  }
                }
                return collisions;
              };
              Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
                rayWidth = rayWidth || 1e-100;
                var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {angle: rayAngle}), collisions = Query.collides(ray, bodies);
                for (var i = 0; i < collisions.length; i += 1) {
                  var collision = collisions[i];
                  collision.body = collision.bodyB = collision.bodyA;
                }
                return collisions;
              };
              Query.region = function(bodies, bounds, outside) {
                var result = [];
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], overlaps = Bounds.overlaps(body.bounds, bounds);
                  if (overlaps && !outside || !overlaps && outside)
                    result.push(body);
                }
                return result;
              };
              Query.point = function(bodies, point) {
                var result = [];
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (Bounds.contains(body.bounds, point)) {
                    for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                      var part = body.parts[j];
                      if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {
                        result.push(body);
                        break;
                      }
                    }
                  }
                }
                return result;
              };
            })();
          },
          44272: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Resolver = {};
            module2.exports = Resolver;
            var Vertices = __webpack_require__2(39745);
            var Common = __webpack_require__2(68758);
            var Bounds = __webpack_require__2(84091);
            (function() {
              Resolver._restingThresh = 2;
              Resolver._restingThreshTangent = Math.sqrt(6);
              Resolver._positionDampen = 0.9;
              Resolver._positionWarming = 0.8;
              Resolver._frictionNormalMultiplier = 5;
              Resolver._frictionMaxStatic = Number.MAX_VALUE;
              Resolver.preSolvePosition = function(pairs) {
                var i, pair, activeCount, pairsLength = pairs.length;
                for (i = 0; i < pairsLength; i++) {
                  pair = pairs[i];
                  if (!pair.isActive)
                    continue;
                  activeCount = pair.activeContacts.length;
                  pair.collision.parentA.totalContacts += activeCount;
                  pair.collision.parentB.totalContacts += activeCount;
                }
              };
              Resolver.solvePosition = function(pairs, delta, damping) {
                var i, pair, collision, bodyA, bodyB, normal, contactShare, positionImpulse, positionDampen = Resolver._positionDampen * (damping || 1), slopDampen = Common.clamp(delta / Common._baseDelta, 0, 1), pairsLength = pairs.length;
                for (i = 0; i < pairsLength; i++) {
                  pair = pairs[i];
                  if (!pair.isActive || pair.isSensor)
                    continue;
                  collision = pair.collision;
                  bodyA = collision.parentA;
                  bodyB = collision.parentB;
                  normal = collision.normal;
                  pair.separation = normal.x * (bodyB.positionImpulse.x + collision.penetration.x - bodyA.positionImpulse.x) + normal.y * (bodyB.positionImpulse.y + collision.penetration.y - bodyA.positionImpulse.y);
                }
                for (i = 0; i < pairsLength; i++) {
                  pair = pairs[i];
                  if (!pair.isActive || pair.isSensor)
                    continue;
                  collision = pair.collision;
                  bodyA = collision.parentA;
                  bodyB = collision.parentB;
                  normal = collision.normal;
                  positionImpulse = pair.separation - pair.slop * slopDampen;
                  if (bodyA.isStatic || bodyB.isStatic)
                    positionImpulse *= 2;
                  if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    contactShare = positionDampen / bodyA.totalContacts;
                    bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;
                    bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;
                  }
                  if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    contactShare = positionDampen / bodyB.totalContacts;
                    bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;
                    bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;
                  }
                }
              };
              Resolver.postSolvePosition = function(bodies) {
                var positionWarming = Resolver._positionWarming, bodiesLength = bodies.length, verticesTranslate = Vertices.translate, boundsUpdate = Bounds.update;
                for (var i = 0; i < bodiesLength; i++) {
                  var body = bodies[i], positionImpulse = body.positionImpulse, positionImpulseX = positionImpulse.x, positionImpulseY = positionImpulse.y, velocity = body.velocity;
                  body.totalContacts = 0;
                  if (positionImpulseX !== 0 || positionImpulseY !== 0) {
                    for (var j = 0; j < body.parts.length; j++) {
                      var part = body.parts[j];
                      verticesTranslate(part.vertices, positionImpulse);
                      boundsUpdate(part.bounds, part.vertices, velocity);
                      part.position.x += positionImpulseX;
                      part.position.y += positionImpulseY;
                    }
                    body.positionPrev.x += positionImpulseX;
                    body.positionPrev.y += positionImpulseY;
                    if (positionImpulseX * velocity.x + positionImpulseY * velocity.y < 0) {
                      positionImpulse.x = 0;
                      positionImpulse.y = 0;
                    } else {
                      positionImpulse.x *= positionWarming;
                      positionImpulse.y *= positionWarming;
                    }
                  }
                }
              };
              Resolver.preSolveVelocity = function(pairs) {
                var pairsLength = pairs.length, i, j;
                for (i = 0; i < pairsLength; i++) {
                  var pair = pairs[i];
                  if (!pair.isActive || pair.isSensor)
                    continue;
                  var contacts = pair.activeContacts, contactsLength = contacts.length, collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent;
                  for (j = 0; j < contactsLength; j++) {
                    var contact = contacts[j], contactVertex = contact.vertex, normalImpulse = contact.normalImpulse, tangentImpulse = contact.tangentImpulse;
                    if (normalImpulse !== 0 || tangentImpulse !== 0) {
                      var impulseX = normal.x * normalImpulse + tangent.x * tangentImpulse, impulseY = normal.y * normalImpulse + tangent.y * tangentImpulse;
                      if (!(bodyA.isStatic || bodyA.isSleeping)) {
                        bodyA.positionPrev.x += impulseX * bodyA.inverseMass;
                        bodyA.positionPrev.y += impulseY * bodyA.inverseMass;
                        bodyA.anglePrev += bodyA.inverseInertia * ((contactVertex.x - bodyA.position.x) * impulseY - (contactVertex.y - bodyA.position.y) * impulseX);
                      }
                      if (!(bodyB.isStatic || bodyB.isSleeping)) {
                        bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;
                        bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;
                        bodyB.anglePrev -= bodyB.inverseInertia * ((contactVertex.x - bodyB.position.x) * impulseY - (contactVertex.y - bodyB.position.y) * impulseX);
                      }
                    }
                  }
                }
              };
              Resolver.solveVelocity = function(pairs, delta) {
                var timeScale = delta / Common._baseDelta, timeScaleSquared = timeScale * timeScale, timeScaleCubed = timeScaleSquared * timeScale, restingThresh = -Resolver._restingThresh * timeScale, restingThreshTangent = Resolver._restingThreshTangent, frictionNormalMultiplier = Resolver._frictionNormalMultiplier * timeScale, frictionMaxStatic = Resolver._frictionMaxStatic, pairsLength = pairs.length, tangentImpulse, maxFriction, i, j;
                for (i = 0; i < pairsLength; i++) {
                  var pair = pairs[i];
                  if (!pair.isActive || pair.isSensor)
                    continue;
                  var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, bodyAVelocity = bodyA.velocity, bodyBVelocity = bodyB.velocity, normalX = collision.normal.x, normalY = collision.normal.y, tangentX = collision.tangent.x, tangentY = collision.tangent.y, contacts = pair.activeContacts, contactsLength = contacts.length, contactShare = 1 / contactsLength, inverseMassTotal = bodyA.inverseMass + bodyB.inverseMass, friction = pair.friction * pair.frictionStatic * frictionNormalMultiplier;
                  bodyAVelocity.x = bodyA.position.x - bodyA.positionPrev.x;
                  bodyAVelocity.y = bodyA.position.y - bodyA.positionPrev.y;
                  bodyBVelocity.x = bodyB.position.x - bodyB.positionPrev.x;
                  bodyBVelocity.y = bodyB.position.y - bodyB.positionPrev.y;
                  bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
                  bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;
                  for (j = 0; j < contactsLength; j++) {
                    var contact = contacts[j], contactVertex = contact.vertex;
                    var offsetAX = contactVertex.x - bodyA.position.x, offsetAY = contactVertex.y - bodyA.position.y, offsetBX = contactVertex.x - bodyB.position.x, offsetBY = contactVertex.y - bodyB.position.y;
                    var velocityPointAX = bodyAVelocity.x - offsetAY * bodyA.angularVelocity, velocityPointAY = bodyAVelocity.y + offsetAX * bodyA.angularVelocity, velocityPointBX = bodyBVelocity.x - offsetBY * bodyB.angularVelocity, velocityPointBY = bodyBVelocity.y + offsetBX * bodyB.angularVelocity;
                    var relativeVelocityX = velocityPointAX - velocityPointBX, relativeVelocityY = velocityPointAY - velocityPointBY;
                    var normalVelocity = normalX * relativeVelocityX + normalY * relativeVelocityY, tangentVelocity = tangentX * relativeVelocityX + tangentY * relativeVelocityY;
                    var normalOverlap = pair.separation + normalVelocity;
                    var normalForce = Math.min(normalOverlap, 1);
                    normalForce = normalOverlap < 0 ? 0 : normalForce;
                    var frictionLimit = normalForce * friction;
                    if (tangentVelocity < -frictionLimit || tangentVelocity > frictionLimit) {
                      maxFriction = tangentVelocity > 0 ? tangentVelocity : -tangentVelocity;
                      tangentImpulse = pair.friction * (tangentVelocity > 0 ? 1 : -1) * timeScaleCubed;
                      if (tangentImpulse < -maxFriction) {
                        tangentImpulse = -maxFriction;
                      } else if (tangentImpulse > maxFriction) {
                        tangentImpulse = maxFriction;
                      }
                    } else {
                      tangentImpulse = tangentVelocity;
                      maxFriction = frictionMaxStatic;
                    }
                    var oAcN = offsetAX * normalY - offsetAY * normalX, oBcN = offsetBX * normalY - offsetBY * normalX, share = contactShare / (inverseMassTotal + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);
                    var normalImpulse = (1 + pair.restitution) * normalVelocity * share;
                    tangentImpulse *= share;
                    if (normalVelocity < restingThresh) {
                      contact.normalImpulse = 0;
                    } else {
                      var contactNormalImpulse = contact.normalImpulse;
                      contact.normalImpulse += normalImpulse;
                      if (contact.normalImpulse > 0)
                        contact.normalImpulse = 0;
                      normalImpulse = contact.normalImpulse - contactNormalImpulse;
                    }
                    if (tangentVelocity < -restingThreshTangent || tangentVelocity > restingThreshTangent) {
                      contact.tangentImpulse = 0;
                    } else {
                      var contactTangentImpulse = contact.tangentImpulse;
                      contact.tangentImpulse += tangentImpulse;
                      if (contact.tangentImpulse < -maxFriction)
                        contact.tangentImpulse = -maxFriction;
                      if (contact.tangentImpulse > maxFriction)
                        contact.tangentImpulse = maxFriction;
                      tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                    }
                    var impulseX = normalX * normalImpulse + tangentX * tangentImpulse, impulseY = normalY * normalImpulse + tangentY * tangentImpulse;
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                      bodyA.positionPrev.x += impulseX * bodyA.inverseMass;
                      bodyA.positionPrev.y += impulseY * bodyA.inverseMass;
                      bodyA.anglePrev += (offsetAX * impulseY - offsetAY * impulseX) * bodyA.inverseInertia;
                    }
                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                      bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;
                      bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;
                      bodyB.anglePrev -= (offsetBX * impulseY - offsetBY * impulseX) * bodyB.inverseInertia;
                    }
                  }
                }
              };
            })();
          },
          52838: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Constraint = {};
            module2.exports = Constraint;
            var Vertices = __webpack_require__2(39745);
            var Vector = __webpack_require__2(10438);
            var Sleeping = __webpack_require__2(22806);
            var Bounds = __webpack_require__2(84091);
            var Axes = __webpack_require__2(50658);
            var Common = __webpack_require__2(68758);
            (function() {
              Constraint._warming = 0.4;
              Constraint._torqueDampen = 1;
              Constraint._minLength = 1e-6;
              Constraint.create = function(options) {
                var constraint = options;
                if (constraint.bodyA && !constraint.pointA)
                  constraint.pointA = {x: 0, y: 0};
                if (constraint.bodyB && !constraint.pointB)
                  constraint.pointB = {x: 0, y: 0};
                var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
                constraint.length = typeof constraint.length !== "undefined" ? constraint.length : length;
                constraint.id = constraint.id || Common.nextId();
                constraint.label = constraint.label || "Constraint";
                constraint.type = "constraint";
                constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
                constraint.damping = constraint.damping || 0;
                constraint.angularStiffness = constraint.angularStiffness || 0;
                constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
                constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
                constraint.plugin = {};
                var render = {
                  visible: true,
                  type: "line",
                  anchors: true,
                  lineColor: null,
                  lineOpacity: null,
                  lineThickness: null,
                  pinSize: null,
                  anchorColor: null,
                  anchorSize: null
                };
                if (constraint.length === 0 && constraint.stiffness > 0.1) {
                  render.type = "pin";
                  render.anchors = false;
                } else if (constraint.stiffness < 0.9) {
                  render.type = "spring";
                }
                constraint.render = Common.extend(render, constraint.render);
                return constraint;
              };
              Constraint.preSolveAll = function(bodies) {
                for (var i = 0; i < bodies.length; i += 1) {
                  var body = bodies[i], impulse = body.constraintImpulse;
                  if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                    continue;
                  }
                  body.position.x += impulse.x;
                  body.position.y += impulse.y;
                  body.angle += impulse.angle;
                }
              };
              Constraint.solveAll = function(constraints, delta) {
                var timeScale = Common.clamp(delta / Common._baseDelta, 0, 1);
                for (var i = 0; i < constraints.length; i += 1) {
                  var constraint = constraints[i], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                  if (fixedA || fixedB) {
                    Constraint.solve(constraints[i], timeScale);
                  }
                }
                for (i = 0; i < constraints.length; i += 1) {
                  constraint = constraints[i];
                  fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;
                  fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                  if (!fixedA && !fixedB) {
                    Constraint.solve(constraints[i], timeScale);
                  }
                }
              };
              Constraint.solve = function(constraint, timeScale) {
                var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;
                if (!bodyA && !bodyB)
                  return;
                if (bodyA && !bodyA.isStatic) {
                  Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
                  constraint.angleA = bodyA.angle;
                }
                if (bodyB && !bodyB.isStatic) {
                  Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
                  constraint.angleB = bodyB.angle;
                }
                var pointAWorld = pointA, pointBWorld = pointB;
                if (bodyA)
                  pointAWorld = Vector.add(bodyA.position, pointA);
                if (bodyB)
                  pointBWorld = Vector.add(bodyB.position, pointB);
                if (!pointAWorld || !pointBWorld)
                  return;
                var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);
                if (currentLength < Constraint._minLength) {
                  currentLength = Constraint._minLength;
                }
                var difference = (currentLength - constraint.length) / currentLength, isRigid = constraint.stiffness >= 1 || constraint.length === 0, stiffness = isRigid ? constraint.stiffness * timeScale : constraint.stiffness * timeScale * timeScale, damping = constraint.damping * timeScale, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;
                if (damping > 0) {
                  var zero = Vector.create();
                  normal = Vector.div(delta, currentLength);
                  relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);
                  normalVelocity = Vector.dot(normal, relativeVelocity);
                }
                if (bodyA && !bodyA.isStatic) {
                  share = bodyA.inverseMass / massTotal;
                  bodyA.constraintImpulse.x -= force.x * share;
                  bodyA.constraintImpulse.y -= force.y * share;
                  bodyA.position.x -= force.x * share;
                  bodyA.position.y -= force.y * share;
                  if (damping > 0) {
                    bodyA.positionPrev.x -= damping * normal.x * normalVelocity * share;
                    bodyA.positionPrev.y -= damping * normal.y * normalVelocity * share;
                  }
                  torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
                  bodyA.constraintImpulse.angle -= torque;
                  bodyA.angle -= torque;
                }
                if (bodyB && !bodyB.isStatic) {
                  share = bodyB.inverseMass / massTotal;
                  bodyB.constraintImpulse.x += force.x * share;
                  bodyB.constraintImpulse.y += force.y * share;
                  bodyB.position.x += force.x * share;
                  bodyB.position.y += force.y * share;
                  if (damping > 0) {
                    bodyB.positionPrev.x += damping * normal.x * normalVelocity * share;
                    bodyB.positionPrev.y += damping * normal.y * normalVelocity * share;
                  }
                  torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
                  bodyB.constraintImpulse.angle += torque;
                  bodyB.angle += torque;
                }
              };
              Constraint.postSolveAll = function(bodies) {
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], impulse = body.constraintImpulse;
                  if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                    continue;
                  }
                  Sleeping.set(body, false);
                  for (var j = 0; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    Vertices.translate(part.vertices, impulse);
                    if (j > 0) {
                      part.position.x += impulse.x;
                      part.position.y += impulse.y;
                    }
                    if (impulse.angle !== 0) {
                      Vertices.rotate(part.vertices, impulse.angle, body.position);
                      Axes.rotate(part.axes, impulse.angle);
                      if (j > 0) {
                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                      }
                    }
                    Bounds.update(part.bounds, part.vertices, body.velocity);
                  }
                  impulse.angle *= Constraint._warming;
                  impulse.x *= Constraint._warming;
                  impulse.y *= Constraint._warming;
                }
              };
              Constraint.pointAWorld = function(constraint) {
                return {
                  x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + (constraint.pointA ? constraint.pointA.x : 0),
                  y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + (constraint.pointA ? constraint.pointA.y : 0)
                };
              };
              Constraint.pointBWorld = function(constraint) {
                return {
                  x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + (constraint.pointB ? constraint.pointB.x : 0),
                  y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + (constraint.pointB ? constraint.pointB.y : 0)
                };
              };
              Constraint.currentLength = function(constraint) {
                var pointAX = (constraint.bodyA ? constraint.bodyA.position.x : 0) + (constraint.pointA ? constraint.pointA.x : 0);
                var pointAY = (constraint.bodyA ? constraint.bodyA.position.y : 0) + (constraint.pointA ? constraint.pointA.y : 0);
                var pointBX = (constraint.bodyB ? constraint.bodyB.position.x : 0) + (constraint.pointB ? constraint.pointB.x : 0);
                var pointBY = (constraint.bodyB ? constraint.bodyB.position.y : 0) + (constraint.pointB ? constraint.pointB.y : 0);
                var deltaX = pointAX - pointBX;
                var deltaY = pointAY - pointBY;
                return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
              };
            })();
          },
          68758: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Common = {};
            module2.exports = Common;
            (function() {
              Common._baseDelta = 1e3 / 60;
              Common._nextId = 0;
              Common._seed = 0;
              Common._nowStartTime = +new Date();
              Common._warnedOnce = {};
              Common._decomp = null;
              Common.extend = function(obj, deep) {
                var argsStart, args, deepClone;
                if (typeof deep === "boolean") {
                  argsStart = 2;
                  deepClone = deep;
                } else {
                  argsStart = 1;
                  deepClone = true;
                }
                for (var i = argsStart; i < arguments.length; i++) {
                  var source = arguments[i];
                  if (source) {
                    for (var prop in source) {
                      if (deepClone && source[prop] && source[prop].constructor === Object) {
                        if (!obj[prop] || obj[prop].constructor === Object) {
                          obj[prop] = obj[prop] || {};
                          Common.extend(obj[prop], deepClone, source[prop]);
                        } else {
                          obj[prop] = source[prop];
                        }
                      } else {
                        obj[prop] = source[prop];
                      }
                    }
                  }
                }
                return obj;
              };
              Common.clone = function(obj, deep) {
                return Common.extend({}, deep, obj);
              };
              Common.keys = function(obj) {
                if (Object.keys)
                  return Object.keys(obj);
                var keys = [];
                for (var key in obj)
                  keys.push(key);
                return keys;
              };
              Common.values = function(obj) {
                var values = [];
                if (Object.keys) {
                  var keys = Object.keys(obj);
                  for (var i = 0; i < keys.length; i++) {
                    values.push(obj[keys[i]]);
                  }
                  return values;
                }
                for (var key in obj)
                  values.push(obj[key]);
                return values;
              };
              Common.get = function(obj, path, begin, end) {
                path = path.split(".").slice(begin, end);
                for (var i = 0; i < path.length; i += 1) {
                  obj = obj[path[i]];
                }
                return obj;
              };
              Common.set = function(obj, path, val, begin, end) {
                var parts = path.split(".").slice(begin, end);
                Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
                return val;
              };
              Common.shuffle = function(array) {
                for (var i = array.length - 1; i > 0; i--) {
                  var j = Math.floor(Common.random() * (i + 1));
                  var temp = array[i];
                  array[i] = array[j];
                  array[j] = temp;
                }
                return array;
              };
              Common.choose = function(choices) {
                return choices[Math.floor(Common.random() * choices.length)];
              };
              Common.isElement = function(obj) {
                if (typeof HTMLElement !== "undefined") {
                  return obj instanceof HTMLElement;
                }
                return !!(obj && obj.nodeType && obj.nodeName);
              };
              Common.isArray = function(obj) {
                return Object.prototype.toString.call(obj) === "[object Array]";
              };
              Common.isFunction = function(obj) {
                return typeof obj === "function";
              };
              Common.isPlainObject = function(obj) {
                return typeof obj === "object" && obj.constructor === Object;
              };
              Common.isString = function(obj) {
                return toString.call(obj) === "[object String]";
              };
              Common.clamp = function(value, min, max) {
                if (value < min)
                  return min;
                if (value > max)
                  return max;
                return value;
              };
              Common.sign = function(value) {
                return value < 0 ? -1 : 1;
              };
              Common.now = function() {
                if (typeof window !== "undefined" && window.performance) {
                  if (window.performance.now) {
                    return window.performance.now();
                  } else if (window.performance.webkitNow) {
                    return window.performance.webkitNow();
                  }
                }
                if (Date.now) {
                  return Date.now();
                }
                return new Date() - Common._nowStartTime;
              };
              Common.random = function(min, max) {
                min = typeof min !== "undefined" ? min : 0;
                max = typeof max !== "undefined" ? max : 1;
                return min + _seededRandom() * (max - min);
              };
              var _seededRandom = function() {
                Common._seed = (Common._seed * 9301 + 49297) % 233280;
                return Common._seed / 233280;
              };
              Common.colorToNumber = function(colorString) {
                colorString = colorString.replace("#", "");
                if (colorString.length == 3) {
                  colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);
                }
                return parseInt(colorString, 16);
              };
              Common.logLevel = 1;
              Common.log = function() {
                if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                  console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
                }
              };
              Common.info = function() {
                if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
                  console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
                }
              };
              Common.warn = function() {
                if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                  console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
                }
              };
              Common.warnOnce = function() {
                var message = Array.prototype.slice.call(arguments).join(" ");
                if (!Common._warnedOnce[message]) {
                  Common.warn(message);
                  Common._warnedOnce[message] = true;
                }
              };
              Common.deprecated = function(obj, prop, warning) {
                obj[prop] = Common.chain(function() {
                  Common.warnOnce("\u{1F505} deprecated \u{1F505}", warning);
                }, obj[prop]);
              };
              Common.nextId = function() {
                return Common._nextId++;
              };
              Common.indexOf = function(haystack, needle) {
                if (haystack.indexOf)
                  return haystack.indexOf(needle);
                for (var i = 0; i < haystack.length; i++) {
                  if (haystack[i] === needle)
                    return i;
                }
                return -1;
              };
              Common.map = function(list, func) {
                if (list.map) {
                  return list.map(func);
                }
                var mapped = [];
                for (var i = 0; i < list.length; i += 1) {
                  mapped.push(func(list[i]));
                }
                return mapped;
              };
              Common.topologicalSort = function(graph) {
                var result = [], visited = [], temp = [];
                for (var node in graph) {
                  if (!visited[node] && !temp[node]) {
                    Common._topologicalSort(node, visited, temp, graph, result);
                  }
                }
                return result;
              };
              Common._topologicalSort = function(node, visited, temp, graph, result) {
                var neighbors = graph[node] || [];
                temp[node] = true;
                for (var i = 0; i < neighbors.length; i += 1) {
                  var neighbor = neighbors[i];
                  if (temp[neighbor]) {
                    continue;
                  }
                  if (!visited[neighbor]) {
                    Common._topologicalSort(neighbor, visited, temp, graph, result);
                  }
                }
                temp[node] = false;
                visited[node] = true;
                result.push(node);
              };
              Common.chain = function() {
                var funcs = [];
                for (var i = 0; i < arguments.length; i += 1) {
                  var func = arguments[i];
                  if (func._chained) {
                    funcs.push.apply(funcs, func._chained);
                  } else {
                    funcs.push(func);
                  }
                }
                var chain = function() {
                  var lastResult, args = new Array(arguments.length);
                  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
                    args[i2] = arguments[i2];
                  }
                  for (i2 = 0; i2 < funcs.length; i2 += 1) {
                    var result = funcs[i2].apply(lastResult, args);
                    if (typeof result !== "undefined") {
                      lastResult = result;
                    }
                  }
                  return lastResult;
                };
                chain._chained = funcs;
                return chain;
              };
              Common.chainPathBefore = function(base, path, func) {
                return Common.set(base, path, Common.chain(func, Common.get(base, path)));
              };
              Common.chainPathAfter = function(base, path, func) {
                return Common.set(base, path, Common.chain(Common.get(base, path), func));
              };
              Common.setDecomp = function(decomp) {
                Common._decomp = decomp;
              };
              Common.getDecomp = function() {
                var decomp = Common._decomp;
                try {
                  if (!decomp && typeof window !== "undefined") {
                    decomp = window.decomp;
                  }
                  if (!decomp && typeof __webpack_require__2.g !== "undefined") {
                    decomp = __webpack_require__2.g.decomp;
                  }
                } catch (e) {
                  decomp = null;
                }
                return decomp;
              };
            })();
          },
          45775: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Engine = {};
            module2.exports = Engine;
            var Sleeping = __webpack_require__2(22806);
            var Resolver = __webpack_require__2(44272);
            var Detector = __webpack_require__2(13657);
            var Pairs = __webpack_require__2(91327);
            var Events = __webpack_require__2(39073);
            var Composite = __webpack_require__2(11299);
            var Constraint = __webpack_require__2(52838);
            var Common = __webpack_require__2(68758);
            var Body = __webpack_require__2(84125);
            (function() {
              Engine.create = function(options) {
                options = options || {};
                var defaults = {
                  positionIterations: 6,
                  velocityIterations: 4,
                  constraintIterations: 2,
                  enableSleeping: false,
                  events: [],
                  plugin: {},
                  gravity: {
                    x: 0,
                    y: 1,
                    scale: 1e-3
                  },
                  timing: {
                    timestamp: 0,
                    timeScale: 1,
                    lastDelta: 0,
                    lastElapsed: 0
                  }
                };
                var engine = Common.extend(defaults, options);
                engine.world = options.world || Composite.create({label: "World"});
                engine.pairs = options.pairs || Pairs.create();
                engine.detector = options.detector || Detector.create();
                engine.grid = {buckets: []};
                engine.world.gravity = engine.gravity;
                engine.broadphase = engine.grid;
                engine.metrics = {};
                return engine;
              };
              Engine.update = function(engine, delta) {
                var startTime = Common.now();
                var world = engine.world, detector = engine.detector, pairs = engine.pairs, timing = engine.timing, timestamp = timing.timestamp, i;
                delta = typeof delta !== "undefined" ? delta : Common._baseDelta;
                delta *= timing.timeScale;
                timing.timestamp += delta;
                timing.lastDelta = delta;
                var event = {
                  timestamp: timing.timestamp,
                  delta
                };
                Events.trigger(engine, "beforeUpdate", event);
                var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world);
                if (world.isModified) {
                  Detector.setBodies(detector, allBodies);
                  Composite.setModified(world, false, false, true);
                }
                if (engine.enableSleeping)
                  Sleeping.update(allBodies, delta);
                Engine._bodiesApplyGravity(allBodies, engine.gravity);
                if (delta > 0) {
                  Engine._bodiesUpdate(allBodies, delta);
                }
                Events.trigger(engine, "beforeSolve", event);
                Constraint.preSolveAll(allBodies);
                for (i = 0; i < engine.constraintIterations; i++) {
                  Constraint.solveAll(allConstraints, delta);
                }
                Constraint.postSolveAll(allBodies);
                detector.pairs = engine.pairs;
                var collisions = Detector.collisions(detector);
                Pairs.update(pairs, collisions, timestamp);
                if (engine.enableSleeping)
                  Sleeping.afterCollisions(pairs.list);
                if (pairs.collisionStart.length > 0) {
                  Events.trigger(engine, "collisionStart", {
                    pairs: pairs.collisionStart,
                    timestamp: timing.timestamp,
                    delta
                  });
                }
                var positionDamping = Common.clamp(20 / engine.positionIterations, 0, 1);
                Resolver.preSolvePosition(pairs.list);
                for (i = 0; i < engine.positionIterations; i++) {
                  Resolver.solvePosition(pairs.list, delta, positionDamping);
                }
                Resolver.postSolvePosition(allBodies);
                Constraint.preSolveAll(allBodies);
                for (i = 0; i < engine.constraintIterations; i++) {
                  Constraint.solveAll(allConstraints, delta);
                }
                Constraint.postSolveAll(allBodies);
                Resolver.preSolveVelocity(pairs.list);
                for (i = 0; i < engine.velocityIterations; i++) {
                  Resolver.solveVelocity(pairs.list, delta);
                }
                Engine._bodiesUpdateVelocities(allBodies);
                if (pairs.collisionActive.length > 0) {
                  Events.trigger(engine, "collisionActive", {
                    pairs: pairs.collisionActive,
                    timestamp: timing.timestamp,
                    delta
                  });
                }
                if (pairs.collisionEnd.length > 0) {
                  Events.trigger(engine, "collisionEnd", {
                    pairs: pairs.collisionEnd,
                    timestamp: timing.timestamp,
                    delta
                  });
                }
                Engine._bodiesClearForces(allBodies);
                Events.trigger(engine, "afterUpdate", event);
                engine.timing.lastElapsed = Common.now() - startTime;
                return engine;
              };
              Engine.merge = function(engineA, engineB) {
                Common.extend(engineA, engineB);
                if (engineB.world) {
                  engineA.world = engineB.world;
                  Engine.clear(engineA);
                  var bodies = Composite.allBodies(engineA.world);
                  for (var i = 0; i < bodies.length; i++) {
                    var body = bodies[i];
                    Sleeping.set(body, false);
                    body.id = Common.nextId();
                  }
                }
              };
              Engine.clear = function(engine) {
                Pairs.clear(engine.pairs);
                Detector.clear(engine.detector);
              };
              Engine._bodiesClearForces = function(bodies) {
                var bodiesLength = bodies.length;
                for (var i = 0; i < bodiesLength; i++) {
                  var body = bodies[i];
                  body.force.x = 0;
                  body.force.y = 0;
                  body.torque = 0;
                }
              };
              Engine._bodiesApplyGravity = function(bodies, gravity) {
                var gravityScale = typeof gravity.scale !== "undefined" ? gravity.scale : 1e-3, bodiesLength = bodies.length;
                if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {
                  return;
                }
                for (var i = 0; i < bodiesLength; i++) {
                  var body = bodies[i];
                  if (body.ignoreGravity || body.isStatic || body.isSleeping)
                    continue;
                  body.force.y += body.mass * gravity.y * gravityScale;
                  body.force.x += body.mass * gravity.x * gravityScale;
                }
              };
              Engine._bodiesUpdate = function(bodies, delta) {
                var bodiesLength = bodies.length;
                for (var i = 0; i < bodiesLength; i++) {
                  var body = bodies[i];
                  if (body.isStatic || body.isSleeping)
                    continue;
                  Body.update(body, delta);
                }
              };
              Engine._bodiesUpdateVelocities = function(bodies) {
                var bodiesLength = bodies.length;
                for (var i = 0; i < bodiesLength; i++) {
                  Body.updateVelocities(bodies[i]);
                }
              };
            })();
          },
          39073: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Events = {};
            module2.exports = Events;
            var Common = __webpack_require__2(68758);
            (function() {
              Events.on = function(object, eventNames, callback) {
                var names = eventNames.split(" "), name;
                for (var i = 0; i < names.length; i++) {
                  name = names[i];
                  object.events = object.events || {};
                  object.events[name] = object.events[name] || [];
                  object.events[name].push(callback);
                }
                return callback;
              };
              Events.off = function(object, eventNames, callback) {
                if (!eventNames) {
                  object.events = {};
                  return;
                }
                if (typeof eventNames === "function") {
                  callback = eventNames;
                  eventNames = Common.keys(object.events).join(" ");
                }
                var names = eventNames.split(" ");
                for (var i = 0; i < names.length; i++) {
                  var callbacks = object.events[names[i]], newCallbacks = [];
                  if (callback && callbacks) {
                    for (var j = 0; j < callbacks.length; j++) {
                      if (callbacks[j] !== callback)
                        newCallbacks.push(callbacks[j]);
                    }
                  }
                  object.events[names[i]] = newCallbacks;
                }
              };
              Events.trigger = function(object, eventNames, event) {
                var names, name, callbacks, eventClone;
                var events = object.events;
                if (events && Common.keys(events).length > 0) {
                  if (!event)
                    event = {};
                  names = eventNames.split(" ");
                  for (var i = 0; i < names.length; i++) {
                    name = names[i];
                    callbacks = events[name];
                    if (callbacks) {
                      eventClone = Common.clone(event, false);
                      eventClone.name = name;
                      eventClone.source = object;
                      for (var j = 0; j < callbacks.length; j++) {
                        callbacks[j].apply(object, [eventClone]);
                      }
                    }
                  }
                }
              };
            })();
          },
          16929: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Matter = {};
            module2.exports = Matter;
            var Plugin = __webpack_require__2(84474);
            var Common = __webpack_require__2(68758);
            (function() {
              Matter.name = "matter-js";
              Matter.version = "0.19.0";
              Matter.uses = [];
              Matter.used = [];
              Matter.use = function() {
                Plugin.use(Matter, Array.prototype.slice.call(arguments));
              };
              Matter.before = function(path, func) {
                path = path.replace(/^Matter./, "");
                return Common.chainPathBefore(Matter, path, func);
              };
              Matter.after = function(path, func) {
                path = path.replace(/^Matter./, "");
                return Common.chainPathAfter(Matter, path, func);
              };
            })();
          },
          84474: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Plugin = {};
            module2.exports = Plugin;
            var Common = __webpack_require__2(68758);
            (function() {
              Plugin._registry = {};
              Plugin.register = function(plugin) {
                if (!Plugin.isPlugin(plugin)) {
                  Common.warn("Plugin.register:", Plugin.toString(plugin), "does not implement all required fields.");
                }
                if (plugin.name in Plugin._registry) {
                  var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;
                  if (pluginVersion > registeredVersion) {
                    Common.warn("Plugin.register:", Plugin.toString(registered), "was upgraded to", Plugin.toString(plugin));
                    Plugin._registry[plugin.name] = plugin;
                  } else if (pluginVersion < registeredVersion) {
                    Common.warn("Plugin.register:", Plugin.toString(registered), "can not be downgraded to", Plugin.toString(plugin));
                  } else if (plugin !== registered) {
                    Common.warn("Plugin.register:", Plugin.toString(plugin), "is already registered to different plugin object");
                  }
                } else {
                  Plugin._registry[plugin.name] = plugin;
                }
                return plugin;
              };
              Plugin.resolve = function(dependency) {
                return Plugin._registry[Plugin.dependencyParse(dependency).name];
              };
              Plugin.toString = function(plugin) {
                return typeof plugin === "string" ? plugin : (plugin.name || "anonymous") + "@" + (plugin.version || plugin.range || "0.0.0");
              };
              Plugin.isPlugin = function(obj) {
                return obj && obj.name && obj.version && obj.install;
              };
              Plugin.isUsed = function(module3, name) {
                return module3.used.indexOf(name) > -1;
              };
              Plugin.isFor = function(plugin, module3) {
                var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
                return !plugin.for || module3.name === parsed.name && Plugin.versionSatisfies(module3.version, parsed.range);
              };
              Plugin.use = function(module3, plugins) {
                module3.uses = (module3.uses || []).concat(plugins || []);
                if (module3.uses.length === 0) {
                  Common.warn("Plugin.use:", Plugin.toString(module3), "does not specify any dependencies to install.");
                  return;
                }
                var dependencies = Plugin.dependencies(module3), sortedDependencies = Common.topologicalSort(dependencies), status = [];
                for (var i = 0; i < sortedDependencies.length; i += 1) {
                  if (sortedDependencies[i] === module3.name) {
                    continue;
                  }
                  var plugin = Plugin.resolve(sortedDependencies[i]);
                  if (!plugin) {
                    status.push("\u274C " + sortedDependencies[i]);
                    continue;
                  }
                  if (Plugin.isUsed(module3, plugin.name)) {
                    continue;
                  }
                  if (!Plugin.isFor(plugin, module3)) {
                    Common.warn("Plugin.use:", Plugin.toString(plugin), "is for", plugin.for, "but installed on", Plugin.toString(module3) + ".");
                    plugin._warned = true;
                  }
                  if (plugin.install) {
                    plugin.install(module3);
                  } else {
                    Common.warn("Plugin.use:", Plugin.toString(plugin), "does not specify an install function.");
                    plugin._warned = true;
                  }
                  if (plugin._warned) {
                    status.push("\u{1F536} " + Plugin.toString(plugin));
                    delete plugin._warned;
                  } else {
                    status.push("\u2705 " + Plugin.toString(plugin));
                  }
                  module3.used.push(plugin.name);
                }
                if (status.length > 0 && !plugin.silent) {
                  Common.info(status.join("  "));
                }
              };
              Plugin.dependencies = function(module3, tracked) {
                var parsedBase = Plugin.dependencyParse(module3), name = parsedBase.name;
                tracked = tracked || {};
                if (name in tracked) {
                  return;
                }
                module3 = Plugin.resolve(module3) || module3;
                tracked[name] = Common.map(module3.uses || [], function(dependency) {
                  if (Plugin.isPlugin(dependency)) {
                    Plugin.register(dependency);
                  }
                  var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);
                  if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                    Common.warn("Plugin.dependencies:", Plugin.toString(resolved), "does not satisfy", Plugin.toString(parsed), "used by", Plugin.toString(parsedBase) + ".");
                    resolved._warned = true;
                    module3._warned = true;
                  } else if (!resolved) {
                    Common.warn("Plugin.dependencies:", Plugin.toString(dependency), "used by", Plugin.toString(parsedBase), "could not be resolved.");
                    module3._warned = true;
                  }
                  return parsed.name;
                });
                for (var i = 0; i < tracked[name].length; i += 1) {
                  Plugin.dependencies(tracked[name][i], tracked);
                }
                return tracked;
              };
              Plugin.dependencyParse = function(dependency) {
                if (Common.isString(dependency)) {
                  var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/;
                  if (!pattern.test(dependency)) {
                    Common.warn("Plugin.dependencyParse:", dependency, "is not a valid dependency string.");
                  }
                  return {
                    name: dependency.split("@")[0],
                    range: dependency.split("@")[1] || "*"
                  };
                }
                return {
                  name: dependency.name,
                  range: dependency.range || dependency.version
                };
              };
              Plugin.versionParse = function(range) {
                var pattern = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
                if (!pattern.test(range)) {
                  Common.warn("Plugin.versionParse:", range, "is not a valid version or range.");
                }
                var parts = pattern.exec(range);
                var major = Number(parts[4]);
                var minor = Number(parts[5]);
                var patch = Number(parts[6]);
                return {
                  isRange: Boolean(parts[1] || parts[2]),
                  version: parts[3],
                  range,
                  operator: parts[1] || parts[2] || "",
                  major,
                  minor,
                  patch,
                  parts: [major, minor, patch],
                  prerelease: parts[7],
                  number: major * 1e8 + minor * 1e4 + patch
                };
              };
              Plugin.versionSatisfies = function(version, range) {
                range = range || "*";
                var r = Plugin.versionParse(range), v = Plugin.versionParse(version);
                if (r.isRange) {
                  if (r.operator === "*" || version === "*") {
                    return true;
                  }
                  if (r.operator === ">") {
                    return v.number > r.number;
                  }
                  if (r.operator === ">=") {
                    return v.number >= r.number;
                  }
                  if (r.operator === "~") {
                    return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;
                  }
                  if (r.operator === "^") {
                    if (r.major > 0) {
                      return v.major === r.major && v.number >= r.number;
                    }
                    if (r.minor > 0) {
                      return v.minor === r.minor && v.patch >= r.patch;
                    }
                    return v.patch === r.patch;
                  }
                }
                return version === range || version === "*";
              };
            })();
          },
          22806: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Sleeping = {};
            module2.exports = Sleeping;
            var Body = __webpack_require__2(84125);
            var Events = __webpack_require__2(39073);
            var Common = __webpack_require__2(68758);
            (function() {
              Sleeping._motionWakeThreshold = 0.18;
              Sleeping._motionSleepThreshold = 0.08;
              Sleeping._minBias = 0.9;
              Sleeping.update = function(bodies, delta) {
                var timeScale = delta / Common._baseDelta, motionSleepThreshold = Sleeping._motionSleepThreshold;
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], speed = Body.getSpeed(body), angularSpeed = Body.getAngularSpeed(body), motion = speed * speed + angularSpeed * angularSpeed;
                  if (body.force.x !== 0 || body.force.y !== 0) {
                    Sleeping.set(body, false);
                    continue;
                  }
                  var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);
                  body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
                  if (body.sleepThreshold > 0 && body.motion < motionSleepThreshold) {
                    body.sleepCounter += 1;
                    if (body.sleepCounter >= body.sleepThreshold / timeScale) {
                      Sleeping.set(body, true);
                    }
                  } else if (body.sleepCounter > 0) {
                    body.sleepCounter -= 1;
                  }
                }
              };
              Sleeping.afterCollisions = function(pairs) {
                var motionSleepThreshold = Sleeping._motionSleepThreshold;
                for (var i = 0; i < pairs.length; i++) {
                  var pair = pairs[i];
                  if (!pair.isActive)
                    continue;
                  var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;
                  if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic)
                    continue;
                  if (bodyA.isSleeping || bodyB.isSleeping) {
                    var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;
                    if (!sleepingBody.isStatic && movingBody.motion > motionSleepThreshold) {
                      Sleeping.set(sleepingBody, false);
                    }
                  }
                }
              };
              Sleeping.set = function(body, isSleeping) {
                var wasSleeping = body.isSleeping;
                if (isSleeping) {
                  body.isSleeping = true;
                  body.sleepCounter = body.sleepThreshold;
                  body.positionImpulse.x = 0;
                  body.positionImpulse.y = 0;
                  body.positionPrev.x = body.position.x;
                  body.positionPrev.y = body.position.y;
                  body.anglePrev = body.angle;
                  body.speed = 0;
                  body.angularSpeed = 0;
                  body.motion = 0;
                  if (!wasSleeping) {
                    Events.trigger(body, "sleepStart");
                  }
                } else {
                  body.isSleeping = false;
                  body.sleepCounter = 0;
                  if (wasSleeping) {
                    Events.trigger(body, "sleepEnd");
                  }
                }
              };
            })();
          },
          68516: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Bodies = {};
            module2.exports = Bodies;
            var Vertices = __webpack_require__2(39745);
            var Common = __webpack_require__2(68758);
            var Body = __webpack_require__2(84125);
            var Bounds = __webpack_require__2(84091);
            var Vector = __webpack_require__2(10438);
            (function() {
              Bodies.rectangle = function(x, y, width, height, options) {
                options = options || {};
                var rectangle = {
                  label: "Rectangle Body",
                  position: {x, y},
                  vertices: Vertices.fromPath("L 0 0 L " + width + " 0 L " + width + " " + height + " L 0 " + height)
                };
                if (options.chamfer) {
                  var chamfer = options.chamfer;
                  rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                  delete options.chamfer;
                }
                return Body.create(Common.extend({}, rectangle, options));
              };
              Bodies.trapezoid = function(x, y, width, height, slope, options) {
                options = options || {};
                slope *= 0.5;
                var roof = (1 - slope * 2) * width;
                var x1 = width * slope, x2 = x1 + roof, x3 = x2 + x1, verticesPath;
                if (slope < 0.5) {
                  verticesPath = "L 0 0 L " + x1 + " " + -height + " L " + x2 + " " + -height + " L " + x3 + " 0";
                } else {
                  verticesPath = "L 0 0 L " + x2 + " " + -height + " L " + x3 + " 0";
                }
                var trapezoid = {
                  label: "Trapezoid Body",
                  position: {x, y},
                  vertices: Vertices.fromPath(verticesPath)
                };
                if (options.chamfer) {
                  var chamfer = options.chamfer;
                  trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                  delete options.chamfer;
                }
                return Body.create(Common.extend({}, trapezoid, options));
              };
              Bodies.circle = function(x, y, radius, options, maxSides) {
                options = options || {};
                var circle = {
                  label: "Circle Body",
                  circleRadius: radius
                };
                maxSides = maxSides || 25;
                var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));
                if (sides % 2 === 1)
                  sides += 1;
                return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
              };
              Bodies.polygon = function(x, y, sides, radius, options) {
                options = options || {};
                if (sides < 3)
                  return Bodies.circle(x, y, radius, options);
                var theta = 2 * Math.PI / sides, path = "", offset = theta * 0.5;
                for (var i = 0; i < sides; i += 1) {
                  var angle = offset + i * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;
                  path += "L " + xx.toFixed(3) + " " + yy.toFixed(3) + " ";
                }
                var polygon = {
                  label: "Polygon Body",
                  position: {x, y},
                  vertices: Vertices.fromPath(path)
                };
                if (options.chamfer) {
                  var chamfer = options.chamfer;
                  polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                  delete options.chamfer;
                }
                return Body.create(Common.extend({}, polygon, options));
              };
              Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {
                var decomp = Common.getDecomp(), canDecomp, body, parts, isConvex, isConcave, vertices, i, j, k, v, z;
                canDecomp = Boolean(decomp && decomp.quickDecomp);
                options = options || {};
                parts = [];
                flagInternal = typeof flagInternal !== "undefined" ? flagInternal : false;
                removeCollinear = typeof removeCollinear !== "undefined" ? removeCollinear : 0.01;
                minimumArea = typeof minimumArea !== "undefined" ? minimumArea : 10;
                removeDuplicatePoints = typeof removeDuplicatePoints !== "undefined" ? removeDuplicatePoints : 0.01;
                if (!Common.isArray(vertexSets[0])) {
                  vertexSets = [vertexSets];
                }
                for (v = 0; v < vertexSets.length; v += 1) {
                  vertices = vertexSets[v];
                  isConvex = Vertices.isConvex(vertices);
                  isConcave = !isConvex;
                  if (isConcave && !canDecomp) {
                    Common.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices.");
                  }
                  if (isConvex || !canDecomp) {
                    if (isConvex) {
                      vertices = Vertices.clockwiseSort(vertices);
                    } else {
                      vertices = Vertices.hull(vertices);
                    }
                    parts.push({
                      position: {x, y},
                      vertices
                    });
                  } else {
                    var concave = vertices.map(function(vertex) {
                      return [vertex.x, vertex.y];
                    });
                    decomp.makeCCW(concave);
                    if (removeCollinear !== false)
                      decomp.removeCollinearPoints(concave, removeCollinear);
                    if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints)
                      decomp.removeDuplicatePoints(concave, removeDuplicatePoints);
                    var decomposed = decomp.quickDecomp(concave);
                    for (i = 0; i < decomposed.length; i++) {
                      var chunk = decomposed[i];
                      var chunkVertices = chunk.map(function(vertices2) {
                        return {
                          x: vertices2[0],
                          y: vertices2[1]
                        };
                      });
                      if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
                        continue;
                      parts.push({
                        position: Vertices.centre(chunkVertices),
                        vertices: chunkVertices
                      });
                    }
                  }
                }
                for (i = 0; i < parts.length; i++) {
                  parts[i] = Body.create(Common.extend(parts[i], options));
                }
                if (flagInternal) {
                  var coincident_max_dist = 5;
                  for (i = 0; i < parts.length; i++) {
                    var partA = parts[i];
                    for (j = i + 1; j < parts.length; j++) {
                      var partB = parts[j];
                      if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                        var pav = partA.vertices, pbv = partB.vertices;
                        for (k = 0; k < partA.vertices.length; k++) {
                          for (z = 0; z < partB.vertices.length; z++) {
                            var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])), db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));
                            if (da < coincident_max_dist && db < coincident_max_dist) {
                              pav[k].isInternal = true;
                              pbv[z].isInternal = true;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (parts.length > 1) {
                  body = Body.create(Common.extend({parts: parts.slice(0)}, options));
                  Body.setPosition(body, {x, y});
                  return body;
                } else {
                  return parts[0];
                }
              };
              Bodies.flagCoincidentParts = function(parts, maxDistance) {
                if (maxDistance === void 0) {
                  maxDistance = 5;
                }
                for (var i = 0; i < parts.length; i++) {
                  var partA = parts[i];
                  for (var j = i + 1; j < parts.length; j++) {
                    var partB = parts[j];
                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                      var pav = partA.vertices;
                      var pbv = partB.vertices;
                      for (var k = 0; k < partA.vertices.length; k++) {
                        for (var z = 0; z < partB.vertices.length; z++) {
                          var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z]));
                          var db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));
                          if (da < maxDistance && db < maxDistance) {
                            pav[k].isInternal = true;
                            pbv[z].isInternal = true;
                          }
                        }
                      }
                    }
                  }
                }
                return parts;
              };
            })();
          },
          56643: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Composites = {};
            module2.exports = Composites;
            var Composite = __webpack_require__2(11299);
            var Constraint = __webpack_require__2(52838);
            var Common = __webpack_require__2(68758);
            var Body = __webpack_require__2(84125);
            var Bodies = __webpack_require__2(68516);
            (function() {
              Composites.stack = function(x, y, columns, rows, columnGap, rowGap, callback) {
                var stack = Composite.create({label: "Stack"}), currentX = x, currentY = y, lastBody, i = 0;
                for (var row = 0; row < rows; row++) {
                  var maxHeight = 0;
                  for (var column = 0; column < columns; column++) {
                    var body = callback(currentX, currentY, column, row, lastBody, i);
                    if (body) {
                      var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;
                      if (bodyHeight > maxHeight)
                        maxHeight = bodyHeight;
                      Body.translate(body, {x: bodyWidth * 0.5, y: bodyHeight * 0.5});
                      currentX = body.bounds.max.x + columnGap;
                      Composite.addBody(stack, body);
                      lastBody = body;
                      i += 1;
                    } else {
                      currentX += columnGap;
                    }
                  }
                  currentY += maxHeight + rowGap;
                  currentX = x;
                }
                return stack;
              };
              Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
                var bodies = composite.bodies;
                for (var i = 1; i < bodies.length; i++) {
                  var bodyA = bodies[i - 1], bodyB = bodies[i], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
                  var defaults = {
                    bodyA,
                    pointA: {x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA},
                    bodyB,
                    pointB: {x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB}
                  };
                  var constraint = Common.extend(defaults, options);
                  Composite.addConstraint(composite, Constraint.create(constraint));
                }
                composite.label += " Chain";
                return composite;
              };
              Composites.mesh = function(composite, columns, rows, crossBrace, options) {
                var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;
                for (row = 0; row < rows; row++) {
                  for (col = 1; col < columns; col++) {
                    bodyA = bodies[col - 1 + row * columns];
                    bodyB = bodies[col + row * columns];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA, bodyB}, options)));
                  }
                  if (row > 0) {
                    for (col = 0; col < columns; col++) {
                      bodyA = bodies[col + (row - 1) * columns];
                      bodyB = bodies[col + row * columns];
                      Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA, bodyB}, options)));
                      if (crossBrace && col > 0) {
                        bodyC = bodies[col - 1 + (row - 1) * columns];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA: bodyC, bodyB}, options)));
                      }
                      if (crossBrace && col < columns - 1) {
                        bodyC = bodies[col + 1 + (row - 1) * columns];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA: bodyC, bodyB}, options)));
                      }
                    }
                  }
                }
                composite.label += " Mesh";
                return composite;
              };
              Composites.pyramid = function(x, y, columns, rows, columnGap, rowGap, callback) {
                return Composites.stack(x, y, columns, rows, columnGap, rowGap, function(stackX, stackY, column, row, lastBody, i) {
                  var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
                  if (row > actualRows)
                    return;
                  row = actualRows - row;
                  var start = row, end = columns - 1 - row;
                  if (column < start || column > end)
                    return;
                  if (i === 1) {
                    Body.translate(lastBody, {x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0});
                  }
                  var xOffset = lastBody ? column * lastBodyWidth : 0;
                  return callback(x + xOffset + column * columnGap, stackY, column, row, lastBody, i);
                });
              };
              Composites.newtonsCradle = function(x, y, number, size, length) {
                var newtonsCradle = Composite.create({label: "Newtons Cradle"});
                for (var i = 0; i < number; i++) {
                  var separation = 1.9, circle = Bodies.circle(x + i * (size * separation), y + length, size, {inertia: Infinity, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1}), constraint = Constraint.create({pointA: {x: x + i * (size * separation), y}, bodyB: circle});
                  Composite.addBody(newtonsCradle, circle);
                  Composite.addConstraint(newtonsCradle, constraint);
                }
                return newtonsCradle;
              };
              Composites.car = function(x, y, width, height, wheelSize) {
                var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;
                var car = Composite.create({label: "Car"}), body = Bodies.rectangle(x, y, width, height, {
                  collisionFilter: {
                    group
                  },
                  chamfer: {
                    radius: height * 0.5
                  },
                  density: 2e-4
                });
                var wheelA = Bodies.circle(x + wheelAOffset, y + wheelYOffset, wheelSize, {
                  collisionFilter: {
                    group
                  },
                  friction: 0.8
                });
                var wheelB = Bodies.circle(x + wheelBOffset, y + wheelYOffset, wheelSize, {
                  collisionFilter: {
                    group
                  },
                  friction: 0.8
                });
                var axelA = Constraint.create({
                  bodyB: body,
                  pointB: {x: wheelAOffset, y: wheelYOffset},
                  bodyA: wheelA,
                  stiffness: 1,
                  length: 0
                });
                var axelB = Constraint.create({
                  bodyB: body,
                  pointB: {x: wheelBOffset, y: wheelYOffset},
                  bodyA: wheelB,
                  stiffness: 1,
                  length: 0
                });
                Composite.addBody(car, body);
                Composite.addBody(car, wheelA);
                Composite.addBody(car, wheelB);
                Composite.addConstraint(car, axelA);
                Composite.addConstraint(car, axelB);
                return car;
              };
              Composites.softBody = function(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
                particleOptions = Common.extend({inertia: Infinity}, particleOptions);
                constraintOptions = Common.extend({stiffness: 0.2, render: {type: "line", anchors: false}}, constraintOptions);
                var softBody = Composites.stack(x, y, columns, rows, columnGap, rowGap, function(stackX, stackY) {
                  return Bodies.circle(stackX, stackY, particleRadius, particleOptions);
                });
                Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);
                softBody.label = "Soft Body";
                return softBody;
              };
            })();
          },
          50658: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Axes = {};
            module2.exports = Axes;
            var Vector = __webpack_require__2(10438);
            var Common = __webpack_require__2(68758);
            (function() {
              Axes.fromVertices = function(vertices) {
                var axes = {};
                for (var i = 0; i < vertices.length; i++) {
                  var j = (i + 1) % vertices.length, normal = Vector.normalise({
                    x: vertices[j].y - vertices[i].y,
                    y: vertices[i].x - vertices[j].x
                  }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;
                  gradient = gradient.toFixed(3).toString();
                  axes[gradient] = normal;
                }
                return Common.values(axes);
              };
              Axes.rotate = function(axes, angle) {
                if (angle === 0)
                  return;
                var cos = Math.cos(angle), sin = Math.sin(angle);
                for (var i = 0; i < axes.length; i++) {
                  var axis = axes[i], xx;
                  xx = axis.x * cos - axis.y * sin;
                  axis.y = axis.x * sin + axis.y * cos;
                  axis.x = xx;
                }
              };
            })();
          },
          84091: (module2) => {
            var Bounds = {};
            module2.exports = Bounds;
            (function() {
              Bounds.create = function(vertices) {
                var bounds = {
                  min: {x: 0, y: 0},
                  max: {x: 0, y: 0}
                };
                if (vertices)
                  Bounds.update(bounds, vertices);
                return bounds;
              };
              Bounds.update = function(bounds, vertices, velocity) {
                bounds.min.x = Infinity;
                bounds.max.x = -Infinity;
                bounds.min.y = Infinity;
                bounds.max.y = -Infinity;
                for (var i = 0; i < vertices.length; i++) {
                  var vertex = vertices[i];
                  if (vertex.x > bounds.max.x)
                    bounds.max.x = vertex.x;
                  if (vertex.x < bounds.min.x)
                    bounds.min.x = vertex.x;
                  if (vertex.y > bounds.max.y)
                    bounds.max.y = vertex.y;
                  if (vertex.y < bounds.min.y)
                    bounds.min.y = vertex.y;
                }
                if (velocity) {
                  if (velocity.x > 0) {
                    bounds.max.x += velocity.x;
                  } else {
                    bounds.min.x += velocity.x;
                  }
                  if (velocity.y > 0) {
                    bounds.max.y += velocity.y;
                  } else {
                    bounds.min.y += velocity.y;
                  }
                }
              };
              Bounds.contains = function(bounds, point) {
                return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
              };
              Bounds.overlaps = function(boundsA, boundsB) {
                return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
              };
              Bounds.translate = function(bounds, vector) {
                bounds.min.x += vector.x;
                bounds.max.x += vector.x;
                bounds.min.y += vector.y;
                bounds.max.y += vector.y;
              };
              Bounds.shift = function(bounds, position) {
                var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;
                bounds.min.x = position.x;
                bounds.max.x = position.x + deltaX;
                bounds.min.y = position.y;
                bounds.max.y = position.y + deltaY;
              };
            })();
          },
          92765: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Svg = {};
            module2.exports = Svg;
            var Bounds = __webpack_require__2(84091);
            var Common = __webpack_require__2(68758);
            (function() {
              Svg.pathToVertices = function(path, sampleLength) {
                if (typeof window !== "undefined" && !("SVGPathSeg" in window)) {
                  Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
                }
                var i, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x = 0, y = 0;
                sampleLength = sampleLength || 15;
                var addPoint = function(px, py, pathSegType) {
                  var isRelative = pathSegType % 2 === 1 && pathSegType > 1;
                  if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                    if (lastPoint && isRelative) {
                      lx = lastPoint.x;
                      ly = lastPoint.y;
                    } else {
                      lx = 0;
                      ly = 0;
                    }
                    var point2 = {
                      x: lx + px,
                      y: ly + py
                    };
                    if (isRelative || !lastPoint) {
                      lastPoint = point2;
                    }
                    points.push(point2);
                    x = lx + px;
                    y = ly + py;
                  }
                };
                var addSegmentPoint = function(segment2) {
                  var segType = segment2.pathSegTypeAsLetter.toUpperCase();
                  if (segType === "Z")
                    return;
                  switch (segType) {
                    case "M":
                    case "L":
                    case "T":
                    case "C":
                    case "S":
                    case "Q":
                      x = segment2.x;
                      y = segment2.y;
                      break;
                    case "H":
                      x = segment2.x;
                      break;
                    case "V":
                      y = segment2.y;
                      break;
                  }
                  addPoint(x, y, segment2.pathSegType);
                };
                Svg._svgPathToAbsolute(path);
                total = path.getTotalLength();
                segments = [];
                for (i = 0; i < path.pathSegList.numberOfItems; i += 1)
                  segments.push(path.pathSegList.getItem(i));
                segmentsQueue = segments.concat();
                while (length < total) {
                  segmentIndex = path.getPathSegAtLength(length);
                  segment = segments[segmentIndex];
                  if (segment != lastSegment) {
                    while (segmentsQueue.length && segmentsQueue[0] != segment)
                      addSegmentPoint(segmentsQueue.shift());
                    lastSegment = segment;
                  }
                  switch (segment.pathSegTypeAsLetter.toUpperCase()) {
                    case "C":
                    case "T":
                    case "S":
                    case "Q":
                    case "A":
                      point = path.getPointAtLength(length);
                      addPoint(point.x, point.y, 0);
                      break;
                  }
                  length += sampleLength;
                }
                for (i = 0, il = segmentsQueue.length; i < il; ++i)
                  addSegmentPoint(segmentsQueue[i]);
                return points;
              };
              Svg._svgPathToAbsolute = function(path) {
                var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems;
                for (var i = 0; i < len; ++i) {
                  var seg = segs.getItem(i), segType = seg.pathSegTypeAsLetter;
                  if (/[MLHVCSQTA]/.test(segType)) {
                    if ("x" in seg)
                      x = seg.x;
                    if ("y" in seg)
                      y = seg.y;
                  } else {
                    if ("x1" in seg)
                      x1 = x + seg.x1;
                    if ("x2" in seg)
                      x2 = x + seg.x2;
                    if ("y1" in seg)
                      y1 = y + seg.y1;
                    if ("y2" in seg)
                      y2 = y + seg.y2;
                    if ("x" in seg)
                      x += seg.x;
                    if ("y" in seg)
                      y += seg.y;
                    switch (segType) {
                      case "m":
                        segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                        break;
                      case "l":
                        segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                        break;
                      case "h":
                        segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                        break;
                      case "v":
                        segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                        break;
                      case "c":
                        segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                        break;
                      case "s":
                        segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                        break;
                      case "q":
                        segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                        break;
                      case "t":
                        segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                        break;
                      case "a":
                        segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                        break;
                      case "z":
                      case "Z":
                        x = x0;
                        y = y0;
                        break;
                    }
                  }
                  if (segType == "M" || segType == "m") {
                    x0 = x;
                    y0 = y;
                  }
                }
              };
            })();
          },
          10438: (module2) => {
            var Vector = {};
            module2.exports = Vector;
            (function() {
              Vector.create = function(x, y) {
                return {x: x || 0, y: y || 0};
              };
              Vector.clone = function(vector) {
                return {x: vector.x, y: vector.y};
              };
              Vector.magnitude = function(vector) {
                return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
              };
              Vector.magnitudeSquared = function(vector) {
                return vector.x * vector.x + vector.y * vector.y;
              };
              Vector.rotate = function(vector, angle, output) {
                var cos = Math.cos(angle), sin = Math.sin(angle);
                if (!output)
                  output = {};
                var x = vector.x * cos - vector.y * sin;
                output.y = vector.x * sin + vector.y * cos;
                output.x = x;
                return output;
              };
              Vector.rotateAbout = function(vector, angle, point, output) {
                var cos = Math.cos(angle), sin = Math.sin(angle);
                if (!output)
                  output = {};
                var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
                output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
                output.x = x;
                return output;
              };
              Vector.normalise = function(vector) {
                var magnitude = Vector.magnitude(vector);
                if (magnitude === 0)
                  return {x: 0, y: 0};
                return {x: vector.x / magnitude, y: vector.y / magnitude};
              };
              Vector.dot = function(vectorA, vectorB) {
                return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
              };
              Vector.cross = function(vectorA, vectorB) {
                return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
              };
              Vector.cross3 = function(vectorA, vectorB, vectorC) {
                return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
              };
              Vector.add = function(vectorA, vectorB, output) {
                if (!output)
                  output = {};
                output.x = vectorA.x + vectorB.x;
                output.y = vectorA.y + vectorB.y;
                return output;
              };
              Vector.sub = function(vectorA, vectorB, output) {
                if (!output)
                  output = {};
                output.x = vectorA.x - vectorB.x;
                output.y = vectorA.y - vectorB.y;
                return output;
              };
              Vector.mult = function(vector, scalar) {
                return {x: vector.x * scalar, y: vector.y * scalar};
              };
              Vector.div = function(vector, scalar) {
                return {x: vector.x / scalar, y: vector.y / scalar};
              };
              Vector.perp = function(vector, negate) {
                negate = negate === true ? -1 : 1;
                return {x: negate * -vector.y, y: negate * vector.x};
              };
              Vector.neg = function(vector) {
                return {x: -vector.x, y: -vector.y};
              };
              Vector.angle = function(vectorA, vectorB) {
                return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
              };
              Vector._temp = [
                Vector.create(),
                Vector.create(),
                Vector.create(),
                Vector.create(),
                Vector.create(),
                Vector.create()
              ];
            })();
          },
          39745: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Vertices = {};
            module2.exports = Vertices;
            var Vector = __webpack_require__2(10438);
            var Common = __webpack_require__2(68758);
            (function() {
              Vertices.create = function(points, body) {
                var vertices = [];
                for (var i = 0; i < points.length; i++) {
                  var point = points[i], vertex = {
                    x: point.x,
                    y: point.y,
                    index: i,
                    body,
                    isInternal: false
                  };
                  vertices.push(vertex);
                }
                return vertices;
              };
              Vertices.fromPath = function(path, body) {
                var pathPattern = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, points = [];
                path.replace(pathPattern, function(match, x, y) {
                  points.push({x: parseFloat(x), y: parseFloat(y)});
                });
                return Vertices.create(points, body);
              };
              Vertices.centre = function(vertices) {
                var area = Vertices.area(vertices, true), centre = {x: 0, y: 0}, cross, temp, j;
                for (var i = 0; i < vertices.length; i++) {
                  j = (i + 1) % vertices.length;
                  cross = Vector.cross(vertices[i], vertices[j]);
                  temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
                  centre = Vector.add(centre, temp);
                }
                return Vector.div(centre, 6 * area);
              };
              Vertices.mean = function(vertices) {
                var average = {x: 0, y: 0};
                for (var i = 0; i < vertices.length; i++) {
                  average.x += vertices[i].x;
                  average.y += vertices[i].y;
                }
                return Vector.div(average, vertices.length);
              };
              Vertices.area = function(vertices, signed) {
                var area = 0, j = vertices.length - 1;
                for (var i = 0; i < vertices.length; i++) {
                  area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
                  j = i;
                }
                if (signed)
                  return area / 2;
                return Math.abs(area) / 2;
              };
              Vertices.inertia = function(vertices, mass) {
                var numerator = 0, denominator = 0, v = vertices, cross, j;
                for (var n = 0; n < v.length; n++) {
                  j = (n + 1) % v.length;
                  cross = Math.abs(Vector.cross(v[j], v[n]));
                  numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
                  denominator += cross;
                }
                return mass / 6 * (numerator / denominator);
              };
              Vertices.translate = function(vertices, vector, scalar) {
                scalar = typeof scalar !== "undefined" ? scalar : 1;
                var verticesLength = vertices.length, translateX = vector.x * scalar, translateY = vector.y * scalar, i;
                for (i = 0; i < verticesLength; i++) {
                  vertices[i].x += translateX;
                  vertices[i].y += translateY;
                }
                return vertices;
              };
              Vertices.rotate = function(vertices, angle, point) {
                if (angle === 0)
                  return;
                var cos = Math.cos(angle), sin = Math.sin(angle), pointX = point.x, pointY = point.y, verticesLength = vertices.length, vertex, dx, dy, i;
                for (i = 0; i < verticesLength; i++) {
                  vertex = vertices[i];
                  dx = vertex.x - pointX;
                  dy = vertex.y - pointY;
                  vertex.x = pointX + (dx * cos - dy * sin);
                  vertex.y = pointY + (dx * sin + dy * cos);
                }
                return vertices;
              };
              Vertices.contains = function(vertices, point) {
                var pointX = point.x, pointY = point.y, verticesLength = vertices.length, vertex = vertices[verticesLength - 1], nextVertex;
                for (var i = 0; i < verticesLength; i++) {
                  nextVertex = vertices[i];
                  if ((pointX - vertex.x) * (nextVertex.y - vertex.y) + (pointY - vertex.y) * (vertex.x - nextVertex.x) > 0) {
                    return false;
                  }
                  vertex = nextVertex;
                }
                return true;
              };
              Vertices.scale = function(vertices, scaleX, scaleY, point) {
                if (scaleX === 1 && scaleY === 1)
                  return vertices;
                point = point || Vertices.centre(vertices);
                var vertex, delta;
                for (var i = 0; i < vertices.length; i++) {
                  vertex = vertices[i];
                  delta = Vector.sub(vertex, point);
                  vertices[i].x = point.x + delta.x * scaleX;
                  vertices[i].y = point.y + delta.y * scaleY;
                }
                return vertices;
              };
              Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
                if (typeof radius === "number") {
                  radius = [radius];
                } else {
                  radius = radius || [8];
                }
                quality = typeof quality !== "undefined" ? quality : -1;
                qualityMin = qualityMin || 2;
                qualityMax = qualityMax || 14;
                var newVertices = [];
                for (var i = 0; i < vertices.length; i++) {
                  var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1], vertex = vertices[i], nextVertex = vertices[(i + 1) % vertices.length], currentRadius = radius[i < radius.length ? i : radius.length - 1];
                  if (currentRadius === 0) {
                    newVertices.push(vertex);
                    continue;
                  }
                  var prevNormal = Vector.normalise({
                    x: vertex.y - prevVertex.y,
                    y: prevVertex.x - vertex.x
                  });
                  var nextNormal = Vector.normalise({
                    x: nextVertex.y - vertex.y,
                    y: vertex.x - nextVertex.x
                  });
                  var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));
                  var precision = quality;
                  if (quality === -1) {
                    precision = Math.pow(currentRadius, 0.32) * 1.75;
                  }
                  precision = Common.clamp(precision, qualityMin, qualityMax);
                  if (precision % 2 === 1)
                    precision += 1;
                  var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;
                  for (var j = 0; j < precision; j++) {
                    newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
                  }
                }
                return newVertices;
              };
              Vertices.clockwiseSort = function(vertices) {
                var centre = Vertices.mean(vertices);
                vertices.sort(function(vertexA, vertexB) {
                  return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
                });
                return vertices;
              };
              Vertices.isConvex = function(vertices) {
                var flag = 0, n = vertices.length, i, j, k, z;
                if (n < 3)
                  return null;
                for (i = 0; i < n; i++) {
                  j = (i + 1) % n;
                  k = (i + 2) % n;
                  z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
                  z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);
                  if (z < 0) {
                    flag |= 1;
                  } else if (z > 0) {
                    flag |= 2;
                  }
                  if (flag === 3) {
                    return false;
                  }
                }
                if (flag !== 0) {
                  return true;
                } else {
                  return null;
                }
              };
              Vertices.hull = function(vertices) {
                var upper = [], lower = [], vertex, i;
                vertices = vertices.slice(0);
                vertices.sort(function(vertexA, vertexB) {
                  var dx = vertexA.x - vertexB.x;
                  return dx !== 0 ? dx : vertexA.y - vertexB.y;
                });
                for (i = 0; i < vertices.length; i += 1) {
                  vertex = vertices[i];
                  while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                    lower.pop();
                  }
                  lower.push(vertex);
                }
                for (i = vertices.length - 1; i >= 0; i -= 1) {
                  vertex = vertices[i];
                  while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                    upper.pop();
                  }
                  upper.push(vertex);
                }
                upper.pop();
                lower.pop();
                return upper.concat(lower);
              };
            })();
          },
          1675: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Matter = __webpack_require__2(18171);
            var MatterAttractors = {
              name: "matter-attractors",
              version: "0.1.7",
              for: "matter-js@^0.19.0",
              silent: true,
              install: function(base) {
                base.after("Body.create", function() {
                  MatterAttractors.Body.init(this);
                });
                base.before("Engine.update", function(engine) {
                  MatterAttractors.Engine.update(engine);
                });
              },
              Body: {
                init: function(body) {
                  body.plugin.attractors = body.plugin.attractors || [];
                }
              },
              Engine: {
                update: function(engine) {
                  var bodies = Matter.Composite.allBodies(engine.world);
                  for (var i = 0; i < bodies.length; i++) {
                    var bodyA = bodies[i];
                    var attractors = bodyA.plugin.attractors;
                    if (attractors && attractors.length > 0) {
                      for (var j = 0; j < bodies.length; j++) {
                        var bodyB = bodies[j];
                        if (i !== j) {
                          for (var k = 0; k < attractors.length; k++) {
                            var attractor = attractors[k];
                            var forceVector = attractor;
                            if (Matter.Common.isFunction(attractor)) {
                              forceVector = attractor(bodyA, bodyB);
                            }
                            if (forceVector) {
                              Matter.Body.applyForce(bodyB, bodyB.position, forceVector);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              Attractors: {
                gravityConstant: 1e-3,
                gravity: function(bodyA, bodyB) {
                  var bToA = Matter.Vector.sub(bodyB.position, bodyA.position);
                  var distanceSq = Matter.Vector.magnitudeSquared(bToA) || 1e-4;
                  var normal = Matter.Vector.normalise(bToA);
                  var magnitude = -MatterAttractors.Attractors.gravityConstant * (bodyA.mass * bodyB.mass / distanceSq);
                  var force = Matter.Vector.mult(normal, magnitude);
                  Matter.Body.applyForce(bodyA, bodyA.position, Matter.Vector.neg(force));
                  Matter.Body.applyForce(bodyB, bodyB.position, force);
                }
              }
            };
            module2.exports = MatterAttractors;
          },
          80391: (module2) => {
            /**
             * @author       @dxu https://github.com/dxu/matter-collision-events
             * @author       Richard Davey <rich@photonstorm.com>
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MatterCollisionEvents = {
              name: "matter-collision-events",
              version: "0.1.6",
              for: "matter-js@^0.19.0",
              silent: true,
              install: function(matter) {
                matter.after("Engine.create", function() {
                  matter.Events.on(this, "collisionStart", function(event) {
                    event.pairs.map(function(pair) {
                      var bodyA = pair.bodyA;
                      var bodyB = pair.bodyB;
                      if (bodyA.gameObject) {
                        bodyA.gameObject.emit("collide", bodyA, bodyB, pair);
                      }
                      if (bodyB.gameObject) {
                        bodyB.gameObject.emit("collide", bodyB, bodyA, pair);
                      }
                      matter.Events.trigger(bodyA, "onCollide", {pair});
                      matter.Events.trigger(bodyB, "onCollide", {pair});
                      if (bodyA.onCollideCallback) {
                        bodyA.onCollideCallback(pair);
                      }
                      if (bodyB.onCollideCallback) {
                        bodyB.onCollideCallback(pair);
                      }
                      if (bodyA.onCollideWith[bodyB.id]) {
                        bodyA.onCollideWith[bodyB.id](bodyB, pair);
                      }
                      if (bodyB.onCollideWith[bodyA.id]) {
                        bodyB.onCollideWith[bodyA.id](bodyA, pair);
                      }
                    });
                  });
                  matter.Events.on(this, "collisionActive", function(event) {
                    event.pairs.map(function(pair) {
                      var bodyA = pair.bodyA;
                      var bodyB = pair.bodyB;
                      if (bodyA.gameObject) {
                        bodyA.gameObject.emit("collideActive", bodyA, bodyB, pair);
                      }
                      if (bodyB.gameObject) {
                        bodyB.gameObject.emit("collideActive", bodyB, bodyA, pair);
                      }
                      matter.Events.trigger(bodyA, "onCollideActive", {pair});
                      matter.Events.trigger(bodyB, "onCollideActive", {pair});
                      if (bodyA.onCollideActiveCallback) {
                        bodyA.onCollideActiveCallback(pair);
                      }
                      if (bodyB.onCollideActiveCallback) {
                        bodyB.onCollideActiveCallback(pair);
                      }
                    });
                  });
                  matter.Events.on(this, "collisionEnd", function(event) {
                    event.pairs.map(function(pair) {
                      var bodyA = pair.bodyA;
                      var bodyB = pair.bodyB;
                      if (bodyA.gameObject) {
                        bodyA.gameObject.emit("collideEnd", bodyA, bodyB, pair);
                      }
                      if (bodyB.gameObject) {
                        bodyB.gameObject.emit("collideEnd", bodyB, bodyA, pair);
                      }
                      matter.Events.trigger(bodyA, "onCollideEnd", {pair});
                      matter.Events.trigger(bodyB, "onCollideEnd", {pair});
                      if (bodyA.onCollideEndCallback) {
                        bodyA.onCollideEndCallback(pair);
                      }
                      if (bodyB.onCollideEndCallback) {
                        bodyB.onCollideEndCallback(pair);
                      }
                    });
                  });
                });
              }
            };
            module2.exports = MatterCollisionEvents;
          },
          44097: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Matter = __webpack_require__2(18171);
            var MatterWrap = {
              name: "matter-wrap",
              version: "0.1.4",
              for: "matter-js@^0.19.0",
              silent: true,
              install: function(base) {
                base.after("Engine.update", function() {
                  MatterWrap.Engine.update(this);
                });
              },
              Engine: {
                update: function(engine) {
                  var world = engine.world, bodies = Matter.Composite.allBodies(world), composites = Matter.Composite.allComposites(world);
                  for (var i = 0; i < bodies.length; i += 1) {
                    var body = bodies[i];
                    if (body.plugin.wrap) {
                      MatterWrap.Body.wrap(body, body.plugin.wrap);
                    }
                  }
                  for (i = 0; i < composites.length; i += 1) {
                    var composite = composites[i];
                    if (composite.plugin.wrap) {
                      MatterWrap.Composite.wrap(composite, composite.plugin.wrap);
                    }
                  }
                }
              },
              Bounds: {
                wrap: function(objectBounds, bounds) {
                  var x = null, y = null;
                  if (typeof bounds.min.x !== "undefined" && typeof bounds.max.x !== "undefined") {
                    if (objectBounds.min.x > bounds.max.x) {
                      x = bounds.min.x - objectBounds.max.x;
                    } else if (objectBounds.max.x < bounds.min.x) {
                      x = bounds.max.x - objectBounds.min.x;
                    }
                  }
                  if (typeof bounds.min.y !== "undefined" && typeof bounds.max.y !== "undefined") {
                    if (objectBounds.min.y > bounds.max.y) {
                      y = bounds.min.y - objectBounds.max.y;
                    } else if (objectBounds.max.y < bounds.min.y) {
                      y = bounds.max.y - objectBounds.min.y;
                    }
                  }
                  if (x !== null || y !== null) {
                    return {
                      x: x || 0,
                      y: y || 0
                    };
                  }
                }
              },
              Body: {
                wrap: function(body, bounds) {
                  var translation = MatterWrap.Bounds.wrap(body.bounds, bounds);
                  if (translation) {
                    Matter.Body.translate(body, translation);
                  }
                  return translation;
                }
              },
              Composite: {
                bounds: function(composite) {
                  var bodies = Matter.Composite.allBodies(composite), vertices = [];
                  for (var i = 0; i < bodies.length; i += 1) {
                    var body = bodies[i];
                    vertices.push(body.bounds.min, body.bounds.max);
                  }
                  return Matter.Bounds.create(vertices);
                },
                wrap: function(composite, bounds) {
                  var translation = MatterWrap.Bounds.wrap(MatterWrap.Composite.bounds(composite), bounds);
                  if (translation) {
                    Matter.Composite.translate(composite, translation);
                  }
                  return translation;
                }
              }
            };
            module2.exports = MatterWrap;
          },
          81084: (module2) => {
            /**
             * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              decomp: polygonDecomp,
              quickDecomp: polygonQuickDecomp,
              isSimple: polygonIsSimple,
              removeCollinearPoints: polygonRemoveCollinearPoints,
              removeDuplicatePoints: polygonRemoveDuplicatePoints,
              makeCCW: polygonMakeCCW
            };
            function lineInt(l1, l2, precision) {
              precision = precision || 0;
              var i = [0, 0];
              var a1, b1, c1, a2, b2, c2, det;
              a1 = l1[1][1] - l1[0][1];
              b1 = l1[0][0] - l1[1][0];
              c1 = a1 * l1[0][0] + b1 * l1[0][1];
              a2 = l2[1][1] - l2[0][1];
              b2 = l2[0][0] - l2[1][0];
              c2 = a2 * l2[0][0] + b2 * l2[0][1];
              det = a1 * b2 - a2 * b1;
              if (!scalar_eq(det, 0, precision)) {
                i[0] = (b2 * c1 - b1 * c2) / det;
                i[1] = (a1 * c2 - a2 * c1) / det;
              }
              return i;
            }
            function lineSegmentsIntersect(p1, p2, q1, q2) {
              var dx = p2[0] - p1[0];
              var dy = p2[1] - p1[1];
              var da = q2[0] - q1[0];
              var db = q2[1] - q1[1];
              if (da * dy - db * dx === 0) {
                return false;
              }
              var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
              var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
              return s >= 0 && s <= 1 && t >= 0 && t <= 1;
            }
            function triangleArea(a, b, c) {
              return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
            }
            function isLeft(a, b, c) {
              return triangleArea(a, b, c) > 0;
            }
            function isLeftOn(a, b, c) {
              return triangleArea(a, b, c) >= 0;
            }
            function isRight(a, b, c) {
              return triangleArea(a, b, c) < 0;
            }
            function isRightOn(a, b, c) {
              return triangleArea(a, b, c) <= 0;
            }
            var tmpPoint1 = [], tmpPoint2 = [];
            function collinear(a, b, c, thresholdAngle) {
              if (!thresholdAngle) {
                return triangleArea(a, b, c) === 0;
              } else {
                var ab = tmpPoint1, bc = tmpPoint2;
                ab[0] = b[0] - a[0];
                ab[1] = b[1] - a[1];
                bc[0] = c[0] - b[0];
                bc[1] = c[1] - b[1];
                var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
                return angle < thresholdAngle;
              }
            }
            function sqdist(a, b) {
              var dx = b[0] - a[0];
              var dy = b[1] - a[1];
              return dx * dx + dy * dy;
            }
            function polygonAt(polygon, i) {
              var s = polygon.length;
              return polygon[i < 0 ? i % s + s : i % s];
            }
            function polygonClear(polygon) {
              polygon.length = 0;
            }
            function polygonAppend(polygon, poly, from, to) {
              for (var i = from; i < to; i++) {
                polygon.push(poly[i]);
              }
            }
            function polygonMakeCCW(polygon) {
              var br = 0, v = polygon;
              for (var i = 1; i < polygon.length; ++i) {
                if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {
                  br = i;
                }
              }
              if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
                polygonReverse(polygon);
                return true;
              } else {
                return false;
              }
            }
            function polygonReverse(polygon) {
              var tmp = [];
              var N = polygon.length;
              for (var i = 0; i !== N; i++) {
                tmp.push(polygon.pop());
              }
              for (var i = 0; i !== N; i++) {
                polygon[i] = tmp[i];
              }
            }
            function polygonIsReflex(polygon, i) {
              return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
            }
            var tmpLine1 = [], tmpLine2 = [];
            function polygonCanSee(polygon, a, b) {
              var p, dist, l1 = tmpLine1, l2 = tmpLine2;
              if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
                return false;
              }
              dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
              for (var i = 0; i !== polygon.length; ++i) {
                if ((i + 1) % polygon.length === a || i === a) {
                  continue;
                }
                if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {
                  l1[0] = polygonAt(polygon, a);
                  l1[1] = polygonAt(polygon, b);
                  l2[0] = polygonAt(polygon, i);
                  l2[1] = polygonAt(polygon, i + 1);
                  p = lineInt(l1, l2);
                  if (sqdist(polygonAt(polygon, a), p) < dist) {
                    return false;
                  }
                }
              }
              return true;
            }
            function polygonCanSee2(polygon, a, b) {
              for (var i = 0; i !== polygon.length; ++i) {
                if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
                  continue;
                }
                if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
                  return false;
                }
              }
              return true;
            }
            function polygonCopy(polygon, i, j, targetPoly) {
              var p = targetPoly || [];
              polygonClear(p);
              if (i < j) {
                for (var k = i; k <= j; k++) {
                  p.push(polygon[k]);
                }
              } else {
                for (var k = 0; k <= j; k++) {
                  p.push(polygon[k]);
                }
                for (var k = i; k < polygon.length; k++) {
                  p.push(polygon[k]);
                }
              }
              return p;
            }
            function polygonGetCutEdges(polygon) {
              var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
              var nDiags = Number.MAX_VALUE;
              for (var i = 0; i < polygon.length; ++i) {
                if (polygonIsReflex(polygon, i)) {
                  for (var j = 0; j < polygon.length; ++j) {
                    if (polygonCanSee(polygon, i, j)) {
                      tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                      tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
                      for (var k = 0; k < tmp2.length; k++) {
                        tmp1.push(tmp2[k]);
                      }
                      if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                      }
                    }
                  }
                }
              }
              return min;
            }
            function polygonDecomp(polygon) {
              var edges = polygonGetCutEdges(polygon);
              if (edges.length > 0) {
                return polygonSlice(polygon, edges);
              } else {
                return [polygon];
              }
            }
            function polygonSlice(polygon, cutEdges) {
              if (cutEdges.length === 0) {
                return [polygon];
              }
              if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
                var polys = [polygon];
                for (var i = 0; i < cutEdges.length; i++) {
                  var cutEdge = cutEdges[i];
                  for (var j = 0; j < polys.length; j++) {
                    var poly = polys[j];
                    var result = polygonSlice(poly, cutEdge);
                    if (result) {
                      polys.splice(j, 1);
                      polys.push(result[0], result[1]);
                      break;
                    }
                  }
                }
                return polys;
              } else {
                var cutEdge = cutEdges;
                var i = polygon.indexOf(cutEdge[0]);
                var j = polygon.indexOf(cutEdge[1]);
                if (i !== -1 && j !== -1) {
                  return [
                    polygonCopy(polygon, i, j),
                    polygonCopy(polygon, j, i)
                  ];
                } else {
                  return false;
                }
              }
            }
            function polygonIsSimple(polygon) {
              var path = polygon, i;
              for (i = 0; i < path.length - 1; i++) {
                for (var j = 0; j < i - 1; j++) {
                  if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                    return false;
                  }
                }
              }
              for (i = 1; i < path.length - 2; i++) {
                if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
                  return false;
                }
              }
              return true;
            }
            function getIntersectionPoint(p1, p2, q1, q2, delta) {
              delta = delta || 0;
              var a1 = p2[1] - p1[1];
              var b1 = p1[0] - p2[0];
              var c1 = a1 * p1[0] + b1 * p1[1];
              var a2 = q2[1] - q1[1];
              var b2 = q1[0] - q2[0];
              var c2 = a2 * q1[0] + b2 * q1[1];
              var det = a1 * b2 - a2 * b1;
              if (!scalar_eq(det, 0, delta)) {
                return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
              } else {
                return [0, 0];
              }
            }
            function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
              maxlevel = maxlevel || 100;
              level = level || 0;
              delta = delta || 25;
              result = typeof result !== "undefined" ? result : [];
              reflexVertices = reflexVertices || [];
              steinerPoints = steinerPoints || [];
              var upperInt = [0, 0], lowerInt = [0, 0], p = [0, 0];
              var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
              var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
              var lowerPoly = [], upperPoly = [];
              var poly = polygon, v = polygon;
              if (v.length < 3) {
                return result;
              }
              level++;
              if (level > maxlevel) {
                console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
                return result;
              }
              for (var i = 0; i < polygon.length; ++i) {
                if (polygonIsReflex(poly, i)) {
                  reflexVertices.push(poly[i]);
                  upperDist = lowerDist = Number.MAX_VALUE;
                  for (var j = 0; j < polygon.length; ++j) {
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {
                      p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1));
                      if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) {
                          lowerDist = d;
                          lowerInt = p;
                          lowerIndex = j;
                        }
                      }
                    }
                    if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                      p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                      if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                          upperDist = d;
                          upperInt = p;
                          upperIndex = j;
                        }
                      }
                    }
                  }
                  if (lowerIndex === (upperIndex + 1) % polygon.length) {
                    p[0] = (lowerInt[0] + upperInt[0]) / 2;
                    p[1] = (lowerInt[1] + upperInt[1]) / 2;
                    steinerPoints.push(p);
                    if (i < upperIndex) {
                      polygonAppend(lowerPoly, poly, i, upperIndex + 1);
                      lowerPoly.push(p);
                      upperPoly.push(p);
                      if (lowerIndex !== 0) {
                        polygonAppend(upperPoly, poly, lowerIndex, poly.length);
                      }
                      polygonAppend(upperPoly, poly, 0, i + 1);
                    } else {
                      if (i !== 0) {
                        polygonAppend(lowerPoly, poly, i, poly.length);
                      }
                      polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
                      lowerPoly.push(p);
                      upperPoly.push(p);
                      polygonAppend(upperPoly, poly, lowerIndex, i + 1);
                    }
                  } else {
                    if (lowerIndex > upperIndex) {
                      upperIndex += polygon.length;
                    }
                    closestDist = Number.MAX_VALUE;
                    if (upperIndex < lowerIndex) {
                      return result;
                    }
                    for (var j = lowerIndex; j <= upperIndex; ++j) {
                      if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist && polygonCanSee2(poly, i, j)) {
                          closestDist = d;
                          closestIndex = j % polygon.length;
                        }
                      }
                    }
                    if (i < closestIndex) {
                      polygonAppend(lowerPoly, poly, i, closestIndex + 1);
                      if (closestIndex !== 0) {
                        polygonAppend(upperPoly, poly, closestIndex, v.length);
                      }
                      polygonAppend(upperPoly, poly, 0, i + 1);
                    } else {
                      if (i !== 0) {
                        polygonAppend(lowerPoly, poly, i, v.length);
                      }
                      polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
                      polygonAppend(upperPoly, poly, closestIndex, i + 1);
                    }
                  }
                  if (lowerPoly.length < upperPoly.length) {
                    polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                    polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                  } else {
                    polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                    polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                  }
                  return result;
                }
              }
              result.push(polygon);
              return result;
            }
            function polygonRemoveCollinearPoints(polygon, precision) {
              var num = 0;
              for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
                if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
                  polygon.splice(i % polygon.length, 1);
                  num++;
                }
              }
              return num;
            }
            function polygonRemoveDuplicatePoints(polygon, precision) {
              for (var i = polygon.length - 1; i >= 1; --i) {
                var pi = polygon[i];
                for (var j = i - 1; j >= 0; --j) {
                  if (points_eq(pi, polygon[j], precision)) {
                    polygon.splice(i, 1);
                    continue;
                  }
                }
              }
            }
            function scalar_eq(a, b, precision) {
              precision = precision || 0;
              return Math.abs(a - b) <= precision;
            }
            function points_eq(a, b, precision) {
              return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
            }
          },
          88257: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
            * @author       Richard Davey <rich@photonstorm.com>
            * @copyright    2013-2023 Photon Storm Ltd.
            * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
            */
            var Class = __webpack_require__2(56694);
            var BasePlugin = new Class({
              initialize: function BasePlugin2(pluginManager) {
                this.pluginManager = pluginManager;
                this.game = pluginManager.game;
              },
              init: function() {
              },
              start: function() {
              },
              stop: function() {
              },
              destroy: function() {
                this.pluginManager = null;
                this.game = null;
                this.scene = null;
                this.systems = null;
              }
            });
            module2.exports = BasePlugin;
          },
          18360: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DefaultPlugins = {
              Global: [
                "game",
                "anims",
                "cache",
                "plugins",
                "registry",
                "scale",
                "sound",
                "textures",
                "renderer"
              ],
              CoreScene: [
                "EventEmitter",
                "CameraManager",
                "GameObjectCreator",
                "GameObjectFactory",
                "ScenePlugin",
                "DisplayList",
                "UpdateList"
              ],
              DefaultScene: [
                "Clock",
                "DataManagerPlugin",
                "InputPlugin",
                "Loader",
                "TweenManager",
                "LightsPlugin"
              ]
            };
            if (false) {
            }
            if (false) {
            }
            module2.exports = DefaultPlugins;
          },
          91963: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var corePlugins = {};
            var customPlugins = {};
            var PluginCache = {};
            PluginCache.register = function(key, plugin, mapping, custom) {
              if (custom === void 0) {
                custom = false;
              }
              corePlugins[key] = {plugin, mapping, custom};
            };
            PluginCache.registerCustom = function(key, plugin, mapping, data) {
              customPlugins[key] = {plugin, mapping, data};
            };
            PluginCache.hasCore = function(key) {
              return corePlugins.hasOwnProperty(key);
            };
            PluginCache.hasCustom = function(key) {
              return customPlugins.hasOwnProperty(key);
            };
            PluginCache.getCore = function(key) {
              return corePlugins[key];
            };
            PluginCache.getCustom = function(key) {
              return customPlugins[key];
            };
            PluginCache.getCustomClass = function(key) {
              return customPlugins.hasOwnProperty(key) ? customPlugins[key].plugin : null;
            };
            PluginCache.remove = function(key) {
              if (corePlugins.hasOwnProperty(key)) {
                delete corePlugins[key];
              }
            };
            PluginCache.removeCustom = function(key) {
              if (customPlugins.hasOwnProperty(key)) {
                delete customPlugins[key];
              }
            };
            PluginCache.destroyCorePlugins = function() {
              for (var key in corePlugins) {
                if (corePlugins.hasOwnProperty(key)) {
                  delete corePlugins[key];
                }
              }
            };
            PluginCache.destroyCustomPlugins = function() {
              for (var key in customPlugins) {
                if (customPlugins.hasOwnProperty(key)) {
                  delete customPlugins[key];
                }
              }
            };
            module2.exports = PluginCache;
          },
          49274: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GameEvents = __webpack_require__2(97081);
            var EventEmitter = __webpack_require__2(6659);
            var FileTypesManager = __webpack_require__2(76846);
            var GameObjectCreator = __webpack_require__2(99325);
            var GameObjectFactory = __webpack_require__2(61286);
            var GetFastValue = __webpack_require__2(72632);
            var PluginCache = __webpack_require__2(91963);
            var Remove = __webpack_require__2(66458);
            var PluginManager = new Class({
              Extends: EventEmitter,
              initialize: function PluginManager2(game) {
                EventEmitter.call(this);
                this.game = game;
                this.plugins = [];
                this.scenePlugins = [];
                this._pendingGlobal = [];
                this._pendingScene = [];
                if (game.isBooted) {
                  this.boot();
                } else {
                  game.events.once(GameEvents.BOOT, this.boot, this);
                }
              },
              boot: function() {
                var i;
                var entry;
                var key;
                var plugin;
                var start;
                var mapping;
                var data;
                var config2 = this.game.config;
                var list = config2.installGlobalPlugins;
                list = list.concat(this._pendingGlobal);
                for (i = 0; i < list.length; i++) {
                  entry = list[i];
                  key = GetFastValue(entry, "key", null);
                  plugin = GetFastValue(entry, "plugin", null);
                  start = GetFastValue(entry, "start", false);
                  mapping = GetFastValue(entry, "mapping", null);
                  data = GetFastValue(entry, "data", null);
                  if (key) {
                    if (plugin) {
                      this.install(key, plugin, start, mapping, data);
                    } else {
                      console.warn("Missing `plugin` for key: " + key);
                    }
                  }
                }
                list = config2.installScenePlugins;
                list = list.concat(this._pendingScene);
                for (i = 0; i < list.length; i++) {
                  entry = list[i];
                  key = GetFastValue(entry, "key", null);
                  plugin = GetFastValue(entry, "plugin", null);
                  mapping = GetFastValue(entry, "mapping", null);
                  if (key) {
                    if (plugin) {
                      this.installScenePlugin(key, plugin, mapping);
                    } else {
                      console.warn("Missing `plugin` for key: " + key);
                    }
                  }
                }
                this._pendingGlobal = [];
                this._pendingScene = [];
                this.game.events.once(GameEvents.DESTROY, this.destroy, this);
              },
              addToScene: function(sys, globalPlugins, scenePlugins) {
                var i;
                var pluginKey;
                var pluginList;
                var game = this.game;
                var scene = sys.scene;
                var map = sys.settings.map;
                var isBooted = sys.settings.isBooted;
                for (i = 0; i < globalPlugins.length; i++) {
                  pluginKey = globalPlugins[i];
                  if (game[pluginKey]) {
                    sys[pluginKey] = game[pluginKey];
                    if (map.hasOwnProperty(pluginKey)) {
                      scene[map[pluginKey]] = sys[pluginKey];
                    }
                  } else if (pluginKey === "game" && map.hasOwnProperty(pluginKey)) {
                    scene[map[pluginKey]] = game;
                  }
                }
                for (var s = 0; s < scenePlugins.length; s++) {
                  pluginList = scenePlugins[s];
                  for (i = 0; i < pluginList.length; i++) {
                    pluginKey = pluginList[i];
                    if (!PluginCache.hasCore(pluginKey)) {
                      continue;
                    }
                    var source = PluginCache.getCore(pluginKey);
                    var mapKey = source.mapping;
                    var plugin = new source.plugin(scene, this, mapKey);
                    sys[mapKey] = plugin;
                    if (source.custom) {
                      scene[mapKey] = plugin;
                    } else if (map.hasOwnProperty(mapKey)) {
                      scene[map[mapKey]] = plugin;
                    }
                    if (isBooted) {
                      plugin.boot();
                    }
                  }
                }
                pluginList = this.plugins;
                for (i = 0; i < pluginList.length; i++) {
                  var entry = pluginList[i];
                  if (entry.mapping) {
                    scene[entry.mapping] = entry.plugin;
                  }
                }
              },
              getDefaultScenePlugins: function() {
                var list = this.game.config.defaultPlugins;
                list = list.concat(this.scenePlugins);
                return list;
              },
              installScenePlugin: function(key, plugin, mapping, addToScene, fromLoader) {
                if (fromLoader === void 0) {
                  fromLoader = false;
                }
                if (typeof plugin !== "function") {
                  console.warn("Invalid Scene Plugin: " + key);
                  return;
                }
                if (!PluginCache.hasCore(key)) {
                  PluginCache.register(key, plugin, mapping, true);
                }
                if (this.scenePlugins.indexOf(key) === -1) {
                  this.scenePlugins.push(key);
                } else if (!fromLoader && PluginCache.hasCore(key)) {
                  console.warn("Scene Plugin key in use: " + key);
                  return;
                }
                if (addToScene) {
                  var instance = new plugin(addToScene, this, key);
                  addToScene.sys[key] = instance;
                  if (mapping && mapping !== "") {
                    addToScene[mapping] = instance;
                  }
                  instance.boot();
                }
              },
              install: function(key, plugin, start, mapping, data) {
                if (start === void 0) {
                  start = false;
                }
                if (mapping === void 0) {
                  mapping = null;
                }
                if (data === void 0) {
                  data = null;
                }
                if (typeof plugin !== "function") {
                  console.warn("Invalid Plugin: " + key);
                  return null;
                }
                if (PluginCache.hasCustom(key)) {
                  console.warn("Plugin key in use: " + key);
                  return null;
                }
                if (mapping !== null) {
                  start = true;
                }
                if (!this.game.isBooted) {
                  this._pendingGlobal.push({key, plugin, start, mapping, data});
                } else {
                  PluginCache.registerCustom(key, plugin, mapping, data);
                  if (start) {
                    return this.start(key);
                  }
                }
                return null;
              },
              getIndex: function(key) {
                var list = this.plugins;
                for (var i = 0; i < list.length; i++) {
                  var entry = list[i];
                  if (entry.key === key) {
                    return i;
                  }
                }
                return -1;
              },
              getEntry: function(key) {
                var idx = this.getIndex(key);
                if (idx !== -1) {
                  return this.plugins[idx];
                }
              },
              isActive: function(key) {
                var entry = this.getEntry(key);
                return entry && entry.active;
              },
              start: function(key, runAs) {
                if (runAs === void 0) {
                  runAs = key;
                }
                var entry = this.getEntry(runAs);
                if (entry && !entry.active) {
                  entry.active = true;
                  entry.plugin.start();
                } else if (!entry) {
                  entry = this.createEntry(key, runAs);
                }
                return entry ? entry.plugin : null;
              },
              createEntry: function(key, runAs) {
                var entry = PluginCache.getCustom(key);
                if (entry) {
                  var instance = new entry.plugin(this);
                  entry = {
                    key: runAs,
                    plugin: instance,
                    active: true,
                    mapping: entry.mapping,
                    data: entry.data
                  };
                  this.plugins.push(entry);
                  instance.init(entry.data);
                  instance.start();
                }
                return entry;
              },
              stop: function(key) {
                var entry = this.getEntry(key);
                if (entry && entry.active) {
                  entry.active = false;
                  entry.plugin.stop();
                }
                return this;
              },
              get: function(key, autoStart) {
                if (autoStart === void 0) {
                  autoStart = true;
                }
                var entry = this.getEntry(key);
                if (entry) {
                  return entry.plugin;
                } else {
                  var plugin = this.getClass(key);
                  if (plugin && autoStart) {
                    entry = this.createEntry(key, key);
                    return entry ? entry.plugin : null;
                  } else if (plugin) {
                    return plugin;
                  }
                }
                return null;
              },
              getClass: function(key) {
                return PluginCache.getCustomClass(key);
              },
              removeGlobalPlugin: function(key) {
                var entry = this.getEntry(key);
                if (entry) {
                  Remove(this.plugins, entry);
                }
                PluginCache.removeCustom(key);
              },
              removeScenePlugin: function(key) {
                Remove(this.scenePlugins, key);
                PluginCache.remove(key);
              },
              registerGameObject: function(key, factoryCallback, creatorCallback) {
                if (factoryCallback) {
                  GameObjectFactory.register(key, factoryCallback);
                }
                if (creatorCallback) {
                  GameObjectCreator.register(key, creatorCallback);
                }
                return this;
              },
              removeGameObject: function(key, removeFromFactory, removeFromCreator) {
                if (removeFromFactory === void 0) {
                  removeFromFactory = true;
                }
                if (removeFromCreator === void 0) {
                  removeFromCreator = true;
                }
                if (removeFromFactory) {
                  GameObjectFactory.remove(key);
                }
                if (removeFromCreator) {
                  GameObjectCreator.remove(key);
                }
                return this;
              },
              registerFileType: function(key, callback, addToScene) {
                FileTypesManager.register(key, callback);
                if (addToScene && addToScene.sys.load) {
                  addToScene.sys.load[key] = callback;
                }
              },
              destroy: function() {
                for (var i = 0; i < this.plugins.length; i++) {
                  this.plugins[i].plugin.destroy();
                }
                PluginCache.destroyCustomPlugins();
                if (this.game.noReturn) {
                  PluginCache.destroyCorePlugins();
                }
                this.game = null;
                this.plugins = [];
                this.scenePlugins = [];
              }
            });
            module2.exports = PluginManager;
          },
          39283: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
            * @author       Richard Davey <rich@photonstorm.com>
            * @copyright    2013-2023 Photon Storm Ltd.
            * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
            */
            var BasePlugin = __webpack_require__2(88257);
            var Class = __webpack_require__2(56694);
            var SceneEvents = __webpack_require__2(7599);
            var ScenePlugin = new Class({
              Extends: BasePlugin,
              initialize: function ScenePlugin2(scene, pluginManager, pluginKey) {
                BasePlugin.call(this, pluginManager);
                this.scene = scene;
                this.systems = scene.sys;
                this.pluginKey = pluginKey;
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              },
              boot: function() {
              },
              destroy: function() {
                this.pluginManager = null;
                this.game = null;
                this.scene = null;
                this.systems = null;
              }
            });
            module2.exports = ScenePlugin;
          },
          45615: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              BasePlugin: __webpack_require__2(88257),
              DefaultPlugins: __webpack_require__2(18360),
              PluginCache: __webpack_require__2(91963),
              PluginManager: __webpack_require__2(49274),
              ScenePlugin: __webpack_require__2(39283)
            };
          },
          75205: () => {
            if (HTMLVideoElement && !("requestVideoFrameCallback" in HTMLVideoElement.prototype) && "getVideoPlaybackQuality" in HTMLVideoElement.prototype) {
              HTMLVideoElement.prototype._rvfcpolyfillmap = {};
              HTMLVideoElement.prototype.requestVideoFrameCallback = function(callback) {
                const handle = performance.now();
                const quality = this.getVideoPlaybackQuality();
                const baseline = this.mozPresentedFrames || this.mozPaintedFrames || quality.totalVideoFrames - quality.droppedVideoFrames;
                const check = (old, now) => {
                  const newquality = this.getVideoPlaybackQuality();
                  const presentedFrames = this.mozPresentedFrames || this.mozPaintedFrames || newquality.totalVideoFrames - newquality.droppedVideoFrames;
                  if (presentedFrames > baseline) {
                    const processingDuration = this.mozFrameDelay || newquality.totalFrameDelay - quality.totalFrameDelay || 0;
                    const timediff = now - old;
                    callback(now, {
                      presentationTime: now + processingDuration * 1e3,
                      expectedDisplayTime: now + timediff,
                      width: this.videoWidth,
                      height: this.videoHeight,
                      mediaTime: Math.max(0, this.currentTime || 0) + timediff / 1e3,
                      presentedFrames,
                      processingDuration
                    });
                    delete this._rvfcpolyfillmap[handle];
                  } else {
                    this._rvfcpolyfillmap[handle] = requestAnimationFrame((newer) => check(now, newer));
                  }
                };
                this._rvfcpolyfillmap[handle] = requestAnimationFrame((newer) => check(handle, newer));
                return handle;
              };
              HTMLVideoElement.prototype.cancelVideoFrameCallback = function(handle) {
                cancelAnimationFrame(this._rvfcpolyfillmap[handle]);
                delete this._rvfcpolyfillmap[handle];
              };
            }
          },
          95723: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              SKIP_CHECK: -1,
              NORMAL: 0,
              ADD: 1,
              MULTIPLY: 2,
              SCREEN: 3,
              OVERLAY: 4,
              DARKEN: 5,
              LIGHTEN: 6,
              COLOR_DODGE: 7,
              COLOR_BURN: 8,
              HARD_LIGHT: 9,
              SOFT_LIGHT: 10,
              DIFFERENCE: 11,
              EXCLUSION: 12,
              HUE: 13,
              SATURATION: 14,
              COLOR: 15,
              LUMINOSITY: 16,
              ERASE: 17,
              SOURCE_IN: 18,
              SOURCE_OUT: 19,
              SOURCE_ATOP: 20,
              DESTINATION_OVER: 21,
              DESTINATION_IN: 22,
              DESTINATION_OUT: 23,
              DESTINATION_ATOP: 24,
              LIGHTER: 25,
              COPY: 26,
              XOR: 27
            };
          },
          27394: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ScaleModes = {
              DEFAULT: 0,
              LINEAR: 0,
              NEAREST: 1
            };
            module2.exports = ScaleModes;
          },
          91135: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CameraEvents = __webpack_require__2(89787);
            var CanvasSnapshot = __webpack_require__2(61840);
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(86459);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(81044);
            var GetBlendModes = __webpack_require__2(32834);
            var ScaleEvents = __webpack_require__2(40444);
            var TextureEvents = __webpack_require__2(38203);
            var TransformMatrix = __webpack_require__2(69360);
            var CanvasRenderer = new Class({
              Extends: EventEmitter,
              initialize: function CanvasRenderer2(game) {
                EventEmitter.call(this);
                var gameConfig = game.config;
                this.config = {
                  clearBeforeRender: gameConfig.clearBeforeRender,
                  backgroundColor: gameConfig.backgroundColor,
                  antialias: gameConfig.antialias,
                  roundPixels: gameConfig.roundPixels
                };
                this.game = game;
                this.type = CONST.CANVAS;
                this.drawCount = 0;
                this.width = 0;
                this.height = 0;
                this.gameCanvas = game.canvas;
                var contextOptions = {
                  alpha: game.config.transparent,
                  desynchronized: game.config.desynchronized,
                  willReadFrequently: false
                };
                this.gameContext = gameConfig.context ? gameConfig.context : this.gameCanvas.getContext("2d", contextOptions);
                this.currentContext = this.gameContext;
                this.antialias = game.config.antialias;
                this.blendModes = GetBlendModes();
                this.snapshotState = {
                  x: 0,
                  y: 0,
                  width: 1,
                  height: 1,
                  getPixel: false,
                  callback: null,
                  type: "image/png",
                  encoder: 0.92
                };
                this._tempMatrix1 = new TransformMatrix();
                this._tempMatrix2 = new TransformMatrix();
                this._tempMatrix3 = new TransformMatrix();
                this.isBooted = false;
                this.init();
              },
              init: function() {
                this.game.textures.once(TextureEvents.READY, this.boot, this);
              },
              boot: function() {
                var game = this.game;
                var baseSize = game.scale.baseSize;
                this.width = baseSize.width;
                this.height = baseSize.height;
                this.isBooted = true;
                game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
                this.resize(baseSize.width, baseSize.height);
              },
              onResize: function(gameSize, baseSize) {
                if (baseSize.width !== this.width || baseSize.height !== this.height) {
                  this.resize(baseSize.width, baseSize.height);
                }
              },
              resize: function(width, height) {
                this.width = width;
                this.height = height;
                this.emit(Events.RESIZE, width, height);
              },
              resetTransform: function() {
                this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
              },
              setBlendMode: function(blendMode) {
                this.currentContext.globalCompositeOperation = blendMode;
                return this;
              },
              setContext: function(ctx) {
                this.currentContext = ctx ? ctx : this.gameContext;
                return this;
              },
              setAlpha: function(alpha) {
                this.currentContext.globalAlpha = alpha;
                return this;
              },
              preRender: function() {
                var ctx = this.gameContext;
                var config2 = this.config;
                var width = this.width;
                var height = this.height;
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                if (config2.clearBeforeRender) {
                  ctx.clearRect(0, 0, width, height);
                  if (!config2.transparent) {
                    ctx.fillStyle = config2.backgroundColor.rgba;
                    ctx.fillRect(0, 0, width, height);
                  }
                }
                ctx.save();
                this.drawCount = 0;
                this.emit(Events.PRE_RENDER);
              },
              render: function(scene, children, camera) {
                var childCount = children.length;
                this.emit(Events.RENDER, scene, camera);
                var cx = camera.x;
                var cy = camera.y;
                var cw = camera.width;
                var ch = camera.height;
                var ctx = camera.renderToTexture ? camera.context : scene.sys.context;
                ctx.save();
                if (this.game.scene.customViewports) {
                  ctx.beginPath();
                  ctx.rect(cx, cy, cw, ch);
                  ctx.clip();
                }
                camera.emit(CameraEvents.PRE_RENDER, camera);
                this.currentContext = ctx;
                var mask = camera.mask;
                if (mask) {
                  mask.preRenderCanvas(this, null, camera._maskCamera);
                }
                if (!camera.transparent) {
                  ctx.fillStyle = camera.backgroundColor.rgba;
                  ctx.fillRect(cx, cy, cw, ch);
                }
                ctx.globalAlpha = camera.alpha;
                ctx.globalCompositeOperation = "source-over";
                this.drawCount += childCount;
                if (camera.renderToTexture) {
                  camera.emit(CameraEvents.PRE_RENDER, camera);
                }
                camera.matrix.copyToContext(ctx);
                for (var i = 0; i < childCount; i++) {
                  var child = children[i];
                  if (child.mask) {
                    child.mask.preRenderCanvas(this, child, camera);
                  }
                  child.renderCanvas(this, child, camera);
                  if (child.mask) {
                    child.mask.postRenderCanvas(this, child, camera);
                  }
                }
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.globalCompositeOperation = "source-over";
                ctx.globalAlpha = 1;
                camera.flashEffect.postRenderCanvas(ctx);
                camera.fadeEffect.postRenderCanvas(ctx);
                camera.dirty = false;
                if (mask) {
                  mask.postRenderCanvas(this);
                }
                ctx.restore();
                if (camera.renderToTexture) {
                  camera.emit(CameraEvents.POST_RENDER, camera);
                  if (camera.renderToGame) {
                    scene.sys.context.drawImage(camera.canvas, cx, cy);
                  }
                }
                camera.emit(CameraEvents.POST_RENDER, camera);
              },
              postRender: function() {
                var ctx = this.gameContext;
                ctx.restore();
                this.emit(Events.POST_RENDER);
                var state = this.snapshotState;
                if (state.callback) {
                  CanvasSnapshot(this.gameCanvas, state);
                  state.callback = null;
                }
              },
              snapshotCanvas: function(canvas, callback, getPixel, x, y, width, height, type, encoderOptions) {
                if (getPixel === void 0) {
                  getPixel = false;
                }
                this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
                var state = this.snapshotState;
                state.getPixel = getPixel;
                CanvasSnapshot(canvas, state);
                state.callback = null;
                return this;
              },
              snapshot: function(callback, type, encoderOptions) {
                return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);
              },
              snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
                var state = this.snapshotState;
                state.callback = callback;
                state.type = type;
                state.encoder = encoderOptions;
                state.getPixel = false;
                state.x = x;
                state.y = y;
                state.width = Math.min(width, this.gameCanvas.width);
                state.height = Math.min(height, this.gameCanvas.height);
                return this;
              },
              snapshotPixel: function(x, y, callback) {
                this.snapshotArea(x, y, 1, 1, callback);
                this.snapshotState.getPixel = true;
                return this;
              },
              batchSprite: function(sprite, frame, camera, parentTransformMatrix) {
                var alpha = camera.alpha * sprite.alpha;
                if (alpha === 0) {
                  return;
                }
                var ctx = this.currentContext;
                var camMatrix = this._tempMatrix1;
                var spriteMatrix = this._tempMatrix2;
                var cd = frame.canvasData;
                var frameX = cd.x;
                var frameY = cd.y;
                var frameWidth = frame.cutWidth;
                var frameHeight = frame.cutHeight;
                var customPivot = frame.customPivot;
                var res = frame.source.resolution;
                var displayOriginX = sprite.displayOriginX;
                var displayOriginY = sprite.displayOriginY;
                var x = -displayOriginX + frame.x;
                var y = -displayOriginY + frame.y;
                if (sprite.isCropped) {
                  var crop = sprite._crop;
                  if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {
                    frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);
                  }
                  frameWidth = crop.cw;
                  frameHeight = crop.ch;
                  frameX = crop.cx;
                  frameY = crop.cy;
                  x = -displayOriginX + crop.x;
                  y = -displayOriginY + crop.y;
                  if (sprite.flipX) {
                    if (x >= 0) {
                      x = -(x + frameWidth);
                    } else if (x < 0) {
                      x = Math.abs(x) - frameWidth;
                    }
                  }
                  if (sprite.flipY) {
                    if (y >= 0) {
                      y = -(y + frameHeight);
                    } else if (y < 0) {
                      y = Math.abs(y) - frameHeight;
                    }
                  }
                }
                var flipX = 1;
                var flipY = 1;
                if (sprite.flipX) {
                  if (!customPivot) {
                    x += -frame.realWidth + displayOriginX * 2;
                  }
                  flipX = -1;
                }
                if (sprite.flipY) {
                  if (!customPivot) {
                    y += -frame.realHeight + displayOriginY * 2;
                  }
                  flipY = -1;
                }
                var gx = sprite.x;
                var gy = sprite.y;
                spriteMatrix.applyITRS(gx, gy, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);
                camMatrix.copyFrom(camera.matrix);
                if (parentTransformMatrix) {
                  camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);
                  spriteMatrix.e = gx;
                  spriteMatrix.f = gy;
                } else {
                  spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;
                  spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;
                }
                camMatrix.multiply(spriteMatrix);
                if (camera.roundPixels) {
                  camMatrix.e = Math.round(camMatrix.e);
                  camMatrix.f = Math.round(camMatrix.f);
                }
                ctx.save();
                camMatrix.setToContext(ctx);
                ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];
                ctx.globalAlpha = alpha;
                ctx.imageSmoothingEnabled = !frame.source.scaleMode;
                if (sprite.mask) {
                  sprite.mask.preRenderCanvas(this, sprite, camera);
                }
                if (frameWidth > 0 && frameHeight > 0) {
                  if (camera.roundPixels) {
                    ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, Math.round(x), Math.round(y), Math.round(frameWidth / res), Math.round(frameHeight / res));
                  } else {
                    ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);
                  }
                }
                if (sprite.mask) {
                  sprite.mask.postRenderCanvas(this, sprite, camera);
                }
                ctx.restore();
              },
              destroy: function() {
                this.removeAllListeners();
                this.game = null;
                this.gameCanvas = null;
                this.gameContext = null;
              }
            });
            module2.exports = CanvasRenderer;
          },
          6046: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              CanvasRenderer: __webpack_require__2(91135),
              GetBlendModes: __webpack_require__2(32834),
              SetTransform: __webpack_require__2(49584)
            };
          },
          32834: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var modes = __webpack_require__2(95723);
            var CanvasFeatures = __webpack_require__2(98581);
            var GetBlendModes = function() {
              var output = [];
              var useNew = CanvasFeatures.supportNewBlendModes;
              var so = "source-over";
              output[modes.NORMAL] = so;
              output[modes.ADD] = "lighter";
              output[modes.MULTIPLY] = useNew ? "multiply" : so;
              output[modes.SCREEN] = useNew ? "screen" : so;
              output[modes.OVERLAY] = useNew ? "overlay" : so;
              output[modes.DARKEN] = useNew ? "darken" : so;
              output[modes.LIGHTEN] = useNew ? "lighten" : so;
              output[modes.COLOR_DODGE] = useNew ? "color-dodge" : so;
              output[modes.COLOR_BURN] = useNew ? "color-burn" : so;
              output[modes.HARD_LIGHT] = useNew ? "hard-light" : so;
              output[modes.SOFT_LIGHT] = useNew ? "soft-light" : so;
              output[modes.DIFFERENCE] = useNew ? "difference" : so;
              output[modes.EXCLUSION] = useNew ? "exclusion" : so;
              output[modes.HUE] = useNew ? "hue" : so;
              output[modes.SATURATION] = useNew ? "saturation" : so;
              output[modes.COLOR] = useNew ? "color" : so;
              output[modes.LUMINOSITY] = useNew ? "luminosity" : so;
              output[modes.ERASE] = "destination-out";
              output[modes.SOURCE_IN] = "source-in";
              output[modes.SOURCE_OUT] = "source-out";
              output[modes.SOURCE_ATOP] = "source-atop";
              output[modes.DESTINATION_OVER] = "destination-over";
              output[modes.DESTINATION_IN] = "destination-in";
              output[modes.DESTINATION_OUT] = "destination-out";
              output[modes.DESTINATION_ATOP] = "destination-atop";
              output[modes.LIGHTER] = "lighter";
              output[modes.COPY] = "copy";
              output[modes.XOR] = "xor";
              return output;
            };
            module2.exports = GetBlendModes;
          },
          49584: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetCalcMatrix = __webpack_require__2(73329);
            var SetTransform = function(renderer, ctx, src, camera, parentMatrix) {
              var alpha = camera.alpha * src.alpha;
              if (alpha <= 0) {
                return false;
              }
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
              ctx.globalAlpha = alpha;
              ctx.save();
              calcMatrix.setToContext(ctx);
              ctx.imageSmoothingEnabled = src.frame ? !src.frame.source.scaleMode : renderer.antialias;
              return true;
            };
            module2.exports = SetTransform;
          },
          70936: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "postrender";
          },
          99298: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "prerender";
          },
          7743: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "render";
          },
          99519: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resize";
          },
          81044: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              POST_RENDER: __webpack_require__2(70936),
              PRE_RENDER: __webpack_require__2(99298),
              RENDER: __webpack_require__2(7743),
              RESIZE: __webpack_require__2(99519)
            };
          },
          42069: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Canvas: __webpack_require__2(6046),
              Events: __webpack_require__2(81044),
              Snapshot: __webpack_require__2(95528),
              WebGL: __webpack_require__2(55478)
            };
          },
          61840: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasPool = __webpack_require__2(61068);
            var Color = __webpack_require__2(27119);
            var GetFastValue = __webpack_require__2(72632);
            var CanvasSnapshot = function(canvas, config2) {
              var callback = GetFastValue(config2, "callback");
              var type = GetFastValue(config2, "type", "image/png");
              var encoderOptions = GetFastValue(config2, "encoder", 0.92);
              var x = Math.abs(Math.round(GetFastValue(config2, "x", 0)));
              var y = Math.abs(Math.round(GetFastValue(config2, "y", 0)));
              var width = Math.floor(GetFastValue(config2, "width", canvas.width));
              var height = Math.floor(GetFastValue(config2, "height", canvas.height));
              var getPixel = GetFastValue(config2, "getPixel", false);
              if (getPixel) {
                var context = canvas.getContext("2d", {willReadFrequently: false});
                var imageData = context.getImageData(x, y, 1, 1);
                var data = imageData.data;
                callback.call(null, new Color(data[0], data[1], data[2], data[3]));
              } else if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
                var copyCanvas = CanvasPool.createWebGL(this, width, height);
                var ctx = copyCanvas.getContext("2d", {willReadFrequently: true});
                if (width > 0 && height > 0) {
                  ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
                }
                var image1 = new Image();
                image1.onerror = function() {
                  callback.call(null);
                  CanvasPool.remove(copyCanvas);
                };
                image1.onload = function() {
                  callback.call(null, image1);
                  CanvasPool.remove(copyCanvas);
                };
                image1.src = copyCanvas.toDataURL(type, encoderOptions);
              } else {
                var image2 = new Image();
                image2.onerror = function() {
                  callback.call(null);
                };
                image2.onload = function() {
                  callback.call(null, image2);
                };
                image2.src = canvas.toDataURL(type, encoderOptions);
              }
            };
            module2.exports = CanvasSnapshot;
          },
          1217: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasPool = __webpack_require__2(61068);
            var Color = __webpack_require__2(27119);
            var GetFastValue = __webpack_require__2(72632);
            var WebGLSnapshot = function(sourceContext, config2) {
              var gl = sourceContext;
              var callback = GetFastValue(config2, "callback");
              var type = GetFastValue(config2, "type", "image/png");
              var encoderOptions = GetFastValue(config2, "encoder", 0.92);
              var x = Math.abs(Math.round(GetFastValue(config2, "x", 0)));
              var y = Math.abs(Math.round(GetFastValue(config2, "y", 0)));
              var getPixel = GetFastValue(config2, "getPixel", false);
              var isFramebuffer = GetFastValue(config2, "isFramebuffer", false);
              var bufferWidth = isFramebuffer ? GetFastValue(config2, "bufferWidth", 1) : gl.drawingBufferWidth;
              var bufferHeight = isFramebuffer ? GetFastValue(config2, "bufferHeight", 1) : gl.drawingBufferHeight;
              if (getPixel) {
                var pixel = new Uint8Array(4);
                var destY = isFramebuffer ? y : bufferHeight - y;
                gl.readPixels(x, destY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
                callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3]));
              } else {
                var width = Math.floor(GetFastValue(config2, "width", bufferWidth));
                var height = Math.floor(GetFastValue(config2, "height", bufferHeight));
                var total = width * height * 4;
                var pixels = new Uint8Array(total);
                gl.readPixels(x, bufferHeight - y - height, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                var canvas = CanvasPool.createWebGL(this, width, height);
                var ctx = canvas.getContext("2d", {willReadFrequently: true});
                var imageData = ctx.getImageData(0, 0, width, height);
                var data = imageData.data;
                for (var py = 0; py < height; py++) {
                  for (var px = 0; px < width; px++) {
                    var sourceIndex = ((height - py - 1) * width + px) * 4;
                    var destIndex = isFramebuffer ? total - (py * width + (width - px)) * 4 : (py * width + px) * 4;
                    data[destIndex + 0] = pixels[sourceIndex + 0];
                    data[destIndex + 1] = pixels[sourceIndex + 1];
                    data[destIndex + 2] = pixels[sourceIndex + 2];
                    data[destIndex + 3] = pixels[sourceIndex + 3];
                  }
                }
                ctx.putImageData(imageData, 0, 0);
                var image = new Image();
                image.onerror = function() {
                  callback.call(null);
                  CanvasPool.remove(canvas);
                };
                image.onload = function() {
                  callback.call(null, image);
                  CanvasPool.remove(canvas);
                };
                image.src = canvas.toDataURL(type, encoderOptions);
              }
            };
            module2.exports = WebGLSnapshot;
          },
          95528: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Canvas: __webpack_require__2(61840),
              WebGL: __webpack_require__2(1217)
            };
          },
          35217: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(65641);
            var CustomMap = __webpack_require__2(33885);
            var Device = __webpack_require__2(77290);
            var GetFastValue = __webpack_require__2(72632);
            var RenderTarget = __webpack_require__2(37410);
            var SnapCeil = __webpack_require__2(82127);
            var BitmapMaskPipeline = __webpack_require__2(5583);
            var FX = __webpack_require__2(58136);
            var FX_CONST = __webpack_require__2(47406);
            var FXPipeline = __webpack_require__2(81828);
            var LightPipeline = __webpack_require__2(66901);
            var MobilePipeline = __webpack_require__2(71264);
            var MultiPipeline = __webpack_require__2(77310);
            var PointLightPipeline = __webpack_require__2(10919);
            var RopePipeline = __webpack_require__2(21213);
            var SinglePipeline = __webpack_require__2(51212);
            var UtilityPipeline = __webpack_require__2(60848);
            var PipelineManager = new Class({
              initialize: function PipelineManager2(renderer) {
                this.game = renderer.game;
                this.renderer = renderer;
                this.classes = new CustomMap([
                  [CONST.UTILITY_PIPELINE, UtilityPipeline],
                  [CONST.MULTI_PIPELINE, MultiPipeline],
                  [CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline],
                  [CONST.SINGLE_PIPELINE, SinglePipeline],
                  [CONST.ROPE_PIPELINE, RopePipeline],
                  [CONST.LIGHT_PIPELINE, LightPipeline],
                  [CONST.POINTLIGHT_PIPELINE, PointLightPipeline],
                  [CONST.MOBILE_PIPELINE, MobilePipeline]
                ]);
                this.postPipelineClasses = new CustomMap();
                this.pipelines = new CustomMap();
                this.default = null;
                this.current = null;
                this.previous = null;
                this.MULTI_PIPELINE = null;
                this.BITMAPMASK_PIPELINE = null;
                this.UTILITY_PIPELINE = null;
                this.MOBILE_PIPELINE = null;
                this.FX_PIPELINE = null;
                this.fullFrame1;
                this.fullFrame2;
                this.halfFrame1;
                this.halfFrame2;
                this.renderTargets = [];
                this.maxDimension = 0;
                this.frameInc = 32;
                this.targetIndex = 0;
              },
              boot: function(pipelineConfig, defaultPipeline, autoMobilePipeline) {
                var renderer = this.renderer;
                var targets = this.renderTargets;
                this.frameInc = Math.floor(GetFastValue(pipelineConfig, "frameInc", 32));
                var renderWidth = renderer.width;
                var renderHeight = renderer.height;
                var disablePreFX = this.game.config.disablePreFX;
                var disablePostFX = this.game.config.disablePostFX;
                if (!disablePostFX) {
                  this.postPipelineClasses.setAll([
                    [String(FX_CONST.BARREL), FX.Barrel],
                    [String(FX_CONST.BLOOM), FX.Bloom],
                    [String(FX_CONST.BLUR), FX.Blur],
                    [String(FX_CONST.BOKEH), FX.Bokeh],
                    [String(FX_CONST.CIRCLE), FX.Circle],
                    [String(FX_CONST.COLOR_MATRIX), FX.ColorMatrix],
                    [String(FX_CONST.DISPLACEMENT), FX.Displacement],
                    [String(FX_CONST.GLOW), FX.Glow],
                    [String(FX_CONST.GRADIENT), FX.Gradient],
                    [String(FX_CONST.PIXELATE), FX.Pixelate],
                    [String(FX_CONST.SHADOW), FX.Shadow],
                    [String(FX_CONST.SHINE), FX.Shine],
                    [String(FX_CONST.VIGNETTE), FX.Vignette],
                    [String(FX_CONST.WIPE), FX.Wipe]
                  ]);
                }
                if (!disablePreFX) {
                  this.classes.set(CONST.FX_PIPELINE, FXPipeline);
                  var minDimension = Math.min(renderWidth, renderHeight);
                  var qty = Math.ceil(minDimension / this.frameInc);
                  for (var i = 1; i < qty; i++) {
                    var targetWidth = i * this.frameInc;
                    targets.push(new RenderTarget(renderer, targetWidth, targetWidth));
                    targets.push(new RenderTarget(renderer, targetWidth, targetWidth));
                    targets.push(new RenderTarget(renderer, targetWidth, targetWidth));
                    this.maxDimension = targetWidth;
                  }
                  targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
                  targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
                  targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
                }
                var instance;
                var pipelineName;
                var _this = this;
                var game = this.game;
                this.classes.each(function(pipelineName2, pipeline) {
                  instance = _this.add(pipelineName2, new pipeline({game}));
                  if (pipelineName2 === CONST.UTILITY_PIPELINE) {
                    _this.UTILITY_PIPELINE = instance;
                    _this.fullFrame1 = instance.fullFrame1;
                    _this.fullFrame2 = instance.fullFrame2;
                    _this.halfFrame1 = instance.halfFrame1;
                    _this.halfFrame2 = instance.halfFrame2;
                  }
                });
                this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE);
                this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE);
                this.MOBILE_PIPELINE = this.get(CONST.MOBILE_PIPELINE);
                if (!disablePreFX) {
                  this.FX_PIPELINE = this.get(CONST.FX_PIPELINE);
                }
                if (pipelineConfig) {
                  for (pipelineName in pipelineConfig) {
                    var pipelineClass = pipelineConfig[pipelineName];
                    instance = new pipelineClass(game);
                    instance.name = pipelineName;
                    if (instance.isPostFX) {
                      this.postPipelineClasses.set(pipelineName, pipelineClass);
                    } else if (!this.has(pipelineName)) {
                      this.classes.set(pipelineName, pipelineClass);
                      this.add(pipelineName, instance);
                    }
                  }
                }
                this.default = this.get(defaultPipeline);
                if (autoMobilePipeline && !Device.os.desktop) {
                  this.default = this.MOBILE_PIPELINE;
                }
              },
              setDefaultPipeline: function(pipeline) {
                var instance = this.get(pipeline);
                if (instance) {
                  this.default = instance;
                }
                return instance;
              },
              add: function(name, pipeline) {
                if (pipeline.isPostFX) {
                  console.warn(name + " is a Post Pipeline. Use `addPostPipeline` instead");
                  return;
                }
                var pipelines = this.pipelines;
                var renderer = this.renderer;
                if (!pipelines.has(name)) {
                  pipeline.name = name;
                  pipeline.manager = this;
                  pipelines.set(name, pipeline);
                } else {
                  console.warn("Pipeline exists: " + name);
                }
                if (!pipeline.hasBooted) {
                  pipeline.boot();
                }
                if (renderer.width !== 0 && renderer.height !== 0 && !pipeline.isPreFX) {
                  pipeline.resize(renderer.width, renderer.height);
                }
                return pipeline;
              },
              addPostPipeline: function(name, pipeline) {
                if (!this.postPipelineClasses.has(name)) {
                  this.postPipelineClasses.set(name, pipeline);
                }
              },
              flush: function() {
                if (this.current) {
                  this.current.flush();
                }
              },
              has: function(pipeline) {
                var pipelines = this.pipelines;
                if (typeof pipeline === "string") {
                  return pipelines.has(pipeline);
                } else if (pipelines.contains(pipeline)) {
                  return true;
                }
                return false;
              },
              get: function(pipeline) {
                var pipelines = this.pipelines;
                if (typeof pipeline === "string") {
                  return pipelines.get(pipeline);
                } else if (pipelines.contains(pipeline)) {
                  return pipeline;
                }
              },
              getPostPipeline: function(pipeline, gameObject, config2) {
                var pipelineClasses = this.postPipelineClasses;
                var instance;
                var pipelineName = "";
                var pipetype = typeof pipeline;
                if (pipetype === "string" || pipetype === "number") {
                  instance = pipelineClasses.get(pipeline);
                  pipelineName = pipeline;
                } else if (pipetype === "function") {
                  if (pipelineClasses.contains(pipeline)) {
                    instance = pipeline;
                  }
                  pipelineName = pipeline.name;
                } else if (pipetype === "object") {
                  instance = pipelineClasses.get(pipeline.name);
                  pipelineName = pipeline.name;
                }
                if (instance) {
                  var newPipeline = new instance(this.game, config2);
                  newPipeline.name = pipelineName;
                  if (gameObject) {
                    newPipeline.gameObject = gameObject;
                  }
                  return newPipeline;
                }
              },
              remove: function(name, removeClass, removePostPipelineClass) {
                if (removeClass === void 0) {
                  removeClass = true;
                }
                if (removePostPipelineClass === void 0) {
                  removePostPipelineClass = true;
                }
                this.pipelines.delete(name);
                if (removeClass) {
                  this.classes.delete(name);
                }
                if (removePostPipelineClass) {
                  this.postPipelineClasses.delete(name);
                }
              },
              set: function(pipeline, gameObject, currentShader) {
                if (pipeline.isPostFX) {
                  return;
                }
                if (!this.isCurrent(pipeline, currentShader)) {
                  this.flush();
                  if (this.current) {
                    this.current.unbind();
                  }
                  this.current = pipeline;
                  pipeline.bind(currentShader);
                }
                pipeline.updateProjectionMatrix();
                pipeline.onBind(gameObject);
                return pipeline;
              },
              preBatch: function(gameObject) {
                if (gameObject.hasPostPipeline) {
                  this.flush();
                  var pipelines = gameObject.postPipelines;
                  for (var i = pipelines.length - 1; i >= 0; i--) {
                    var pipeline = pipelines[i];
                    if (pipeline.active) {
                      pipeline.preBatch(gameObject);
                    }
                  }
                }
              },
              postBatch: function(gameObject) {
                if (gameObject.hasPostPipeline) {
                  this.flush();
                  var pipelines = gameObject.postPipelines;
                  for (var i = 0; i < pipelines.length; i++) {
                    var pipeline = pipelines[i];
                    if (pipeline.active) {
                      pipeline.postBatch(gameObject);
                    }
                  }
                }
              },
              preBatchCamera: function(camera) {
                if (camera.hasPostPipeline) {
                  this.flush();
                  var pipelines = camera.postPipelines;
                  for (var i = pipelines.length - 1; i >= 0; i--) {
                    var pipeline = pipelines[i];
                    if (pipeline.active) {
                      pipeline.preBatch(camera);
                    }
                  }
                }
              },
              postBatchCamera: function(camera) {
                if (camera.hasPostPipeline) {
                  this.flush();
                  var pipelines = camera.postPipelines;
                  for (var i = 0; i < pipelines.length; i++) {
                    var pipeline = pipelines[i];
                    if (pipeline.active) {
                      pipeline.postBatch(camera);
                    }
                  }
                }
              },
              isCurrent: function(pipeline, currentShader) {
                var renderer = this.renderer;
                var current = this.current;
                if (current && !currentShader) {
                  currentShader = current.currentShader;
                }
                return !(current !== pipeline || currentShader.program !== renderer.currentProgram);
              },
              copyFrame: function(source, target, brightness, clear, clearAlpha) {
                this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha);
                return this;
              },
              copyToGame: function(source) {
                this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source);
                return this;
              },
              drawFrame: function(source, target, clearAlpha, colorMatrix) {
                this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix);
                return this;
              },
              blendFrames: function(source1, source2, target, strength, clearAlpha) {
                this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha);
                return this;
              },
              blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
                this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha);
                return this;
              },
              clearFrame: function(target, clearAlpha) {
                this.UTILITY_PIPELINE.clearFrame(target, clearAlpha);
                return this;
              },
              blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
                this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
                return this;
              },
              copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
                this.UTILITY_PIPELINE.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
                return this;
              },
              forceZero: function() {
                return this.current && this.current.forceZero;
              },
              setMulti: function() {
                return this.set(this.MULTI_PIPELINE);
              },
              setUtility: function(currentShader) {
                return this.UTILITY_PIPELINE.bind(currentShader);
              },
              setFX: function() {
                return this.set(this.FX_PIPELINE);
              },
              rebind: function(pipeline) {
                if (pipeline === void 0 && this.previous) {
                  pipeline = this.previous;
                }
                var renderer = this.renderer;
                var gl = renderer.gl;
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                if (renderer.hasActiveStencilMask()) {
                  gl.clear(gl.DEPTH_BUFFER_BIT);
                } else {
                  gl.disable(gl.STENCIL_TEST);
                  gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                }
                gl.viewport(0, 0, renderer.width, renderer.height);
                renderer.currentProgram = null;
                renderer.setBlendMode(0, true);
                var vao = renderer.vaoExtension;
                if (vao) {
                  vao.bindVertexArrayOES(null);
                }
                var entries = this.pipelines.entries;
                for (var key in entries) {
                  entries[key].glReset = true;
                }
                if (pipeline) {
                  this.current = pipeline;
                  pipeline.rebind();
                }
              },
              clear: function() {
                var renderer = this.renderer;
                this.flush();
                if (this.current) {
                  this.current.unbind();
                  this.previous = this.current;
                  this.current = null;
                } else {
                  this.previous = null;
                }
                renderer.currentProgram = null;
                renderer.setBlendMode(0, true);
                var vao = renderer.vaoExtension;
                if (vao) {
                  vao.bindVertexArrayOES(null);
                }
              },
              getRenderTarget: function(size) {
                var targets = this.renderTargets;
                var offset = 3;
                if (size > this.maxDimension) {
                  this.targetIndex = targets.length - offset;
                  return targets[this.targetIndex];
                } else {
                  var index = (SnapCeil(size, this.frameInc, 0, true) - 1) * offset;
                  this.targetIndex = index;
                  return targets[index];
                }
              },
              getSwapRenderTarget: function() {
                return this.renderTargets[this.targetIndex + 1];
              },
              getAltSwapRenderTarget: function() {
                return this.renderTargets[this.targetIndex + 2];
              },
              destroy: function() {
                this.flush();
                this.classes.clear();
                this.postPipelineClasses.clear();
                this.pipelines.clear();
                this.renderer = null;
                this.game = null;
                this.classes = null;
                this.postPipelineClasses = null;
                this.pipelines = null;
                this.default = null;
                this.current = null;
                this.previous = null;
              }
            });
            module2.exports = PipelineManager;
          },
          37410: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(81044);
            var RenderTarget = new Class({
              initialize: function RenderTarget2(renderer, width, height, scale, minFilter, autoClear, autoResize, addDepthBuffer, forceClamp) {
                if (scale === void 0) {
                  scale = 1;
                }
                if (minFilter === void 0) {
                  minFilter = 0;
                }
                if (autoClear === void 0) {
                  autoClear = true;
                }
                if (autoResize === void 0) {
                  autoResize = false;
                }
                if (addDepthBuffer === void 0) {
                  addDepthBuffer = true;
                }
                if (forceClamp === void 0) {
                  forceClamp = true;
                }
                this.renderer = renderer;
                this.framebuffer = null;
                this.texture = null;
                this.width = 0;
                this.height = 0;
                this.scale = scale;
                this.minFilter = minFilter;
                this.autoClear = autoClear;
                this.autoResize = true;
                this.hasDepthBuffer = addDepthBuffer;
                this.forceClamp = forceClamp;
                this.resize(width, height);
                if (autoResize) {
                  this.setAutoResize(true);
                } else {
                  this.autoResize = false;
                }
              },
              setAutoResize: function(autoResize) {
                if (autoResize && !this.autoResize) {
                  this.renderer.on(Events.RESIZE, this.resize, this);
                  this.autoResize = true;
                } else if (!autoResize && this.autoResize) {
                  this.renderer.off(Events.RESIZE, this.resize, this);
                  this.autoResize = false;
                }
                return this;
              },
              resize: function(width, height) {
                width = Math.round(width * this.scale);
                height = Math.round(height * this.scale);
                if (width <= 0) {
                  width = 1;
                }
                if (height <= 0) {
                  height = 1;
                }
                if (this.autoResize && (width !== this.width || height !== this.height)) {
                  var renderer = this.renderer;
                  renderer.deleteFramebuffer(this.framebuffer);
                  renderer.deleteTexture(this.texture);
                  this.texture = renderer.createTextureFromSource(null, width, height, this.minFilter, this.forceClamp);
                  this.framebuffer = renderer.createFramebuffer(width, height, this.texture, this.hasDepthBuffer);
                  this.width = width;
                  this.height = height;
                }
                return this;
              },
              willResize: function(width, height) {
                width = Math.round(width * this.scale);
                height = Math.round(height * this.scale);
                if (width <= 0) {
                  width = 1;
                }
                if (height <= 0) {
                  height = 1;
                }
                return width !== this.width || height !== this.height;
              },
              bind: function(adjustViewport, width, height) {
                if (adjustViewport === void 0) {
                  adjustViewport = false;
                }
                var renderer = this.renderer;
                if (adjustViewport) {
                  renderer.flush();
                }
                if (width && height) {
                  this.resize(width, height);
                }
                renderer.pushFramebuffer(this.framebuffer, false, false);
                if (adjustViewport) {
                  this.adjustViewport();
                }
                if (this.autoClear) {
                  var gl = this.renderer.gl;
                  gl.clearColor(0, 0, 0, 0);
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                renderer.clearStencilMask();
              },
              adjustViewport: function() {
                var gl = this.renderer.gl;
                gl.viewport(0, 0, this.width, this.height);
                gl.disable(gl.SCISSOR_TEST);
              },
              clear: function() {
                var renderer = this.renderer;
                var gl = renderer.gl;
                renderer.pushFramebuffer(this.framebuffer);
                gl.disable(gl.SCISSOR_TEST);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                renderer.popFramebuffer();
                renderer.resetScissor();
              },
              unbind: function(flush) {
                if (flush === void 0) {
                  flush = false;
                }
                var renderer = this.renderer;
                if (flush) {
                  renderer.flush();
                }
                return renderer.popFramebuffer();
              },
              destroy: function() {
                var renderer = this.renderer;
                renderer.off(Events.RESIZE, this.resize, this);
                renderer.deleteFramebuffer(this.framebuffer);
                renderer.deleteTexture(this.texture);
                this.renderer = null;
                this.framebuffer = null;
                this.texture = null;
              }
            });
            module2.exports = RenderTarget;
          },
          75512: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @author       Matthew Groves <@doormat>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              getTintFromFloats: function(r, g, b, a) {
                var ur = (r * 255 | 0) & 255;
                var ug = (g * 255 | 0) & 255;
                var ub = (b * 255 | 0) & 255;
                var ua = (a * 255 | 0) & 255;
                return (ua << 24 | ur << 16 | ug << 8 | ub) >>> 0;
              },
              getTintAppendFloatAlpha: function(rgb, a) {
                var ua = (a * 255 | 0) & 255;
                return (ua << 24 | rgb) >>> 0;
              },
              getTintAppendFloatAlphaAndSwap: function(rgb, a) {
                var ur = (rgb >> 16 | 0) & 255;
                var ug = (rgb >> 8 | 0) & 255;
                var ub = (rgb | 0) & 255;
                var ua = (a * 255 | 0) & 255;
                return (ua << 24 | ub << 16 | ug << 8 | ur) >>> 0;
              },
              getFloatsFromUintRGB: function(rgb) {
                var ur = (rgb >> 16 | 0) & 255;
                var ug = (rgb >> 8 | 0) & 255;
                var ub = (rgb | 0) & 255;
                return [ur / 255, ug / 255, ub / 255];
              },
              checkShaderMax: function(gl, maxTextures) {
                var gpuMax = Math.min(16, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
                if (!maxTextures || maxTextures === -1) {
                  return gpuMax;
                } else {
                  return Math.min(gpuMax, maxTextures);
                }
              },
              parseFragmentShaderMaxTextures: function(fragmentShaderSource, maxTextures) {
                if (!fragmentShaderSource) {
                  return "";
                }
                var src = "";
                for (var i = 0; i < maxTextures; i++) {
                  if (i > 0) {
                    src += "\n	else ";
                  }
                  if (i < maxTextures - 1) {
                    src += "if (outTexId < " + i + ".5)";
                  }
                  src += "\n	{";
                  src += "\n		texture = texture2D(uMainSampler[" + i + "], outTexCoord);";
                  src += "\n	}";
                }
                fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, maxTextures.toString());
                return fragmentShaderSource.replace(/%forloop%/gi, src);
              },
              setGlowQuality: function(shader, game, quality, distance) {
                if (quality === void 0) {
                  quality = game.config.glowFXQuality;
                }
                if (distance === void 0) {
                  distance = game.config.glowFXDistance;
                }
                shader = shader.replace(/__SIZE__/gi, (1 / quality / distance).toFixed(7));
                shader = shader.replace(/__DIST__/gi, distance.toFixed(0) + ".0");
                return shader;
              }
            };
          },
          44775: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var DeepCopy = __webpack_require__2(28699);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(18970);
            var GetFastValue = __webpack_require__2(72632);
            var Matrix4 = __webpack_require__2(16650);
            var RendererEvents = __webpack_require__2(81044);
            var RenderTarget = __webpack_require__2(37410);
            var Utils = __webpack_require__2(75512);
            var WebGLShader = __webpack_require__2(71305);
            var WebGLPipeline = new Class({
              Extends: EventEmitter,
              initialize: function WebGLPipeline2(config2) {
                EventEmitter.call(this);
                var game = config2.game;
                var renderer = game.renderer;
                var gl = renderer.gl;
                this.name = GetFastValue(config2, "name", "WebGLPipeline");
                this.game = game;
                this.renderer = renderer;
                this.manager;
                this.gl = gl;
                this.view = game.canvas;
                this.width = 0;
                this.height = 0;
                this.vertexCount = 0;
                this.vertexCapacity = 0;
                this.vertexData;
                this.vertexBuffer;
                this.activeBuffer;
                this.topology = GetFastValue(config2, "topology", gl.TRIANGLES);
                this.bytes;
                this.vertexViewF32;
                this.vertexViewU32;
                this.active = true;
                this.forceZero = GetFastValue(config2, "forceZero", false);
                this.hasBooted = false;
                this.isPostFX = false;
                this.isPreFX = false;
                this.renderTargets = [];
                this.currentRenderTarget;
                this.shaders = [];
                this.currentShader;
                this.projectionMatrix;
                this.projectionWidth = 0;
                this.projectionHeight = 0;
                this.config = config2;
                this.glReset = false;
                this.batch = [];
                this.currentBatch = null;
                this.currentTexture = null;
                this.currentUnit = 0;
                this.activeTextures = [];
              },
              boot: function() {
                var i;
                var gl = this.gl;
                var config2 = this.config;
                var renderer = this.renderer;
                if (!this.isPostFX) {
                  this.projectionMatrix = new Matrix4().identity();
                }
                var renderTargets = this.renderTargets;
                var targets = GetFastValue(config2, "renderTarget", false);
                if (typeof targets === "boolean" && targets) {
                  targets = 1;
                }
                var width = renderer.width;
                var height = renderer.height;
                if (typeof targets === "number") {
                  for (i = 0; i < targets; i++) {
                    renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, true));
                  }
                } else if (Array.isArray(targets)) {
                  for (i = 0; i < targets.length; i++) {
                    var scale = GetFastValue(targets[i], "scale", 1);
                    var minFilter = GetFastValue(targets[i], "minFilter", 0);
                    var autoClear = GetFastValue(targets[i], "autoClear", 1);
                    var targetWidth = GetFastValue(targets[i], "width", null);
                    var targetHeight = GetFastValue(targets[i], "height", targetWidth);
                    if (targetWidth) {
                      renderTargets.push(new RenderTarget(renderer, targetWidth, targetHeight, 1, minFilter, autoClear));
                    } else {
                      renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear));
                    }
                  }
                }
                if (renderTargets.length) {
                  this.currentRenderTarget = renderTargets[0];
                }
                this.setShadersFromConfig(config2);
                var shaders = this.shaders;
                var vertexSize = 0;
                for (i = 0; i < shaders.length; i++) {
                  if (shaders[i].vertexSize > vertexSize) {
                    vertexSize = shaders[i].vertexSize;
                  }
                }
                var batchSize = GetFastValue(config2, "batchSize", renderer.config.batchSize);
                this.vertexCapacity = batchSize * 6;
                var data = new ArrayBuffer(this.vertexCapacity * vertexSize);
                this.vertexData = data;
                this.bytes = new Uint8Array(data);
                this.vertexViewF32 = new Float32Array(data);
                this.vertexViewU32 = new Uint32Array(data);
                var configVerts = GetFastValue(config2, "vertices", null);
                if (configVerts) {
                  this.vertexViewF32.set(configVerts);
                  this.vertexBuffer = renderer.createVertexBuffer(data, gl.STATIC_DRAW);
                } else {
                  this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl.DYNAMIC_DRAW);
                }
                this.setVertexBuffer();
                for (i = shaders.length - 1; i >= 0; i--) {
                  shaders[i].rebind();
                }
                this.hasBooted = true;
                renderer.on(RendererEvents.RESIZE, this.resize, this);
                renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this);
                renderer.on(RendererEvents.RENDER, this.onRender, this);
                renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this);
                this.emit(Events.BOOT, this);
                this.onBoot();
              },
              onBoot: function() {
              },
              onResize: function() {
              },
              setShader: function(shader, setAttributes, vertexBuffer) {
                var renderer = this.renderer;
                if (shader !== this.currentShader || renderer.currentProgram !== this.currentShader.program) {
                  this.flush();
                  var wasBound = this.setVertexBuffer(vertexBuffer);
                  if (wasBound && !setAttributes) {
                    setAttributes = true;
                  }
                  shader.bind(setAttributes, false);
                  this.currentShader = shader;
                }
                return this;
              },
              getShaderByName: function(name) {
                var shaders = this.shaders;
                for (var i = 0; i < shaders.length; i++) {
                  if (shaders[i].name === name) {
                    return shaders[i];
                  }
                }
              },
              setShadersFromConfig: function(config2) {
                var i;
                var shaders = this.shaders;
                var renderer = this.renderer;
                for (i = 0; i < shaders.length; i++) {
                  shaders[i].destroy();
                }
                var vName = "vertShader";
                var fName = "fragShader";
                var aName = "attributes";
                var defaultVertShader = GetFastValue(config2, vName, null);
                var defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config2, fName, null), renderer.maxTextures);
                var defaultAttribs = GetFastValue(config2, aName, null);
                var configShaders = GetFastValue(config2, "shaders", []);
                var len = configShaders.length;
                if (len === 0) {
                  if (defaultVertShader && defaultFragShader) {
                    this.shaders = [new WebGLShader(this, "default", defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs))];
                  }
                } else {
                  var newShaders = [];
                  for (i = 0; i < len; i++) {
                    var shaderEntry = configShaders[i];
                    var name;
                    var vertShader;
                    var fragShader;
                    var attributes;
                    if (typeof shaderEntry === "string") {
                      name = "default";
                      vertShader = defaultVertShader;
                      fragShader = Utils.parseFragmentShaderMaxTextures(shaderEntry, renderer.maxTextures);
                      attributes = defaultAttribs;
                    } else {
                      name = GetFastValue(shaderEntry, "name", "default");
                      vertShader = GetFastValue(shaderEntry, vName, defaultVertShader);
                      fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(shaderEntry, fName, defaultFragShader), renderer.maxTextures);
                      attributes = GetFastValue(shaderEntry, aName, defaultAttribs);
                    }
                    if (name === "default") {
                      var lines = fragShader.split("\n");
                      var test = lines[0].trim();
                      if (test.indexOf("#define SHADER_NAME") > -1) {
                        name = test.substring(20);
                      }
                    }
                    if (vertShader && fragShader) {
                      newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));
                    }
                  }
                  this.shaders = newShaders;
                }
                if (this.shaders.length === 0) {
                  console.warn("Pipeline: " + this.name + " - Invalid shader config");
                } else {
                  this.currentShader = this.shaders[0];
                }
                return this;
              },
              createBatch: function(texture) {
                this.currentBatch = {
                  start: this.vertexCount,
                  count: 0,
                  texture: [texture],
                  unit: 0,
                  maxUnit: 0
                };
                this.currentUnit = 0;
                this.currentTexture = texture;
                this.batch.push(this.currentBatch);
                return 0;
              },
              addTextureToBatch: function(texture) {
                var batch = this.currentBatch;
                if (batch) {
                  batch.texture.push(texture);
                  batch.unit++;
                  batch.maxUnit++;
                }
              },
              pushBatch: function(texture) {
                if (!this.currentBatch || this.forceZero && texture !== this.currentTexture) {
                  return this.createBatch(texture);
                }
                if (texture === this.currentTexture) {
                  return this.currentUnit;
                } else {
                  var current = this.currentBatch;
                  var idx = current.texture.indexOf(texture);
                  if (idx === -1) {
                    if (current.texture.length === this.renderer.maxTextures) {
                      return this.createBatch(texture);
                    } else {
                      current.unit++;
                      current.maxUnit++;
                      current.texture.push(texture);
                      this.currentUnit = current.unit;
                      this.currentTexture = texture;
                      return current.unit;
                    }
                  } else {
                    this.currentUnit = idx;
                    this.currentTexture = texture;
                    return idx;
                  }
                }
              },
              setGameObject: function(gameObject, frame) {
                if (frame === void 0) {
                  frame = gameObject.frame;
                }
                return this.pushBatch(frame.source.glTexture);
              },
              shouldFlush: function(amount) {
                if (amount === void 0) {
                  amount = 0;
                }
                return this.vertexCount + amount > this.vertexCapacity;
              },
              vertexAvailable: function() {
                return this.vertexCapacity - this.vertexCount;
              },
              resize: function(width, height) {
                if (width !== this.width || height !== this.height) {
                  this.flush();
                }
                this.width = width;
                this.height = height;
                var targets = this.renderTargets;
                for (var i = 0; i < targets.length; i++) {
                  targets[i].resize(width, height);
                }
                this.setProjectionMatrix(width, height);
                this.emit(Events.RESIZE, width, height, this);
                this.onResize(width, height);
                return this;
              },
              setProjectionMatrix: function(width, height) {
                var projectionMatrix = this.projectionMatrix;
                if (!projectionMatrix) {
                  return this;
                }
                this.projectionWidth = width;
                this.projectionHeight = height;
                projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
                var shaders = this.shaders;
                var name = "uProjectionMatrix";
                for (var i = 0; i < shaders.length; i++) {
                  var shader = shaders[i];
                  if (shader.hasUniform(name)) {
                    shader.resetUniform(name);
                    shader.setMatrix4fv(name, false, projectionMatrix.val, shader);
                  }
                }
                return this;
              },
              flipProjectionMatrix: function(flipY) {
                if (flipY === void 0) {
                  flipY = true;
                }
                var projectionMatrix = this.projectionMatrix;
                if (!projectionMatrix) {
                  return this;
                }
                var width = this.projectionWidth;
                var height = this.projectionHeight;
                if (flipY) {
                  projectionMatrix.ortho(0, width, 0, height, -1e3, 1e3);
                } else {
                  projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
                }
                this.setMatrix4fv("uProjectionMatrix", false, projectionMatrix.val);
              },
              updateProjectionMatrix: function() {
                if (this.projectionMatrix) {
                  var globalWidth = this.renderer.projectionWidth;
                  var globalHeight = this.renderer.projectionHeight;
                  if (this.projectionWidth !== globalWidth || this.projectionHeight !== globalHeight) {
                    this.setProjectionMatrix(globalWidth, globalHeight);
                  }
                }
              },
              bind: function(currentShader) {
                if (currentShader === void 0) {
                  currentShader = this.currentShader;
                }
                if (this.glReset) {
                  return this.rebind(currentShader);
                }
                var wasBound = false;
                var gl = this.gl;
                if (gl.getParameter(gl.ARRAY_BUFFER_BINDING) !== this.vertexBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                  this.activeBuffer = this.vertexBuffer;
                  wasBound = true;
                }
                currentShader.bind(wasBound);
                this.currentShader = currentShader;
                this.activeTextures.length = 0;
                this.emit(Events.BIND, this, currentShader);
                this.onActive(currentShader);
                return this;
              },
              rebind: function(currentShader) {
                this.activeBuffer = null;
                this.setVertexBuffer();
                var shaders = this.shaders;
                for (var i = shaders.length - 1; i >= 0; i--) {
                  var shader = shaders[i].rebind();
                  if (!currentShader || shader === currentShader) {
                    this.currentShader = shader;
                  }
                }
                this.activeTextures.length = 0;
                this.emit(Events.REBIND, this.currentShader);
                this.onActive(this.currentShader);
                this.onRebind();
                this.glReset = false;
                return this;
              },
              setVertexBuffer: function(buffer) {
                if (buffer === void 0) {
                  buffer = this.vertexBuffer;
                }
                if (buffer !== this.activeBuffer) {
                  var gl = this.gl;
                  this.gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  this.activeBuffer = buffer;
                  return true;
                }
                return false;
              },
              preBatch: function(gameObject) {
                if (this.currentRenderTarget) {
                  this.currentRenderTarget.bind();
                }
                this.onPreBatch(gameObject);
                return this;
              },
              postBatch: function(gameObject) {
                this.onDraw(this.currentRenderTarget);
                this.onPostBatch(gameObject);
                return this;
              },
              onDraw: function() {
              },
              unbind: function() {
                if (this.currentRenderTarget) {
                  this.currentRenderTarget.unbind();
                }
              },
              flush: function(isPostFlush) {
                if (isPostFlush === void 0) {
                  isPostFlush = false;
                }
                if (this.vertexCount > 0) {
                  this.emit(Events.BEFORE_FLUSH, this, isPostFlush);
                  this.onBeforeFlush(isPostFlush);
                  var gl = this.gl;
                  var vertexCount = this.vertexCount;
                  var vertexSize = this.currentShader.vertexSize;
                  var topology = this.topology;
                  if (this.active) {
                    this.setVertexBuffer();
                    if (vertexCount === this.vertexCapacity) {
                      gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);
                    } else {
                      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
                    }
                    var i;
                    var entry;
                    var texture;
                    var batch = this.batch;
                    var activeTextures = this.activeTextures;
                    if (this.forceZero) {
                      if (!activeTextures[0]) {
                        gl.activeTexture(gl.TEXTURE0);
                      }
                      for (i = 0; i < batch.length; i++) {
                        entry = batch[i];
                        texture = entry.texture[0];
                        if (activeTextures[0] !== texture) {
                          gl.bindTexture(gl.TEXTURE_2D, texture);
                          activeTextures[0] = texture;
                        }
                        gl.drawArrays(topology, entry.start, entry.count);
                      }
                    } else {
                      for (i = 0; i < batch.length; i++) {
                        entry = batch[i];
                        for (var t = 0; t <= entry.maxUnit; t++) {
                          texture = entry.texture[t];
                          if (activeTextures[t] !== texture) {
                            gl.activeTexture(gl.TEXTURE0 + t);
                            gl.bindTexture(gl.TEXTURE_2D, texture);
                            activeTextures[t] = texture;
                          }
                        }
                        gl.drawArrays(topology, entry.start, entry.count);
                      }
                    }
                  }
                  this.vertexCount = 0;
                  this.batch.length = 0;
                  this.currentBatch = null;
                  this.currentTexture = null;
                  this.currentUnit = 0;
                  this.emit(Events.AFTER_FLUSH, this, isPostFlush);
                  this.onAfterFlush(isPostFlush);
                }
                return this;
              },
              onActive: function() {
              },
              onBind: function() {
              },
              onRebind: function() {
              },
              onBatch: function() {
              },
              onPreBatch: function() {
              },
              onPostBatch: function() {
              },
              onPreRender: function() {
              },
              onRender: function() {
              },
              onPostRender: function() {
              },
              onBeforeFlush: function() {
              },
              onAfterFlush: function() {
              },
              batchVert: function(x, y, u, v, unit, tintEffect, tint) {
                var vertexViewF32 = this.vertexViewF32;
                var vertexViewU32 = this.vertexViewU32;
                var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
                vertexViewF32[++vertexOffset] = x;
                vertexViewF32[++vertexOffset] = y;
                vertexViewF32[++vertexOffset] = u;
                vertexViewF32[++vertexOffset] = v;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tint;
                this.vertexCount++;
                this.currentBatch.count = this.vertexCount - this.currentBatch.start;
              },
              batchQuad: function(gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit) {
                if (unit === void 0) {
                  unit = this.currentUnit;
                }
                var hasFlushed = false;
                if (this.shouldFlush(6)) {
                  this.flush();
                  hasFlushed = true;
                }
                if (!this.currentBatch) {
                  unit = this.setTexture2D(texture);
                }
                var vertexViewF32 = this.vertexViewF32;
                var vertexViewU32 = this.vertexViewU32;
                var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
                vertexViewF32[++vertexOffset] = x0;
                vertexViewF32[++vertexOffset] = y0;
                vertexViewF32[++vertexOffset] = u0;
                vertexViewF32[++vertexOffset] = v0;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintTL;
                vertexViewF32[++vertexOffset] = x1;
                vertexViewF32[++vertexOffset] = y1;
                vertexViewF32[++vertexOffset] = u0;
                vertexViewF32[++vertexOffset] = v1;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintBL;
                vertexViewF32[++vertexOffset] = x2;
                vertexViewF32[++vertexOffset] = y2;
                vertexViewF32[++vertexOffset] = u1;
                vertexViewF32[++vertexOffset] = v1;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintBR;
                vertexViewF32[++vertexOffset] = x0;
                vertexViewF32[++vertexOffset] = y0;
                vertexViewF32[++vertexOffset] = u0;
                vertexViewF32[++vertexOffset] = v0;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintTL;
                vertexViewF32[++vertexOffset] = x2;
                vertexViewF32[++vertexOffset] = y2;
                vertexViewF32[++vertexOffset] = u1;
                vertexViewF32[++vertexOffset] = v1;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintBR;
                vertexViewF32[++vertexOffset] = x3;
                vertexViewF32[++vertexOffset] = y3;
                vertexViewF32[++vertexOffset] = u1;
                vertexViewF32[++vertexOffset] = v0;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintTR;
                this.vertexCount += 6;
                this.currentBatch.count = this.vertexCount - this.currentBatch.start;
                this.onBatch(gameObject);
                return hasFlushed;
              },
              batchTri: function(gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit) {
                if (unit === void 0) {
                  unit = this.currentUnit;
                }
                var hasFlushed = false;
                if (this.shouldFlush(3)) {
                  this.flush();
                  hasFlushed = true;
                }
                if (!this.currentBatch) {
                  unit = this.setTexture2D(texture);
                }
                var vertexViewF32 = this.vertexViewF32;
                var vertexViewU32 = this.vertexViewU32;
                var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
                vertexViewF32[++vertexOffset] = x0;
                vertexViewF32[++vertexOffset] = y0;
                vertexViewF32[++vertexOffset] = u0;
                vertexViewF32[++vertexOffset] = v0;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintTL;
                vertexViewF32[++vertexOffset] = x1;
                vertexViewF32[++vertexOffset] = y1;
                vertexViewF32[++vertexOffset] = u0;
                vertexViewF32[++vertexOffset] = v1;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintTR;
                vertexViewF32[++vertexOffset] = x2;
                vertexViewF32[++vertexOffset] = y2;
                vertexViewF32[++vertexOffset] = u1;
                vertexViewF32[++vertexOffset] = v1;
                vertexViewF32[++vertexOffset] = unit;
                vertexViewF32[++vertexOffset] = tintEffect;
                vertexViewU32[++vertexOffset] = tintBL;
                this.vertexCount += 3;
                this.currentBatch.count = this.vertexCount - this.currentBatch.start;
                this.onBatch(gameObject);
                return hasFlushed;
              },
              drawFillRect: function(x, y, width, height, color, alpha, texture, flipUV) {
                if (texture === void 0) {
                  texture = this.renderer.whiteTexture;
                }
                if (flipUV === void 0) {
                  flipUV = true;
                }
                x = Math.floor(x);
                y = Math.floor(y);
                var xw = Math.floor(x + width);
                var yh = Math.floor(y + height);
                var unit = this.setTexture2D(texture);
                var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);
                var u0 = 0;
                var v0 = 0;
                var u1 = 1;
                var v1 = 1;
                if (flipUV) {
                  v0 = 1;
                  v1 = 0;
                }
                this.batchQuad(null, x, y, x, yh, xw, yh, xw, y, u0, v0, u1, v1, tint, tint, tint, tint, 0, texture, unit);
              },
              setTexture2D: function(texture) {
                if (texture === void 0) {
                  texture = this.renderer.whiteTexture;
                }
                return this.pushBatch(texture);
              },
              bindTexture: function(texture, unit) {
                if (unit === void 0) {
                  unit = 0;
                }
                var gl = this.gl;
                gl.activeTexture(gl.TEXTURE0 + unit);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                return this;
              },
              bindRenderTarget: function(target, unit) {
                return this.bindTexture(target.texture, unit);
              },
              setTime: function(name, shader) {
                this.set1f(name, this.game.loop.getDuration(), shader);
                return this;
              },
              setBoolean: function(name, value, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.setBoolean(name, value);
                return this;
              },
              set1f: function(name, x, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set1f(name, x);
                return this;
              },
              set2f: function(name, x, y, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set2f(name, x, y);
                return this;
              },
              set3f: function(name, x, y, z, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set3f(name, x, y, z);
                return this;
              },
              set4f: function(name, x, y, z, w, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set4f(name, x, y, z, w);
                return this;
              },
              set1fv: function(name, arr, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set1fv(name, arr);
                return this;
              },
              set2fv: function(name, arr, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set2fv(name, arr);
                return this;
              },
              set3fv: function(name, arr, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set3fv(name, arr);
                return this;
              },
              set4fv: function(name, arr, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set4fv(name, arr);
                return this;
              },
              set1iv: function(name, arr, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set1iv(name, arr);
                return this;
              },
              set2iv: function(name, arr, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set2iv(name, arr);
                return this;
              },
              set3iv: function(name, arr, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set3iv(name, arr);
                return this;
              },
              set4iv: function(name, arr, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set4iv(name, arr);
                return this;
              },
              set1i: function(name, x, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set1i(name, x);
                return this;
              },
              set2i: function(name, x, y, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set2i(name, x, y);
                return this;
              },
              set3i: function(name, x, y, z, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set3i(name, x, y, z);
                return this;
              },
              set4i: function(name, x, y, z, w, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.set4i(name, x, y, z, w);
                return this;
              },
              setMatrix2fv: function(name, transpose, matrix, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.setMatrix2fv(name, transpose, matrix);
                return this;
              },
              setMatrix3fv: function(name, transpose, matrix, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.setMatrix3fv(name, transpose, matrix);
                return this;
              },
              setMatrix4fv: function(name, transpose, matrix, shader) {
                if (shader === void 0) {
                  shader = this.currentShader;
                }
                shader.setMatrix4fv(name, transpose, matrix);
                return this;
              },
              destroy: function() {
                this.emit(Events.DESTROY, this);
                var i;
                var shaders = this.shaders;
                for (i = 0; i < shaders.length; i++) {
                  shaders[i].destroy();
                }
                var targets = this.renderTargets;
                for (i = 0; i < targets.length; i++) {
                  targets[i].destroy();
                }
                this.gl.deleteBuffer(this.vertexBuffer);
                var renderer = this.renderer;
                renderer.off(RendererEvents.RESIZE, this.resize, this);
                renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this);
                renderer.off(RendererEvents.RENDER, this.onRender, this);
                renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this);
                this.removeAllListeners();
                this.game = null;
                this.renderer = null;
                this.manager = null;
                this.gl = null;
                this.view = null;
                this.shaders = null;
                this.renderTargets = null;
                this.bytes = null;
                this.vertexViewF32 = null;
                this.vertexViewU32 = null;
                this.vertexData = null;
                this.vertexBuffer = null;
                this.currentShader = null;
                this.currentRenderTarget = null;
                this.activeTextures = null;
                return this;
              }
            });
            module2.exports = WebGLPipeline;
          },
          11857: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArrayRemove = __webpack_require__2(66458);
            var CameraEvents = __webpack_require__2(89787);
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(86459);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(81044);
            var IsSizePowerOfTwo = __webpack_require__2(28621);
            var Matrix4 = __webpack_require__2(16650);
            var NOOP = __webpack_require__2(72283);
            var PipelineManager = __webpack_require__2(35217);
            var RenderTarget = __webpack_require__2(37410);
            var ScaleEvents = __webpack_require__2(40444);
            var TextureEvents = __webpack_require__2(38203);
            var Utils = __webpack_require__2(75512);
            var WebGLSnapshot = __webpack_require__2(1217);
            var DEBUG = false;
            if (false) {
              var SPECTOR;
            }
            var WebGLRenderer = new Class({
              Extends: EventEmitter,
              initialize: function WebGLRenderer2(game) {
                EventEmitter.call(this);
                var gameConfig = game.config;
                var contextCreationConfig = {
                  alpha: gameConfig.transparent,
                  desynchronized: gameConfig.desynchronized,
                  depth: true,
                  antialias: gameConfig.antialiasGL,
                  premultipliedAlpha: gameConfig.premultipliedAlpha,
                  stencil: true,
                  failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,
                  powerPreference: gameConfig.powerPreference,
                  preserveDrawingBuffer: gameConfig.preserveDrawingBuffer,
                  willReadFrequently: false
                };
                this.config = {
                  clearBeforeRender: gameConfig.clearBeforeRender,
                  antialias: gameConfig.antialias,
                  backgroundColor: gameConfig.backgroundColor,
                  contextCreation: contextCreationConfig,
                  roundPixels: gameConfig.roundPixels,
                  maxTextures: gameConfig.maxTextures,
                  maxTextureSize: gameConfig.maxTextureSize,
                  batchSize: gameConfig.batchSize,
                  maxLights: gameConfig.maxLights,
                  mipmapFilter: gameConfig.mipmapFilter
                };
                this.game = game;
                this.type = CONST.WEBGL;
                this.pipelines = null;
                this.width = 0;
                this.height = 0;
                this.canvas = game.canvas;
                this.blendModes = [];
                this.contextLost = false;
                this.snapshotState = {
                  x: 0,
                  y: 0,
                  width: 1,
                  height: 1,
                  getPixel: false,
                  callback: null,
                  type: "image/png",
                  encoder: 0.92,
                  isFramebuffer: false,
                  bufferWidth: 0,
                  bufferHeight: 0
                };
                this.maxTextures = 0;
                this.textureIndexes;
                this.currentFramebuffer = null;
                this.fboStack = [];
                this.currentProgram = null;
                this.currentBlendMode = Infinity;
                this.currentScissorEnabled = false;
                this.currentScissor = null;
                this.scissorStack = [];
                this.contextLostHandler = NOOP;
                this.contextRestoredHandler = NOOP;
                this.gl = null;
                this.supportedExtensions = null;
                this.instancedArraysExtension = null;
                this.vaoExtension = null;
                this.extensions = {};
                this.glFormats;
                this.compression;
                this.drawingBufferHeight = 0;
                this.blankTexture = null;
                this.whiteTexture = null;
                this.maskCount = 0;
                this.maskStack = [];
                this.currentMask = {mask: null, camera: null};
                this.currentCameraMask = {mask: null, camera: null};
                this.glFuncMap = null;
                this.currentType = "";
                this.newType = false;
                this.nextTypeMatch = false;
                this.finalType = false;
                this.mipmapFilter = null;
                this.defaultScissor = [0, 0, 0, 0];
                this.isBooted = false;
                this.renderTarget = null;
                this.projectionMatrix;
                this.projectionWidth = 0;
                this.projectionHeight = 0;
                this.maskSource = null;
                this.maskTarget = null;
                this.spector = null;
                this._debugCapture = false;
                this.init(this.config);
              },
              init: function(config2) {
                var gl;
                var game = this.game;
                var canvas = this.canvas;
                var clearColor = config2.backgroundColor;
                if (DEBUG) {
                  this.spector = new SPECTOR.Spector();
                  this.spector.onCapture.add(this.onCapture.bind(this));
                }
                if (game.config.context) {
                  gl = game.config.context;
                } else {
                  gl = canvas.getContext("webgl", config2.contextCreation) || canvas.getContext("experimental-webgl", config2.contextCreation);
                }
                if (!gl || gl.isContextLost()) {
                  this.contextLost = true;
                  throw new Error("WebGL unsupported");
                }
                this.gl = gl;
                var _this = this;
                this.contextLostHandler = function(event) {
                  _this.contextLost = true;
                  if (console) {
                    console.warn("WebGL Context lost. Renderer disabled");
                  }
                  event.preventDefault();
                };
                canvas.addEventListener("webglcontextlost", this.contextLostHandler, false);
                game.context = gl;
                for (var i = 0; i <= 27; i++) {
                  this.blendModes.push({func: [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], equation: gl.FUNC_ADD});
                }
                this.blendModes[1].func = [gl.ONE, gl.DST_ALPHA];
                this.blendModes[2].func = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
                this.blendModes[3].func = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
                this.blendModes[17] = {func: [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], equation: gl.FUNC_REVERSE_SUBTRACT};
                this.glFormats = [gl.BYTE, gl.SHORT, gl.UNSIGNED_BYTE, gl.UNSIGNED_SHORT, gl.FLOAT];
                this.glFuncMap = {
                  mat2: {func: gl.uniformMatrix2fv, length: 1, matrix: true},
                  mat3: {func: gl.uniformMatrix3fv, length: 1, matrix: true},
                  mat4: {func: gl.uniformMatrix4fv, length: 1, matrix: true},
                  "1f": {func: gl.uniform1f, length: 1},
                  "1fv": {func: gl.uniform1fv, length: 1},
                  "1i": {func: gl.uniform1i, length: 1},
                  "1iv": {func: gl.uniform1iv, length: 1},
                  "2f": {func: gl.uniform2f, length: 2},
                  "2fv": {func: gl.uniform2fv, length: 1},
                  "2i": {func: gl.uniform2i, length: 2},
                  "2iv": {func: gl.uniform2iv, length: 1},
                  "3f": {func: gl.uniform3f, length: 3},
                  "3fv": {func: gl.uniform3fv, length: 1},
                  "3i": {func: gl.uniform3i, length: 3},
                  "3iv": {func: gl.uniform3iv, length: 1},
                  "4f": {func: gl.uniform4f, length: 4},
                  "4fv": {func: gl.uniform4fv, length: 1},
                  "4i": {func: gl.uniform4i, length: 4},
                  "4iv": {func: gl.uniform4iv, length: 1}
                };
                var exts = gl.getSupportedExtensions();
                if (!config2.maxTextures || config2.maxTextures === -1) {
                  config2.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                }
                if (!config2.maxTextureSize) {
                  config2.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                }
                this.compression = this.getCompressedTextures();
                this.supportedExtensions = exts;
                var angleString = "ANGLE_instanced_arrays";
                this.instancedArraysExtension = exts.indexOf(angleString) > -1 ? gl.getExtension(angleString) : null;
                var vaoString = "OES_vertex_array_object";
                this.vaoExtension = exts.indexOf(vaoString) > -1 ? gl.getExtension(vaoString) : null;
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
                var validMipMaps = ["NEAREST", "LINEAR", "NEAREST_MIPMAP_NEAREST", "LINEAR_MIPMAP_NEAREST", "NEAREST_MIPMAP_LINEAR", "LINEAR_MIPMAP_LINEAR"];
                if (validMipMaps.indexOf(config2.mipmapFilter) !== -1) {
                  this.mipmapFilter = gl[config2.mipmapFilter];
                }
                this.maxTextures = Utils.checkShaderMax(gl, config2.maxTextures);
                this.textureIndexes = [];
                for (var index = 0; index < this.maxTextures; index++) {
                  var tempTexture = gl.createTexture();
                  gl.activeTexture(gl.TEXTURE0 + index);
                  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
                  this.textureIndexes.push(index);
                }
                this.pipelines = new PipelineManager(this);
                this.setBlendMode(CONST.BlendModes.NORMAL);
                this.projectionMatrix = new Matrix4().identity();
                game.textures.once(TextureEvents.READY, this.boot, this);
                return this;
              },
              boot: function() {
                var game = this.game;
                var pipelineManager = this.pipelines;
                var baseSize = game.scale.baseSize;
                var width = baseSize.width;
                var height = baseSize.height;
                this.width = width;
                this.height = height;
                this.isBooted = true;
                this.renderTarget = new RenderTarget(this, width, height, 1, 0, true, true);
                this.maskTarget = new RenderTarget(this, width, height, 1, 0, true, true);
                this.maskSource = new RenderTarget(this, width, height, 1, 0, true, true);
                var config2 = game.config;
                pipelineManager.boot(config2.pipeline, config2.defaultPipeline, config2.autoMobilePipeline);
                this.blankTexture = game.textures.getFrame("__DEFAULT").glTexture;
                this.whiteTexture = game.textures.getFrame("__WHITE").glTexture;
                var gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.enable(gl.SCISSOR_TEST);
                game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
                this.resize(width, height);
              },
              captureFrame: function(quickCapture, fullCapture) {
                if (quickCapture === void 0) {
                  quickCapture = false;
                }
                if (fullCapture === void 0) {
                  fullCapture = false;
                }
                if (DEBUG && this.spector && !this._debugCapture) {
                  this.spector.captureCanvas(this.canvas, 0, quickCapture, fullCapture);
                  this._debugCapture = true;
                }
              },
              captureNextFrame: function() {
                if (DEBUG && this.spector && !this._debugCapture) {
                  this._debugCapture = true;
                  this.spector.captureNextFrame(this.canvas);
                }
              },
              getFps: function() {
                if (DEBUG && this.spector) {
                  return this.spector.getFps();
                }
              },
              log: function() {
                if (DEBUG && this.spector) {
                  var t = Array.prototype.slice.call(arguments).join(" ");
                  return this.spector.log(t);
                }
              },
              startCapture: function(commandCount, quickCapture, fullCapture) {
                if (commandCount === void 0) {
                  commandCount = 0;
                }
                if (quickCapture === void 0) {
                  quickCapture = false;
                }
                if (fullCapture === void 0) {
                  fullCapture = false;
                }
                if (DEBUG && this.spector && !this._debugCapture) {
                  this.spector.startCapture(this.canvas, commandCount, quickCapture, fullCapture);
                  this._debugCapture = true;
                }
              },
              stopCapture: function() {
                if (DEBUG && this.spector && this._debugCapture) {
                  return this.spector.stopCapture();
                }
              },
              onCapture: function(capture) {
                if (DEBUG) {
                  var view = this.spector.getResultUI();
                  view.display(capture);
                  this._debugCapture = false;
                }
              },
              onResize: function(gameSize, baseSize) {
                if (baseSize.width !== this.width || baseSize.height !== this.height) {
                  this.resize(baseSize.width, baseSize.height);
                }
              },
              beginCapture: function(width, height) {
                if (width === void 0) {
                  width = this.width;
                }
                if (height === void 0) {
                  height = this.height;
                }
                this.renderTarget.bind(true, width, height);
                this.setProjectionMatrix(width, height);
              },
              endCapture: function() {
                this.renderTarget.unbind(true);
                this.resetProjectionMatrix();
                return this.renderTarget;
              },
              resize: function(width, height) {
                var gl = this.gl;
                this.width = width;
                this.height = height;
                this.setProjectionMatrix(width, height);
                gl.viewport(0, 0, width, height);
                this.drawingBufferHeight = gl.drawingBufferHeight;
                gl.scissor(0, gl.drawingBufferHeight - height, width, height);
                this.defaultScissor[2] = width;
                this.defaultScissor[3] = height;
                this.emit(Events.RESIZE, width, height);
                return this;
              },
              getCompressedTextures: function() {
                var extString = "WEBGL_compressed_texture_";
                var wkExtString = "WEBKIT_" + extString;
                var hasExt = function(gl2, format) {
                  var results = gl2.getExtension(extString + format) || gl2.getExtension(wkExtString + format);
                  if (results) {
                    var glEnums = {};
                    for (var key in results) {
                      glEnums[results[key]] = key;
                    }
                    return glEnums;
                  }
                };
                var gl = this.gl;
                return {
                  ETC: hasExt(gl, "etc"),
                  ETC1: hasExt(gl, "etc1"),
                  ATC: hasExt(gl, "atc"),
                  ASTC: hasExt(gl, "astc"),
                  BPTC: hasExt(gl, "bptc"),
                  RGTC: hasExt(gl, "rgtc"),
                  PVRTC: hasExt(gl, "pvrtc"),
                  S3TC: hasExt(gl, "s3tc"),
                  S3TCSRGB: hasExt(gl, "s3tc_srgb"),
                  IMG: true
                };
              },
              getCompressedTextureName: function(baseFormat, format) {
                var supportedFormats = this.compression[baseFormat.toUpperCase()];
                if (format in supportedFormats) {
                  return supportedFormats[format];
                }
              },
              supportsCompressedTexture: function(baseFormat, format) {
                var supportedFormats = this.compression[baseFormat.toUpperCase()];
                if (supportedFormats) {
                  if (format) {
                    return format in supportedFormats;
                  } else {
                    return true;
                  }
                }
                return false;
              },
              getAspectRatio: function() {
                return this.width / this.height;
              },
              setProjectionMatrix: function(width, height) {
                if (width !== this.projectionWidth || height !== this.projectionHeight) {
                  this.projectionWidth = width;
                  this.projectionHeight = height;
                  this.projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
                }
                return this;
              },
              resetProjectionMatrix: function() {
                return this.setProjectionMatrix(this.width, this.height);
              },
              hasExtension: function(extensionName) {
                return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;
              },
              getExtension: function(extensionName) {
                if (!this.hasExtension(extensionName)) {
                  return null;
                }
                if (!(extensionName in this.extensions)) {
                  this.extensions[extensionName] = this.gl.getExtension(extensionName);
                }
                return this.extensions[extensionName];
              },
              flush: function() {
                this.pipelines.flush();
              },
              pushScissor: function(x, y, width, height, drawingBufferHeight) {
                if (drawingBufferHeight === void 0) {
                  drawingBufferHeight = this.drawingBufferHeight;
                }
                var scissorStack = this.scissorStack;
                var scissor = [x, y, width, height];
                scissorStack.push(scissor);
                this.setScissor(x, y, width, height, drawingBufferHeight);
                this.currentScissor = scissor;
                return scissor;
              },
              setScissor: function(x, y, width, height, drawingBufferHeight) {
                if (drawingBufferHeight === void 0) {
                  drawingBufferHeight = this.drawingBufferHeight;
                }
                var gl = this.gl;
                var current = this.currentScissor;
                var setScissor = width > 0 && height > 0;
                if (current && setScissor) {
                  var cx = current[0];
                  var cy = current[1];
                  var cw = current[2];
                  var ch = current[3];
                  setScissor = cx !== x || cy !== y || cw !== width || ch !== height;
                }
                if (setScissor) {
                  this.flush();
                  gl.scissor(x, drawingBufferHeight - y - height, width, height);
                }
              },
              resetScissor: function() {
                var gl = this.gl;
                gl.enable(gl.SCISSOR_TEST);
                var current = this.currentScissor;
                if (current) {
                  var x = current[0];
                  var y = current[1];
                  var width = current[2];
                  var height = current[3];
                  if (width > 0 && height > 0) {
                    gl.scissor(x, this.drawingBufferHeight - y - height, width, height);
                  }
                }
              },
              popScissor: function() {
                var scissorStack = this.scissorStack;
                scissorStack.pop();
                var scissor = scissorStack[scissorStack.length - 1];
                if (scissor) {
                  this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);
                }
                this.currentScissor = scissor;
              },
              hasActiveStencilMask: function() {
                var mask = this.currentMask.mask;
                var camMask = this.currentCameraMask.mask;
                return mask && mask.isStencil || camMask && camMask.isStencil;
              },
              resetViewport: function() {
                var gl = this.gl;
                gl.viewport(0, 0, this.width, this.height);
                this.drawingBufferHeight = gl.drawingBufferHeight;
              },
              setBlendMode: function(blendModeId, force) {
                if (force === void 0) {
                  force = false;
                }
                var gl = this.gl;
                var blendMode = this.blendModes[blendModeId];
                if (force || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) {
                  this.flush();
                  gl.enable(gl.BLEND);
                  gl.blendEquation(blendMode.equation);
                  if (blendMode.func.length > 2) {
                    gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);
                  } else {
                    gl.blendFunc(blendMode.func[0], blendMode.func[1]);
                  }
                  this.currentBlendMode = blendModeId;
                  return true;
                }
                return false;
              },
              addBlendMode: function(func, equation) {
                var index = this.blendModes.push({func, equation});
                return index - 1;
              },
              updateBlendMode: function(index, func, equation) {
                if (this.blendModes[index]) {
                  this.blendModes[index].func = func;
                  if (equation) {
                    this.blendModes[index].equation = equation;
                  }
                }
                return this;
              },
              removeBlendMode: function(index) {
                if (index > 17 && this.blendModes[index]) {
                  this.blendModes.splice(index, 1);
                }
                return this;
              },
              pushFramebuffer: function(framebuffer, updateScissor, setViewport, texture, clear) {
                if (framebuffer === this.currentFramebuffer) {
                  return this;
                }
                this.fboStack.push(framebuffer);
                return this.setFramebuffer(framebuffer, updateScissor, setViewport, texture, clear);
              },
              setFramebuffer: function(framebuffer, updateScissor, setViewport, texture, clear) {
                if (updateScissor === void 0) {
                  updateScissor = false;
                }
                if (setViewport === void 0) {
                  setViewport = true;
                }
                if (texture === void 0) {
                  texture = null;
                }
                if (clear === void 0) {
                  clear = false;
                }
                if (framebuffer === this.currentFramebuffer) {
                  return this;
                }
                var gl = this.gl;
                var width = this.width;
                var height = this.height;
                if (framebuffer && framebuffer.renderTexture && setViewport) {
                  width = framebuffer.renderTexture.width;
                  height = framebuffer.renderTexture.height;
                } else {
                  this.flush();
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                if (setViewport) {
                  gl.viewport(0, 0, width, height);
                }
                if (texture) {
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                }
                if (clear) {
                  gl.clearColor(0, 0, 0, 0);
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                if (updateScissor) {
                  if (framebuffer) {
                    this.drawingBufferHeight = height;
                    this.pushScissor(0, 0, width, height);
                  } else {
                    this.drawingBufferHeight = this.height;
                    this.popScissor();
                  }
                }
                this.currentFramebuffer = framebuffer;
                return this;
              },
              popFramebuffer: function(updateScissor, setViewport) {
                if (updateScissor === void 0) {
                  updateScissor = false;
                }
                if (setViewport === void 0) {
                  setViewport = true;
                }
                var fboStack = this.fboStack;
                fboStack.pop();
                var framebuffer = fboStack[fboStack.length - 1];
                if (!framebuffer) {
                  framebuffer = null;
                }
                this.setFramebuffer(framebuffer, updateScissor, setViewport);
                return framebuffer;
              },
              restoreFramebuffer: function(updateScissor, setViewport) {
                if (updateScissor === void 0) {
                  updateScissor = false;
                }
                if (setViewport === void 0) {
                  setViewport = true;
                }
                var fboStack = this.fboStack;
                var framebuffer = fboStack[fboStack.length - 1];
                if (!framebuffer) {
                  framebuffer = null;
                }
                this.currentFramebuffer = null;
                this.setFramebuffer(framebuffer, updateScissor, setViewport);
              },
              setProgram: function(program) {
                if (program !== this.currentProgram) {
                  this.flush();
                  this.gl.useProgram(program);
                  this.currentProgram = program;
                  return true;
                }
                return false;
              },
              resetProgram: function() {
                this.gl.useProgram(this.currentProgram);
                return this;
              },
              createTextureFromSource: function(source, width, height, scaleMode, forceClamp) {
                if (forceClamp === void 0) {
                  forceClamp = false;
                }
                var gl = this.gl;
                var minFilter = gl.NEAREST;
                var magFilter = gl.NEAREST;
                var wrap = gl.CLAMP_TO_EDGE;
                var texture = null;
                width = source ? source.width : width;
                height = source ? source.height : height;
                var pow = IsSizePowerOfTwo(width, height);
                if (pow && !forceClamp) {
                  wrap = gl.REPEAT;
                }
                if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias) {
                  minFilter = pow && this.mipmapFilter ? this.mipmapFilter : gl.LINEAR;
                  magFilter = gl.LINEAR;
                }
                if (source && source.compressed) {
                  minFilter = gl.LINEAR;
                  magFilter = gl.LINEAR;
                }
                if (!source && typeof width === "number" && typeof height === "number") {
                  texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);
                } else {
                  texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);
                }
                return texture;
              },
              createTexture2D: function(mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY) {
                pma = pma === void 0 || pma === null ? true : pma;
                if (forceSize === void 0) {
                  forceSize = false;
                }
                if (flipY === void 0) {
                  flipY = false;
                }
                var gl = this.gl;
                var texture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);
                if (flipY) {
                  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                }
                var generateMipmap = false;
                if (pixels === null || pixels === void 0) {
                  gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);
                  generateMipmap = IsSizePowerOfTwo(width, height);
                } else if (pixels.compressed) {
                  width = pixels.width;
                  height = pixels.height;
                  generateMipmap = pixels.generateMipmap;
                  for (var i = 0; i < pixels.mipmaps.length; i++) {
                    gl.compressedTexImage2D(gl.TEXTURE_2D, i, pixels.internalFormat, pixels.mipmaps[i].width, pixels.mipmaps[i].height, 0, pixels.mipmaps[i].data);
                  }
                } else {
                  if (!forceSize) {
                    width = pixels.width;
                    height = pixels.height;
                  }
                  gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);
                  generateMipmap = IsSizePowerOfTwo(width, height);
                }
                if (generateMipmap) {
                  gl.generateMipmap(gl.TEXTURE_2D);
                }
                if (currentTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                }
                texture.isAlphaPremultiplied = pma;
                texture.isRenderTexture = false;
                texture.width = width;
                texture.height = height;
                return texture;
              },
              createFramebuffer: function(width, height, renderTexture, addDepthStencilBuffer) {
                if (addDepthStencilBuffer === void 0) {
                  addDepthStencilBuffer = true;
                }
                var gl = this.gl;
                var framebuffer = gl.createFramebuffer();
                var complete = 0;
                this.setFramebuffer(framebuffer);
                renderTexture.isRenderTexture = true;
                renderTexture.isAlphaPremultiplied = false;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
                complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (complete !== gl.FRAMEBUFFER_COMPLETE) {
                  var errors = {
                    36054: "Incomplete Attachment",
                    36055: "Missing Attachment",
                    36057: "Incomplete Dimensions",
                    36061: "Framebuffer Unsupported"
                  };
                  throw new Error("Framebuffer status: " + (errors[complete] || complete));
                }
                framebuffer.renderTexture = renderTexture;
                if (addDepthStencilBuffer) {
                  var depthStencilBuffer = gl.createRenderbuffer();
                  gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);
                  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
                  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);
                }
                this.setFramebuffer(null);
                return framebuffer;
              },
              beginBitmapMask: function(bitmapMask, camera) {
                var gl = this.gl;
                if (gl) {
                  this.flush();
                  this.maskTarget.bind(true);
                  if (this.currentCameraMask.mask !== bitmapMask) {
                    this.currentMask.mask = bitmapMask;
                    this.currentMask.camera = camera;
                  }
                }
              },
              drawBitmapMask: function(bitmapMask, camera, bitmapMaskPipeline) {
                this.flush();
                this.maskSource.bind();
                this.setBlendMode(0, true);
                bitmapMask.renderWebGL(this, bitmapMask, camera);
                this.maskSource.unbind(true);
                this.maskTarget.unbind();
                var gl = this.gl;
                var prev = this.getCurrentStencilMask();
                if (prev) {
                  gl.enable(gl.STENCIL_TEST);
                  prev.mask.applyStencil(this, prev.camera, true);
                } else {
                  this.currentMask.mask = null;
                }
                this.pipelines.set(bitmapMaskPipeline);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.maskTarget.texture);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, this.maskSource.texture);
              },
              createProgram: function(vertexShader, fragmentShader) {
                var gl = this.gl;
                var program = gl.createProgram();
                var vs = gl.createShader(gl.VERTEX_SHADER);
                var fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(vs, vertexShader);
                gl.shaderSource(fs, fragmentShader);
                gl.compileShader(vs);
                gl.compileShader(fs);
                var failed = "Shader failed:\n";
                if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                  throw new Error("Vertex " + failed + gl.getShaderInfoLog(vs));
                }
                if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                  throw new Error("Fragment " + failed + gl.getShaderInfoLog(fs));
                }
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                  throw new Error("Link " + failed + gl.getProgramInfoLog(program));
                }
                gl.useProgram(program);
                return program;
              },
              createVertexBuffer: function(initialDataOrSize, bufferUsage) {
                var gl = this.gl;
                var vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                return vertexBuffer;
              },
              createIndexBuffer: function(initialDataOrSize, bufferUsage) {
                var gl = this.gl;
                var indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                return indexBuffer;
              },
              deleteTexture: function(texture) {
                if (texture) {
                  this.gl.deleteTexture(texture);
                }
                return this;
              },
              deleteFramebuffer: function(framebuffer) {
                if (!framebuffer) {
                  return this;
                }
                var gl = this.gl;
                if (this.currentFramebuffer === framebuffer) {
                  this.currentFramebuffer = null;
                }
                ArrayRemove(this.fboStack, framebuffer);
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                framebuffer.renderTexture = void 0;
                var colorAttachment = gl.getFramebufferAttachmentParameter(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
                if (colorAttachment !== null) {
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
                  gl.deleteTexture(colorAttachment);
                }
                var depthStencilAttachment = gl.getFramebufferAttachmentParameter(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
                if (depthStencilAttachment !== null) {
                  gl.deleteRenderbuffer(depthStencilAttachment);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.deleteFramebuffer(framebuffer);
                return this;
              },
              deleteProgram: function(program) {
                if (program) {
                  this.gl.deleteProgram(program);
                }
                return this;
              },
              deleteBuffer: function(buffer) {
                this.gl.deleteBuffer(buffer);
                return this;
              },
              preRenderCamera: function(camera) {
                var cx = camera.x;
                var cy = camera.y;
                var cw = camera.width;
                var ch = camera.height;
                var color = camera.backgroundColor;
                camera.emit(CameraEvents.PRE_RENDER, camera);
                this.pipelines.preBatchCamera(camera);
                this.pushScissor(cx, cy, cw, ch);
                if (camera.mask) {
                  this.currentCameraMask.mask = camera.mask;
                  this.currentCameraMask.camera = camera._maskCamera;
                  camera.mask.preRenderWebGL(this, camera, camera._maskCamera);
                }
                if (color.alphaGL > 0) {
                  var pipeline = this.pipelines.setMulti();
                  pipeline.drawFillRect(cx, cy, cw, ch, Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1), color.alphaGL);
                }
              },
              getCurrentStencilMask: function() {
                var prev = null;
                var stack = this.maskStack;
                var cameraMask = this.currentCameraMask;
                if (stack.length > 0) {
                  prev = stack[stack.length - 1];
                } else if (cameraMask.mask && cameraMask.mask.isStencil) {
                  prev = cameraMask;
                }
                return prev;
              },
              postRenderCamera: function(camera) {
                var flashEffect = camera.flashEffect;
                var fadeEffect = camera.fadeEffect;
                if (flashEffect.isRunning || (fadeEffect.isRunning || fadeEffect.isComplete)) {
                  var pipeline = this.pipelines.setMulti();
                  flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
                  fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
                }
                camera.dirty = false;
                this.popScissor();
                if (camera.mask) {
                  this.currentCameraMask.mask = null;
                  camera.mask.postRenderWebGL(this, camera._maskCamera);
                }
                this.pipelines.postBatchCamera(camera);
                camera.emit(CameraEvents.POST_RENDER, camera);
              },
              preRender: function() {
                if (this.contextLost) {
                  return;
                }
                var gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                if (this.config.clearBeforeRender) {
                  var clearColor = this.config.backgroundColor;
                  gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
                  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                }
                gl.enable(gl.SCISSOR_TEST);
                this.currentScissor = this.defaultScissor;
                this.scissorStack.length = 0;
                this.scissorStack.push(this.currentScissor);
                if (this.game.scene.customViewports) {
                  gl.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);
                }
                this.currentMask.mask = null;
                this.currentCameraMask.mask = null;
                this.maskStack.length = 0;
                this.emit(Events.PRE_RENDER);
              },
              render: function(scene, children, camera) {
                if (this.contextLost) {
                  return;
                }
                var childCount = children.length;
                this.emit(Events.RENDER, scene, camera);
                this.preRenderCamera(camera);
                if (childCount === 0) {
                  this.setBlendMode(CONST.BlendModes.NORMAL);
                  this.postRenderCamera(camera);
                  return;
                }
                this.currentType = "";
                var current = this.currentMask;
                for (var i = 0; i < childCount; i++) {
                  this.finalType = i === childCount - 1;
                  var child = children[i];
                  var mask = child.mask;
                  current = this.currentMask;
                  if (current.mask && current.mask !== mask) {
                    current.mask.postRenderWebGL(this, current.camera);
                  }
                  if (mask && current.mask !== mask) {
                    mask.preRenderWebGL(this, child, camera);
                  }
                  if (child.blendMode !== this.currentBlendMode) {
                    this.setBlendMode(child.blendMode);
                  }
                  var type = child.type;
                  if (type !== this.currentType) {
                    this.newType = true;
                    this.currentType = type;
                  }
                  if (!this.finalType) {
                    this.nextTypeMatch = children[i + 1].type === this.currentType;
                  } else {
                    this.nextTypeMatch = false;
                  }
                  child.renderWebGL(this, child, camera);
                  this.newType = false;
                }
                current = this.currentMask;
                if (current.mask) {
                  current.mask.postRenderWebGL(this, current.camera);
                }
                this.setBlendMode(CONST.BlendModes.NORMAL);
                this.postRenderCamera(camera);
              },
              postRender: function() {
                if (this.contextLost) {
                  return;
                }
                this.flush();
                this.emit(Events.POST_RENDER);
                var state = this.snapshotState;
                if (state.callback) {
                  WebGLSnapshot(this.gl, state);
                  state.callback = null;
                }
              },
              clearStencilMask: function() {
                this.gl.disable(this.gl.STENCIL_TEST);
              },
              restoreStencilMask: function() {
                var gl = this.gl;
                var current = this.getCurrentStencilMask();
                if (current) {
                  var mask = current.mask;
                  gl.enable(gl.STENCIL_TEST);
                  if (mask.invertAlpha) {
                    gl.stencilFunc(gl.NOTEQUAL, mask.level, 255);
                  } else {
                    gl.stencilFunc(gl.EQUAL, mask.level, 255);
                  }
                }
              },
              snapshot: function(callback, type, encoderOptions) {
                return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);
              },
              snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
                var state = this.snapshotState;
                state.callback = callback;
                state.type = type;
                state.encoder = encoderOptions;
                state.getPixel = false;
                state.x = x;
                state.y = y;
                state.width = width;
                state.height = height;
                return this;
              },
              snapshotPixel: function(x, y, callback) {
                this.snapshotArea(x, y, 1, 1, callback);
                this.snapshotState.getPixel = true;
                return this;
              },
              snapshotFramebuffer: function(framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions) {
                if (getPixel === void 0) {
                  getPixel = false;
                }
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = bufferWidth;
                }
                if (height === void 0) {
                  height = bufferHeight;
                }
                if (type === "pixel") {
                  getPixel = true;
                  type = "image/png";
                }
                var currentFramebuffer = this.currentFramebuffer;
                this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
                var state = this.snapshotState;
                state.getPixel = getPixel;
                state.isFramebuffer = true;
                state.bufferWidth = bufferWidth;
                state.bufferHeight = bufferHeight;
                state.width = Math.min(state.width, bufferWidth);
                state.height = Math.min(state.height, bufferHeight);
                this.setFramebuffer(framebuffer);
                WebGLSnapshot(this.gl, state);
                this.setFramebuffer(currentFramebuffer);
                state.callback = null;
                state.isFramebuffer = false;
                return this;
              },
              canvasToTexture: function(srcCanvas, dstTexture, noRepeat, flipY) {
                if (noRepeat === void 0) {
                  noRepeat = false;
                }
                if (flipY === void 0) {
                  flipY = false;
                }
                if (!dstTexture) {
                  return this.createCanvasTexture(srcCanvas, noRepeat, flipY);
                } else {
                  return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);
                }
              },
              createCanvasTexture: function(srcCanvas, noRepeat, flipY) {
                if (noRepeat === void 0) {
                  noRepeat = false;
                }
                if (flipY === void 0) {
                  flipY = false;
                }
                var gl = this.gl;
                var minFilter = gl.NEAREST;
                var magFilter = gl.NEAREST;
                var width = srcCanvas.width;
                var height = srcCanvas.height;
                var wrapping = gl.CLAMP_TO_EDGE;
                var pow = IsSizePowerOfTwo(width, height);
                if (!noRepeat && pow) {
                  wrapping = gl.REPEAT;
                }
                if (this.config.antialias) {
                  minFilter = pow && this.mipmapFilter ? this.mipmapFilter : gl.LINEAR;
                  magFilter = gl.LINEAR;
                }
                return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);
              },
              updateCanvasTexture: function(srcCanvas, dstTexture, flipY) {
                if (flipY === void 0) {
                  flipY = false;
                }
                var gl = this.gl;
                var width = srcCanvas.width;
                var height = srcCanvas.height;
                if (width > 0 && height > 0) {
                  gl.activeTexture(gl.TEXTURE0);
                  var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
                  gl.bindTexture(gl.TEXTURE_2D, dstTexture);
                  if (flipY) {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                  }
                  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
                  dstTexture.width = width;
                  dstTexture.height = height;
                  if (currentTexture) {
                    gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                  }
                }
                return dstTexture;
              },
              createVideoTexture: function(srcVideo, noRepeat, flipY) {
                if (noRepeat === void 0) {
                  noRepeat = false;
                }
                if (flipY === void 0) {
                  flipY = false;
                }
                var gl = this.gl;
                var minFilter = gl.NEAREST;
                var magFilter = gl.NEAREST;
                var width = srcVideo.videoWidth;
                var height = srcVideo.videoHeight;
                var wrapping = gl.CLAMP_TO_EDGE;
                var pow = IsSizePowerOfTwo(width, height);
                if (!noRepeat && pow) {
                  wrapping = gl.REPEAT;
                }
                if (this.config.antialias) {
                  minFilter = pow && this.mipmapFilter ? this.mipmapFilter : gl.LINEAR;
                  magFilter = gl.LINEAR;
                }
                return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);
              },
              updateVideoTexture: function(srcVideo, dstTexture, flipY) {
                if (flipY === void 0) {
                  flipY = false;
                }
                var gl = this.gl;
                var width = srcVideo.videoWidth;
                var height = srcVideo.videoHeight;
                if (width > 0 && height > 0) {
                  gl.activeTexture(gl.TEXTURE0);
                  var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
                  gl.bindTexture(gl.TEXTURE_2D, dstTexture);
                  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo);
                  dstTexture.width = width;
                  dstTexture.height = height;
                  if (currentTexture) {
                    gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                  }
                }
                return dstTexture;
              },
              setTextureFilter: function(texture, filter) {
                var gl = this.gl;
                var glFilter = filter === 0 ? gl.LINEAR : gl.NEAREST;
                gl.activeTexture(gl.TEXTURE0);
                var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);
                if (currentTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                }
                return this;
              },
              getMaxTextureSize: function() {
                return this.config.maxTextureSize;
              },
              destroy: function() {
                this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, false);
                this.maskTarget.destroy();
                this.maskSource.destroy();
                this.pipelines.destroy();
                this.removeAllListeners();
                this.fboStack = [];
                this.maskStack = [];
                this.extensions = {};
                this.textureIndexes = [];
                this.gl = null;
                this.game = null;
                this.canvas = null;
                this.contextLost = true;
                this.currentMask = null;
                this.currentCameraMask = null;
                if (DEBUG) {
                  this.spector = null;
                }
              }
            });
            module2.exports = WebGLRenderer;
          },
          71305: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var WEBGL_CONST = __webpack_require__2(71402);
            var WebGLShader = new Class({
              initialize: function WebGLShader2(pipeline, name, vertexShader, fragmentShader, attributes) {
                this.pipeline = pipeline;
                this.name = name;
                this.renderer = pipeline.renderer;
                this.gl = this.renderer.gl;
                this.fragSrc = fragmentShader;
                this.vertSrc = vertexShader;
                this.program = this.renderer.createProgram(vertexShader, fragmentShader);
                this.attributes;
                this.vertexComponentCount = 0;
                this.vertexSize = 0;
                this.uniforms = {};
                this.createAttributes(attributes);
                this.createUniforms();
              },
              createAttributes: function(attributes) {
                var count = 0;
                var offset = 0;
                var result = [];
                this.vertexComponentCount = 0;
                for (var i = 0; i < attributes.length; i++) {
                  var element = attributes[i];
                  var name = element.name;
                  var size = GetFastValue(element, "size", 1);
                  var glType = GetFastValue(element, "type", WEBGL_CONST.FLOAT);
                  var type = glType.enum;
                  var typeSize = glType.size;
                  var normalized = element.normalized ? true : false;
                  result.push({
                    name,
                    size,
                    type,
                    normalized,
                    offset,
                    enabled: false,
                    location: -1
                  });
                  if (typeSize === 4) {
                    count += size;
                  } else {
                    count++;
                  }
                  offset += size * typeSize;
                }
                this.vertexSize = offset;
                this.vertexComponentCount = count;
                this.attributes = result;
              },
              bind: function(setAttributes, flush) {
                if (setAttributes === void 0) {
                  setAttributes = false;
                }
                if (flush === void 0) {
                  flush = false;
                }
                if (flush) {
                  this.pipeline.flush();
                }
                this.renderer.setProgram(this.program);
                if (setAttributes) {
                  this.setAttribPointers();
                }
                return this;
              },
              rebind: function() {
                this.renderer.setProgram(this.program);
                this.setAttribPointers(true);
                return this;
              },
              setAttribPointers: function(reset) {
                if (reset === void 0) {
                  reset = false;
                }
                var gl = this.gl;
                var vertexSize = this.vertexSize;
                var attributes = this.attributes;
                var program = this.program;
                for (var i = 0; i < attributes.length; i++) {
                  var element = attributes[i];
                  var size = element.size;
                  var type = element.type;
                  var offset = element.offset;
                  var enabled = element.enabled;
                  var location = element.location;
                  var normalized = element.normalized ? true : false;
                  if (reset) {
                    var attribLocation = gl.getAttribLocation(program, element.name);
                    if (attribLocation >= 0) {
                      gl.enableVertexAttribArray(attribLocation);
                      gl.vertexAttribPointer(attribLocation, size, type, normalized, vertexSize, offset);
                      element.enabled = true;
                      element.location = attribLocation;
                    } else if (attribLocation !== -1) {
                      gl.disableVertexAttribArray(attribLocation);
                    }
                  } else if (enabled) {
                    gl.vertexAttribPointer(location, size, type, normalized, vertexSize, offset);
                  } else if (!enabled && location > -1) {
                    gl.disableVertexAttribArray(location);
                    element.location = -1;
                  }
                }
                return this;
              },
              createUniforms: function() {
                var gl = this.gl;
                var program = this.program;
                var uniforms = this.uniforms;
                var i;
                var name;
                var location;
                var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                for (i = 0; i < totalUniforms; i++) {
                  var info = gl.getActiveUniform(program, i);
                  if (info) {
                    name = info.name;
                    location = gl.getUniformLocation(program, name);
                    if (location !== null) {
                      uniforms[name] = {
                        name,
                        location,
                        value1: null,
                        value2: null,
                        value3: null,
                        value4: null
                      };
                    }
                    var struct = name.indexOf("[");
                    if (struct > 0) {
                      name = name.substr(0, struct);
                      if (!uniforms.hasOwnProperty(name)) {
                        location = gl.getUniformLocation(program, name);
                        if (location !== null) {
                          uniforms[name] = {
                            name,
                            location,
                            value1: null,
                            value2: null,
                            value3: null,
                            value4: null
                          };
                        }
                      }
                    }
                  }
                }
                return this;
              },
              hasUniform: function(name) {
                return this.uniforms.hasOwnProperty(name);
              },
              resetUniform: function(name) {
                var uniform = this.uniforms[name];
                if (uniform) {
                  uniform.value1 = null;
                  uniform.value2 = null;
                  uniform.value3 = null;
                  uniform.value4 = null;
                }
                return this;
              },
              setUniform1: function(setter, name, value1, skipCheck) {
                var uniform = this.uniforms[name];
                if (!uniform) {
                  return this;
                }
                if (skipCheck || uniform.value1 !== value1) {
                  uniform.value1 = value1;
                  this.renderer.setProgram(this.program);
                  setter.call(this.gl, uniform.location, value1);
                  this.pipeline.currentShader = this;
                }
                return this;
              },
              setUniform2: function(setter, name, value1, value2, skipCheck) {
                var uniform = this.uniforms[name];
                if (!uniform) {
                  return this;
                }
                if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2) {
                  uniform.value1 = value1;
                  uniform.value2 = value2;
                  this.renderer.setProgram(this.program);
                  setter.call(this.gl, uniform.location, value1, value2);
                  this.pipeline.currentShader = this;
                }
                return this;
              },
              setUniform3: function(setter, name, value1, value2, value3, skipCheck) {
                var uniform = this.uniforms[name];
                if (!uniform) {
                  return this;
                }
                if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3) {
                  uniform.value1 = value1;
                  uniform.value2 = value2;
                  uniform.value3 = value3;
                  this.renderer.setProgram(this.program);
                  setter.call(this.gl, uniform.location, value1, value2, value3);
                  this.pipeline.currentShader = this;
                }
                return this;
              },
              setUniform4: function(setter, name, value1, value2, value3, value4, skipCheck) {
                var uniform = this.uniforms[name];
                if (!uniform) {
                  return this;
                }
                if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3 || uniform.value4 !== value4) {
                  uniform.value1 = value1;
                  uniform.value2 = value2;
                  uniform.value3 = value3;
                  uniform.value4 = value4;
                  this.renderer.setProgram(this.program);
                  setter.call(this.gl, uniform.location, value1, value2, value3, value4);
                  this.pipeline.currentShader = this;
                }
                return this;
              },
              setBoolean: function(name, value) {
                return this.setUniform1(this.gl.uniform1i, name, Number(value));
              },
              set1f: function(name, x) {
                return this.setUniform1(this.gl.uniform1f, name, x);
              },
              set2f: function(name, x, y) {
                return this.setUniform2(this.gl.uniform2f, name, x, y);
              },
              set3f: function(name, x, y, z) {
                return this.setUniform3(this.gl.uniform3f, name, x, y, z);
              },
              set4f: function(name, x, y, z, w) {
                return this.setUniform4(this.gl.uniform4f, name, x, y, z, w);
              },
              set1fv: function(name, arr) {
                return this.setUniform1(this.gl.uniform1fv, name, arr, true);
              },
              set2fv: function(name, arr) {
                return this.setUniform1(this.gl.uniform2fv, name, arr, true);
              },
              set3fv: function(name, arr) {
                return this.setUniform1(this.gl.uniform3fv, name, arr, true);
              },
              set4fv: function(name, arr) {
                return this.setUniform1(this.gl.uniform4fv, name, arr, true);
              },
              set1iv: function(name, arr) {
                return this.setUniform1(this.gl.uniform1iv, name, arr, true);
              },
              set2iv: function(name, arr) {
                return this.setUniform1(this.gl.uniform2iv, name, arr, true);
              },
              set3iv: function(name, arr) {
                return this.setUniform1(this.gl.uniform3iv, name, arr, true);
              },
              set4iv: function(name, arr) {
                return this.setUniform1(this.gl.uniform4iv, name, arr, true);
              },
              set1i: function(name, x) {
                return this.setUniform1(this.gl.uniform1i, name, x);
              },
              set2i: function(name, x, y) {
                return this.setUniform2(this.gl.uniform2i, name, x, y);
              },
              set3i: function(name, x, y, z) {
                return this.setUniform3(this.gl.uniform3i, name, x, y, z);
              },
              set4i: function(name, x, y, z, w) {
                return this.setUniform4(this.gl.uniform4i, name, x, y, z, w);
              },
              setMatrix2fv: function(name, transpose, matrix) {
                return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix, true);
              },
              setMatrix3fv: function(name, transpose, matrix) {
                return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix, true);
              },
              setMatrix4fv: function(name, transpose, matrix) {
                return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix, true);
              },
              createProgram: function(vertSrc, fragSrc) {
                if (vertSrc === void 0) {
                  vertSrc = this.vertSrc;
                }
                if (fragSrc === void 0) {
                  fragSrc = this.fragSrc;
                }
                var gl = this.gl;
                if (this.program) {
                  gl.deleteProgram(this.program);
                }
                this.vertSrc = vertSrc;
                this.fragSrc = fragSrc;
                this.program = this.renderer.createProgram(vertSrc, fragSrc);
                this.createUniforms();
                return this.rebind();
              },
              destroy: function() {
                this.gl.deleteProgram(this.program);
                this.pipeline = null;
                this.renderer = null;
                this.gl = null;
                this.program = null;
                this.attributes = null;
                this.uniforms = null;
              }
            });
            module2.exports = WebGLShader;
          },
          71402: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var WEBGL_CONST = {
              BYTE: {enum: 5120, size: 1},
              UNSIGNED_BYTE: {enum: 5121, size: 1},
              SHORT: {enum: 5122, size: 2},
              UNSIGNED_SHORT: {enum: 5123, size: 2},
              INT: {enum: 5124, size: 4},
              UNSIGNED_INT: {enum: 5125, size: 4},
              FLOAT: {enum: 5126, size: 4}
            };
            module2.exports = WEBGL_CONST;
          },
          55478: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var WEBGL_CONST = __webpack_require__2(71402);
            var Extend = __webpack_require__2(98611);
            var WebGL = {
              PipelineManager: __webpack_require__2(35217),
              Pipelines: __webpack_require__2(62253),
              RenderTarget: __webpack_require__2(37410),
              Utils: __webpack_require__2(75512),
              WebGLPipeline: __webpack_require__2(44775),
              WebGLRenderer: __webpack_require__2(11857),
              WebGLShader: __webpack_require__2(71305)
            };
            WebGL = Extend(false, WebGL, WEBGL_CONST);
            module2.exports = WebGL;
          },
          5583: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var ShaderSourceFS = __webpack_require__2(91679);
            var ShaderSourceVS = __webpack_require__2(89053);
            var WEBGL_CONST = __webpack_require__2(71402);
            var WebGLPipeline = __webpack_require__2(44775);
            var BitmapMaskPipeline = new Class({
              Extends: WebGLPipeline,
              initialize: function BitmapMaskPipeline2(config2) {
                config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS), config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS), config2.batchSize = GetFastValue(config2, "batchSize", 1), config2.vertices = GetFastValue(config2, "vertices", [-1, 1, -1, -7, 7, 1]), config2.attributes = GetFastValue(config2, "attributes", [
                  {
                    name: "inPosition",
                    size: 2,
                    type: WEBGL_CONST.FLOAT
                  }
                ]);
                WebGLPipeline.call(this, config2);
              },
              boot: function() {
                WebGLPipeline.prototype.boot.call(this);
                this.set1i("uMainSampler", 0);
                this.set1i("uMaskSampler", 1);
              },
              resize: function(width, height) {
                WebGLPipeline.prototype.resize.call(this, width, height);
                this.set2f("uResolution", width, height);
              },
              beginMask: function(mask, maskedObject, camera) {
                this.renderer.beginBitmapMask(mask, camera);
              },
              endMask: function(mask, camera, renderTarget) {
                var gl = this.gl;
                var renderer = this.renderer;
                var bitmapMask = mask.bitmapMask;
                if (bitmapMask && gl) {
                  renderer.drawBitmapMask(bitmapMask, camera, this);
                  if (renderTarget) {
                    this.set2f("uResolution", renderTarget.width, renderTarget.height);
                  }
                  this.set1i("uInvertMaskAlpha", mask.invertAlpha);
                  gl.drawArrays(this.topology, 0, 3);
                  if (renderTarget) {
                    this.set2f("uResolution", this.width, this.height);
                  }
                  gl.bindTexture(gl.TEXTURE_2D, null);
                }
              }
            });
            module2.exports = BitmapMaskPipeline;
          },
          81828: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var FX = __webpack_require__2(58136);
            var FX_CONST = __webpack_require__2(47406);
            var GetFastValue = __webpack_require__2(72632);
            var PreFXPipeline = __webpack_require__2(87228);
            var Shaders = __webpack_require__2(92462);
            var Utils = __webpack_require__2(75512);
            var FXPipeline = new Class({
              Extends: PreFXPipeline,
              initialize: function FXPipeline2(config2) {
                config2.shaders = [
                  Utils.setGlowQuality(Shaders.FXGlowFrag, config2.game),
                  Shaders.FXShadowFrag,
                  Shaders.FXPixelateFrag,
                  Shaders.FXVignetteFrag,
                  Shaders.FXShineFrag,
                  Shaders.FXBlurLowFrag,
                  Shaders.FXBlurMedFrag,
                  Shaders.FXBlurHighFrag,
                  Shaders.FXGradientFrag,
                  Shaders.FXBloomFrag,
                  Shaders.ColorMatrixFrag,
                  Shaders.FXCircleFrag,
                  Shaders.FXBarrelFrag,
                  Shaders.FXDisplacementFrag,
                  Shaders.FXWipeFrag,
                  Shaders.FXBokehFrag
                ];
                PreFXPipeline.call(this, config2);
                var game = this.game;
                this.glow = new FX.Glow(game);
                this.shadow = new FX.Shadow(game);
                this.pixelate = new FX.Pixelate(game);
                this.vignette = new FX.Vignette(game);
                this.shine = new FX.Shine(game);
                this.gradient = new FX.Gradient(game);
                this.circle = new FX.Circle(game);
                this.barrel = new FX.Barrel(game);
                this.wipe = new FX.Wipe(game);
                this.bokeh = new FX.Bokeh(game);
                var fxHandlers = [];
                fxHandlers[FX_CONST.GLOW] = this.onGlow;
                fxHandlers[FX_CONST.SHADOW] = this.onShadow;
                fxHandlers[FX_CONST.PIXELATE] = this.onPixelate;
                fxHandlers[FX_CONST.VIGNETTE] = this.onVignette;
                fxHandlers[FX_CONST.SHINE] = this.onShine;
                fxHandlers[FX_CONST.BLUR] = this.onBlur;
                fxHandlers[FX_CONST.GRADIENT] = this.onGradient;
                fxHandlers[FX_CONST.BLOOM] = this.onBloom;
                fxHandlers[FX_CONST.COLOR_MATRIX] = this.onColorMatrix;
                fxHandlers[FX_CONST.CIRCLE] = this.onCircle;
                fxHandlers[FX_CONST.BARREL] = this.onBarrel;
                fxHandlers[FX_CONST.DISPLACEMENT] = this.onDisplacement;
                fxHandlers[FX_CONST.WIPE] = this.onWipe;
                fxHandlers[FX_CONST.BOKEH] = this.onBokeh;
                this.fxHandlers = fxHandlers;
                this.source;
                this.target;
                this.swap;
              },
              onDraw: function(target1, target2, target3) {
                this.source = target1;
                this.target = target2;
                this.swap = target3;
                var width = target1.width;
                var height = target1.height;
                var sprite = this.tempSprite;
                var handlers = this.fxHandlers;
                if (sprite && sprite.preFX) {
                  var fx = sprite.preFX.list;
                  for (var i = 0; i < fx.length; i++) {
                    var controller = fx[i];
                    if (controller.active) {
                      handlers[controller.type].call(this, controller, width, height);
                    }
                  }
                }
                this.drawToGame(this.source);
              },
              runDraw: function() {
                var source = this.source;
                var target = this.target;
                this.copy(source, target);
                this.source = target;
                this.target = source;
              },
              onGlow: function(config2, width, height) {
                var shader = this.shaders[FX_CONST.GLOW];
                this.setShader(shader);
                this.glow.onPreRender(config2, shader, width, height);
                this.runDraw();
              },
              onShadow: function(config2) {
                var shader = this.shaders[FX_CONST.SHADOW];
                this.setShader(shader);
                this.shadow.onPreRender(config2, shader);
                this.runDraw();
              },
              onPixelate: function(config2, width, height) {
                var shader = this.shaders[FX_CONST.PIXELATE];
                this.setShader(shader);
                this.pixelate.onPreRender(config2, shader, width, height);
                this.runDraw();
              },
              onVignette: function(config2) {
                var shader = this.shaders[FX_CONST.VIGNETTE];
                this.setShader(shader);
                this.vignette.onPreRender(config2, shader);
                this.runDraw();
              },
              onShine: function(config2, width, height) {
                var shader = this.shaders[FX_CONST.SHINE];
                this.setShader(shader);
                this.shine.onPreRender(config2, shader, width, height);
                this.runDraw();
              },
              onBlur: function(config2, width, height) {
                var quality = GetFastValue(config2, "quality");
                var shader = this.shaders[FX_CONST.BLUR + quality];
                this.setShader(shader);
                this.set1i("uMainSampler", 0);
                this.set2f("resolution", width, height);
                this.set1f("strength", GetFastValue(config2, "strength"));
                this.set3fv("color", GetFastValue(config2, "glcolor"));
                var x = GetFastValue(config2, "x");
                var y = GetFastValue(config2, "y");
                var steps = GetFastValue(config2, "steps");
                for (var i = 0; i < steps; i++) {
                  this.set2f("offset", x, 0);
                  this.runDraw();
                  this.set2f("offset", 0, y);
                  this.runDraw();
                }
              },
              onGradient: function(config2) {
                var shader = this.shaders[FX_CONST.GRADIENT];
                this.setShader(shader);
                this.gradient.onPreRender(config2, shader);
                this.runDraw();
              },
              onBloom: function(config2, width, height) {
                var shader = this.shaders[FX_CONST.BLOOM];
                this.copySprite(this.source, this.swap);
                this.setShader(shader);
                this.set1i("uMainSampler", 0);
                this.set1f("strength", GetFastValue(config2, "blurStrength"));
                this.set3fv("color", GetFastValue(config2, "glcolor"));
                var x = 2 / width * GetFastValue(config2, "offsetX");
                var y = 2 / height * GetFastValue(config2, "offsetY");
                var steps = GetFastValue(config2, "steps");
                for (var i = 0; i < steps; i++) {
                  this.set2f("offset", x, 0);
                  this.runDraw();
                  this.set2f("offset", 0, y);
                  this.runDraw();
                }
                this.blendFrames(this.swap, this.source, this.target, GetFastValue(config2, "strength"));
                this.copySprite(this.target, this.source);
              },
              onColorMatrix: function(config2) {
                this.setShader(this.colorMatrixShader);
                this.set1fv("uColorMatrix", config2.getData());
                this.set1f("uAlpha", config2.alpha);
                this.runDraw();
              },
              onCircle: function(config2, width, height) {
                var shader = this.shaders[FX_CONST.CIRCLE];
                this.setShader(shader);
                this.circle.onPreRender(config2, shader, width, height);
                this.runDraw();
              },
              onBarrel: function(config2) {
                var shader = this.shaders[FX_CONST.BARREL];
                this.setShader(shader);
                this.barrel.onPreRender(config2, shader);
                this.runDraw();
              },
              onDisplacement: function(config2) {
                this.setShader(this.shaders[FX_CONST.DISPLACEMENT]);
                this.set1i("uDisplacementSampler", 1);
                this.set2f("amount", config2.x, config2.y);
                this.bindTexture(config2.glTexture, 1);
                this.runDraw();
              },
              onWipe: function(config2) {
                var shader = this.shaders[FX_CONST.WIPE];
                this.setShader(shader);
                this.wipe.onPreRender(config2, shader);
                this.runDraw();
              },
              onBokeh: function(config2, width, height) {
                var shader = this.shaders[FX_CONST.BOKEH];
                this.setShader(shader);
                this.bokeh.onPreRender(config2, shader, width, height);
                this.runDraw();
              },
              destroy: function() {
                this.glow.destroy();
                this.shadow.destroy();
                this.pixelate.destroy();
                this.vignette.destroy();
                this.shine.destroy();
                this.gradient.destroy();
                this.circle.destroy();
                this.barrel.destroy();
                this.wipe.destroy();
                this.bokeh.destroy();
                this.fxHandlers = null;
                this.source = null;
                this.target = null;
                this.swap = null;
                PreFXPipeline.prototype.destroy.call(this);
                return this;
              }
            });
            module2.exports = FXPipeline;
          },
          66901: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var LightShaderSourceFS = __webpack_require__2(65045);
            var MultiPipeline = __webpack_require__2(77310);
            var TransformMatrix = __webpack_require__2(69360);
            var Vec2 = __webpack_require__2(93736);
            var WebGLPipeline = __webpack_require__2(44775);
            var LightPipeline = new Class({
              Extends: MultiPipeline,
              initialize: function LightPipeline2(config2) {
                var fragShader = GetFastValue(config2, "fragShader", LightShaderSourceFS);
                config2.fragShader = fragShader.replace("%LIGHT_COUNT%", config2.game.renderer.config.maxLights);
                MultiPipeline.call(this, config2);
                this.inverseRotationMatrix = new Float32Array([
                  1,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  1
                ]);
                this.defaultNormalMap;
                this.currentNormalMap;
                this.lightsActive = true;
                this.tempVec2 = new Vec2();
                this._tempMatrix = new TransformMatrix();
                this._tempMatrix2 = new TransformMatrix();
              },
              boot: function() {
                WebGLPipeline.prototype.boot.call(this);
                var gl = this.gl;
                var tempTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tempTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255]));
                this.defaultNormalMap = {glTexture: tempTexture};
              },
              onRender: function(scene, camera) {
                var lightManager = scene.sys.lights;
                this.lightsActive = false;
                if (!lightManager || !lightManager.active) {
                  return;
                }
                var lights = lightManager.getLights(camera);
                var lightsCount = lights.length;
                this.lightsActive = true;
                var i;
                var renderer = this.renderer;
                var height = renderer.height;
                var cameraMatrix = camera.matrix;
                var tempVec2 = this.tempVec2;
                this.set1i("uMainSampler", 0);
                this.set1i("uNormSampler", 1);
                this.set2f("uResolution", this.width / 2, this.height / 2);
                this.set4f("uCamera", camera.x, camera.y, camera.rotation, camera.zoom);
                this.set3f("uAmbientLightColor", lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);
                this.set1i("uLightCount", lightsCount);
                for (i = 0; i < lightsCount; i++) {
                  var light = lights[i].light;
                  var color = light.color;
                  var lightName = "uLights[" + i + "].";
                  cameraMatrix.transformPoint(light.x, light.y, tempVec2);
                  this.set2f(lightName + "position", tempVec2.x - camera.scrollX * light.scrollFactorX * camera.zoom, height - (tempVec2.y - camera.scrollY * light.scrollFactorY * camera.zoom));
                  this.set3f(lightName + "color", color.r, color.g, color.b);
                  this.set1f(lightName + "intensity", light.intensity);
                  this.set1f(lightName + "radius", light.radius);
                }
                this.currentNormalMapRotation = null;
              },
              setNormalMapRotation: function(rotation) {
                if (rotation !== this.currentNormalMapRotation || this.vertexCount === 0) {
                  if (this.vertexCount > 0) {
                    this.flush();
                  }
                  var inverseRotationMatrix = this.inverseRotationMatrix;
                  if (rotation) {
                    var rot = -rotation;
                    var c = Math.cos(rot);
                    var s = Math.sin(rot);
                    inverseRotationMatrix[1] = s;
                    inverseRotationMatrix[3] = -s;
                    inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;
                  } else {
                    inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;
                    inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;
                  }
                  this.setMatrix3fv("uInverseRotationMatrix", false, inverseRotationMatrix);
                  this.currentNormalMapRotation = rotation;
                }
              },
              setTexture2D: function(texture, gameObject) {
                var renderer = this.renderer;
                if (texture === void 0) {
                  texture = renderer.whiteTexture;
                }
                var normalMap = this.getNormalMap(gameObject);
                if (this.isNewNormalMap(texture, normalMap)) {
                  this.flush();
                  this.createBatch(texture);
                  this.addTextureToBatch(normalMap);
                  this.currentNormalMap = normalMap;
                }
                var rotation = 0;
                if (gameObject && gameObject.parentContainer) {
                  var matrix = gameObject.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);
                  rotation = matrix.rotationNormalized;
                } else if (gameObject) {
                  rotation = gameObject.rotation;
                }
                this.setNormalMapRotation(rotation);
                return 0;
              },
              setGameObject: function(gameObject, frame) {
                if (frame === void 0) {
                  frame = gameObject.frame;
                }
                var texture = frame.glTexture;
                var normalMap = this.getNormalMap(gameObject);
                if (this.isNewNormalMap(texture, normalMap)) {
                  this.flush();
                  this.createBatch(texture);
                  this.addTextureToBatch(normalMap);
                  this.currentNormalMap = normalMap;
                }
                if (gameObject.parentContainer) {
                  var matrix = gameObject.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);
                  this.setNormalMapRotation(matrix.rotationNormalized);
                } else {
                  this.setNormalMapRotation(gameObject.rotation);
                }
                return 0;
              },
              isNewNormalMap: function(texture, normalMap) {
                return this.currentTexture !== texture || this.currentNormalMap !== normalMap;
              },
              getNormalMap: function(gameObject) {
                var normalMap;
                if (!gameObject) {
                  normalMap = this.defaultNormalMap;
                } else if (gameObject.displayTexture) {
                  normalMap = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];
                } else if (gameObject.texture) {
                  normalMap = gameObject.texture.dataSource[gameObject.frame.sourceIndex];
                } else if (gameObject.tileset) {
                  if (Array.isArray(gameObject.tileset)) {
                    normalMap = gameObject.tileset[0].image.dataSource[0];
                  } else {
                    normalMap = gameObject.tileset.image.dataSource[0];
                  }
                }
                if (!normalMap) {
                  normalMap = this.defaultNormalMap;
                }
                return normalMap.glTexture;
              },
              batchSprite: function(gameObject, camera, parentTransformMatrix) {
                if (this.lightsActive) {
                  MultiPipeline.prototype.batchSprite.call(this, gameObject, camera, parentTransformMatrix);
                }
              },
              batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
                if (this.lightsActive) {
                  MultiPipeline.prototype.batchTexture.call(this, gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit);
                }
              },
              batchTextureFrame: function(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
                if (this.lightsActive) {
                  MultiPipeline.prototype.batchTextureFrame.call(this, frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix);
                }
              }
            });
            module2.exports = LightPipeline;
          },
          71264: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var MultiPipeline = __webpack_require__2(77310);
            var ShaderSourceFS = __webpack_require__2(85060);
            var ShaderSourceVS = __webpack_require__2(18166);
            var WEBGL_CONST = __webpack_require__2(71402);
            var WebGLPipeline = __webpack_require__2(44775);
            var MobilePipeline = new Class({
              Extends: MultiPipeline,
              initialize: function MobilePipeline2(config2) {
                config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS);
                config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
                config2.attributes = GetFastValue(config2, "attributes", [
                  {
                    name: "inPosition",
                    size: 2
                  },
                  {
                    name: "inTexCoord",
                    size: 2
                  },
                  {
                    name: "inTexId"
                  },
                  {
                    name: "inTintEffect"
                  },
                  {
                    name: "inTint",
                    size: 4,
                    type: WEBGL_CONST.UNSIGNED_BYTE,
                    normalized: true
                  }
                ]);
                config2.forceZero = true;
                MultiPipeline.call(this, config2);
              },
              boot: function() {
                WebGLPipeline.prototype.boot.call(this);
                var renderer = this.renderer;
                this.set1i("uMainSampler", 0);
                this.set2f("uResolution", renderer.width, renderer.height);
                this.set1i("uRoundPixels", renderer.config.roundPixels);
              }
            });
            module2.exports = MobilePipeline;
          },
          77310: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Felipe Alfonso <@bitnenfer>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Earcut = __webpack_require__2(11117);
            var GetFastValue = __webpack_require__2(72632);
            var ShaderSourceFS = __webpack_require__2(53787);
            var ShaderSourceVS = __webpack_require__2(15968);
            var TransformMatrix = __webpack_require__2(69360);
            var Utils = __webpack_require__2(75512);
            var WEBGL_CONST = __webpack_require__2(71402);
            var WebGLPipeline = __webpack_require__2(44775);
            var MultiPipeline = new Class({
              Extends: WebGLPipeline,
              initialize: function MultiPipeline2(config2) {
                var renderer = config2.game.renderer;
                var fragmentShaderSource = GetFastValue(config2, "fragShader", ShaderSourceFS);
                config2.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures);
                config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
                config2.attributes = GetFastValue(config2, "attributes", [
                  {
                    name: "inPosition",
                    size: 2
                  },
                  {
                    name: "inTexCoord",
                    size: 2
                  },
                  {
                    name: "inTexId"
                  },
                  {
                    name: "inTintEffect"
                  },
                  {
                    name: "inTint",
                    size: 4,
                    type: WEBGL_CONST.UNSIGNED_BYTE,
                    normalized: true
                  }
                ]);
                WebGLPipeline.call(this, config2);
                this._tempMatrix1 = new TransformMatrix();
                this._tempMatrix2 = new TransformMatrix();
                this._tempMatrix3 = new TransformMatrix();
                this.calcMatrix = new TransformMatrix();
                this.tempTriangle = [
                  {x: 0, y: 0, width: 0},
                  {x: 0, y: 0, width: 0},
                  {x: 0, y: 0, width: 0},
                  {x: 0, y: 0, width: 0}
                ];
                this.strokeTint = {TL: 0, TR: 0, BL: 0, BR: 0};
                this.fillTint = {TL: 0, TR: 0, BL: 0, BR: 0};
                this.currentFrame = {u0: 0, v0: 0, u1: 1, v1: 1};
                this.firstQuad = [0, 0, 0, 0, 0];
                this.prevQuad = [0, 0, 0, 0, 0];
                this.polygonCache = [];
              },
              boot: function() {
                WebGLPipeline.prototype.boot.call(this);
                var renderer = this.renderer;
                this.set1iv("uMainSampler", renderer.textureIndexes);
                this.set2f("uResolution", renderer.width, renderer.height);
                this.set1i("uRoundPixels", renderer.config.roundPixels);
              },
              batchSprite: function(gameObject, camera, parentTransformMatrix) {
                this.manager.set(this, gameObject);
                var camMatrix = this._tempMatrix1;
                var spriteMatrix = this._tempMatrix2;
                var calcMatrix = this._tempMatrix3;
                var frame = gameObject.frame;
                var texture = frame.glTexture;
                var u0 = frame.u0;
                var v0 = frame.v0;
                var u1 = frame.u1;
                var v1 = frame.v1;
                var frameX = frame.x;
                var frameY = frame.y;
                var frameWidth = frame.cutWidth;
                var frameHeight = frame.cutHeight;
                var customPivot = frame.customPivot;
                var displayOriginX = gameObject.displayOriginX;
                var displayOriginY = gameObject.displayOriginY;
                var x = -displayOriginX + frameX;
                var y = -displayOriginY + frameY;
                if (gameObject.isCropped) {
                  var crop = gameObject._crop;
                  if (crop.flipX !== gameObject.flipX || crop.flipY !== gameObject.flipY) {
                    frame.updateCropUVs(crop, gameObject.flipX, gameObject.flipY);
                  }
                  u0 = crop.u0;
                  v0 = crop.v0;
                  u1 = crop.u1;
                  v1 = crop.v1;
                  frameWidth = crop.width;
                  frameHeight = crop.height;
                  frameX = crop.x;
                  frameY = crop.y;
                  x = -displayOriginX + frameX;
                  y = -displayOriginY + frameY;
                }
                var flipX = 1;
                var flipY = 1;
                if (gameObject.flipX) {
                  if (!customPivot) {
                    x += -frame.realWidth + displayOriginX * 2;
                  }
                  flipX = -1;
                }
                if (gameObject.flipY || frame.source.isGLTexture && !texture.flipY) {
                  if (!customPivot) {
                    y += -frame.realHeight + displayOriginY * 2;
                  }
                  flipY = -1;
                }
                var gx = gameObject.x;
                var gy = gameObject.y;
                spriteMatrix.applyITRS(gx, gy, gameObject.rotation, gameObject.scaleX * flipX, gameObject.scaleY * flipY);
                camMatrix.copyFrom(camera.matrix);
                if (parentTransformMatrix) {
                  camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * gameObject.scrollFactorX, -camera.scrollY * gameObject.scrollFactorY);
                  spriteMatrix.e = gx;
                  spriteMatrix.f = gy;
                } else {
                  spriteMatrix.e -= camera.scrollX * gameObject.scrollFactorX;
                  spriteMatrix.f -= camera.scrollY * gameObject.scrollFactorY;
                }
                camMatrix.multiply(spriteMatrix, calcMatrix);
                var quad = calcMatrix.setQuad(x, y, x + frameWidth, y + frameHeight);
                var getTint = Utils.getTintAppendFloatAlpha;
                var cameraAlpha = camera.alpha;
                var tintTL = getTint(gameObject.tintTopLeft, cameraAlpha * gameObject._alphaTL);
                var tintTR = getTint(gameObject.tintTopRight, cameraAlpha * gameObject._alphaTR);
                var tintBL = getTint(gameObject.tintBottomLeft, cameraAlpha * gameObject._alphaBL);
                var tintBR = getTint(gameObject.tintBottomRight, cameraAlpha * gameObject._alphaBR);
                if (this.shouldFlush(6)) {
                  this.flush();
                }
                var unit = this.setGameObject(gameObject, frame);
                this.manager.preBatch(gameObject);
                this.currentShader.set1i("uRoundPixels", camera.roundPixels);
                this.batchQuad(gameObject, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit);
                this.manager.postBatch(gameObject);
              },
              batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit, skipPrePost) {
                if (skipPrePost === void 0) {
                  skipPrePost = false;
                }
                this.manager.set(this, gameObject);
                var camMatrix = this._tempMatrix1;
                var spriteMatrix = this._tempMatrix2;
                var calcMatrix = this._tempMatrix3;
                var u0 = frameX / textureWidth + uOffset;
                var v0 = frameY / textureHeight + vOffset;
                var u1 = (frameX + frameWidth) / textureWidth + uOffset;
                var v1 = (frameY + frameHeight) / textureHeight + vOffset;
                var width = srcWidth;
                var height = srcHeight;
                var x = -displayOriginX;
                var y = -displayOriginY;
                if (gameObject.isCropped) {
                  var crop = gameObject._crop;
                  var cropWidth = crop.width;
                  var cropHeight = crop.height;
                  width = cropWidth;
                  height = cropHeight;
                  srcWidth = cropWidth;
                  srcHeight = cropHeight;
                  frameX = crop.x;
                  frameY = crop.y;
                  var ox = frameX;
                  var oy = frameY;
                  if (flipX) {
                    ox = frameWidth - crop.x - cropWidth;
                  }
                  if (flipY) {
                    oy = frameHeight - crop.y - cropHeight;
                  }
                  u0 = ox / textureWidth + uOffset;
                  v0 = oy / textureHeight + vOffset;
                  u1 = (ox + cropWidth) / textureWidth + uOffset;
                  v1 = (oy + cropHeight) / textureHeight + vOffset;
                  x = -displayOriginX + frameX;
                  y = -displayOriginY + frameY;
                }
                flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);
                if (flipX) {
                  width *= -1;
                  x += srcWidth;
                }
                if (flipY) {
                  height *= -1;
                  y += srcHeight;
                }
                spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);
                camMatrix.copyFrom(camera.matrix);
                if (parentTransformMatrix) {
                  camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
                  spriteMatrix.e = srcX;
                  spriteMatrix.f = srcY;
                } else {
                  spriteMatrix.e -= camera.scrollX * scrollFactorX;
                  spriteMatrix.f -= camera.scrollY * scrollFactorY;
                }
                camMatrix.multiply(spriteMatrix, calcMatrix);
                var quad = calcMatrix.setQuad(x, y, x + width, y + height);
                if (textureUnit === void 0 || textureUnit === null) {
                  textureUnit = this.setTexture2D(texture);
                }
                if (gameObject && !skipPrePost) {
                  this.manager.preBatch(gameObject);
                }
                this.currentShader.set1i("uRoundPixels", camera.roundPixels);
                this.batchQuad(gameObject, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
                if (gameObject && !skipPrePost) {
                  this.manager.postBatch(gameObject);
                }
              },
              batchTextureFrame: function(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
                this.manager.set(this);
                var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);
                var calcMatrix = this._tempMatrix2;
                if (parentTransformMatrix) {
                  spriteMatrix.multiply(parentTransformMatrix, calcMatrix);
                } else {
                  calcMatrix = spriteMatrix;
                }
                var quad = calcMatrix.setQuad(x, y, x + frame.width, y + frame.height);
                var unit = this.setTexture2D(frame.source.glTexture);
                tint = Utils.getTintAppendFloatAlpha(tint, alpha);
                this.batchQuad(null, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);
              },
              batchFillRect: function(x, y, width, height, currentMatrix, parentMatrix) {
                this.renderer.pipelines.set(this);
                var calcMatrix = this.calcMatrix;
                if (parentMatrix) {
                  parentMatrix.multiply(currentMatrix, calcMatrix);
                }
                var quad = calcMatrix.setQuad(x, y, x + width, y + height);
                var tint = this.fillTint;
                this.batchQuad(null, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, tint.BR, 2);
              },
              batchFillTriangle: function(x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
                this.renderer.pipelines.set(this);
                var calcMatrix = this.calcMatrix;
                if (parentMatrix) {
                  parentMatrix.multiply(currentMatrix, calcMatrix);
                }
                var tx0 = calcMatrix.getX(x0, y0);
                var ty0 = calcMatrix.getY(x0, y0);
                var tx1 = calcMatrix.getX(x1, y1);
                var ty1 = calcMatrix.getY(x1, y1);
                var tx2 = calcMatrix.getX(x2, y2);
                var ty2 = calcMatrix.getY(x2, y2);
                var tint = this.fillTint;
                this.currentShader.set1i("uRoundPixels", false);
                this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, 2);
              },
              batchStrokeTriangle: function(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
                var tempTriangle = this.tempTriangle;
                tempTriangle[0].x = x0;
                tempTriangle[0].y = y0;
                tempTriangle[0].width = lineWidth;
                tempTriangle[1].x = x1;
                tempTriangle[1].y = y1;
                tempTriangle[1].width = lineWidth;
                tempTriangle[2].x = x2;
                tempTriangle[2].y = y2;
                tempTriangle[2].width = lineWidth;
                tempTriangle[3].x = x0;
                tempTriangle[3].y = y0;
                tempTriangle[3].width = lineWidth;
                this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
              },
              batchFillPath: function(path, currentMatrix, parentMatrix) {
                this.renderer.pipelines.set(this);
                var calcMatrix = this.calcMatrix;
                if (parentMatrix) {
                  parentMatrix.multiply(currentMatrix, calcMatrix);
                }
                var length = path.length;
                var polygonCache = this.polygonCache;
                var polygonIndexArray;
                var point;
                var tintTL = this.fillTint.TL;
                var tintTR = this.fillTint.TR;
                var tintBL = this.fillTint.BL;
                for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
                  point = path[pathIndex];
                  polygonCache.push(point.x, point.y);
                }
                polygonIndexArray = Earcut(polygonCache);
                length = polygonIndexArray.length;
                this.currentShader.set1i("uRoundPixels", false);
                for (var index = 0; index < length; index += 3) {
                  var p0 = polygonIndexArray[index + 0] * 2;
                  var p1 = polygonIndexArray[index + 1] * 2;
                  var p2 = polygonIndexArray[index + 2] * 2;
                  var x0 = polygonCache[p0 + 0];
                  var y0 = polygonCache[p0 + 1];
                  var x1 = polygonCache[p1 + 0];
                  var y1 = polygonCache[p1 + 1];
                  var x2 = polygonCache[p2 + 0];
                  var y2 = polygonCache[p2 + 1];
                  var tx0 = calcMatrix.getX(x0, y0);
                  var ty0 = calcMatrix.getY(x0, y0);
                  var tx1 = calcMatrix.getX(x1, y1);
                  var ty1 = calcMatrix.getY(x1, y1);
                  var tx2 = calcMatrix.getX(x2, y2);
                  var ty2 = calcMatrix.getY(x2, y2);
                  this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tintTL, tintTR, tintBL, 2);
                }
                polygonCache.length = 0;
              },
              batchStrokePath: function(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
                this.renderer.pipelines.set(this);
                this.prevQuad[4] = 0;
                this.firstQuad[4] = 0;
                var pathLength = path.length - 1;
                for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
                  var point0 = path[pathIndex];
                  var point1 = path[pathIndex + 1];
                  this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
                }
              },
              batchLine: function(ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix) {
                this.renderer.pipelines.set(this);
                var calcMatrix = this.calcMatrix;
                if (parentMatrix) {
                  parentMatrix.multiply(currentMatrix, calcMatrix);
                }
                var dx = bx - ax;
                var dy = by - ay;
                var len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) {
                  return;
                }
                var al0 = aLineWidth * (by - ay) / len;
                var al1 = aLineWidth * (ax - bx) / len;
                var bl0 = bLineWidth * (by - ay) / len;
                var bl1 = bLineWidth * (ax - bx) / len;
                var lx0 = bx - bl0;
                var ly0 = by - bl1;
                var lx1 = ax - al0;
                var ly1 = ay - al1;
                var lx2 = bx + bl0;
                var ly2 = by + bl1;
                var lx3 = ax + al0;
                var ly3 = ay + al1;
                var brX = calcMatrix.getX(lx0, ly0);
                var brY = calcMatrix.getY(lx0, ly0);
                var blX = calcMatrix.getX(lx1, ly1);
                var blY = calcMatrix.getY(lx1, ly1);
                var trX = calcMatrix.getX(lx2, ly2);
                var trY = calcMatrix.getY(lx2, ly2);
                var tlX = calcMatrix.getX(lx3, ly3);
                var tlY = calcMatrix.getY(lx3, ly3);
                var tint = this.strokeTint;
                var tintTL = tint.TL;
                var tintTR = tint.TR;
                var tintBL = tint.BL;
                var tintBR = tint.BR;
                this.currentShader.set1i("uRoundPixels", false);
                this.batchQuad(null, tlX, tlY, blX, blY, brX, brY, trX, trY, 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
                if (lineWidth <= 2) {
                  return;
                }
                var prev = this.prevQuad;
                var first = this.firstQuad;
                if (index > 0 && prev[4]) {
                  this.batchQuad(null, tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
                } else {
                  first[0] = tlX;
                  first[1] = tlY;
                  first[2] = blX;
                  first[3] = blY;
                  first[4] = 1;
                }
                if (closePath && first[4]) {
                  this.batchQuad(null, brX, brY, trX, trY, first[0], first[1], first[2], first[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
                } else {
                  prev[0] = brX;
                  prev[1] = brY;
                  prev[2] = trX;
                  prev[3] = trY;
                  prev[4] = 1;
                }
              },
              destroy: function() {
                this._tempMatrix1.destroy();
                this._tempMatrix2.destroy();
                this._tempMatrix3.destroy();
                this._tempMatrix1 = null;
                this._tempMatrix1 = null;
                this._tempMatrix1 = null;
                WebGLPipeline.prototype.destroy.call(this);
                return this;
              }
            });
            module2.exports = MultiPipeline;
          },
          10919: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var PointLightShaderSourceFS = __webpack_require__2(83327);
            var PointLightShaderSourceVS = __webpack_require__2(54677);
            var WebGLPipeline = __webpack_require__2(44775);
            var PointLightPipeline = new Class({
              Extends: WebGLPipeline,
              initialize: function PointLightPipeline2(config2) {
                config2.vertShader = GetFastValue(config2, "vertShader", PointLightShaderSourceVS);
                config2.fragShader = GetFastValue(config2, "fragShader", PointLightShaderSourceFS);
                config2.attributes = GetFastValue(config2, "attributes", [
                  {
                    name: "inPosition",
                    size: 2
                  },
                  {
                    name: "inLightPosition",
                    size: 2
                  },
                  {
                    name: "inLightRadius"
                  },
                  {
                    name: "inLightAttenuation"
                  },
                  {
                    name: "inLightColor",
                    size: 4
                  }
                ]);
                WebGLPipeline.call(this, config2);
              },
              onRender: function(scene, camera) {
                this.set2f("uResolution", this.width, this.height);
                this.set1f("uCameraZoom", camera.zoom);
              },
              batchPointLight: function(light, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY) {
                var color = light.color;
                var intensity = light.intensity;
                var radius = light.radius;
                var attenuation = light.attenuation;
                var r = color.r * intensity;
                var g = color.g * intensity;
                var b = color.b * intensity;
                var a = camera.alpha * light.alpha;
                if (this.shouldFlush(6)) {
                  this.flush();
                }
                if (!this.currentBatch) {
                  this.setTexture2D();
                }
                this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
                this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r, g, b, a);
                this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
                this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
                this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
                this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r, g, b, a);
                this.currentBatch.count = this.vertexCount - this.currentBatch.start;
              },
              batchLightVert: function(x, y, lightX, lightY, radius, attenuation, r, g, b, a) {
                var vertexViewF32 = this.vertexViewF32;
                var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
                vertexViewF32[++vertexOffset] = x;
                vertexViewF32[++vertexOffset] = y;
                vertexViewF32[++vertexOffset] = lightX;
                vertexViewF32[++vertexOffset] = lightY;
                vertexViewF32[++vertexOffset] = radius;
                vertexViewF32[++vertexOffset] = attenuation;
                vertexViewF32[++vertexOffset] = r;
                vertexViewF32[++vertexOffset] = g;
                vertexViewF32[++vertexOffset] = b;
                vertexViewF32[++vertexOffset] = a;
                this.vertexCount++;
              }
            });
            module2.exports = PointLightPipeline;
          },
          80486: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ColorMatrix = __webpack_require__2(65246);
            var GetFastValue = __webpack_require__2(72632);
            var ShaderSourceFS = __webpack_require__2(12569);
            var ShaderSourceVS = __webpack_require__2(99365);
            var WebGLPipeline = __webpack_require__2(44775);
            var PostFXPipeline = new Class({
              Extends: WebGLPipeline,
              initialize: function PostFXPipeline2(config2) {
                config2.renderTarget = GetFastValue(config2, "renderTarget", 1);
                config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS);
                config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
                config2.attributes = GetFastValue(config2, "attributes", [
                  {
                    name: "inPosition",
                    size: 2
                  },
                  {
                    name: "inTexCoord",
                    size: 2
                  }
                ]);
                config2.batchSize = 1;
                config2.vertices = [
                  -1,
                  -1,
                  0,
                  0,
                  -1,
                  1,
                  0,
                  1,
                  1,
                  1,
                  1,
                  1,
                  -1,
                  -1,
                  0,
                  0,
                  1,
                  1,
                  1,
                  1,
                  1,
                  -1,
                  1,
                  0
                ];
                WebGLPipeline.call(this, config2);
                this.isPostFX = true;
                this.gameObject;
                this.controller;
                this.colorMatrix = new ColorMatrix();
                this.fullFrame1;
                this.fullFrame2;
                this.halfFrame1;
                this.halfFrame2;
                if (this.renderer.isBooted) {
                  this.manager = this.renderer.pipelines;
                }
              },
              bootFX: function() {
                WebGLPipeline.prototype.boot.call(this);
                var utility = this.manager.UTILITY_PIPELINE;
                this.fullFrame1 = utility.fullFrame1;
                this.fullFrame2 = utility.fullFrame2;
                this.halfFrame1 = utility.halfFrame1;
                this.halfFrame2 = utility.halfFrame2;
                var renderer = this.renderer;
                this.set1i("uMainSampler", 0);
                this.set2f("uResolution", renderer.width, renderer.height);
                this.set1i("uRoundPixels", renderer.config.roundPixels);
                var targets = this.renderTargets;
                for (var i = 0; i < targets.length; i++) {
                  targets[i].autoResize = true;
                }
              },
              postBatch: function(gameObject) {
                if (!this.hasBooted) {
                  this.bootFX();
                }
                this.onDraw(this.currentRenderTarget);
                this.onPostBatch(gameObject);
                return this;
              },
              onDraw: function(renderTarget) {
                this.bindAndDraw(renderTarget);
              },
              getController: function(controller) {
                if (controller !== void 0) {
                  return controller;
                } else if (this.controller) {
                  return this.controller;
                } else {
                  return this;
                }
              },
              copySprite: function(source, target, reset) {
                if (reset === void 0) {
                  reset = false;
                }
                var gl = this.gl;
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source.texture);
                var currentFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                if (reset) {
                  gl.bindTexture(gl.TEXTURE_2D, null);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, currentFBO);
                }
              },
              copyFrame: function(source, target, brightness, clear, clearAlpha) {
                this.manager.copyFrame(source, target, brightness, clear, clearAlpha);
              },
              copyToGame: function(source) {
                this.manager.copyToGame(source);
              },
              drawFrame: function(source, target, clearAlpha) {
                this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);
              },
              blendFrames: function(source1, source2, target, strength, clearAlpha) {
                this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
              },
              blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
                this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
              },
              clearFrame: function(target, clearAlpha) {
                this.manager.clearFrame(target, clearAlpha);
              },
              blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
                this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
              },
              copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
                this.manager.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
              },
              bindAndDraw: function(source, target, clear, clearAlpha, currentShader) {
                if (clear === void 0) {
                  clear = true;
                }
                if (clearAlpha === void 0) {
                  clearAlpha = true;
                }
                var gl = this.gl;
                var renderer = this.renderer;
                this.bind(currentShader);
                this.set1i("uMainSampler", 0);
                if (target) {
                  gl.viewport(0, 0, target.width, target.height);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                  if (clear) {
                    if (clearAlpha) {
                      gl.clearColor(0, 0, 0, 0);
                    } else {
                      gl.clearColor(0, 0, 0, 1);
                    }
                    gl.clear(gl.COLOR_BUFFER_BIT);
                  }
                } else {
                  renderer.popFramebuffer(false, false);
                  if (!renderer.currentFramebuffer) {
                    gl.viewport(0, 0, renderer.width, renderer.height);
                  }
                }
                renderer.restoreStencilMask();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source.texture);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                if (target) {
                  gl.bindTexture(gl.TEXTURE_2D, null);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.currentFramebuffer);
                }
              },
              destroy: function() {
                if (this.controller) {
                  this.controller.destroy();
                }
                this.gameObject = null;
                this.controller = null;
                this.colorMatrix = null;
                this.fullFrame1 = null;
                this.fullFrame2 = null;
                this.halfFrame1 = null;
                this.halfFrame2 = null;
                WebGLPipeline.prototype.destroy.call(this);
                return this;
              }
            });
            module2.exports = PostFXPipeline;
          },
          87228: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BlendModes = __webpack_require__2(95723);
            var CenterOn = __webpack_require__2(79993);
            var Class = __webpack_require__2(56694);
            var ColorMatrixFS = __webpack_require__2(37486);
            var GetFastValue = __webpack_require__2(72632);
            var MultiPipeline = __webpack_require__2(77310);
            var PostFXFS = __webpack_require__2(12569);
            var Rectangle = __webpack_require__2(74118);
            var RenderTarget = __webpack_require__2(37410);
            var SingleQuadFS = __webpack_require__2(85060);
            var SingleQuadVS = __webpack_require__2(18166);
            var WebGLPipeline = __webpack_require__2(44775);
            var PreFXPipeline = new Class({
              Extends: MultiPipeline,
              initialize: function PreFXPipeline2(config2) {
                var fragShader = GetFastValue(config2, "fragShader", PostFXFS);
                var vertShader = GetFastValue(config2, "vertShader", SingleQuadVS);
                var drawShader = GetFastValue(config2, "drawShader", PostFXFS);
                var defaultShaders = [
                  {
                    name: "DrawSprite",
                    fragShader: SingleQuadFS,
                    vertShader: SingleQuadVS
                  },
                  {
                    name: "CopySprite",
                    fragShader,
                    vertShader
                  },
                  {
                    name: "DrawGame",
                    fragShader: drawShader,
                    vertShader: SingleQuadVS
                  },
                  {
                    name: "ColorMatrix",
                    fragShader: ColorMatrixFS
                  }
                ];
                var configShaders = GetFastValue(config2, "shaders", []);
                config2.shaders = defaultShaders.concat(configShaders);
                if (!config2.vertShader) {
                  config2.vertShader = vertShader;
                }
                config2.batchSize = 1;
                MultiPipeline.call(this, config2);
                this.isPreFX = true;
                this.customMainSampler = null;
                this.drawSpriteShader;
                this.copyShader;
                this.gameShader;
                this.colorMatrixShader;
                this.quadVertexData;
                this.quadVertexBuffer;
                this.quadVertexViewF32;
                this.spriteBounds = new Rectangle();
                this.targetBounds = new Rectangle();
                this.fsTarget;
                this.tempSprite;
                if (this.renderer.isBooted) {
                  this.manager = this.renderer.pipelines;
                  this.boot();
                }
              },
              boot: function() {
                WebGLPipeline.prototype.boot.call(this);
                var shaders = this.shaders;
                var renderer = this.renderer;
                this.drawSpriteShader = shaders[0];
                this.copyShader = shaders[1];
                this.gameShader = shaders[2];
                this.colorMatrixShader = shaders[3];
                this.fsTarget = new RenderTarget(renderer, renderer.width, renderer.height, 1, 0, true, true);
                this.renderTargets = this.manager.renderTargets.concat(this.fsTarget);
                var data = new ArrayBuffer(168);
                this.quadVertexData = data;
                this.quadVertexViewF32 = new Float32Array(data);
                this.quadVertexBuffer = renderer.createVertexBuffer(data, this.gl.STATIC_DRAW);
                this.onResize(renderer.width, renderer.height);
                this.currentShader = this.copyShader;
                this.set2f("uResolution", renderer.width, renderer.height);
                this.set1i("uRoundPixels", renderer.config.roundPixels);
              },
              onResize: function(width, height) {
                var vertexViewF32 = this.quadVertexViewF32;
                vertexViewF32[1] = height;
                vertexViewF32[22] = height;
                vertexViewF32[14] = width;
                vertexViewF32[28] = width;
                vertexViewF32[35] = width;
                vertexViewF32[36] = height;
              },
              batchQuad: function(gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture) {
                var bx = Math.min(x0, x1, x2, x3);
                var by = Math.min(y0, y1, y2, y3);
                var br = Math.max(x0, x1, x2, x3);
                var bb = Math.max(y0, y1, y2, y3);
                var bw = br - bx;
                var bh = bb - by;
                var bounds = this.spriteBounds.setTo(bx, by, bw, bh);
                var padding = gameObject ? gameObject.preFX.padding : 0;
                var width = bw + padding * 2;
                var height = bh + padding * 2;
                var maxDimension = Math.abs(Math.max(width, height));
                var target = this.manager.getRenderTarget(maxDimension);
                var targetBounds = this.targetBounds.setTo(0, 0, target.width, target.height);
                CenterOn(targetBounds, bounds.centerX, bounds.centerY);
                this.tempSprite = gameObject;
                var gl = this.gl;
                var renderer = this.renderer;
                renderer.clearStencilMask();
                this.setShader(this.drawSpriteShader);
                this.set1i("uMainSampler", 0);
                this.set2f("uResolution", renderer.width, renderer.height);
                this.set1i("uRoundPixels", renderer.config.roundPixels);
                this.flipProjectionMatrix(true);
                if (gameObject) {
                  this.onDrawSprite(gameObject, target);
                  gameObject.preFX.onFX(this);
                }
                var fsTarget = this.fsTarget;
                this.flush();
                gl.viewport(0, 0, renderer.width, renderer.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fsTarget.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fsTarget.texture, 0);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                this.setTexture2D(texture);
                this.batchVert(x0, y0, u0, v0, 0, tintEffect, tintTL);
                this.batchVert(x1, y1, u0, v1, 0, tintEffect, tintBL);
                this.batchVert(x2, y2, u1, v1, 0, tintEffect, tintBR);
                this.batchVert(x0, y0, u0, v0, 0, tintEffect, tintTL);
                this.batchVert(x2, y2, u1, v1, 0, tintEffect, tintBR);
                this.batchVert(x3, y3, u1, v0, 0, tintEffect, tintTR);
                this.flush();
                this.flipProjectionMatrix(false);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, target.texture);
                gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, targetBounds.x, targetBounds.y, targetBounds.width, targetBounds.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                this.onBatch(gameObject);
                this.currentShader = this.copyShader;
                this.onDraw(target, this.manager.getSwapRenderTarget(), this.manager.getAltSwapRenderTarget());
                return true;
              },
              onDrawSprite: function() {
              },
              onCopySprite: function() {
              },
              copySprite: function(source, target, clear, clearAlpha, eraseMode, colorMatrix, shader) {
                if (clear === void 0) {
                  clear = true;
                }
                if (clearAlpha === void 0) {
                  clearAlpha = true;
                }
                if (eraseMode === void 0) {
                  eraseMode = false;
                }
                if (shader === void 0) {
                  shader = this.copyShader;
                }
                var gl = this.gl;
                var sprite = this.tempSprite;
                if (colorMatrix) {
                  shader = this.colorMatrixShader;
                }
                this.currentShader = shader;
                var wasBound = this.setVertexBuffer(this.quadVertexBuffer);
                shader.bind(wasBound, false);
                var renderer = this.renderer;
                this.set1i("uMainSampler", 0);
                this.set2f("uResolution", renderer.width, renderer.height);
                this.set1i("uRoundPixels", renderer.config.roundPixels);
                sprite.preFX.onFXCopy(this);
                this.onCopySprite(source, target, sprite);
                if (colorMatrix) {
                  this.set1fv("uColorMatrix", colorMatrix.getData());
                  this.set1f("uAlpha", colorMatrix.alpha);
                }
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source.texture);
                if (source.height > target.height) {
                  gl.viewport(0, 0, source.width, source.height);
                  this.setTargetUVs(source, target);
                } else {
                  var diff = target.height - source.height;
                  gl.viewport(0, diff, source.width, source.height);
                  this.resetUVs();
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                if (clear) {
                  gl.clearColor(0, 0, 0, Number(!clearAlpha));
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                if (eraseMode) {
                  var blendMode = this.renderer.currentBlendMode;
                  this.renderer.setBlendMode(BlendModes.ERASE);
                }
                gl.bufferData(gl.ARRAY_BUFFER, this.quadVertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                if (eraseMode) {
                  this.renderer.setBlendMode(blendMode);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              },
              copy: function(source, target) {
                var gl = this.gl;
                this.set1i("uMainSampler", 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source.texture);
                gl.viewport(0, 0, source.width, source.height);
                this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bufferData(gl.ARRAY_BUFFER, this.quadVertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              },
              blendFrames: function(source1, source2, target, strength, clearAlpha) {
                this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
              },
              blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
                this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
              },
              drawToGame: function(source) {
                this.currentShader = null;
                this.setShader(this.copyShader);
                this.bindAndDraw(source);
              },
              copyToGame: function(source) {
                this.currentShader = null;
                this.setShader(this.gameShader);
                this.bindAndDraw(source);
              },
              bindAndDraw: function(source) {
                var gl = this.gl;
                var renderer = this.renderer;
                this.set1i("uMainSampler", 0);
                if (this.customMainSampler) {
                  this.setTexture2D(this.customMainSampler);
                } else {
                  this.setTexture2D(source.texture);
                }
                var matrix = this._tempMatrix1.loadIdentity();
                var x = this.targetBounds.x;
                var y = this.targetBounds.y;
                var xw = x + source.width;
                var yh = y + source.height;
                var x0 = matrix.getX(x, y);
                var x1 = matrix.getX(x, yh);
                var x2 = matrix.getX(xw, yh);
                var x3 = matrix.getX(xw, y);
                var y0 = matrix.getY(x, y);
                var y1 = matrix.getY(x, yh);
                var y2 = matrix.getY(xw, yh);
                var y3 = matrix.getY(xw, y);
                var white = 16777215;
                this.batchVert(x0, y0, 0, 0, 0, 0, white);
                this.batchVert(x1, y1, 0, 1, 0, 0, white);
                this.batchVert(x2, y2, 1, 1, 0, 0, white);
                this.batchVert(x0, y0, 0, 0, 0, 0, white);
                this.batchVert(x2, y2, 1, 1, 0, 0, white);
                this.batchVert(x3, y3, 1, 0, 0, 0, white);
                renderer.restoreFramebuffer(false, true);
                if (!renderer.currentFramebuffer) {
                  gl.viewport(0, 0, renderer.width, renderer.height);
                }
                renderer.restoreStencilMask();
                this.flush();
                this.tempSprite = null;
              },
              onDraw: function(target) {
                this.drawToGame(target);
              },
              setUVs: function(uA, vA, uB, vB, uC, vC, uD, vD) {
                var vertexViewF32 = this.quadVertexViewF32;
                vertexViewF32[2] = uA;
                vertexViewF32[3] = vA;
                vertexViewF32[9] = uB;
                vertexViewF32[10] = vB;
                vertexViewF32[16] = uC;
                vertexViewF32[17] = vC;
                vertexViewF32[23] = uA;
                vertexViewF32[24] = vA;
                vertexViewF32[30] = uC;
                vertexViewF32[31] = vC;
                vertexViewF32[37] = uD;
                vertexViewF32[38] = vD;
              },
              setTargetUVs: function(source, target) {
                var diff = target.height / source.height;
                if (diff > 0.5) {
                  diff = 0.5 - (diff - 0.5);
                } else {
                  diff = 0.5 + (0.5 - diff);
                }
                this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
              },
              resetUVs: function() {
                this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
              },
              destroy: function() {
                this.gl.deleteBuffer(this.quadVertexBuffer);
                this.drawSpriteShader = null;
                this.copyShader = null;
                this.gameShader = null;
                this.colorMatrixShader = null;
                this.quadVertexData = null;
                this.quadVertexBuffer = null;
                this.quadVertexViewF32 = null;
                this.fsTarget = null;
                this.tempSprite = null;
                MultiPipeline.prototype.destroy.call(this);
                return this;
              }
            });
            module2.exports = PreFXPipeline;
          },
          21213: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var MultiPipeline = __webpack_require__2(77310);
            var RopePipeline = new Class({
              Extends: MultiPipeline,
              initialize: function RopePipeline2(config2) {
                config2.topology = 5;
                config2.batchSize = GetFastValue(config2, "batchSize", 256);
                MultiPipeline.call(this, config2);
              }
            });
            module2.exports = RopePipeline;
          },
          51212: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var MultiPipeline = __webpack_require__2(77310);
            var ShaderSourceFS = __webpack_require__2(85060);
            var ShaderSourceVS = __webpack_require__2(18166);
            var WebGLPipeline = __webpack_require__2(44775);
            var SinglePipeline = new Class({
              Extends: MultiPipeline,
              initialize: function SinglePipeline2(config2) {
                config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS), config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS), config2.forceZero = true;
                MultiPipeline.call(this, config2);
              },
              boot: function() {
                WebGLPipeline.prototype.boot.call(this);
                var renderer = this.renderer;
                this.set1i("uMainSampler", 0);
                this.set2f("uResolution", renderer.width, renderer.height);
                this.set1i("uRoundPixels", renderer.config.roundPixels);
              }
            });
            module2.exports = SinglePipeline;
          },
          60848: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AddBlendFS = __webpack_require__2(2529);
            var BlendModes = __webpack_require__2(95723);
            var Class = __webpack_require__2(56694);
            var ColorMatrix = __webpack_require__2(65246);
            var ColorMatrixFS = __webpack_require__2(37486);
            var CopyFS = __webpack_require__2(79060);
            var GetFastValue = __webpack_require__2(72632);
            var LinearBlendFS = __webpack_require__2(98921);
            var QuadVS = __webpack_require__2(99365);
            var WebGLPipeline = __webpack_require__2(44775);
            var UtilityPipeline = new Class({
              Extends: WebGLPipeline,
              initialize: function UtilityPipeline2(config2) {
                config2.renderTarget = GetFastValue(config2, "renderTarget", [
                  {
                    scale: 1
                  },
                  {
                    scale: 1
                  },
                  {
                    scale: 0.5
                  },
                  {
                    scale: 0.5
                  }
                ]);
                config2.vertShader = GetFastValue(config2, "vertShader", QuadVS);
                config2.shaders = GetFastValue(config2, "shaders", [
                  {
                    name: "Copy",
                    fragShader: CopyFS
                  },
                  {
                    name: "AddBlend",
                    fragShader: AddBlendFS
                  },
                  {
                    name: "LinearBlend",
                    fragShader: LinearBlendFS
                  },
                  {
                    name: "ColorMatrix",
                    fragShader: ColorMatrixFS
                  }
                ]);
                config2.attributes = GetFastValue(config2, "attributes", [
                  {
                    name: "inPosition",
                    size: 2
                  },
                  {
                    name: "inTexCoord",
                    size: 2
                  }
                ]);
                config2.vertices = [
                  -1,
                  -1,
                  0,
                  0,
                  -1,
                  1,
                  0,
                  1,
                  1,
                  1,
                  1,
                  1,
                  -1,
                  -1,
                  0,
                  0,
                  1,
                  1,
                  1,
                  1,
                  1,
                  -1,
                  1,
                  0
                ];
                config2.batchSize = 1;
                WebGLPipeline.call(this, config2);
                this.colorMatrix = new ColorMatrix();
                this.copyShader;
                this.addShader;
                this.linearShader;
                this.colorMatrixShader;
                this.fullFrame1;
                this.fullFrame2;
                this.halfFrame1;
                this.halfFrame2;
              },
              boot: function() {
                WebGLPipeline.prototype.boot.call(this);
                var shaders = this.shaders;
                var targets = this.renderTargets;
                this.copyShader = shaders[0];
                this.addShader = shaders[1];
                this.linearShader = shaders[2];
                this.colorMatrixShader = shaders[3];
                this.fullFrame1 = targets[0];
                this.fullFrame2 = targets[1];
                this.halfFrame1 = targets[2];
                this.halfFrame2 = targets[3];
              },
              copyFrame: function(source, target, brightness, clear, clearAlpha) {
                if (brightness === void 0) {
                  brightness = 1;
                }
                if (clear === void 0) {
                  clear = true;
                }
                if (clearAlpha === void 0) {
                  clearAlpha = true;
                }
                var gl = this.gl;
                this.setShader(this.copyShader);
                this.set1i("uMainSampler", 0);
                this.set1f("uBrightness", brightness);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source.texture);
                if (target) {
                  gl.viewport(0, 0, target.width, target.height);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                } else {
                  gl.viewport(0, 0, source.width, source.height);
                }
                if (clear) {
                  if (clearAlpha) {
                    gl.clearColor(0, 0, 0, 0);
                  } else {
                    gl.clearColor(0, 0, 0, 1);
                  }
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
              },
              blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode, flipY) {
                if (brightness === void 0) {
                  brightness = 1;
                }
                if (clear === void 0) {
                  clear = true;
                }
                if (clearAlpha === void 0) {
                  clearAlpha = true;
                }
                if (eraseMode === void 0) {
                  eraseMode = false;
                }
                if (flipY === void 0) {
                  flipY = false;
                }
                var gl = this.gl;
                this.setShader(this.copyShader);
                this.set1i("uMainSampler", 0);
                this.set1f("uBrightness", brightness);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source.texture);
                if (source.height > target.height) {
                  gl.viewport(0, 0, source.width, source.height);
                  this.setTargetUVs(source, target);
                } else {
                  var diff = target.height - source.height;
                  gl.viewport(0, diff, source.width, source.height);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                if (clear) {
                  if (clearAlpha) {
                    gl.clearColor(0, 0, 0, 0);
                  } else {
                    gl.clearColor(0, 0, 0, 1);
                  }
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                if (eraseMode) {
                  var blendMode = this.renderer.currentBlendMode;
                  this.renderer.setBlendMode(BlendModes.ERASE);
                }
                if (flipY) {
                  this.flipY();
                }
                gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                if (eraseMode) {
                  this.renderer.setBlendMode(blendMode);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                this.resetUVs();
              },
              copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
                if (clear === void 0) {
                  clear = true;
                }
                if (clearAlpha === void 0) {
                  clearAlpha = true;
                }
                var gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, source.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.texture, 0);
                if (clear) {
                  if (clearAlpha) {
                    gl.clearColor(0, 0, 0, 0);
                  } else {
                    gl.clearColor(0, 0, 0, 1);
                  }
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, target.texture);
                gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, width, height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
              },
              copyToGame: function(source) {
                var gl = this.gl;
                this.setShader(this.copyShader);
                this.set1i("uMainSampler", 0);
                this.set1f("uBrightness", 1);
                this.renderer.popFramebuffer();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source.texture);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
              },
              drawFrame: function(source, target, clearAlpha, colorMatrix) {
                if (clearAlpha === void 0) {
                  clearAlpha = true;
                }
                if (colorMatrix === void 0) {
                  colorMatrix = this.colorMatrix;
                }
                var gl = this.gl;
                this.setShader(this.colorMatrixShader);
                this.set1i("uMainSampler", 0);
                this.set1fv("uColorMatrix", colorMatrix.getData());
                this.set1f("uAlpha", colorMatrix.alpha);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source.texture);
                if (target) {
                  gl.viewport(0, 0, target.width, target.height);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                } else {
                  gl.viewport(0, 0, source.width, source.height);
                }
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
              },
              blendFrames: function(source1, source2, target, strength, clearAlpha, blendShader) {
                if (strength === void 0) {
                  strength = 1;
                }
                if (clearAlpha === void 0) {
                  clearAlpha = true;
                }
                if (blendShader === void 0) {
                  blendShader = this.linearShader;
                }
                var gl = this.gl;
                this.setShader(blendShader);
                this.set1i("uMainSampler1", 0);
                this.set1i("uMainSampler2", 1);
                this.set1f("uStrength", strength);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, source1.texture);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, source2.texture);
                if (target) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                  gl.viewport(0, 0, target.width, target.height);
                } else {
                  gl.viewport(0, 0, source1.width, source1.height);
                }
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
              },
              blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
                this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);
              },
              clearFrame: function(target, clearAlpha) {
                if (clearAlpha === void 0) {
                  clearAlpha = true;
                }
                var gl = this.gl;
                gl.viewport(0, 0, target.width, target.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
                var fbo = this.renderer.currentFramebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
              },
              setUVs: function(uA, vA, uB, vB, uC, vC, uD, vD) {
                var vertexViewF32 = this.vertexViewF32;
                vertexViewF32[2] = uA;
                vertexViewF32[3] = vA;
                vertexViewF32[6] = uB;
                vertexViewF32[7] = vB;
                vertexViewF32[10] = uC;
                vertexViewF32[11] = vC;
                vertexViewF32[14] = uA;
                vertexViewF32[15] = vA;
                vertexViewF32[18] = uC;
                vertexViewF32[19] = vC;
                vertexViewF32[22] = uD;
                vertexViewF32[23] = vD;
              },
              setTargetUVs: function(source, target) {
                var diff = target.height / source.height;
                if (diff > 0.5) {
                  diff = 0.5 - (diff - 0.5);
                } else {
                  diff = 0.5 + (0.5 - diff);
                }
                this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
              },
              flipX: function() {
                this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
              },
              flipY: function() {
                this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
              },
              resetUVs: function() {
                this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
              }
            });
            module2.exports = UtilityPipeline;
          },
          65641: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PIPELINE_CONST = {
              BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
              LIGHT_PIPELINE: "Light2D",
              POINTLIGHT_PIPELINE: "PointLightPipeline",
              SINGLE_PIPELINE: "SinglePipeline",
              MULTI_PIPELINE: "MultiPipeline",
              ROPE_PIPELINE: "RopePipeline",
              GRAPHICS_PIPELINE: "GraphicsPipeline",
              POSTFX_PIPELINE: "PostFXPipeline",
              UTILITY_PIPELINE: "UtilityPipeline",
              MOBILE_PIPELINE: "MobilePipeline",
              FX_PIPELINE: "FxPipeline"
            };
            module2.exports = PIPELINE_CONST;
          },
          68726: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pipelineafterflush";
          },
          67186: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pipelinebeforeflush";
          },
          22709: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pipelinebind";
          },
          74469: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pipelineboot";
          },
          93953: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pipelinedestroy";
          },
          51687: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pipelinerebind";
          },
          25034: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pipelineresize";
          },
          18970: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              AFTER_FLUSH: __webpack_require__2(68726),
              BEFORE_FLUSH: __webpack_require__2(67186),
              BIND: __webpack_require__2(22709),
              BOOT: __webpack_require__2(74469),
              DESTROY: __webpack_require__2(93953),
              REBIND: __webpack_require__2(51687),
              RESIZE: __webpack_require__2(25034)
            };
          },
          32469: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var BarrelFrag = __webpack_require__2(87751);
            var PostFXPipeline = __webpack_require__2(80486);
            var BarrelFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function BarrelFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: BarrelFrag
                });
                this.amount = 1;
              },
              onPreRender: function(controller, shader) {
                controller = this.getController(controller);
                this.set1f("amount", controller.amount, shader);
              }
            });
            module2.exports = BarrelFXPipeline;
          },
          2134: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var BloomFrag = __webpack_require__2(88222);
            var PostFXPipeline = __webpack_require__2(80486);
            var BloomFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function BloomFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: BloomFrag
                });
                this.steps = 4;
                this.offsetX = 1;
                this.offsetY = 1;
                this.blurStrength = 1;
                this.strength = 1;
                this.glcolor = [1, 1, 1];
              },
              onPreRender: function(controller) {
                controller = this.getController(controller);
                this.set1f("strength", controller.blurStrength);
                this.set3fv("color", controller.glcolor);
              },
              onDraw: function(target1) {
                var controller = this.getController();
                var target2 = this.fullFrame1;
                var target3 = this.fullFrame2;
                this.copyFrame(target1, target3);
                var x = 2 / target1.width * controller.offsetX;
                var y = 2 / target1.height * controller.offsetY;
                for (var i = 0; i < controller.steps; i++) {
                  this.set2f("offset", x, 0);
                  this.copySprite(target1, target2);
                  this.set2f("offset", 0, y);
                  this.copySprite(target2, target1);
                }
                this.blendFrames(target3, target1, target2, controller.strength);
                this.copyToGame(target2);
              }
            });
            module2.exports = BloomFXPipeline;
          },
          63377: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var BlurLowFrag = __webpack_require__2(35491);
            var BlurMedFrag = __webpack_require__2(75568);
            var BlurHighFrag = __webpack_require__2(44481);
            var PostFXPipeline = __webpack_require__2(80486);
            var BlurFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function BlurFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  shaders: [
                    {
                      name: "Gaussian5",
                      fragShader: BlurLowFrag
                    },
                    {
                      name: "Gaussian9",
                      fragShader: BlurMedFrag
                    },
                    {
                      name: "Gaussian13",
                      fragShader: BlurHighFrag
                    }
                  ]
                });
                this.activeShader = this.shaders[0];
                this.x = 2;
                this.y = 2;
                this.steps = 4;
                this.strength = 1;
                this.glcolor = [1, 1, 1];
              },
              setQualityLow: function() {
                this.activeShader = this.shaders[0];
                return this;
              },
              setQualityMedium: function() {
                this.activeShader = this.shaders[1];
                return this;
              },
              setQualityHigh: function() {
                this.activeShader = this.shaders[2];
                return this;
              },
              onDraw: function(target1) {
                var controller = this.getController();
                var gl = this.gl;
                var target2 = this.fullFrame1;
                var currentFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
                this.bind(this.shaders[controller.quality]);
                gl.activeTexture(gl.TEXTURE0);
                gl.viewport(0, 0, target1.width, target1.height);
                this.set1i("uMainSampler", 0);
                this.set2f("resolution", target1.width, target1.height);
                this.set1f("strength", controller.strength);
                this.set3fv("color", controller.glcolor);
                for (var i = 0; i < controller.steps; i++) {
                  this.set2f("offset", controller.x, 0);
                  this.copySprite(target1, target2);
                  this.set2f("offset", 0, controller.y);
                  this.copySprite(target2, target1);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, currentFBO);
                gl.bindTexture(gl.TEXTURE_2D, null);
                this.copyToGame(target1);
              }
            });
            module2.exports = BlurFXPipeline;
          },
          49745: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var BokehFrag = __webpack_require__2(69960);
            var PostFXPipeline = __webpack_require__2(80486);
            var BokehFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function BokehFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: BokehFrag
                });
                this.isTiltShift = false;
                this.strength = 1;
                this.blurX = 1;
                this.blurY = 1;
                this.radius = 0.5;
                this.amount = 1;
                this.contrast = 0.2;
              },
              onPreRender: function(controller, shader, width, height) {
                controller = this.getController(controller);
                this.set1f("radius", controller.radius, shader);
                this.set1f("amount", controller.amount, shader);
                this.set1f("contrast", controller.contrast, shader);
                this.set1f("strength", controller.strength, shader);
                this.set2f("blur", controller.blurX, controller.blurY, shader);
                this.setBoolean("isTiltShift", controller.isTiltShift, shader);
                if (width && height) {
                  this.set2f("resolution", width, height, shader);
                }
              },
              onDraw: function(target) {
                this.set2f("resolution", target.width, target.height);
                this.bindAndDraw(target);
              }
            });
            module2.exports = BokehFXPipeline;
          },
          4323: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CircleFrag = __webpack_require__2(33754);
            var PostFXPipeline = __webpack_require__2(80486);
            var CircleFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function CircleFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: CircleFrag
                });
                this.scale = 1;
                this.feather = 5e-3;
                this.thickness = 8;
                this.glcolor = [1, 0.2, 0.7];
                this.glcolor2 = [1, 0, 0, 0.4];
              },
              onPreRender: function(controller, shader, width, height) {
                controller = this.getController(controller);
                this.set1f("scale", controller.scale, shader);
                this.set1f("feather", controller.feather, shader);
                this.set1f("thickness", controller.thickness, shader);
                this.set3fv("color", controller.glcolor, shader);
                this.set4fv("backgroundColor", controller.glcolor2, shader);
                if (width && height) {
                  this.set2f("resolution", width, height, shader);
                }
              },
              onDraw: function(target) {
                this.set2f("resolution", target.width, target.height);
                this.bindAndDraw(target);
              }
            });
            module2.exports = CircleFXPipeline;
          },
          92066: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var PostFXPipeline = __webpack_require__2(80486);
            var ColorMatrixFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function ColorMatrixFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game
                });
              },
              onDraw: function(source) {
                var target = this.fullFrame1;
                if (this.controller) {
                  this.manager.drawFrame(source, target, true, this.controller);
                } else {
                  this.drawFrame(source, target);
                }
                this.copyToGame(target);
              }
            });
            module2.exports = ColorMatrixFXPipeline;
          },
          89581: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var DisplacementFrag = __webpack_require__2(35668);
            var PostFXPipeline = __webpack_require__2(80486);
            var DisplacementFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function DisplacementFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: DisplacementFrag
                });
                this.x = 5e-3;
                this.y = 5e-3;
                this.glTexture;
              },
              onBoot: function() {
                this.setTexture("__WHITE");
              },
              setTexture: function(texture) {
                var phaserTexture = this.game.textures.getFrame(texture);
                if (phaserTexture) {
                  this.glTexture = phaserTexture.glTexture;
                }
              },
              onDraw: function(source) {
                var controller = this.getController();
                var target = this.fullFrame1;
                this.bind();
                this.set1i("uMainSampler", 0);
                this.set1i("uDisplacementSampler", 1);
                this.set2f("amount", controller.x, controller.y);
                this.bindTexture(controller.glTexture, 1);
                this.copySprite(source, target);
                this.copyToGame(target);
              }
            });
            module2.exports = DisplacementFXPipeline;
          },
          55084: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var GlowFrag = __webpack_require__2(69675);
            var PostFXPipeline = __webpack_require__2(80486);
            var Utils = __webpack_require__2(75512);
            var GlowFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function GlowFXPipeline2(game, config2) {
                var quality = GetFastValue(config2, "quality", 0.1);
                var distance = GetFastValue(config2, "distance", 10);
                PostFXPipeline.call(this, {
                  game,
                  fragShader: Utils.setGlowQuality(GlowFrag, game, quality, distance)
                });
                this.outerStrength = 4;
                this.innerStrength = 0;
                this.knockout = false;
                this.glcolor = [1, 1, 1, 1];
              },
              onPreRender: function(controller, shader, width, height) {
                controller = this.getController(controller);
                this.set1f("outerStrength", controller.outerStrength, shader);
                this.set1f("innerStrength", controller.innerStrength, shader);
                this.set4fv("glowColor", controller.glcolor, shader);
                this.setBoolean("knockout", controller.knockout, shader);
                if (width && height) {
                  this.set2f("resolution", width, height, shader);
                }
              },
              onDraw: function(target) {
                this.set2f("resolution", target.width, target.height);
                this.bindAndDraw(target);
              }
            });
            module2.exports = GlowFXPipeline;
          },
          41653: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GradientFrag = __webpack_require__2(90993);
            var PostFXPipeline = __webpack_require__2(80486);
            var GradientFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function GradientFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: GradientFrag
                });
                this.alpha = 0.2;
                this.size = 0;
                this.fromX = 0;
                this.fromY = 0;
                this.toX = 0;
                this.toY = 1;
                this.glcolor1 = [255, 0, 0];
                this.glcolor2 = [0, 255, 0];
              },
              onPreRender: function(controller, shader) {
                controller = this.getController(controller);
                this.set1f("alpha", controller.alpha, shader);
                this.set1i("size", controller.size, shader);
                this.set3fv("color1", controller.glcolor1, shader);
                this.set3fv("color2", controller.glcolor2, shader);
                this.set2f("positionFrom", controller.fromX, controller.fromY, shader);
                this.set2f("positionTo", controller.toX, controller.toY, shader);
              }
            });
            module2.exports = GradientFXPipeline;
          },
          73416: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var PixelateFrag = __webpack_require__2(37945);
            var PostFXPipeline = __webpack_require__2(80486);
            var PixelateFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function PixelateFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: PixelateFrag
                });
                this.amount = 1;
              },
              onPreRender: function(controller, shader, width, height) {
                controller = this.getController(controller);
                this.set1f("amount", controller.amount, shader);
                if (width && height) {
                  this.set2f("resolution", width, height, shader);
                }
              },
              onDraw: function(target) {
                this.set2f("resolution", target.width, target.height);
                this.bindAndDraw(target);
              }
            });
            module2.exports = PixelateFXPipeline;
          },
          58049: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ShadowFrag = __webpack_require__2(85718);
            var PostFXPipeline = __webpack_require__2(80486);
            var ShadowFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function ShadowFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: ShadowFrag
                });
                this.x = 0;
                this.y = 0;
                this.decay = 0.1;
                this.power = 1;
                this.glcolor = [0, 0, 0, 1];
                this.samples = 6;
                this.intensity = 1;
              },
              onPreRender: function(controller, shader) {
                controller = this.getController(controller);
                var samples = controller.samples;
                this.set1i("samples", samples, shader);
                this.set1f("intensity", controller.intensity, shader);
                this.set1f("decay", controller.decay, shader);
                this.set1f("power", controller.power / samples, shader);
                this.set2f("lightPosition", controller.x, controller.y, shader);
                this.set4fv("color", controller.glcolor, shader);
              }
            });
            module2.exports = ShadowFXPipeline;
          },
          18026: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ShineFrag = __webpack_require__2(13740);
            var PostFXPipeline = __webpack_require__2(80486);
            var ShineFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function ShineFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: ShineFrag
                });
                this.speed = 0.5;
                this.lineWidth = 0.5;
                this.gradient = 3;
                this.reveal = false;
              },
              onPreRender: function(controller, shader, width, height) {
                controller = this.getController(controller);
                this.setTime("time", shader);
                this.set1f("speed", controller.speed, shader);
                this.set1f("lineWidth", controller.lineWidth, shader);
                this.set1f("gradient", controller.gradient, shader);
                this.setBoolean("reveal", controller.reveal, shader);
                if (width && height) {
                  this.set2f("resolution", width, height, shader);
                }
              },
              onDraw: function(target) {
                this.set2f("resolution", target.width, target.height);
                this.bindAndDraw(target);
              }
            });
            module2.exports = ShineFXPipeline;
          },
          72381: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var VignetteFrag = __webpack_require__2(80617);
            var PostFXPipeline = __webpack_require__2(80486);
            var VignetteFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function VignetteFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: VignetteFrag
                });
                this.x = 0.5;
                this.y = 0.5;
                this.radius = 0.5;
                this.strength = 0.5;
              },
              onPreRender: function(controller, shader) {
                controller = this.getController(controller);
                this.set1f("radius", controller.radius, shader);
                this.set1f("strength", controller.strength, shader);
                this.set2f("position", controller.x, controller.y, shader);
              }
            });
            module2.exports = VignetteFXPipeline;
          },
          80542: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var WipeFrag = __webpack_require__2(62879);
            var PostFXPipeline = __webpack_require__2(80486);
            var WipeFXPipeline = new Class({
              Extends: PostFXPipeline,
              initialize: function WipeFXPipeline2(game) {
                PostFXPipeline.call(this, {
                  game,
                  fragShader: WipeFrag
                });
                this.progress = 0;
                this.wipeWidth = 0.1;
                this.direction = 0;
                this.axis = 0;
                this.reveal = false;
              },
              onPreRender: function(controller, shader) {
                controller = this.getController(controller);
                var progress = controller.progress;
                var wipeWidth = controller.wipeWidth;
                var direction = controller.direction;
                var axis = controller.axis;
                this.set4f("config", progress, wipeWidth, direction, axis, shader);
                this.setBoolean("reveal", controller.reveal, shader);
              }
            });
            module2.exports = WipeFXPipeline;
          },
          58136: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FX = {
              Barrel: __webpack_require__2(32469),
              Bloom: __webpack_require__2(2134),
              Blur: __webpack_require__2(63377),
              Bokeh: __webpack_require__2(49745),
              Circle: __webpack_require__2(4323),
              ColorMatrix: __webpack_require__2(92066),
              Displacement: __webpack_require__2(89581),
              Glow: __webpack_require__2(55084),
              Gradient: __webpack_require__2(41653),
              Pixelate: __webpack_require__2(73416),
              Shadow: __webpack_require__2(58049),
              Shine: __webpack_require__2(18026),
              Vignette: __webpack_require__2(72381),
              Wipe: __webpack_require__2(80542)
            };
            module2.exports = FX;
          },
          62253: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(65641);
            var Extend = __webpack_require__2(98611);
            var Pipelines = {
              FX: __webpack_require__2(58136),
              BitmapMaskPipeline: __webpack_require__2(5583),
              Events: __webpack_require__2(18970),
              FXPipeline: __webpack_require__2(81828),
              LightPipeline: __webpack_require__2(66901),
              MobilePipeline: __webpack_require__2(71264),
              MultiPipeline: __webpack_require__2(77310),
              PointLightPipeline: __webpack_require__2(10919),
              PostFXPipeline: __webpack_require__2(80486),
              PreFXPipeline: __webpack_require__2(87228),
              RopePipeline: __webpack_require__2(21213),
              SinglePipeline: __webpack_require__2(51212),
              UtilityPipeline: __webpack_require__2(60848)
            };
            Pipelines = Extend(false, Pipelines, CONST);
            module2.exports = Pipelines;
          },
          2529: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_ADD_BLEND_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler1;",
              "uniform sampler2D uMainSampler2;",
              "uniform float uStrength;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
              "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
              "    gl_FragColor = frame1 + frame2 * uStrength;",
              "}"
            ].join("\n");
          },
          91679: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_BITMAP_MASK_FS",
              "precision mediump float;",
              "uniform vec2 uResolution;",
              "uniform sampler2D uMainSampler;",
              "uniform sampler2D uMaskSampler;",
              "uniform bool uInvertMaskAlpha;",
              "void main ()",
              "{",
              "    vec2 uv = gl_FragCoord.xy / uResolution;",
              "    vec4 mainColor = texture2D(uMainSampler, uv);",
              "    vec4 maskColor = texture2D(uMaskSampler, uv);",
              "    if (!uInvertMaskAlpha)",
              "    {",
              "        mainColor *= maskColor.a;",
              "    }",
              "    else",
              "    {",
              "        mainColor *= (1.0 - maskColor.a);",
              "    }",
              "    gl_FragColor = mainColor;",
              "}"
            ].join("\n");
          },
          89053: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_BITMAP_MASK_VS",
              "precision mediump float;",
              "attribute vec2 inPosition;",
              "void main ()",
              "{",
              "    gl_Position = vec4(inPosition, 0.0, 1.0);",
              "}"
            ].join("\n");
          },
          37486: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_COLORMATRIX_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform float uColorMatrix[20];",
              "uniform float uAlpha;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec4 c = texture2D(uMainSampler, outTexCoord);",
              "    if (uAlpha == 0.0)",
              "    {",
              "        gl_FragColor = c;",
              "        return;",
              "    }",
              "    if (c.a > 0.0)",
              "    {",
              "        c.rgb /= c.a;",
              "    }",
              "    vec4 result;",
              "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];",
              "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];",
              "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];",
              "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];",
              "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);",
              "    rgb *= result.a;",
              "    gl_FragColor = vec4(rgb, result.a);",
              "}"
            ].join("\n");
          },
          79060: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_COPY_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform float uBrightness;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;",
              "}"
            ].join("\n");
          },
          87751: (module2) => {
            module2.exports = [
              "#define SHADER_NAME BARREL_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform float amount;",
              "varying vec2 outTexCoord;",
              "vec2 Distort(vec2 p)",
              "{",
              "    float theta  = atan(p.y, p.x);",
              "    float radius = length(p);",
              "    radius = pow(radius, amount);",
              "    p.x = radius * cos(theta);",
              "    p.y = radius * sin(theta);",
              "    return 0.5 * (p + 1.0);",
              "}",
              "void main()",
              "{",
              "    vec2 xy = 2.0 * outTexCoord - 1.0;",
              "    vec2 texCoord = outTexCoord;",
              "    if (length(xy) < 1.0)",
              "    {",
              "        texCoord = Distort(xy);",
              "    }",
              "    gl_FragColor = texture2D(uMainSampler, texCoord);",
              "}"
            ].join("\n");
          },
          88222: (module2) => {
            module2.exports = [
              "#define SHADER_NAME BLOOM_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 offset;",
              "uniform float strength;",
              "uniform vec3 color;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec4 sum = texture2D(uMainSampler, outTexCoord) * 0.204164 * strength;",
              "    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 1.407333) * 0.304005;",
              "    sum = sum + texture2D(uMainSampler, outTexCoord - offset * 1.407333) * 0.304005;",
              "    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 3.294215) * 0.093913;",
              "    gl_FragColor = (sum + texture2D(uMainSampler, outTexCoord - offset * 3.294215) * 0.093913) * vec4(color, 1);",
              "}"
            ].join("\n");
          },
          44481: (module2) => {
            module2.exports = [
              "#define SHADER_NAME BLUR_HIGH_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 resolution;",
              "uniform vec2 offset;",
              "uniform float strength;",
              "uniform vec3 color;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec2 uv = outTexCoord;",
              "    vec4 col = vec4(0.0);",
              "    vec2 off1 = vec2(1.411764705882353) * offset * strength;",
              "    vec2 off2 = vec2(3.2941176470588234) * offset * strength;",
              "    vec2 off3 = vec2(5.176470588235294) * offset * strength;",
              "    col += texture2D(uMainSampler, uv) * 0.1964825501511404;",
              "    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.2969069646728344;",
              "    col += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.2969069646728344;",
              "    col += texture2D(uMainSampler, uv + (off2 / resolution)) * 0.09447039785044732;",
              "    col += texture2D(uMainSampler, uv - (off2 / resolution)) * 0.09447039785044732;",
              "    col += texture2D(uMainSampler, uv + (off3 / resolution)) * 0.010381362401148057;",
              "    col += texture2D(uMainSampler, uv - (off3 / resolution)) * 0.010381362401148057;",
              "    gl_FragColor = col * vec4(color, 1.0);",
              "}"
            ].join("\n");
          },
          35491: (module2) => {
            module2.exports = [
              "#define SHADER_NAME BLUR_LOW_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 resolution;",
              "uniform vec2 offset;",
              "uniform float strength;",
              "uniform vec3 color;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec2 uv = outTexCoord;",
              "    vec4 col = vec4(0.0);",
              "    vec2 offset = vec2(1.333) * offset * strength;",
              "    col += texture2D(uMainSampler, uv) * 0.29411764705882354;",
              "    col += texture2D(uMainSampler, uv + (offset / resolution)) * 0.35294117647058826;",
              "    col += texture2D(uMainSampler, uv - (offset / resolution)) * 0.35294117647058826;",
              "    gl_FragColor = col * vec4(color, 1.0);",
              "}"
            ].join("\n");
          },
          75568: (module2) => {
            module2.exports = [
              "#define SHADER_NAME BLUR_MED_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 resolution;",
              "uniform vec2 offset;",
              "uniform float strength;",
              "uniform vec3 color;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec2 uv = outTexCoord;",
              "    vec4 col = vec4(0.0);",
              "    vec2 off1 = vec2(1.3846153846) * offset * strength;",
              "    vec2 off2 = vec2(3.2307692308) * offset * strength;",
              "    col += texture2D(uMainSampler, uv) * 0.2270270270;",
              "    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.3162162162;",
              "    col += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.3162162162;",
              "    col += texture2D(uMainSampler, uv + (off2 / resolution)) * 0.0702702703;",
              "    col += texture2D(uMainSampler, uv - (off2 / resolution)) * 0.0702702703;",
              "    gl_FragColor = col * vec4(color, 1.0);",
              "}"
            ].join("\n");
          },
          69960: (module2) => {
            module2.exports = [
              "#define SHADER_NAME BOKEH_FS",
              "precision mediump float;",
              "#define ITERATIONS 100.0",
              "#define ONEOVER_ITR 1.0 / ITERATIONS",
              "#define PI 3.141596",
              "#define GOLDEN_ANGLE 2.39996323",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 resolution;",
              "uniform float radius;",
              "uniform float amount;",
              "uniform float contrast;",
              "uniform bool isTiltShift;",
              "uniform float strength;",
              "uniform vec2 blur;",
              "varying vec2 outTexCoord;",
              "vec2 Sample (in float theta, inout float r)",
              "{",
              "    r += 1.0 / r;",
              "    return (r - 1.0) * vec2(cos(theta), sin(theta)) * 0.06;",
              "}",
              "vec3 Bokeh (sampler2D tex, vec2 uv, float radius)",
              "{",
              "    vec3 acc = vec3(0.0);",
              "    vec3 div = vec3(0.0);",
              "    vec2 pixel = vec2(resolution.y / resolution.x, 1.0) * radius * .025;",
              "    float r = 1.0;",
              "    for (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE)",
              "    {",
              "        vec3 col = texture2D(tex, uv + pixel * Sample(j, r)).xyz;",
              "        col = contrast > 0.0 ? col * col * (1.0 + contrast) : col;",
              "        vec3 bokeh = vec3(0.5) + pow(col, vec3(10.0)) * amount;",
              "        acc += col * bokeh;",
              "        div += bokeh;",
              "    }",
              "    return acc / div;",
              "}",
              "void main ()",
              "{",
              "    float shift = 1.0;",
              "    if (isTiltShift)",
              "    {",
              "        vec2 uv = vec2(gl_FragCoord.xy / resolution + vec2(-0.5, -0.5)) * 2.0;",
              "        float centerStrength = 1.0;",
              "        shift = length(uv * blur * strength) * centerStrength;",
              "    }",
              "    gl_FragColor = vec4(Bokeh(uMainSampler, outTexCoord * vec2(1.0, 1.0), radius * shift), 0.0);",
              "}"
            ].join("\n");
          },
          33754: (module2) => {
            module2.exports = [
              "#define SHADER_NAME CIRCLE_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 resolution;",
              "uniform vec3 color;",
              "uniform vec4 backgroundColor;",
              "uniform float thickness;",
              "uniform float scale;",
              "uniform float feather;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
              "    vec2 position = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;",
              "    float aspectRatio = resolution.x / resolution.y;",
              "    position.x *= aspectRatio;",
              "    float grad = length(position);",
              "    float outer = aspectRatio;",
              "    float inner = outer - (thickness * 2.0 / resolution.y);",
              "    if (aspectRatio >= 1.0)",
              "    {",
              "        float f = 2.0 + (resolution.y / resolution.x);",
              "        outer = 1.0;",
              "        inner = 1.0 - (thickness * f / resolution.x);",
              "    }",
              "    outer *= scale;",
              "    inner *= scale;",
              "    float circle = smoothstep(outer, outer - 0.01, grad);",
              "    float ring = circle - smoothstep(inner, inner - feather, grad);",
              "    texture = mix(backgroundColor * backgroundColor.a, texture, texture.a);",
              "    texture = (texture * (circle - ring));",
              "    gl_FragColor = vec4(texture.rgb + (ring * color), texture.a);",
              "}"
            ].join("\n");
          },
          35668: (module2) => {
            module2.exports = [
              "#define SHADER_NAME DISPLACEMENT_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform sampler2D uDisplacementSampler;",
              "uniform vec2 amount;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec2 disp = (-vec2(0.5, 0.5) + texture2D(uDisplacementSampler, outTexCoord).rr) * amount;",
              "    gl_FragColor = texture2D(uMainSampler, outTexCoord + disp).rgba;",
              "}"
            ].join("\n");
          },
          69675: (module2) => {
            module2.exports = [
              "#define SHADER_NAME GLOW_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "varying vec2 outTexCoord;",
              "uniform float outerStrength;",
              "uniform float innerStrength;",
              "uniform vec2 resolution;",
              "uniform vec4 glowColor;",
              "uniform bool knockout;",
              "const float PI = 3.14159265358979323846264;",
              "const float DIST = __DIST__;",
              "const float SIZE = min(__SIZE__, PI * 2.0);",
              "const float STEP = ceil(PI * 2.0 / SIZE);",
              "const float MAX_ALPHA = STEP * DIST * (DIST + 1.0) / 2.0;",
              "void main ()",
              "{",
              "    vec2 px = vec2(1.0 / resolution.x, 1.0 / resolution.y);",
              "    float totalAlpha = 0.0;",
              "    vec2 direction;",
              "    vec2 displaced;",
              "    vec4 color;",
              "    for (float angle = 0.0; angle < PI * 2.0; angle += SIZE)",
              "    {",
              "        direction = vec2(cos(angle), sin(angle)) * px;",
              "        for (float curDistance = 0.0; curDistance < DIST; curDistance++)",
              "        {",
              "            displaced = outTexCoord + direction * (curDistance + 1.0);",
              "            color = texture2D(uMainSampler, displaced);",
              "            totalAlpha += (DIST - curDistance) * color.a;",
              "        }",
              "    }",
              "    color = texture2D(uMainSampler, outTexCoord);",
              "    float alphaRatio = (totalAlpha / MAX_ALPHA);",
              "    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * color.a;",
              "    float innerGlowStrength = min(1.0, innerGlowAlpha);",
              "    vec4 innerColor = mix(color, glowColor, innerGlowStrength);",
              "    float outerGlowAlpha = alphaRatio * outerStrength * (1.0 - color.a);",
              "    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);",
              "    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;",
              "    if (knockout)",
              "    {",
              "        float resultAlpha = outerGlowAlpha + innerGlowAlpha;",
              "        gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);",
              "    }",
              "    else",
              "    {",
              "        gl_FragColor = innerColor + outerGlowColor;",
              "    }",
              "}"
            ].join("\n");
          },
          90993: (module2) => {
            module2.exports = [
              "#define SHADER_NAME GRADIENT_FS",
              "#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))",
              "#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))",
              "#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 positionFrom;",
              "uniform vec2 positionTo;",
              "uniform vec3 color1;",
              "uniform vec3 color2;",
              "uniform float alpha;",
              "uniform int size;",
              "varying vec2 outTexCoord;",
              "float gradientNoise(in vec2 uv)",
              "{",
              "    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);",
              "    return fract(magic.z * fract(dot(uv, magic.xy)));",
              "}",
              "float stepped (in float s, in float scale, in int steps)",
              "{",
              "    return steps > 0 ? floor( s / ((1.0 * scale) / float(steps))) * 1.0 / float(steps - 1) : s;",
              "}",
              "void main ()",
              "{",
              "    vec2 a = positionFrom;",
              "    vec2 b = positionTo;",
              "    vec2 ba = b - a;",
              "    float d = dot(outTexCoord - a, ba) / dot(ba, ba);",
              "    float t = size > 0 ? stepped(d, 1.0, size) : d;",
              "    t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));",
              "    vec3 color = mix(SRGB(color1.r, color1.g, color1.b), SRGB(color2.r, color2.g, color2.b), t);",
              "    color = LINEAR_TO_SRGB(color);",
              "    color += (1.0 / 255.0) * gradientNoise(outTexCoord) - (0.5 / 255.0);",
              "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
              "    gl_FragColor = vec4(mix(color.rgb, texture.rgb, alpha), 1.0) * texture.a;",
              "}"
            ].join("\n");
          },
          37945: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PIXELATE_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 resolution;",
              "uniform float amount;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    float pixelSize = floor(2.0 + amount);",
              "    vec2 center = pixelSize * floor(outTexCoord * resolution / pixelSize) + pixelSize * vec2(0.5, 0.5);",
              "    vec2 corner1 = center + pixelSize * vec2(-0.5, -0.5);",
              "    vec2 corner2 = center + pixelSize * vec2(+0.5, -0.5);",
              "    vec2 corner3 = center + pixelSize * vec2(+0.5, +0.5);",
              "    vec2 corner4 = center + pixelSize * vec2(-0.5, +0.5);",
              "    vec4 pixel = 0.4 * texture2D(uMainSampler, center / resolution);",
              "    pixel += 0.15 * texture2D(uMainSampler, corner1 / resolution);",
              "    pixel += 0.15 * texture2D(uMainSampler, corner2 / resolution);",
              "    pixel += 0.15 * texture2D(uMainSampler, corner3 / resolution);",
              "    pixel += 0.15 * texture2D(uMainSampler, corner4 / resolution);",
              "    gl_FragColor = pixel;",
              "}"
            ].join("\n");
          },
          85718: (module2) => {
            module2.exports = [
              "#define SHADER_NAME SHADOW_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "varying vec2 outTexCoord;",
              "uniform vec2 lightPosition;",
              "uniform vec4 color;",
              "uniform float decay;",
              "uniform float power;",
              "uniform float intensity;",
              "uniform int samples;",
              "const int MAX = 12;",
              "void main ()",
              "{",
              "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
              "    vec2 pc = (lightPosition - outTexCoord) * intensity;",
              "    float shadow = 0.0;",
              "    float limit = max(float(MAX), float(samples));",
              "    for (int i = 0; i < MAX; ++i)",
              "    {",
              "        if (i >= samples)",
              "        {",
              "            break;",
              "        }",
              "        shadow += texture2D(uMainSampler, outTexCoord + float(i) * decay / limit * pc).a * power;",
              "    }",
              "    float mask = 1.0 - texture.a;",
              "    gl_FragColor = mix(texture, color, shadow * mask);",
              "}"
            ].join("\n");
          },
          13740: (module2) => {
            module2.exports = [
              "#define SHADER_NAME SHINE_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec2 resolution;",
              "uniform bool reveal;",
              "uniform float speed;",
              "uniform float time;",
              "uniform float lineWidth;",
              "uniform float gradient;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "	vec2 uv = gl_FragCoord.xy / resolution.xy;",
              "    vec4 tex = texture2D(uMainSampler, outTexCoord);",
              "    vec4 col1 = vec4(0.3, 0.0, 0.0, 1.0);",
              "    vec4 col2 = vec4(0.85, 0.85, 0.85, 1.0);",
              "    uv.x = uv.x - mod(time * speed, 2.0) + 0.5;",
              "    float y = uv.x * gradient;",
              "    float s = smoothstep(y - lineWidth, y, uv.y) - smoothstep(y, y + lineWidth, uv.y);",
              "    gl_FragColor = (((s * col1) + (s * col2)) * tex);",
              "    if (!reveal)",
              "    {",
              "        gl_FragColor += tex;",
              "    }",
              "}"
            ].join("\n");
          },
          80617: (module2) => {
            module2.exports = [
              "#define SHADER_NAME VIGNETTE_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform float radius;",
              "uniform float strength;",
              "uniform vec2 position;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec4 col = vec4(1.0);",
              "    float d = length(outTexCoord - position);",
              "    if (d <= radius)",
              "    {",
              "        float g = d / radius;",
              "        g = sin(g * 3.14 * strength);",
              "    	col = vec4(g * g * g);",
              "    }",
              "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
              "    gl_FragColor = texture * (1.0 - col);",
              "}"
            ].join("\n");
          },
          62879: (module2) => {
            module2.exports = [
              "#define SHADER_NAME WIPE_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "uniform vec4 config;",
              "uniform bool reveal;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec2 uv = outTexCoord;",
              "    vec4 color0;",
              "    vec4 color1;",
              "    if (reveal)",
              "    {",
              "        color0 = vec4(0);",
              "        color1 = texture2D(uMainSampler, uv);",
              "    }",
              "    else",
              "    {",
              "        color0 = texture2D(uMainSampler, uv);",
              "        color1 = vec4(0);",
              "    }",
              "    float distance = config.x;",
              "    float width = config.y;",
              "    float direction = config.z;",
              "    float axis = uv.x;",
              "    if (config.w == 1.0)",
              "    {",
              "        axis = uv.y;",
              "    }",
              "    float adjust = mix(width, -width, distance);",
              "    float value = smoothstep(distance - width, distance + width, abs(direction - axis) + adjust);",
              "    gl_FragColor = mix(color1, color0, value);",
              "}"
            ].join("\n");
          },
          65045: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_LIGHT_FS",
              "precision mediump float;",
              "struct Light",
              "{",
              "    vec2 position;",
              "    vec3 color;",
              "    float intensity;",
              "    float radius;",
              "};",
              "const int kMaxLights = %LIGHT_COUNT%;",
              "uniform vec4 uCamera; /* x, y, rotation, zoom */",
              "uniform vec2 uResolution;",
              "uniform sampler2D uMainSampler;",
              "uniform sampler2D uNormSampler;",
              "uniform vec3 uAmbientLightColor;",
              "uniform Light uLights[kMaxLights];",
              "uniform mat3 uInverseRotationMatrix;",
              "uniform int uLightCount;",
              "varying vec2 outTexCoord;",
              "varying float outTexId;",
              "varying float outTintEffect;",
              "varying vec4 outTint;",
              "void main ()",
              "{",
              "    vec3 finalColor = vec3(0.0, 0.0, 0.0);",
              "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
              "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
              "    vec4 color = texture * texel;",
              "    if (outTintEffect == 1.0)",
              "    {",
              "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
              "    }",
              "    else if (outTintEffect == 2.0)",
              "    {",
              "        color = texel;",
              "    }",
              "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;",
              "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));",
              "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;",
              "    for (int index = 0; index < kMaxLights; ++index)",
              "    {",
              "        if (index < uLightCount)",
              "        {",
              "            Light light = uLights[index];",
              "            vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);",
              "            vec3 lightNormal = normalize(lightDir);",
              "            float distToSurf = length(lightDir) * uCamera.w;",
              "            float diffuseFactor = max(dot(normal, lightNormal), 0.0);",
              "            float radius = (light.radius / res.x * uCamera.w) * uCamera.w;",
              "            float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);",
              "            vec3 diffuse = light.color * diffuseFactor;",
              "            finalColor += (attenuation * diffuse) * light.intensity;",
              "        }",
              "    }",
              "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);",
              "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);",
              "}"
            ].join("\n");
          },
          98921: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_LINEAR_BLEND_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler1;",
              "uniform sampler2D uMainSampler2;",
              "uniform float uStrength;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
              "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
              "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);",
              "}"
            ].join("\n");
          },
          25005: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_MESH_FS",
              "precision mediump float;",
              "uniform vec3 uLightPosition;",
              "uniform vec3 uLightAmbient;",
              "uniform vec3 uLightDiffuse;",
              "uniform vec3 uLightSpecular;",
              "uniform vec3 uFogColor;",
              "uniform float uFogNear;",
              "uniform float uFogFar;",
              "uniform vec3 uMaterialAmbient;",
              "uniform vec3 uMaterialDiffuse;",
              "uniform vec3 uMaterialSpecular;",
              "uniform float uMaterialShine;",
              "uniform vec3 uCameraPosition;",
              "uniform sampler2D uTexture;",
              "varying vec2 vTextureCoord;",
              "varying vec3 vNormal;",
              "varying vec3 vPosition;",
              "void main (void)",
              "{",
              "    vec4 color = texture2D(uTexture, vTextureCoord);",
              "    vec3 ambient = uLightAmbient * uMaterialAmbient;",
              "    vec3 norm = normalize(vNormal);",
              "    vec3 lightDir = normalize(uLightPosition - vPosition);",
              "    float diff = max(dot(norm, lightDir), 0.0);",
              "    vec3 diffuse = uLightDiffuse * (diff * uMaterialDiffuse);",
              "    vec3 viewDir = normalize(uCameraPosition - vPosition);",
              "    vec3 reflectDir = reflect(-lightDir, norm);",
              "    float spec = pow(max(dot(viewDir, reflectDir), 0.0), uMaterialShine);",
              "    vec3 specular = uLightSpecular * (spec * uMaterialSpecular);",
              "    vec3 result = (ambient + diffuse + specular) * color.rgb;",
              "    float depth = gl_FragCoord.z / gl_FragCoord.w;",
              "    float fogFactor = smoothstep(uFogNear, uFogFar, depth);",
              "    gl_FragColor.rgb = mix(result.rgb, uFogColor, fogFactor);",
              "    gl_FragColor.a = color.a;",
              "}"
            ].join("\n");
          },
          94914: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_MESH_VS",
              "precision mediump float;",
              "attribute vec3 aVertexPosition;",
              "attribute vec3 aVertexNormal;",
              "attribute vec2 aTextureCoord;",
              "uniform mat4 uViewProjectionMatrix;",
              "uniform mat4 uModelMatrix;",
              "uniform mat4 uNormalMatrix;",
              "varying vec2 vTextureCoord;",
              "varying vec3 vNormal;",
              "varying vec3 vPosition;",
              "void main ()",
              "{",
              "    vTextureCoord = aTextureCoord;",
              "    vPosition = vec3(uModelMatrix * vec4(aVertexPosition, 1.0));",
              "    vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));",
              "    gl_Position = uViewProjectionMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);",
              "}"
            ].join("\n");
          },
          11263: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_MOBILE_FS",
              "#ifdef GL_FRAGMENT_PRECISION_HIGH",
              "precision highp float;",
              "#else",
              "precision mediump float;",
              "#endif",
              "uniform sampler2D uMainSampler;",
              "varying vec2 outTexCoord;",
              "varying float outTintEffect;",
              "varying vec4 outTint;",
              "void main ()",
              "{",
              "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
              "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
              "    vec4 color = texture * texel;",
              "    if (outTintEffect == 1.0)",
              "    {",
              "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
              "    }",
              "    else if (outTintEffect == 2.0)",
              "    {",
              "        color = texel;",
              "    }",
              "    gl_FragColor = color;",
              "}"
            ].join("\n");
          },
          51852: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_MOBILE_VS",
              "precision mediump float;",
              "uniform mat4 uProjectionMatrix;",
              "uniform int uRoundPixels;",
              "uniform vec2 uResolution;",
              "attribute vec2 inPosition;",
              "attribute vec2 inTexCoord;",
              "attribute float inTexId;",
              "attribute float inTintEffect;",
              "attribute vec4 inTint;",
              "varying vec2 outTexCoord;",
              "varying float outTintEffect;",
              "varying vec4 outTint;",
              "void main ()",
              "{",
              "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
              "    if (uRoundPixels == 1)",
              "    {",
              "        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;",
              "    }",
              "    outTexCoord = inTexCoord;",
              "    outTint = inTint;",
              "    outTintEffect = inTintEffect;",
              "}"
            ].join("\n");
          },
          53787: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_MULTI_FS",
              "#ifdef GL_FRAGMENT_PRECISION_HIGH",
              "precision highp float;",
              "#else",
              "precision mediump float;",
              "#endif",
              "uniform sampler2D uMainSampler[%count%];",
              "varying vec2 outTexCoord;",
              "varying float outTexId;",
              "varying float outTintEffect;",
              "varying vec4 outTint;",
              "void main ()",
              "{",
              "    vec4 texture;",
              "    %forloop%",
              "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
              "    vec4 color = texture * texel;",
              "    if (outTintEffect == 1.0)",
              "    {",
              "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
              "    }",
              "    else if (outTintEffect == 2.0)",
              "    {",
              "        color = texel;",
              "    }",
              "    gl_FragColor = color;",
              "}"
            ].join("\n");
          },
          15968: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_MULTI_VS",
              "precision mediump float;",
              "uniform mat4 uProjectionMatrix;",
              "uniform int uRoundPixels;",
              "uniform vec2 uResolution;",
              "attribute vec2 inPosition;",
              "attribute vec2 inTexCoord;",
              "attribute float inTexId;",
              "attribute float inTintEffect;",
              "attribute vec4 inTint;",
              "varying vec2 outTexCoord;",
              "varying float outTexId;",
              "varying float outTintEffect;",
              "varying vec4 outTint;",
              "void main ()",
              "{",
              "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
              "    if (uRoundPixels == 1)",
              "    {",
              "        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;",
              "    }",
              "    outTexCoord = inTexCoord;",
              "    outTexId = inTexId;",
              "    outTint = inTint;",
              "    outTintEffect = inTintEffect;",
              "}"
            ].join("\n");
          },
          83327: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_POINTLIGHT_FS",
              "precision mediump float;",
              "uniform vec2 uResolution;",
              "uniform float uCameraZoom;",
              "varying vec4 lightPosition;",
              "varying vec4 lightColor;",
              "varying float lightRadius;",
              "varying float lightAttenuation;",
              "void main ()",
              "{",
              "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);",
              "    float distToSurf = length(center - gl_FragCoord.xy);",
              "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);",
              "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);",
              "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;",
              "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);",
              "}"
            ].join("\n");
          },
          54677: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_POINTLIGHT_VS",
              "precision mediump float;",
              "uniform mat4 uProjectionMatrix;",
              "attribute vec2 inPosition;",
              "attribute vec2 inLightPosition;",
              "attribute vec4 inLightColor;",
              "attribute float inLightRadius;",
              "attribute float inLightAttenuation;",
              "varying vec4 lightPosition;",
              "varying vec4 lightColor;",
              "varying float lightRadius;",
              "varying float lightAttenuation;",
              "void main ()",
              "{",
              "    lightColor = inLightColor;",
              "    lightRadius = inLightRadius;",
              "    lightAttenuation = inLightAttenuation;",
              "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);",
              "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
              "}"
            ].join("\n");
          },
          12569: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_POSTFX_FS",
              "precision mediump float;",
              "uniform sampler2D uMainSampler;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    gl_FragColor = texture2D(uMainSampler, outTexCoord);",
              "}"
            ].join("\n");
          },
          99365: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_QUAD_VS",
              "precision mediump float;",
              "attribute vec2 inPosition;",
              "attribute vec2 inTexCoord;",
              "varying vec2 outFragCoord;",
              "varying vec2 outTexCoord;",
              "void main ()",
              "{",
              "    outFragCoord = inPosition.xy * 0.5 + 0.5;",
              "    outTexCoord = inTexCoord;",
              "    gl_Position = vec4(inPosition, 0, 1);",
              "}"
            ].join("\n");
          },
          85060: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_SINGLE_FS",
              "#ifdef GL_FRAGMENT_PRECISION_HIGH",
              "precision highp float;",
              "#else",
              "precision mediump float;",
              "#endif",
              "uniform sampler2D uMainSampler;",
              "varying vec2 outTexCoord;",
              "varying float outTintEffect;",
              "varying vec4 outTint;",
              "void main ()",
              "{",
              "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
              "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
              "    vec4 color = texture * texel;",
              "    if (outTintEffect == 1.0)",
              "    {",
              "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
              "    }",
              "    else if (outTintEffect == 2.0)",
              "    {",
              "        color = texel;",
              "    }",
              "    gl_FragColor = color;",
              "}"
            ].join("\n");
          },
          18166: (module2) => {
            module2.exports = [
              "#define SHADER_NAME PHASER_SINGLE_VS",
              "precision mediump float;",
              "uniform mat4 uProjectionMatrix;",
              "uniform int uRoundPixels;",
              "uniform vec2 uResolution;",
              "attribute vec2 inPosition;",
              "attribute vec2 inTexCoord;",
              "attribute float inTexId;",
              "attribute float inTintEffect;",
              "attribute vec4 inTint;",
              "varying vec2 outTexCoord;",
              "varying float outTintEffect;",
              "varying vec4 outTint;",
              "void main ()",
              "{",
              "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
              "    if (uRoundPixels == 1)",
              "    {",
              "        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;",
              "    }",
              "    outTexCoord = inTexCoord;",
              "    outTint = inTint;",
              "    outTintEffect = inTintEffect;",
              "}"
            ].join("\n");
          },
          92462: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              AddBlendFrag: __webpack_require__2(2529),
              BitmapMaskFrag: __webpack_require__2(91679),
              BitmapMaskVert: __webpack_require__2(89053),
              ColorMatrixFrag: __webpack_require__2(37486),
              CopyFrag: __webpack_require__2(79060),
              FXBarrelFrag: __webpack_require__2(87751),
              FXBloomFrag: __webpack_require__2(88222),
              FXBlurHighFrag: __webpack_require__2(44481),
              FXBlurLowFrag: __webpack_require__2(35491),
              FXBlurMedFrag: __webpack_require__2(75568),
              FXBokehFrag: __webpack_require__2(69960),
              FXCircleFrag: __webpack_require__2(33754),
              FXDisplacementFrag: __webpack_require__2(35668),
              FXGlowFrag: __webpack_require__2(69675),
              FXGradientFrag: __webpack_require__2(90993),
              FXPixelateFrag: __webpack_require__2(37945),
              FXShadowFrag: __webpack_require__2(85718),
              FXShineFrag: __webpack_require__2(13740),
              FXVignetteFrag: __webpack_require__2(80617),
              FXWipeFrag: __webpack_require__2(62879),
              LightFrag: __webpack_require__2(65045),
              LinearBlendFrag: __webpack_require__2(98921),
              MeshFrag: __webpack_require__2(25005),
              MeshVert: __webpack_require__2(94914),
              MobileFrag: __webpack_require__2(11263),
              MobileVert: __webpack_require__2(51852),
              MultiFrag: __webpack_require__2(53787),
              MultiVert: __webpack_require__2(15968),
              PointLightFrag: __webpack_require__2(83327),
              PointLightVert: __webpack_require__2(54677),
              PostFXFrag: __webpack_require__2(12569),
              QuadVert: __webpack_require__2(99365),
              SingleFrag: __webpack_require__2(85060),
              SingleVert: __webpack_require__2(18166)
            };
          },
          756: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(55301);
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(40444);
            var GameEvents = __webpack_require__2(97081);
            var GetInnerHeight = __webpack_require__2(74181);
            var GetTarget = __webpack_require__2(2893);
            var GetScreenOrientation = __webpack_require__2(9229);
            var NOOP = __webpack_require__2(72283);
            var Rectangle = __webpack_require__2(74118);
            var Size = __webpack_require__2(90881);
            var SnapFloor = __webpack_require__2(84314);
            var Vector2 = __webpack_require__2(93736);
            var Camera = __webpack_require__2(47751);
            var ScaleManager = new Class({
              Extends: EventEmitter,
              initialize: function ScaleManager2(game) {
                EventEmitter.call(this);
                this.game = game;
                this.canvas;
                this.canvasBounds = new Rectangle();
                this.parent = null;
                this.parentIsWindow = false;
                this.parentSize = new Size();
                this.gameSize = new Size();
                this.baseSize = new Size();
                this.displaySize = new Size();
                this.scaleMode = CONST.SCALE_MODE.NONE;
                this.zoom = 1;
                this._resetZoom = false;
                this.displayScale = new Vector2(1, 1);
                this.autoRound = false;
                this.autoCenter = CONST.CENTER.NO_CENTER;
                this.orientation = CONST.ORIENTATION.LANDSCAPE;
                this.fullscreen;
                this.fullscreenTarget = null;
                this._createdFullscreenTarget = false;
                this.dirty = false;
                this.resizeInterval = 500;
                this._lastCheck = 0;
                this._checkOrientation = false;
                this.domlisteners = {
                  orientationChange: NOOP,
                  windowResize: NOOP,
                  fullScreenChange: NOOP,
                  fullScreenError: NOOP
                };
              },
              preBoot: function() {
                this.parseConfig(this.game.config);
                this.game.events.once(GameEvents.BOOT, this.boot, this);
              },
              boot: function() {
                var game = this.game;
                this.canvas = game.canvas;
                this.fullscreen = game.device.fullscreen;
                if (this.scaleMode !== CONST.SCALE_MODE.RESIZE) {
                  this.displaySize.setAspectMode(this.scaleMode);
                }
                if (this.scaleMode === CONST.SCALE_MODE.NONE) {
                  this.resize(this.width, this.height);
                } else {
                  this.getParentBounds();
                  if (this.parentSize.width > 0 && this.parentSize.height > 0) {
                    this.displaySize.setParent(this.parentSize);
                  }
                  this.refresh();
                }
                game.events.on(GameEvents.PRE_STEP, this.step, this);
                game.events.once(GameEvents.READY, this.refresh, this);
                game.events.once(GameEvents.DESTROY, this.destroy, this);
                this.startListeners();
              },
              parseConfig: function(config2) {
                this.getParent(config2);
                this.getParentBounds();
                var width = config2.width;
                var height = config2.height;
                var scaleMode = config2.scaleMode;
                var zoom = config2.zoom;
                var autoRound = config2.autoRound;
                if (typeof width === "string") {
                  if (width.substr(-1) !== "%") {
                    width = parseInt(width, 10);
                  } else {
                    var parentWidth = this.parentSize.width;
                    if (parentWidth === 0) {
                      parentWidth = window.innerWidth;
                    }
                    var parentScaleX = parseInt(width, 10) / 100;
                    width = Math.floor(parentWidth * parentScaleX);
                  }
                }
                if (typeof height === "string") {
                  if (height.substr(-1) !== "%") {
                    height = parseInt(height, 10);
                  } else {
                    var parentHeight = this.parentSize.height;
                    if (parentHeight === 0) {
                      parentHeight = window.innerHeight;
                    }
                    var parentScaleY = parseInt(height, 10) / 100;
                    height = Math.floor(parentHeight * parentScaleY);
                  }
                }
                this.scaleMode = scaleMode;
                this.autoRound = autoRound;
                this.autoCenter = config2.autoCenter;
                this.resizeInterval = config2.resizeInterval;
                if (autoRound) {
                  width = Math.floor(width);
                  height = Math.floor(height);
                }
                this.gameSize.setSize(width, height);
                if (zoom === CONST.ZOOM.MAX_ZOOM) {
                  zoom = this.getMaxZoom();
                }
                this.zoom = zoom;
                if (zoom !== 1) {
                  this._resetZoom = true;
                }
                this.baseSize.setSize(width, height);
                if (autoRound) {
                  this.baseSize.width = Math.floor(this.baseSize.width);
                  this.baseSize.height = Math.floor(this.baseSize.height);
                }
                if (config2.minWidth > 0) {
                  this.displaySize.setMin(config2.minWidth * zoom, config2.minHeight * zoom);
                }
                if (config2.maxWidth > 0) {
                  this.displaySize.setMax(config2.maxWidth * zoom, config2.maxHeight * zoom);
                }
                this.displaySize.setSize(width, height);
                this.orientation = GetScreenOrientation(width, height);
              },
              getParent: function(config2) {
                var parent = config2.parent;
                if (parent === null) {
                  return;
                }
                this.parent = GetTarget(parent);
                this.parentIsWindow = this.parent === document.body;
                if (config2.expandParent && config2.scaleMode !== CONST.SCALE_MODE.NONE) {
                  var DOMRect = this.parent.getBoundingClientRect();
                  if (this.parentIsWindow || DOMRect.height === 0) {
                    document.documentElement.style.height = "100%";
                    document.body.style.height = "100%";
                    DOMRect = this.parent.getBoundingClientRect();
                    if (!this.parentIsWindow && DOMRect.height === 0) {
                      this.parent.style.overflow = "hidden";
                      this.parent.style.width = "100%";
                      this.parent.style.height = "100%";
                    }
                  }
                }
                if (config2.fullscreenTarget && !this.fullscreenTarget) {
                  this.fullscreenTarget = GetTarget(config2.fullscreenTarget);
                }
              },
              getParentBounds: function() {
                if (!this.parent) {
                  return false;
                }
                var parentSize = this.parentSize;
                var DOMRect = this.parent.getBoundingClientRect();
                if (this.parentIsWindow && this.game.device.os.iOS) {
                  DOMRect.height = GetInnerHeight(true);
                }
                var newWidth = DOMRect.width;
                var newHeight = DOMRect.height;
                if (parentSize.width !== newWidth || parentSize.height !== newHeight) {
                  parentSize.setSize(newWidth, newHeight);
                  return true;
                } else if (this.canvas) {
                  var canvasBounds = this.canvasBounds;
                  var canvasRect = this.canvas.getBoundingClientRect();
                  if (canvasRect.x !== canvasBounds.x || canvasRect.y !== canvasBounds.y) {
                    return true;
                  }
                }
                return false;
              },
              lockOrientation: function(orientation) {
                var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
                if (lock) {
                  return lock.call(screen, orientation);
                }
                return false;
              },
              setParentSize: function(width, height) {
                this.parentSize.setSize(width, height);
                return this.refresh();
              },
              setGameSize: function(width, height) {
                var autoRound = this.autoRound;
                if (autoRound) {
                  width = Math.floor(width);
                  height = Math.floor(height);
                }
                var previousWidth = this.width;
                var previousHeight = this.height;
                this.gameSize.resize(width, height);
                this.baseSize.resize(width, height);
                if (autoRound) {
                  this.baseSize.width = Math.floor(this.baseSize.width);
                  this.baseSize.height = Math.floor(this.baseSize.height);
                }
                this.displaySize.setAspectRatio(width / height);
                this.canvas.width = this.baseSize.width;
                this.canvas.height = this.baseSize.height;
                return this.refresh(previousWidth, previousHeight);
              },
              resize: function(width, height) {
                var zoom = this.zoom;
                var autoRound = this.autoRound;
                if (autoRound) {
                  width = Math.floor(width);
                  height = Math.floor(height);
                }
                var previousWidth = this.width;
                var previousHeight = this.height;
                this.gameSize.resize(width, height);
                this.baseSize.resize(width, height);
                if (autoRound) {
                  this.baseSize.width = Math.floor(this.baseSize.width);
                  this.baseSize.height = Math.floor(this.baseSize.height);
                }
                this.displaySize.setSize(width * zoom, height * zoom);
                this.canvas.width = this.baseSize.width;
                this.canvas.height = this.baseSize.height;
                var style = this.canvas.style;
                var styleWidth = width * zoom;
                var styleHeight = height * zoom;
                if (autoRound) {
                  styleWidth = Math.floor(styleWidth);
                  styleHeight = Math.floor(styleHeight);
                }
                if (styleWidth !== width || styleHeight !== height) {
                  style.width = styleWidth + "px";
                  style.height = styleHeight + "px";
                }
                return this.refresh(previousWidth, previousHeight);
              },
              setZoom: function(value) {
                this.zoom = value;
                this._resetZoom = true;
                return this.refresh();
              },
              setMaxZoom: function() {
                this.zoom = this.getMaxZoom();
                this._resetZoom = true;
                return this.refresh();
              },
              refresh: function(previousWidth, previousHeight) {
                if (previousWidth === void 0) {
                  previousWidth = this.width;
                }
                if (previousHeight === void 0) {
                  previousHeight = this.height;
                }
                this.updateScale();
                this.updateBounds();
                this.updateOrientation();
                this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
                var domContainer = this.game.domContainer;
                if (domContainer) {
                  this.baseSize.setCSS(domContainer);
                  var canvasStyle = this.canvas.style;
                  var domStyle = domContainer.style;
                  domStyle.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")";
                  domStyle.marginLeft = canvasStyle.marginLeft;
                  domStyle.marginTop = canvasStyle.marginTop;
                }
                this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight);
                return this;
              },
              updateOrientation: function() {
                if (this._checkOrientation) {
                  this._checkOrientation = false;
                  var newOrientation = GetScreenOrientation(this.width, this.height);
                  if (newOrientation !== this.orientation) {
                    this.orientation = newOrientation;
                    this.emit(Events.ORIENTATION_CHANGE, newOrientation);
                  }
                }
              },
              updateScale: function() {
                var style = this.canvas.style;
                var width = this.gameSize.width;
                var height = this.gameSize.height;
                var styleWidth;
                var styleHeight;
                var zoom = this.zoom;
                var autoRound = this.autoRound;
                if (this.scaleMode === CONST.SCALE_MODE.NONE) {
                  this.displaySize.setSize(width * zoom, height * zoom);
                  styleWidth = this.displaySize.width;
                  styleHeight = this.displaySize.height;
                  if (autoRound) {
                    styleWidth = Math.floor(styleWidth);
                    styleHeight = Math.floor(styleHeight);
                  }
                  if (this._resetZoom) {
                    style.width = styleWidth + "px";
                    style.height = styleHeight + "px";
                    this._resetZoom = false;
                  }
                } else if (this.scaleMode === CONST.SCALE_MODE.RESIZE) {
                  this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
                  this.gameSize.setSize(this.displaySize.width, this.displaySize.height);
                  this.baseSize.setSize(this.displaySize.width, this.displaySize.height);
                  styleWidth = this.displaySize.width;
                  styleHeight = this.displaySize.height;
                  if (autoRound) {
                    styleWidth = Math.floor(styleWidth);
                    styleHeight = Math.floor(styleHeight);
                  }
                  this.canvas.width = styleWidth;
                  this.canvas.height = styleHeight;
                } else {
                  this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
                  styleWidth = this.displaySize.width;
                  styleHeight = this.displaySize.height;
                  if (autoRound) {
                    styleWidth = Math.floor(styleWidth);
                    styleHeight = Math.floor(styleHeight);
                  }
                  style.width = styleWidth + "px";
                  style.height = styleHeight + "px";
                }
                this.getParentBounds();
                this.updateCenter();
              },
              getMaxZoom: function() {
                var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);
                var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);
                return Math.max(Math.min(zoomH, zoomV), 1);
              },
              updateCenter: function() {
                var autoCenter = this.autoCenter;
                if (autoCenter === CONST.CENTER.NO_CENTER) {
                  return;
                }
                var canvas = this.canvas;
                var style = canvas.style;
                var bounds = canvas.getBoundingClientRect();
                var width = bounds.width;
                var height = bounds.height;
                var offsetX = Math.floor((this.parentSize.width - width) / 2);
                var offsetY = Math.floor((this.parentSize.height - height) / 2);
                if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY) {
                  offsetY = 0;
                } else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY) {
                  offsetX = 0;
                }
                style.marginLeft = offsetX + "px";
                style.marginTop = offsetY + "px";
              },
              updateBounds: function() {
                var bounds = this.canvasBounds;
                var clientRect = this.canvas.getBoundingClientRect();
                bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);
                bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);
                bounds.width = clientRect.width;
                bounds.height = clientRect.height;
              },
              transformX: function(pageX) {
                return (pageX - this.canvasBounds.left) * this.displayScale.x;
              },
              transformY: function(pageY) {
                return (pageY - this.canvasBounds.top) * this.displayScale.y;
              },
              startFullscreen: function(fullscreenOptions) {
                if (fullscreenOptions === void 0) {
                  fullscreenOptions = {navigationUI: "hide"};
                }
                var fullscreen = this.fullscreen;
                if (!fullscreen.available) {
                  this.emit(Events.FULLSCREEN_UNSUPPORTED);
                  return;
                }
                if (!fullscreen.active) {
                  var fsTarget = this.getFullscreenTarget();
                  if (fullscreen.keyboard) {
                    fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);
                  } else {
                    fsTarget[fullscreen.request](fullscreenOptions);
                  }
                }
              },
              fullscreenSuccessHandler: function() {
                this.getParentBounds();
                this.refresh();
                this.emit(Events.ENTER_FULLSCREEN);
              },
              fullscreenErrorHandler: function(error) {
                this.removeFullscreenTarget();
                this.emit(Events.FULLSCREEN_FAILED, error);
              },
              getFullscreenTarget: function() {
                if (!this.fullscreenTarget) {
                  var fsTarget = document.createElement("div");
                  fsTarget.style.margin = "0";
                  fsTarget.style.padding = "0";
                  fsTarget.style.width = "100%";
                  fsTarget.style.height = "100%";
                  this.fullscreenTarget = fsTarget;
                  this._createdFullscreenTarget = true;
                }
                if (this._createdFullscreenTarget) {
                  var canvasParent = this.canvas.parentNode;
                  canvasParent.insertBefore(this.fullscreenTarget, this.canvas);
                  this.fullscreenTarget.appendChild(this.canvas);
                }
                return this.fullscreenTarget;
              },
              removeFullscreenTarget: function() {
                if (this._createdFullscreenTarget) {
                  var fsTarget = this.fullscreenTarget;
                  if (fsTarget && fsTarget.parentNode) {
                    var parent = fsTarget.parentNode;
                    parent.insertBefore(this.canvas, fsTarget);
                    parent.removeChild(fsTarget);
                  }
                }
              },
              stopFullscreen: function() {
                var fullscreen = this.fullscreen;
                if (!fullscreen.available) {
                  this.emit(Events.FULLSCREEN_UNSUPPORTED);
                  return false;
                }
                if (fullscreen.active) {
                  document[fullscreen.cancel]();
                }
                this.removeFullscreenTarget();
                this.getParentBounds();
                this.emit(Events.LEAVE_FULLSCREEN);
                this.refresh();
              },
              toggleFullscreen: function(fullscreenOptions) {
                if (this.fullscreen.active) {
                  this.stopFullscreen();
                } else {
                  this.startFullscreen(fullscreenOptions);
                }
              },
              startListeners: function() {
                var _this = this;
                var listeners = this.domlisteners;
                listeners.orientationChange = function() {
                  _this.updateBounds();
                  _this._checkOrientation = true;
                  _this.dirty = true;
                };
                listeners.windowResize = function() {
                  _this.updateBounds();
                  _this.dirty = true;
                };
                window.addEventListener("orientationchange", listeners.orientationChange, false);
                window.addEventListener("resize", listeners.windowResize, false);
                if (this.fullscreen.available) {
                  listeners.fullScreenChange = function(event) {
                    return _this.onFullScreenChange(event);
                  };
                  listeners.fullScreenError = function(event) {
                    return _this.onFullScreenError(event);
                  };
                  var vendors = ["webkit", "moz", ""];
                  vendors.forEach(function(prefix) {
                    document.addEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
                    document.addEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
                  });
                  document.addEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
                  document.addEventListener("MSFullscreenError", listeners.fullScreenError, false);
                }
              },
              onFullScreenChange: function() {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement) {
                  this.fullscreenSuccessHandler();
                } else {
                  this.stopFullscreen();
                }
              },
              onFullScreenError: function() {
                this.removeFullscreenTarget();
              },
              getViewPort: function(camera, out) {
                if (!(camera instanceof Camera)) {
                  out = camera;
                  camera = void 0;
                }
                if (out === void 0) {
                  out = new Rectangle();
                }
                var baseSize = this.baseSize;
                var parentSize = this.parentSize;
                var canvasBounds = this.canvasBounds;
                var displayScale = this.displayScale;
                var x = canvasBounds.x >= 0 ? 0 : -(canvasBounds.x * displayScale.x);
                var y = canvasBounds.y >= 0 ? 0 : -(canvasBounds.y * displayScale.y);
                var width;
                if (parentSize.width >= canvasBounds.width) {
                  width = baseSize.width;
                } else {
                  width = baseSize.width - (canvasBounds.width - parentSize.width) * displayScale.x;
                }
                var height;
                if (parentSize.height >= canvasBounds.height) {
                  height = baseSize.height;
                } else {
                  height = baseSize.height - (canvasBounds.height - parentSize.height) * displayScale.y;
                }
                out.setTo(x, y, width, height);
                if (camera) {
                  out.width /= camera.zoomX;
                  out.height /= camera.zoomY;
                  out.centerX = camera.centerX + camera.scrollX;
                  out.centerY = camera.centerY + camera.scrollY;
                }
                return out;
              },
              step: function(time, delta) {
                if (!this.parent) {
                  return;
                }
                this._lastCheck += delta;
                if (this.dirty || this._lastCheck > this.resizeInterval) {
                  if (this.getParentBounds()) {
                    this.refresh();
                  }
                  this.dirty = false;
                  this._lastCheck = 0;
                }
              },
              stopListeners: function() {
                var listeners = this.domlisteners;
                window.removeEventListener("orientationchange", listeners.orientationChange, false);
                window.removeEventListener("resize", listeners.windowResize, false);
                var vendors = ["webkit", "moz", ""];
                vendors.forEach(function(prefix) {
                  document.removeEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
                  document.removeEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
                });
                document.removeEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
                document.removeEventListener("MSFullscreenError", listeners.fullScreenError, false);
              },
              destroy: function() {
                this.removeAllListeners();
                this.stopListeners();
                this.game = null;
                this.canvas = null;
                this.canvasBounds = null;
                this.parent = null;
                this.fullscreenTarget = null;
                this.parentSize.destroy();
                this.gameSize.destroy();
                this.baseSize.destroy();
                this.displaySize.destroy();
              },
              isFullscreen: {
                get: function() {
                  return this.fullscreen.active;
                }
              },
              width: {
                get: function() {
                  return this.gameSize.width;
                }
              },
              height: {
                get: function() {
                  return this.gameSize.height;
                }
              },
              isPortrait: {
                get: function() {
                  return this.orientation === CONST.ORIENTATION.PORTRAIT;
                }
              },
              isLandscape: {
                get: function() {
                  return this.orientation === CONST.ORIENTATION.LANDSCAPE;
                }
              },
              isGamePortrait: {
                get: function() {
                  return this.height > this.width;
                }
              },
              isGameLandscape: {
                get: function() {
                  return this.width > this.height;
                }
              }
            });
            module2.exports = ScaleManager;
          },
          35098: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              NO_CENTER: 0,
              CENTER_BOTH: 1,
              CENTER_HORIZONTALLY: 2,
              CENTER_VERTICALLY: 3
            };
          },
          53539: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              LANDSCAPE: "landscape-primary",
              PORTRAIT: "portrait-primary"
            };
          },
          12637: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              NONE: 0,
              WIDTH_CONTROLS_HEIGHT: 1,
              HEIGHT_CONTROLS_WIDTH: 2,
              FIT: 3,
              ENVELOP: 4,
              RESIZE: 5
            };
          },
          10217: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              NO_ZOOM: 1,
              ZOOM_2X: 2,
              ZOOM_4X: 4,
              MAX_ZOOM: -1
            };
          },
          55301: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = {
              CENTER: __webpack_require__2(35098),
              ORIENTATION: __webpack_require__2(53539),
              SCALE_MODE: __webpack_require__2(12637),
              ZOOM: __webpack_require__2(10217)
            };
            module2.exports = CONST;
          },
          82085: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "enterfullscreen";
          },
          11826: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "fullscreenfailed";
          },
          56691: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "fullscreenunsupported";
          },
          34739: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "leavefullscreen";
          },
          26681: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "orientationchange";
          },
          11428: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resize";
          },
          40444: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ENTER_FULLSCREEN: __webpack_require__2(82085),
              FULLSCREEN_FAILED: __webpack_require__2(11826),
              FULLSCREEN_UNSUPPORTED: __webpack_require__2(56691),
              LEAVE_FULLSCREEN: __webpack_require__2(34739),
              ORIENTATION_CHANGE: __webpack_require__2(26681),
              RESIZE: __webpack_require__2(11428)
            };
          },
          86754: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Extend = __webpack_require__2(98611);
            var CONST = __webpack_require__2(55301);
            var Scale = {
              Center: __webpack_require__2(35098),
              Events: __webpack_require__2(40444),
              Orientation: __webpack_require__2(53539),
              ScaleManager: __webpack_require__2(756),
              ScaleModes: __webpack_require__2(12637),
              Zoom: __webpack_require__2(10217)
            };
            Scale = Extend(false, Scale, CONST.CENTER);
            Scale = Extend(false, Scale, CONST.ORIENTATION);
            Scale = Extend(false, Scale, CONST.SCALE_MODE);
            Scale = Extend(false, Scale, CONST.ZOOM);
            module2.exports = Scale;
          },
          47736: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var UppercaseFirst = __webpack_require__2(40587);
            var GetPhysicsPlugins = function(sys) {
              var defaultSystem = sys.game.config.defaultPhysicsSystem;
              var sceneSystems = GetFastValue(sys.settings, "physics", false);
              if (!defaultSystem && !sceneSystems) {
                return;
              }
              var output = [];
              if (defaultSystem) {
                output.push(UppercaseFirst(defaultSystem + "Physics"));
              }
              if (sceneSystems) {
                for (var key in sceneSystems) {
                  key = UppercaseFirst(key.concat("Physics"));
                  if (output.indexOf(key) === -1) {
                    output.push(key);
                  }
                }
              }
              return output;
            };
            module2.exports = GetPhysicsPlugins;
          },
          91088: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var GetScenePlugins = function(sys) {
              var defaultPlugins = sys.plugins.getDefaultScenePlugins();
              var scenePlugins = GetFastValue(sys.settings, "plugins", false);
              if (Array.isArray(scenePlugins)) {
                return scenePlugins;
              } else if (defaultPlugins) {
                return defaultPlugins;
              } else {
                return [];
              }
            };
            module2.exports = GetScenePlugins;
          },
          90415: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var InjectionMap = {
              game: "game",
              renderer: "renderer",
              anims: "anims",
              cache: "cache",
              plugins: "plugins",
              registry: "registry",
              scale: "scale",
              sound: "sound",
              textures: "textures",
              events: "events",
              cameras: "cameras",
              add: "add",
              make: "make",
              scenePlugin: "scene",
              displayList: "children",
              lights: "lights",
              data: "data",
              input: "input",
              load: "load",
              time: "time",
              tweens: "tweens",
              arcadePhysics: "physics",
              impactPhysics: "impact",
              matterPhysics: "matter"
            };
            if (false) {
            }
            if (false) {
            }
            module2.exports = InjectionMap;
          },
          87157: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Systems = __webpack_require__2(63946);
            var Scene6 = new Class({
              initialize: function Scene7(config2) {
                this.sys = new Systems(this, config2);
                this.game;
                this.anims;
                this.cache;
                this.registry;
                this.sound;
                this.textures;
                this.events;
                this.cameras;
                this.add;
                this.make;
                this.scene;
                this.children;
                this.lights;
                this.data;
                this.input;
                this.load;
                this.time;
                this.tweens;
                this.physics;
                this.matter;
                if (false) {
                }
                this.scale;
                this.plugins;
                this.renderer;
              },
              update: function() {
              }
            });
            module2.exports = Scene6;
          },
          13553: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(92980);
            var Events = __webpack_require__2(7599);
            var GameEvents = __webpack_require__2(97081);
            var GetValue = __webpack_require__2(10850);
            var LoaderEvents = __webpack_require__2(683);
            var NOOP = __webpack_require__2(72283);
            var Scene6 = __webpack_require__2(87157);
            var Systems = __webpack_require__2(63946);
            var SceneManager = new Class({
              initialize: function SceneManager2(game, sceneConfig) {
                this.game = game;
                this.keys = {};
                this.scenes = [];
                this._pending = [];
                this._start = [];
                this._queue = [];
                this._data = {};
                this.isProcessing = false;
                this.isBooted = false;
                this.customViewports = 0;
                this.systemScene;
                if (sceneConfig) {
                  if (!Array.isArray(sceneConfig)) {
                    sceneConfig = [sceneConfig];
                  }
                  for (var i = 0; i < sceneConfig.length; i++) {
                    this._pending.push({
                      key: "default",
                      scene: sceneConfig[i],
                      autoStart: i === 0,
                      data: {}
                    });
                  }
                }
                game.events.once(GameEvents.READY, this.bootQueue, this);
              },
              bootQueue: function() {
                if (this.isBooted) {
                  return;
                }
                this.systemScene = this.createSceneFromInstance("__SYSTEM", new Scene6());
                this.game.events.emit(GameEvents.SYSTEM_READY, this.systemScene, this);
                var i;
                var entry;
                var key;
                var sceneConfig;
                for (i = 0; i < this._pending.length; i++) {
                  entry = this._pending[i];
                  key = entry.key;
                  sceneConfig = entry.scene;
                  var newScene;
                  if (sceneConfig instanceof Scene6) {
                    newScene = this.createSceneFromInstance(key, sceneConfig);
                  } else if (typeof sceneConfig === "object") {
                    newScene = this.createSceneFromObject(key, sceneConfig);
                  } else if (typeof sceneConfig === "function") {
                    newScene = this.createSceneFromFunction(key, sceneConfig);
                  }
                  key = newScene.sys.settings.key;
                  this.keys[key] = newScene;
                  this.scenes.push(newScene);
                  if (this._data[key]) {
                    newScene.sys.settings.data = this._data[key].data;
                    if (this._data[key].autoStart) {
                      entry.autoStart = true;
                    }
                  }
                  if (entry.autoStart || newScene.sys.settings.active) {
                    this._start.push(key);
                  }
                }
                this._pending.length = 0;
                this._data = {};
                this.isBooted = true;
                for (i = 0; i < this._start.length; i++) {
                  entry = this._start[i];
                  this.start(entry);
                }
                this._start.length = 0;
              },
              processQueue: function() {
                var pendingLength = this._pending.length;
                var queueLength = this._queue.length;
                if (pendingLength === 0 && queueLength === 0) {
                  return;
                }
                var i;
                var entry;
                if (pendingLength) {
                  for (i = 0; i < pendingLength; i++) {
                    entry = this._pending[i];
                    this.add(entry.key, entry.scene, entry.autoStart, entry.data);
                  }
                  for (i = 0; i < this._start.length; i++) {
                    entry = this._start[i];
                    this.start(entry);
                  }
                  this._start.length = 0;
                  this._pending.length = 0;
                }
                for (i = 0; i < this._queue.length; i++) {
                  entry = this._queue[i];
                  this[entry.op](entry.keyA, entry.keyB);
                }
                this._queue.length = 0;
              },
              add: function(key, sceneConfig, autoStart, data) {
                if (autoStart === void 0) {
                  autoStart = false;
                }
                if (data === void 0) {
                  data = {};
                }
                if (this.isProcessing || !this.isBooted) {
                  this._pending.push({
                    key,
                    scene: sceneConfig,
                    autoStart,
                    data
                  });
                  if (!this.isBooted) {
                    this._data[key] = {data};
                  }
                  return null;
                }
                key = this.getKey(key, sceneConfig);
                var newScene;
                if (sceneConfig instanceof Scene6) {
                  newScene = this.createSceneFromInstance(key, sceneConfig);
                } else if (typeof sceneConfig === "object") {
                  sceneConfig.key = key;
                  newScene = this.createSceneFromObject(key, sceneConfig);
                } else if (typeof sceneConfig === "function") {
                  newScene = this.createSceneFromFunction(key, sceneConfig);
                }
                newScene.sys.settings.data = data;
                key = newScene.sys.settings.key;
                this.keys[key] = newScene;
                this.scenes.push(newScene);
                if (autoStart || newScene.sys.settings.active) {
                  if (this._pending.length) {
                    this._start.push(key);
                  } else {
                    this.start(key);
                  }
                }
                return newScene;
              },
              remove: function(key) {
                if (this.isProcessing) {
                  this._queue.push({op: "remove", keyA: key, keyB: null});
                } else {
                  var sceneToRemove = this.getScene(key);
                  if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) {
                    return this;
                  }
                  var index = this.scenes.indexOf(sceneToRemove);
                  var sceneKey = sceneToRemove.sys.settings.key;
                  if (index > -1) {
                    delete this.keys[sceneKey];
                    this.scenes.splice(index, 1);
                    if (this._start.indexOf(sceneKey) > -1) {
                      index = this._start.indexOf(sceneKey);
                      this._start.splice(index, 1);
                    }
                    sceneToRemove.sys.destroy();
                  }
                }
                return this;
              },
              bootScene: function(scene) {
                var sys = scene.sys;
                var settings = sys.settings;
                sys.sceneUpdate = NOOP;
                if (scene.init) {
                  scene.init.call(scene, settings.data);
                  settings.status = CONST.INIT;
                  if (settings.isTransition) {
                    sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);
                  }
                }
                var loader;
                if (sys.load) {
                  loader = sys.load;
                  loader.reset();
                }
                if (loader && scene.preload) {
                  scene.preload.call(scene);
                  settings.status = CONST.LOADING;
                  loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);
                  loader.start();
                } else {
                  this.create(scene);
                }
              },
              loadComplete: function(loader) {
                if (this.game.sound && this.game.sound.onBlurPausedSounds) {
                  this.game.sound.unlock();
                }
                this.create(loader.scene);
              },
              payloadComplete: function(loader) {
                this.bootScene(loader.scene);
              },
              update: function(time, delta) {
                this.processQueue();
                this.isProcessing = true;
                for (var i = this.scenes.length - 1; i >= 0; i--) {
                  var sys = this.scenes[i].sys;
                  if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING) {
                    sys.step(time, delta);
                  }
                  if (sys.scenePlugin._target) {
                    sys.scenePlugin.step(time, delta);
                  }
                }
              },
              render: function(renderer) {
                for (var i = 0; i < this.scenes.length; i++) {
                  var sys = this.scenes[i].sys;
                  if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING) {
                    sys.render(renderer);
                  }
                }
                this.isProcessing = false;
              },
              create: function(scene) {
                var sys = scene.sys;
                var settings = sys.settings;
                if (scene.create) {
                  settings.status = CONST.CREATING;
                  scene.create.call(scene, settings.data);
                  if (settings.status === CONST.DESTROYED) {
                    return;
                  }
                }
                if (settings.isTransition) {
                  sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);
                }
                if (scene.update) {
                  sys.sceneUpdate = scene.update;
                }
                settings.status = CONST.RUNNING;
                sys.events.emit(Events.CREATE, scene);
              },
              createSceneFromFunction: function(key, scene) {
                var newScene = new scene();
                if (newScene instanceof Scene6) {
                  var configKey = newScene.sys.settings.key;
                  if (configKey !== "") {
                    key = configKey;
                  }
                  if (this.keys.hasOwnProperty(key)) {
                    throw new Error("Cannot add a Scene with duplicate key: " + key);
                  }
                  return this.createSceneFromInstance(key, newScene);
                } else {
                  newScene.sys = new Systems(newScene);
                  newScene.sys.settings.key = key;
                  newScene.sys.init(this.game);
                  return newScene;
                }
              },
              createSceneFromInstance: function(key, newScene) {
                var configKey = newScene.sys.settings.key;
                if (configKey === "") {
                  newScene.sys.settings.key = key;
                }
                newScene.sys.init(this.game);
                return newScene;
              },
              createSceneFromObject: function(key, sceneConfig) {
                var newScene = new Scene6(sceneConfig);
                var configKey = newScene.sys.settings.key;
                if (configKey !== "") {
                  key = configKey;
                } else {
                  newScene.sys.settings.key = key;
                }
                newScene.sys.init(this.game);
                var defaults = ["init", "preload", "create", "update", "render"];
                for (var i = 0; i < defaults.length; i++) {
                  var sceneCallback = GetValue(sceneConfig, defaults[i], null);
                  if (sceneCallback) {
                    newScene[defaults[i]] = sceneCallback;
                  }
                }
                if (sceneConfig.hasOwnProperty("extend")) {
                  for (var propertyKey in sceneConfig.extend) {
                    if (!sceneConfig.extend.hasOwnProperty(propertyKey)) {
                      continue;
                    }
                    var value = sceneConfig.extend[propertyKey];
                    if (propertyKey === "data" && newScene.hasOwnProperty("data") && typeof value === "object") {
                      newScene.data.merge(value);
                    } else if (propertyKey !== "sys") {
                      newScene[propertyKey] = value;
                    }
                  }
                }
                return newScene;
              },
              getKey: function(key, sceneConfig) {
                if (!key) {
                  key = "default";
                }
                if (typeof sceneConfig === "function") {
                  return key;
                } else if (sceneConfig instanceof Scene6) {
                  key = sceneConfig.sys.settings.key;
                } else if (typeof sceneConfig === "object" && sceneConfig.hasOwnProperty("key")) {
                  key = sceneConfig.key;
                }
                if (this.keys.hasOwnProperty(key)) {
                  throw new Error("Cannot add a Scene with duplicate key: " + key);
                } else {
                  return key;
                }
              },
              getScenes: function(isActive, inReverse) {
                if (isActive === void 0) {
                  isActive = true;
                }
                if (inReverse === void 0) {
                  inReverse = false;
                }
                var out = [];
                var scenes = this.scenes;
                for (var i = 0; i < scenes.length; i++) {
                  var scene = scenes[i];
                  if (scene && (!isActive || isActive && scene.sys.isActive())) {
                    out.push(scene);
                  }
                }
                return inReverse ? out.reverse() : out;
              },
              getScene: function(key) {
                if (typeof key === "string") {
                  if (this.keys[key]) {
                    return this.keys[key];
                  }
                } else {
                  for (var i = 0; i < this.scenes.length; i++) {
                    if (key === this.scenes[i]) {
                      return key;
                    }
                  }
                }
                return null;
              },
              isActive: function(key) {
                var scene = this.getScene(key);
                if (scene) {
                  return scene.sys.isActive();
                }
                return null;
              },
              isPaused: function(key) {
                var scene = this.getScene(key);
                if (scene) {
                  return scene.sys.isPaused();
                }
                return null;
              },
              isVisible: function(key) {
                var scene = this.getScene(key);
                if (scene) {
                  return scene.sys.isVisible();
                }
                return null;
              },
              isSleeping: function(key) {
                var scene = this.getScene(key);
                if (scene) {
                  return scene.sys.isSleeping();
                }
                return null;
              },
              pause: function(key, data) {
                var scene = this.getScene(key);
                if (scene) {
                  scene.sys.pause(data);
                }
                return this;
              },
              resume: function(key, data) {
                var scene = this.getScene(key);
                if (scene) {
                  scene.sys.resume(data);
                }
                return this;
              },
              sleep: function(key, data) {
                var scene = this.getScene(key);
                if (scene && !scene.sys.isTransitioning()) {
                  scene.sys.sleep(data);
                }
                return this;
              },
              wake: function(key, data) {
                var scene = this.getScene(key);
                if (scene) {
                  scene.sys.wake(data);
                }
                return this;
              },
              run: function(key, data) {
                var scene = this.getScene(key);
                if (!scene) {
                  for (var i = 0; i < this._pending.length; i++) {
                    if (this._pending[i].key === key) {
                      this.queueOp("start", key, data);
                      break;
                    }
                  }
                  return this;
                }
                if (scene.sys.isSleeping()) {
                  scene.sys.wake(data);
                } else if (scene.sys.isPaused()) {
                  scene.sys.resume(data);
                } else {
                  this.start(key, data);
                }
              },
              start: function(key, data) {
                if (!this.isBooted) {
                  this._data[key] = {
                    autoStart: true,
                    data
                  };
                  return this;
                }
                var scene = this.getScene(key);
                if (!scene) {
                  console.warn("Scene not found for key: " + key);
                  return this;
                }
                var sys = scene.sys;
                var status = sys.settings.status;
                if (status >= CONST.START && status <= CONST.CREATING) {
                  return this;
                } else if (status >= CONST.RUNNING && status <= CONST.SLEEPING) {
                  sys.shutdown();
                  sys.sceneUpdate = NOOP;
                  sys.start(data);
                } else {
                  sys.sceneUpdate = NOOP;
                  sys.start(data);
                  var loader;
                  if (sys.load) {
                    loader = sys.load;
                  }
                  if (loader && sys.settings.hasOwnProperty("pack")) {
                    loader.reset();
                    if (loader.addPack({payload: sys.settings.pack})) {
                      sys.settings.status = CONST.LOADING;
                      loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);
                      loader.start();
                      return this;
                    }
                  }
                }
                this.bootScene(scene);
                return this;
              },
              stop: function(key, data) {
                var scene = this.getScene(key);
                if (scene && !scene.sys.isTransitioning() && scene.sys.settings.status !== CONST.SHUTDOWN) {
                  var loader = scene.sys.load;
                  if (loader) {
                    loader.off(LoaderEvents.COMPLETE, this.loadComplete, this);
                    loader.off(LoaderEvents.COMPLETE, this.payloadComplete, this);
                  }
                  scene.sys.shutdown(data);
                }
                return this;
              },
              switch: function(from, to) {
                var sceneA = this.getScene(from);
                var sceneB = this.getScene(to);
                if (sceneA && sceneB && sceneA !== sceneB) {
                  this.sleep(from);
                  if (this.isSleeping(to)) {
                    this.wake(to);
                  } else {
                    this.start(to);
                  }
                }
                return this;
              },
              getAt: function(index) {
                return this.scenes[index];
              },
              getIndex: function(key) {
                var scene = this.getScene(key);
                return this.scenes.indexOf(scene);
              },
              bringToTop: function(key) {
                if (this.isProcessing) {
                  this._queue.push({op: "bringToTop", keyA: key, keyB: null});
                } else {
                  var index = this.getIndex(key);
                  if (index !== -1 && index < this.scenes.length) {
                    var scene = this.getScene(key);
                    this.scenes.splice(index, 1);
                    this.scenes.push(scene);
                  }
                }
                return this;
              },
              sendToBack: function(key) {
                if (this.isProcessing) {
                  this._queue.push({op: "sendToBack", keyA: key, keyB: null});
                } else {
                  var index = this.getIndex(key);
                  if (index !== -1 && index > 0) {
                    var scene = this.getScene(key);
                    this.scenes.splice(index, 1);
                    this.scenes.unshift(scene);
                  }
                }
                return this;
              },
              moveDown: function(key) {
                if (this.isProcessing) {
                  this._queue.push({op: "moveDown", keyA: key, keyB: null});
                } else {
                  var indexA = this.getIndex(key);
                  if (indexA > 0) {
                    var indexB = indexA - 1;
                    var sceneA = this.getScene(key);
                    var sceneB = this.getAt(indexB);
                    this.scenes[indexA] = sceneB;
                    this.scenes[indexB] = sceneA;
                  }
                }
                return this;
              },
              moveUp: function(key) {
                if (this.isProcessing) {
                  this._queue.push({op: "moveUp", keyA: key, keyB: null});
                } else {
                  var indexA = this.getIndex(key);
                  if (indexA < this.scenes.length - 1) {
                    var indexB = indexA + 1;
                    var sceneA = this.getScene(key);
                    var sceneB = this.getAt(indexB);
                    this.scenes[indexA] = sceneB;
                    this.scenes[indexB] = sceneA;
                  }
                }
                return this;
              },
              moveAbove: function(keyA, keyB) {
                if (keyA === keyB) {
                  return this;
                }
                if (this.isProcessing) {
                  this._queue.push({op: "moveAbove", keyA, keyB});
                } else {
                  var indexA = this.getIndex(keyA);
                  var indexB = this.getIndex(keyB);
                  if (indexA !== -1 && indexB !== -1 && indexB < indexA) {
                    var tempScene = this.getAt(indexB);
                    this.scenes.splice(indexB, 1);
                    this.scenes.splice(indexA + (indexB > indexA), 0, tempScene);
                  }
                }
                return this;
              },
              moveBelow: function(keyA, keyB) {
                if (keyA === keyB) {
                  return this;
                }
                if (this.isProcessing) {
                  this._queue.push({op: "moveBelow", keyA, keyB});
                } else {
                  var indexA = this.getIndex(keyA);
                  var indexB = this.getIndex(keyB);
                  if (indexA !== -1 && indexB !== -1 && indexB > indexA) {
                    var tempScene = this.getAt(indexB);
                    this.scenes.splice(indexB, 1);
                    if (indexA === 0) {
                      this.scenes.unshift(tempScene);
                    } else {
                      this.scenes.splice(indexA - (indexB < indexA), 0, tempScene);
                    }
                  }
                }
                return this;
              },
              queueOp: function(op, keyA, keyB) {
                this._queue.push({op, keyA, keyB});
                return this;
              },
              swapPosition: function(keyA, keyB) {
                if (keyA === keyB) {
                  return this;
                }
                if (this.isProcessing) {
                  this._queue.push({op: "swapPosition", keyA, keyB});
                } else {
                  var indexA = this.getIndex(keyA);
                  var indexB = this.getIndex(keyB);
                  if (indexA !== indexB && indexA !== -1 && indexB !== -1) {
                    var tempScene = this.getAt(indexA);
                    this.scenes[indexA] = this.scenes[indexB];
                    this.scenes[indexB] = tempScene;
                  }
                }
                return this;
              },
              dump: function() {
                var out = [];
                var map = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"];
                for (var i = 0; i < this.scenes.length; i++) {
                  var sys = this.scenes[i].sys;
                  var key = sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED) ? "[*] " : "[-] ";
                  key += sys.settings.key + " (" + map[sys.settings.status] + ")";
                  out.push(key);
                }
                console.log(out.join("\n"));
              },
              destroy: function() {
                for (var i = 0; i < this.scenes.length; i++) {
                  var sys = this.scenes[i].sys;
                  sys.destroy();
                }
                this.systemScene.sys.destroy();
                this.update = NOOP;
                this.scenes = [];
                this._pending = [];
                this._start = [];
                this._queue = [];
                this.game = null;
                this.systemScene = null;
              }
            });
            module2.exports = SceneManager;
          },
          64051: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(7599);
            var GetFastValue = __webpack_require__2(72632);
            var PluginCache = __webpack_require__2(91963);
            var ScenePlugin = new Class({
              initialize: function ScenePlugin2(scene) {
                this.scene = scene;
                this.systems = scene.sys;
                this.settings = scene.sys.settings;
                this.key = scene.sys.settings.key;
                this.manager = scene.sys.game.scene;
                this.transitionProgress = 0;
                this._elapsed = 0;
                this._target = null;
                this._duration = 0;
                this._onUpdate;
                this._onUpdateScope;
                this._willSleep = false;
                this._willRemove = false;
                scene.sys.events.once(Events.BOOT, this.boot, this);
                scene.sys.events.on(Events.START, this.pluginStart, this);
              },
              boot: function() {
                this.systems.events.once(Events.DESTROY, this.destroy, this);
              },
              pluginStart: function() {
                this._target = null;
                this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);
              },
              start: function(key, data) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.queueOp("stop", this.key);
                this.manager.queueOp("start", key, data);
                return this;
              },
              restart: function(data) {
                var key = this.key;
                this.manager.queueOp("stop", key);
                this.manager.queueOp("start", key, data);
                return this;
              },
              transition: function(config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                var key = GetFastValue(config2, "target", false);
                var target = this.manager.getScene(key);
                if (!key || !this.checkValidTransition(target)) {
                  return false;
                }
                var duration = GetFastValue(config2, "duration", 1e3);
                this._elapsed = 0;
                this._target = target;
                this._duration = duration;
                this._willSleep = GetFastValue(config2, "sleep", false);
                this._willRemove = GetFastValue(config2, "remove", false);
                var callback = GetFastValue(config2, "onUpdate", null);
                if (callback) {
                  this._onUpdate = callback;
                  this._onUpdateScope = GetFastValue(config2, "onUpdateScope", this.scene);
                }
                var allowInput = GetFastValue(config2, "allowInput", false);
                this.settings.transitionAllowInput = allowInput;
                var targetSettings = target.sys.settings;
                targetSettings.isTransition = true;
                targetSettings.transitionFrom = this.scene;
                targetSettings.transitionDuration = duration;
                targetSettings.transitionAllowInput = allowInput;
                if (GetFastValue(config2, "moveAbove", false)) {
                  this.manager.moveAbove(this.key, key);
                } else if (GetFastValue(config2, "moveBelow", false)) {
                  this.manager.moveBelow(this.key, key);
                }
                if (target.sys.isSleeping()) {
                  target.sys.wake(GetFastValue(config2, "data"));
                } else {
                  this.manager.start(key, GetFastValue(config2, "data"));
                }
                var onStartCallback = GetFastValue(config2, "onStart", null);
                var onStartScope = GetFastValue(config2, "onStartScope", this.scene);
                if (onStartCallback) {
                  onStartCallback.call(onStartScope, this.scene, target, duration);
                }
                this.systems.events.emit(Events.TRANSITION_OUT, target, duration);
                return true;
              },
              checkValidTransition: function(target) {
                if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning()) {
                  return false;
                }
                return true;
              },
              step: function(time, delta) {
                this._elapsed += delta;
                this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
                }
                if (this._elapsed >= this._duration) {
                  this.transitionComplete();
                }
              },
              transitionComplete: function() {
                var targetSys = this._target.sys;
                var targetSettings = this._target.sys.settings;
                targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);
                targetSettings.isTransition = false;
                targetSettings.transitionFrom = null;
                this._duration = 0;
                this._target = null;
                this._onUpdate = null;
                this._onUpdateScope = null;
                if (this._willRemove) {
                  this.manager.remove(this.key);
                } else if (this._willSleep) {
                  this.systems.sleep();
                } else {
                  this.manager.stop(this.key);
                }
              },
              add: function(key, sceneConfig, autoStart, data) {
                return this.manager.add(key, sceneConfig, autoStart, data);
              },
              launch: function(key, data) {
                if (key && key !== this.key) {
                  this.manager.queueOp("start", key, data);
                }
                return this;
              },
              run: function(key, data) {
                if (key && key !== this.key) {
                  this.manager.queueOp("run", key, data);
                }
                return this;
              },
              pause: function(key, data) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.queueOp("pause", key, data);
                return this;
              },
              resume: function(key, data) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.queueOp("resume", key, data);
                return this;
              },
              sleep: function(key, data) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.queueOp("sleep", key, data);
                return this;
              },
              wake: function(key, data) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.queueOp("wake", key, data);
                return this;
              },
              switch: function(key) {
                if (key !== this.key) {
                  this.manager.queueOp("switch", this.key, key);
                }
                return this;
              },
              stop: function(key, data) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.queueOp("stop", key, data);
                return this;
              },
              setActive: function(value, key, data) {
                if (key === void 0) {
                  key = this.key;
                }
                var scene = this.manager.getScene(key);
                if (scene) {
                  scene.sys.setActive(value, data);
                }
                return this;
              },
              setVisible: function(value, key) {
                if (key === void 0) {
                  key = this.key;
                }
                var scene = this.manager.getScene(key);
                if (scene) {
                  scene.sys.setVisible(value);
                }
                return this;
              },
              isSleeping: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                return this.manager.isSleeping(key);
              },
              isActive: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                return this.manager.isActive(key);
              },
              isPaused: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                return this.manager.isPaused(key);
              },
              isVisible: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                return this.manager.isVisible(key);
              },
              swapPosition: function(keyA, keyB) {
                if (keyB === void 0) {
                  keyB = this.key;
                }
                if (keyA !== keyB) {
                  this.manager.swapPosition(keyA, keyB);
                }
                return this;
              },
              moveAbove: function(keyA, keyB) {
                if (keyB === void 0) {
                  keyB = this.key;
                }
                if (keyA !== keyB) {
                  this.manager.moveAbove(keyA, keyB);
                }
                return this;
              },
              moveBelow: function(keyA, keyB) {
                if (keyB === void 0) {
                  keyB = this.key;
                }
                if (keyA !== keyB) {
                  this.manager.moveBelow(keyA, keyB);
                }
                return this;
              },
              remove: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.remove(key);
                return this;
              },
              moveUp: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.moveUp(key);
                return this;
              },
              moveDown: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.moveDown(key);
                return this;
              },
              bringToTop: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.bringToTop(key);
                return this;
              },
              sendToBack: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                this.manager.sendToBack(key);
                return this;
              },
              get: function(key) {
                return this.manager.getScene(key);
              },
              getStatus: function(key) {
                var scene = this.manager.getScene(key);
                if (scene) {
                  return scene.sys.getStatus();
                }
              },
              getIndex: function(key) {
                if (key === void 0) {
                  key = this.key;
                }
                return this.manager.getIndex(key);
              },
              shutdown: function() {
                var eventEmitter = this.systems.events;
                eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);
                eventEmitter.off(Events.TRANSITION_OUT);
              },
              destroy: function() {
                this.shutdown();
                this.scene.sys.events.off(Events.START, this.start, this);
                this.scene = null;
                this.systems = null;
                this.settings = null;
                this.manager = null;
              }
            });
            PluginCache.register("ScenePlugin", ScenePlugin, "scenePlugin");
            module2.exports = ScenePlugin;
          },
          36765: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(92980);
            var GetValue = __webpack_require__2(10850);
            var Merge = __webpack_require__2(30657);
            var InjectionMap = __webpack_require__2(90415);
            var Settings = {
              create: function(config2) {
                if (typeof config2 === "string") {
                  config2 = {key: config2};
                } else if (config2 === void 0) {
                  config2 = {};
                }
                return {
                  status: CONST.PENDING,
                  key: GetValue(config2, "key", ""),
                  active: GetValue(config2, "active", false),
                  visible: GetValue(config2, "visible", true),
                  isBooted: false,
                  isTransition: false,
                  transitionFrom: null,
                  transitionDuration: 0,
                  transitionAllowInput: true,
                  data: {},
                  pack: GetValue(config2, "pack", false),
                  cameras: GetValue(config2, "cameras", null),
                  map: GetValue(config2, "map", Merge(InjectionMap, GetValue(config2, "mapAdd", {}))),
                  physics: GetValue(config2, "physics", {}),
                  loader: GetValue(config2, "loader", {}),
                  plugins: GetValue(config2, "plugins", false),
                  input: GetValue(config2, "input", {})
                };
              }
            };
            module2.exports = Settings;
          },
          63946: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(92980);
            var DefaultPlugins = __webpack_require__2(18360);
            var Events = __webpack_require__2(7599);
            var GetPhysicsPlugins = __webpack_require__2(47736);
            var GetScenePlugins = __webpack_require__2(91088);
            var NOOP = __webpack_require__2(72283);
            var Settings = __webpack_require__2(36765);
            var Systems = new Class({
              initialize: function Systems2(scene, config2) {
                this.scene = scene;
                this.game;
                this.renderer;
                if (false) {
                }
                this.config = config2;
                this.settings = Settings.create(config2);
                this.canvas;
                this.context;
                this.anims;
                this.cache;
                this.plugins;
                this.registry;
                this.scale;
                this.sound;
                this.textures;
                this.add;
                this.cameras;
                this.displayList;
                this.events;
                this.make;
                this.scenePlugin;
                this.updateList;
                this.sceneUpdate = NOOP;
              },
              init: function(game) {
                this.settings.status = CONST.INIT;
                this.sceneUpdate = NOOP;
                this.game = game;
                this.renderer = game.renderer;
                this.canvas = game.canvas;
                this.context = game.context;
                var pluginManager = game.plugins;
                this.plugins = pluginManager;
                pluginManager.addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]);
                this.events.emit(Events.BOOT, this);
                this.settings.isBooted = true;
              },
              step: function(time, delta) {
                var events = this.events;
                events.emit(Events.PRE_UPDATE, time, delta);
                events.emit(Events.UPDATE, time, delta);
                this.sceneUpdate.call(this.scene, time, delta);
                events.emit(Events.POST_UPDATE, time, delta);
              },
              render: function(renderer) {
                var displayList = this.displayList;
                displayList.depthSort();
                this.events.emit(Events.PRE_RENDER, renderer);
                this.cameras.render(renderer, displayList);
                this.events.emit(Events.RENDER, renderer);
              },
              queueDepthSort: function() {
                this.displayList.queueDepthSort();
              },
              depthSort: function() {
                this.displayList.depthSort();
              },
              pause: function(data) {
                var settings = this.settings;
                var status = this.getStatus();
                if (status !== CONST.CREATING && status !== CONST.RUNNING) {
                  console.warn("Cannot pause non-running Scene", settings.key);
                } else if (this.settings.active) {
                  settings.status = CONST.PAUSED;
                  settings.active = false;
                  this.events.emit(Events.PAUSE, this, data);
                }
                return this;
              },
              resume: function(data) {
                var events = this.events;
                var settings = this.settings;
                if (!this.settings.active) {
                  settings.status = CONST.RUNNING;
                  settings.active = true;
                  events.emit(Events.RESUME, this, data);
                }
                return this;
              },
              sleep: function(data) {
                var settings = this.settings;
                var status = this.getStatus();
                if (status !== CONST.CREATING && status !== CONST.RUNNING) {
                  console.warn("Cannot sleep non-running Scene", settings.key);
                } else {
                  settings.status = CONST.SLEEPING;
                  settings.active = false;
                  settings.visible = false;
                  this.events.emit(Events.SLEEP, this, data);
                }
                return this;
              },
              wake: function(data) {
                var events = this.events;
                var settings = this.settings;
                settings.status = CONST.RUNNING;
                settings.active = true;
                settings.visible = true;
                events.emit(Events.WAKE, this, data);
                if (settings.isTransition) {
                  events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);
                }
                return this;
              },
              getData: function() {
                return this.settings.data;
              },
              getStatus: function() {
                return this.settings.status;
              },
              canInput: function() {
                var status = this.settings.status;
                return status > CONST.PENDING && status <= CONST.RUNNING;
              },
              isSleeping: function() {
                return this.settings.status === CONST.SLEEPING;
              },
              isActive: function() {
                return this.settings.status === CONST.RUNNING;
              },
              isPaused: function() {
                return this.settings.status === CONST.PAUSED;
              },
              isTransitioning: function() {
                return this.settings.isTransition || this.scenePlugin._target !== null;
              },
              isTransitionOut: function() {
                return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;
              },
              isTransitionIn: function() {
                return this.settings.isTransition;
              },
              isVisible: function() {
                return this.settings.visible;
              },
              setVisible: function(value) {
                this.settings.visible = value;
                return this;
              },
              setActive: function(value, data) {
                if (value) {
                  return this.resume(data);
                } else {
                  return this.pause(data);
                }
              },
              start: function(data) {
                var events = this.events;
                var settings = this.settings;
                if (data) {
                  settings.data = data;
                }
                settings.status = CONST.START;
                settings.active = true;
                settings.visible = true;
                events.emit(Events.START, this);
                events.emit(Events.READY, this, data);
              },
              shutdown: function(data) {
                var events = this.events;
                var settings = this.settings;
                events.off(Events.TRANSITION_INIT);
                events.off(Events.TRANSITION_START);
                events.off(Events.TRANSITION_COMPLETE);
                events.off(Events.TRANSITION_OUT);
                settings.status = CONST.SHUTDOWN;
                settings.active = false;
                settings.visible = false;
                events.emit(Events.SHUTDOWN, this, data);
              },
              destroy: function() {
                var events = this.events;
                var settings = this.settings;
                settings.status = CONST.DESTROYED;
                settings.active = false;
                settings.visible = false;
                events.emit(Events.DESTROY, this);
                events.removeAllListeners();
                var props = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"];
                for (var i = 0; i < props.length; i++) {
                  this[props[i]] = null;
                }
              }
            });
            module2.exports = Systems;
          },
          92980: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = {
              PENDING: 0,
              INIT: 1,
              START: 2,
              LOADING: 3,
              CREATING: 4,
              RUNNING: 5,
              PAUSED: 6,
              SLEEPING: 7,
              SHUTDOWN: 8,
              DESTROYED: 9
            };
            module2.exports = CONST;
          },
          31803: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "addedtoscene";
          },
          94817: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "boot";
          },
          28977: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "create";
          },
          91959: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "destroy";
          },
          363: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pause";
          },
          15643: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "postupdate";
          },
          17058: (module2) => {
            /**
             * @author       samme
             * @copyright    2021 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "prerender";
          },
          77125: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "preupdate";
          },
          76018: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "ready";
          },
          28620: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "removedfromscene";
          },
          41538: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "render";
          },
          34268: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resume";
          },
          2342: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "shutdown";
          },
          96541: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "sleep";
          },
          74244: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "start";
          },
          17046: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "transitioncomplete";
          },
          13637: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "transitioninit";
          },
          14733: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "transitionout";
          },
          33899: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "transitionstart";
          },
          52418: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "transitionwake";
          },
          31735: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "update";
          },
          8470: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "wake";
          },
          7599: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ADDED_TO_SCENE: __webpack_require__2(31803),
              BOOT: __webpack_require__2(94817),
              CREATE: __webpack_require__2(28977),
              DESTROY: __webpack_require__2(91959),
              PAUSE: __webpack_require__2(363),
              POST_UPDATE: __webpack_require__2(15643),
              PRE_RENDER: __webpack_require__2(17058),
              PRE_UPDATE: __webpack_require__2(77125),
              READY: __webpack_require__2(76018),
              REMOVED_FROM_SCENE: __webpack_require__2(28620),
              RENDER: __webpack_require__2(41538),
              RESUME: __webpack_require__2(34268),
              SHUTDOWN: __webpack_require__2(2342),
              SLEEP: __webpack_require__2(96541),
              START: __webpack_require__2(74244),
              TRANSITION_COMPLETE: __webpack_require__2(17046),
              TRANSITION_INIT: __webpack_require__2(13637),
              TRANSITION_OUT: __webpack_require__2(14733),
              TRANSITION_START: __webpack_require__2(33899),
              TRANSITION_WAKE: __webpack_require__2(52418),
              UPDATE: __webpack_require__2(31735),
              WAKE: __webpack_require__2(8470)
            };
          },
          20436: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(92980);
            var Extend = __webpack_require__2(98611);
            var Scene6 = {
              Events: __webpack_require__2(7599),
              GetPhysicsPlugins: __webpack_require__2(47736),
              GetScenePlugins: __webpack_require__2(91088),
              SceneManager: __webpack_require__2(13553),
              ScenePlugin: __webpack_require__2(64051),
              Settings: __webpack_require__2(36765),
              Systems: __webpack_require__2(63946)
            };
            Scene6 = Extend(false, Scene6, CONST);
            module2.exports = Scene6;
          },
          25798: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(76038);
            var Extend = __webpack_require__2(98611);
            var NOOP = __webpack_require__2(72283);
            var BaseSound = new Class({
              Extends: EventEmitter,
              initialize: function BaseSound2(manager, key, config2) {
                EventEmitter.call(this);
                this.manager = manager;
                this.key = key;
                this.isPlaying = false;
                this.isPaused = false;
                this.totalRate = 1;
                this.duration = this.duration || 0;
                this.totalDuration = this.totalDuration || 0;
                this.config = {
                  mute: false,
                  volume: 1,
                  rate: 1,
                  detune: 0,
                  seek: 0,
                  loop: false,
                  delay: 0,
                  pan: 0
                };
                this.currentConfig = this.config;
                this.config = Extend(this.config, config2);
                this.markers = {};
                this.currentMarker = null;
                this.pendingRemove = false;
              },
              addMarker: function(marker) {
                if (!marker || !marker.name || typeof marker.name !== "string") {
                  return false;
                }
                if (this.markers[marker.name]) {
                  console.error("addMarker " + marker.name + " already exists in Sound");
                  return false;
                }
                marker = Extend(true, {
                  name: "",
                  start: 0,
                  duration: this.totalDuration - (marker.start || 0),
                  config: {
                    mute: false,
                    volume: 1,
                    rate: 1,
                    detune: 0,
                    seek: 0,
                    loop: false,
                    delay: 0,
                    pan: 0
                  }
                }, marker);
                this.markers[marker.name] = marker;
                return true;
              },
              updateMarker: function(marker) {
                if (!marker || !marker.name || typeof marker.name !== "string") {
                  return false;
                }
                if (!this.markers[marker.name]) {
                  console.warn("Audio Marker: " + marker.name + " missing in Sound: " + this.key);
                  return false;
                }
                this.markers[marker.name] = Extend(true, this.markers[marker.name], marker);
                return true;
              },
              removeMarker: function(markerName) {
                var marker = this.markers[markerName];
                if (!marker) {
                  return null;
                }
                this.markers[markerName] = null;
                return marker;
              },
              play: function(markerName, config2) {
                if (markerName === void 0) {
                  markerName = "";
                }
                if (typeof markerName === "object") {
                  config2 = markerName;
                  markerName = "";
                }
                if (typeof markerName !== "string") {
                  return false;
                }
                if (!markerName) {
                  this.currentMarker = null;
                  this.currentConfig = this.config;
                  this.duration = this.totalDuration;
                } else {
                  if (!this.markers[markerName]) {
                    console.warn("Marker: " + markerName + " missing in Sound: " + this.key);
                    return false;
                  }
                  this.currentMarker = this.markers[markerName];
                  this.currentConfig = this.currentMarker.config;
                  this.duration = this.currentMarker.duration;
                }
                this.resetConfig();
                this.currentConfig = Extend(this.currentConfig, config2);
                this.isPlaying = true;
                this.isPaused = false;
                return true;
              },
              pause: function() {
                if (this.isPaused || !this.isPlaying) {
                  return false;
                }
                this.isPlaying = false;
                this.isPaused = true;
                return true;
              },
              resume: function() {
                if (!this.isPaused || this.isPlaying) {
                  return false;
                }
                this.isPlaying = true;
                this.isPaused = false;
                return true;
              },
              stop: function() {
                if (!this.isPaused && !this.isPlaying) {
                  return false;
                }
                this.isPlaying = false;
                this.isPaused = false;
                this.resetConfig();
                return true;
              },
              applyConfig: function() {
                this.mute = this.currentConfig.mute;
                this.volume = this.currentConfig.volume;
                this.rate = this.currentConfig.rate;
                this.detune = this.currentConfig.detune;
                this.loop = this.currentConfig.loop;
                this.pan = this.currentConfig.pan;
              },
              resetConfig: function() {
                this.currentConfig.seek = 0;
                this.currentConfig.delay = 0;
              },
              update: NOOP,
              calculateRate: function() {
                var cent = 1.0005777895065548;
                var totalDetune = this.currentConfig.detune + this.manager.detune;
                var detuneRate = Math.pow(cent, totalDetune);
                this.totalRate = this.currentConfig.rate * this.manager.rate * detuneRate;
              },
              destroy: function() {
                if (this.pendingRemove) {
                  return;
                }
                this.stop();
                this.emit(Events.DESTROY, this);
                this.removeAllListeners();
                this.pendingRemove = true;
                this.manager = null;
                this.config = null;
                this.currentConfig = null;
                this.markers = null;
                this.currentMarker = null;
              }
            });
            module2.exports = BaseSound;
          },
          12486: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Clone = __webpack_require__2(32742);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(76038);
            var GameEvents = __webpack_require__2(97081);
            var GetAll = __webpack_require__2(71608);
            var GetFirst = __webpack_require__2(51463);
            var NOOP = __webpack_require__2(72283);
            var Vector2 = __webpack_require__2(93736);
            var BaseSoundManager = new Class({
              Extends: EventEmitter,
              initialize: function BaseSoundManager2(game) {
                EventEmitter.call(this);
                this.game = game;
                this.jsonCache = game.cache.json;
                this.sounds = [];
                this.mute = false;
                this.volume = 1;
                this.pauseOnBlur = true;
                this._rate = 1;
                this._detune = 0;
                this.locked = this.locked || false;
                this.unlocked = false;
                this.gameLostFocus = false;
                this.listenerPosition = new Vector2();
                game.events.on(GameEvents.BLUR, this.onGameBlur, this);
                game.events.on(GameEvents.FOCUS, this.onGameFocus, this);
                game.events.on(GameEvents.PRE_STEP, this.update, this);
                game.events.once(GameEvents.DESTROY, this.destroy, this);
              },
              add: NOOP,
              addAudioSprite: function(key, config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                var sound = this.add(key, config2);
                sound.spritemap = this.jsonCache.get(key).spritemap;
                for (var markerName in sound.spritemap) {
                  if (!sound.spritemap.hasOwnProperty(markerName)) {
                    continue;
                  }
                  var markerConfig = Clone(config2);
                  var marker = sound.spritemap[markerName];
                  markerConfig.loop = marker.hasOwnProperty("loop") ? marker.loop : false;
                  sound.addMarker({
                    name: markerName,
                    start: marker.start,
                    duration: marker.end - marker.start,
                    config: markerConfig
                  });
                }
                return sound;
              },
              get: function(key) {
                return GetFirst(this.sounds, "key", key);
              },
              getAll: function(key) {
                if (key) {
                  return GetAll(this.sounds, "key", key);
                } else {
                  return GetAll(this.sounds);
                }
              },
              getAllPlaying: function() {
                return GetAll(this.sounds, "isPlaying", true);
              },
              play: function(key, extra) {
                var sound = this.add(key);
                sound.once(Events.COMPLETE, sound.destroy, sound);
                if (extra) {
                  if (extra.name) {
                    sound.addMarker(extra);
                    return sound.play(extra.name);
                  } else {
                    return sound.play(extra);
                  }
                } else {
                  return sound.play();
                }
              },
              playAudioSprite: function(key, spriteName, config2) {
                var sound = this.addAudioSprite(key);
                sound.once(Events.COMPLETE, sound.destroy, sound);
                return sound.play(spriteName, config2);
              },
              remove: function(sound) {
                var index = this.sounds.indexOf(sound);
                if (index !== -1) {
                  sound.destroy();
                  this.sounds.splice(index, 1);
                  return true;
                }
                return false;
              },
              removeAll: function() {
                this.sounds.forEach(function(sound) {
                  sound.destroy();
                });
                this.sounds.length = 0;
              },
              removeByKey: function(key) {
                var removed = 0;
                for (var i = this.sounds.length - 1; i >= 0; i--) {
                  var sound = this.sounds[i];
                  if (sound.key === key) {
                    sound.destroy();
                    this.sounds.splice(i, 1);
                    removed++;
                  }
                }
                return removed;
              },
              pauseAll: function() {
                this.forEachActiveSound(function(sound) {
                  sound.pause();
                });
                this.emit(Events.PAUSE_ALL, this);
              },
              resumeAll: function() {
                this.forEachActiveSound(function(sound) {
                  sound.resume();
                });
                this.emit(Events.RESUME_ALL, this);
              },
              setListenerPosition: NOOP,
              stopAll: function() {
                this.forEachActiveSound(function(sound) {
                  sound.stop();
                });
                this.emit(Events.STOP_ALL, this);
              },
              stopByKey: function(key) {
                var stopped = 0;
                this.getAll(key).forEach(function(sound) {
                  if (sound.stop()) {
                    stopped++;
                  }
                });
                return stopped;
              },
              unlock: NOOP,
              onBlur: NOOP,
              onFocus: NOOP,
              onGameBlur: function() {
                this.gameLostFocus = true;
                if (this.pauseOnBlur) {
                  this.onBlur();
                }
              },
              onGameFocus: function() {
                this.gameLostFocus = false;
                if (this.pauseOnBlur) {
                  this.onFocus();
                }
              },
              update: function(time, delta) {
                if (this.unlocked) {
                  this.unlocked = false;
                  this.locked = false;
                  this.emit(Events.UNLOCKED, this);
                }
                for (var i = this.sounds.length - 1; i >= 0; i--) {
                  if (this.sounds[i].pendingRemove) {
                    this.sounds.splice(i, 1);
                  }
                }
                this.sounds.forEach(function(sound) {
                  sound.update(time, delta);
                });
              },
              destroy: function() {
                this.game.events.off(GameEvents.BLUR, this.onGameBlur, this);
                this.game.events.off(GameEvents.FOCUS, this.onGameFocus, this);
                this.game.events.off(GameEvents.PRE_STEP, this.update, this);
                this.removeAllListeners();
                this.removeAll();
                this.sounds.length = 0;
                this.sounds = null;
                this.listenerPosition = null;
                this.game = null;
              },
              forEachActiveSound: function(callback, scope) {
                var _this = this;
                this.sounds.forEach(function(sound, index) {
                  if (sound && !sound.pendingRemove) {
                    callback.call(scope || _this, sound, index, _this.sounds);
                  }
                });
              },
              setRate: function(value) {
                this.rate = value;
                return this;
              },
              rate: {
                get: function() {
                  return this._rate;
                },
                set: function(value) {
                  this._rate = value;
                  this.forEachActiveSound(function(sound) {
                    sound.calculateRate();
                  });
                  this.emit(Events.GLOBAL_RATE, this, value);
                }
              },
              setDetune: function(value) {
                this.detune = value;
                return this;
              },
              detune: {
                get: function() {
                  return this._detune;
                },
                set: function(value) {
                  this._detune = value;
                  this.forEachActiveSound(function(sound) {
                    sound.calculateRate();
                  });
                  this.emit(Events.GLOBAL_DETUNE, this, value);
                }
              }
            });
            module2.exports = BaseSoundManager;
          },
          84191: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HTML5AudioSoundManager = __webpack_require__2(27622);
            var NoAudioSoundManager = __webpack_require__2(17546);
            var WebAudioSoundManager = __webpack_require__2(55491);
            var SoundManagerCreator = {
              create: function(game) {
                var audioConfig = game.config.audio;
                var deviceAudio = game.device.audio;
                if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
                  return new NoAudioSoundManager(game);
                }
                if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
                  return new WebAudioSoundManager(game);
                }
                return new HTML5AudioSoundManager(game);
              }
            };
            module2.exports = SoundManagerCreator;
          },
          77578: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "complete";
          },
          19679: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "decodedall";
          },
          56951: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "decoded";
          },
          16436: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "destroy";
          },
          55154: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "detune";
          },
          57818: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "detune";
          },
          57890: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "mute";
          },
          83022: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "rate";
          },
          99170: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "volume";
          },
          64289: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "looped";
          },
          67214: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "loop";
          },
          53128: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "mute";
          },
          73078: (module2) => {
            /**
             * @author       pi-kei
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pan";
          },
          76763: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pauseall";
          },
          88426: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pause";
          },
          13765: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "play";
          },
          80291: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "rate";
          },
          11124: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resumeall";
          },
          55382: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resume";
          },
          71157: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "seek";
          },
          31776: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "stopall";
          },
          39450: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "stop";
          },
          21939: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "unlocked";
          },
          33019: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "volume";
          },
          76038: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              COMPLETE: __webpack_require__2(77578),
              DECODED: __webpack_require__2(56951),
              DECODED_ALL: __webpack_require__2(19679),
              DESTROY: __webpack_require__2(16436),
              DETUNE: __webpack_require__2(55154),
              GLOBAL_DETUNE: __webpack_require__2(57818),
              GLOBAL_MUTE: __webpack_require__2(57890),
              GLOBAL_RATE: __webpack_require__2(83022),
              GLOBAL_VOLUME: __webpack_require__2(99170),
              LOOP: __webpack_require__2(67214),
              LOOPED: __webpack_require__2(64289),
              MUTE: __webpack_require__2(53128),
              PAN: __webpack_require__2(73078),
              PAUSE_ALL: __webpack_require__2(76763),
              PAUSE: __webpack_require__2(88426),
              PLAY: __webpack_require__2(13765),
              RATE: __webpack_require__2(80291),
              RESUME_ALL: __webpack_require__2(11124),
              RESUME: __webpack_require__2(55382),
              SEEK: __webpack_require__2(71157),
              STOP_ALL: __webpack_require__2(31776),
              STOP: __webpack_require__2(39450),
              UNLOCKED: __webpack_require__2(21939),
              VOLUME: __webpack_require__2(33019)
            };
          },
          34350: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseSound = __webpack_require__2(25798);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(76038);
            var Clamp = __webpack_require__2(82897);
            var HTML5AudioSound = new Class({
              Extends: BaseSound,
              initialize: function HTML5AudioSound2(manager, key, config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                this.tags = manager.game.cache.audio.get(key);
                if (!this.tags) {
                  throw new Error('No cached audio asset with key "' + key);
                }
                this.audio = null;
                this.startTime = 0;
                this.previousTime = 0;
                this.duration = this.tags[0].duration;
                this.totalDuration = this.tags[0].duration;
                BaseSound.call(this, manager, key, config2);
              },
              play: function(markerName, config2) {
                if (this.manager.isLocked(this, "play", [markerName, config2])) {
                  return false;
                }
                if (!BaseSound.prototype.play.call(this, markerName, config2)) {
                  return false;
                }
                if (!this.pickAndPlayAudioTag()) {
                  return false;
                }
                this.emit(Events.PLAY, this);
                return true;
              },
              pause: function() {
                if (this.manager.isLocked(this, "pause")) {
                  return false;
                }
                if (this.startTime > 0) {
                  return false;
                }
                if (!BaseSound.prototype.pause.call(this)) {
                  return false;
                }
                this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
                this.stopAndReleaseAudioTag();
                this.emit(Events.PAUSE, this);
                return true;
              },
              resume: function() {
                if (this.manager.isLocked(this, "resume")) {
                  return false;
                }
                if (this.startTime > 0) {
                  return false;
                }
                if (!BaseSound.prototype.resume.call(this)) {
                  return false;
                }
                if (!this.pickAndPlayAudioTag()) {
                  return false;
                }
                this.emit(Events.RESUME, this);
                return true;
              },
              stop: function() {
                if (this.manager.isLocked(this, "stop")) {
                  return false;
                }
                if (!BaseSound.prototype.stop.call(this)) {
                  return false;
                }
                this.stopAndReleaseAudioTag();
                this.emit(Events.STOP, this);
                return true;
              },
              pickAndPlayAudioTag: function() {
                if (!this.pickAudioTag()) {
                  this.reset();
                  return false;
                }
                var seek = this.currentConfig.seek;
                var delay = this.currentConfig.delay;
                var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
                this.previousTime = offset;
                this.audio.currentTime = offset;
                this.applyConfig();
                if (delay === 0) {
                  this.startTime = 0;
                  if (this.audio.paused) {
                    this.playCatchPromise();
                  }
                } else {
                  this.startTime = window.performance.now() + delay * 1e3;
                  if (!this.audio.paused) {
                    this.audio.pause();
                  }
                }
                this.resetConfig();
                return true;
              },
              pickAudioTag: function() {
                if (this.audio) {
                  return true;
                }
                for (var i = 0; i < this.tags.length; i++) {
                  var audio = this.tags[i];
                  if (audio.dataset.used === "false") {
                    audio.dataset.used = "true";
                    this.audio = audio;
                    return true;
                  }
                }
                if (!this.manager.override) {
                  return false;
                }
                var otherSounds = [];
                this.manager.forEachActiveSound(function(sound) {
                  if (sound.key === this.key && sound.audio) {
                    otherSounds.push(sound);
                  }
                }, this);
                otherSounds.sort(function(a1, a2) {
                  if (a1.loop === a2.loop) {
                    return a2.seek / a2.duration - a1.seek / a1.duration;
                  }
                  return a1.loop ? 1 : -1;
                });
                var selectedSound = otherSounds[0];
                this.audio = selectedSound.audio;
                selectedSound.reset();
                selectedSound.audio = null;
                selectedSound.startTime = 0;
                selectedSound.previousTime = 0;
                return true;
              },
              playCatchPromise: function() {
                var playPromise = this.audio.play();
                if (playPromise) {
                  playPromise.catch(function(reason) {
                    console.warn(reason);
                  });
                }
              },
              stopAndReleaseAudioTag: function() {
                this.startTime = 0;
                this.previousTime = 0;
                if (this.audio) {
                  this.audio.pause();
                  this.audio.dataset.used = "false";
                  this.audio = null;
                }
              },
              reset: function() {
                BaseSound.prototype.stop.call(this);
              },
              onBlur: function() {
                this.isPlaying = false;
                this.isPaused = true;
                this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
                this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3);
                this.stopAndReleaseAudioTag();
              },
              onFocus: function() {
                this.isPlaying = true;
                this.isPaused = false;
                this.pickAndPlayAudioTag();
              },
              update: function(time) {
                if (!this.isPlaying) {
                  return;
                }
                if (this.startTime > 0) {
                  if (this.startTime < time - this.manager.audioPlayDelay) {
                    this.audio.currentTime += Math.max(0, time - this.startTime) / 1e3;
                    this.startTime = 0;
                    this.previousTime = this.audio.currentTime;
                    this.playCatchPromise();
                  }
                  return;
                }
                var startTime = this.currentMarker ? this.currentMarker.start : 0;
                var endTime = startTime + this.duration;
                var currentTime = this.audio.currentTime;
                if (this.currentConfig.loop) {
                  if (currentTime >= endTime - this.manager.loopEndOffset) {
                    this.audio.currentTime = startTime + Math.max(0, currentTime - endTime);
                    currentTime = this.audio.currentTime;
                  } else if (currentTime < startTime) {
                    this.audio.currentTime += startTime;
                    currentTime = this.audio.currentTime;
                  }
                  if (currentTime < this.previousTime) {
                    this.emit(Events.LOOPED, this);
                  }
                } else if (currentTime >= endTime) {
                  this.reset();
                  this.stopAndReleaseAudioTag();
                  this.emit(Events.COMPLETE, this);
                  return;
                }
                this.previousTime = currentTime;
              },
              destroy: function() {
                BaseSound.prototype.destroy.call(this);
                this.tags = null;
                if (this.audio) {
                  this.stopAndReleaseAudioTag();
                }
              },
              updateMute: function() {
                if (this.audio) {
                  this.audio.muted = this.currentConfig.mute || this.manager.mute;
                }
              },
              updateVolume: function() {
                if (this.audio) {
                  this.audio.volume = Clamp(this.currentConfig.volume * this.manager.volume, 0, 1);
                }
              },
              calculateRate: function() {
                BaseSound.prototype.calculateRate.call(this);
                if (this.audio) {
                  this.audio.playbackRate = this.totalRate;
                }
              },
              mute: {
                get: function() {
                  return this.currentConfig.mute;
                },
                set: function(value) {
                  this.currentConfig.mute = value;
                  if (this.manager.isLocked(this, "mute", value)) {
                    return;
                  }
                  this.updateMute();
                  this.emit(Events.MUTE, this, value);
                }
              },
              setMute: function(value) {
                this.mute = value;
                return this;
              },
              volume: {
                get: function() {
                  return this.currentConfig.volume;
                },
                set: function(value) {
                  this.currentConfig.volume = value;
                  if (this.manager.isLocked(this, "volume", value)) {
                    return;
                  }
                  this.updateVolume();
                  this.emit(Events.VOLUME, this, value);
                }
              },
              setVolume: function(value) {
                this.volume = value;
                return this;
              },
              rate: {
                get: function() {
                  return this.currentConfig.rate;
                },
                set: function(value) {
                  this.currentConfig.rate = value;
                  if (this.manager.isLocked(this, Events.RATE, value)) {
                    return;
                  } else {
                    this.calculateRate();
                    this.emit(Events.RATE, this, value);
                  }
                }
              },
              setRate: function(value) {
                this.rate = value;
                return this;
              },
              detune: {
                get: function() {
                  return this.currentConfig.detune;
                },
                set: function(value) {
                  this.currentConfig.detune = value;
                  if (this.manager.isLocked(this, Events.DETUNE, value)) {
                    return;
                  } else {
                    this.calculateRate();
                    this.emit(Events.DETUNE, this, value);
                  }
                }
              },
              setDetune: function(value) {
                this.detune = value;
                return this;
              },
              seek: {
                get: function() {
                  if (this.isPlaying) {
                    return this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
                  } else if (this.isPaused) {
                    return this.currentConfig.seek;
                  } else {
                    return 0;
                  }
                },
                set: function(value) {
                  if (this.manager.isLocked(this, "seek", value)) {
                    return;
                  }
                  if (this.startTime > 0) {
                    return;
                  }
                  if (this.isPlaying || this.isPaused) {
                    value = Math.min(Math.max(0, value), this.duration);
                    if (this.isPlaying) {
                      this.previousTime = value;
                      this.audio.currentTime = value;
                    } else if (this.isPaused) {
                      this.currentConfig.seek = value;
                    }
                    this.emit(Events.SEEK, this, value);
                  }
                }
              },
              setSeek: function(value) {
                this.seek = value;
                return this;
              },
              loop: {
                get: function() {
                  return this.currentConfig.loop;
                },
                set: function(value) {
                  this.currentConfig.loop = value;
                  if (this.manager.isLocked(this, "loop", value)) {
                    return;
                  }
                  if (this.audio) {
                    this.audio.loop = value;
                  }
                  this.emit(Events.LOOP, this, value);
                }
              },
              setLoop: function(value) {
                this.loop = value;
                return this;
              },
              pan: {
                get: function() {
                  return this.currentConfig.pan;
                },
                set: function(value) {
                  this.currentConfig.pan = value;
                  this.emit(Events.PAN, this, value);
                }
              },
              setPan: function(value) {
                this.pan = value;
                return this;
              }
            });
            module2.exports = HTML5AudioSound;
          },
          27622: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseSoundManager = __webpack_require__2(12486);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(76038);
            var HTML5AudioSound = __webpack_require__2(34350);
            var HTML5AudioSoundManager = new Class({
              Extends: BaseSoundManager,
              initialize: function HTML5AudioSoundManager2(game) {
                this.override = true;
                this.audioPlayDelay = 0.1;
                this.loopEndOffset = 0.05;
                this.onBlurPausedSounds = [];
                this.locked = "ontouchstart" in window;
                this.lockedActionsQueue = this.locked ? [] : null;
                this._mute = false;
                this._volume = 1;
                BaseSoundManager.call(this, game);
              },
              add: function(key, config2) {
                var sound = new HTML5AudioSound(this, key, config2);
                this.sounds.push(sound);
                return sound;
              },
              unlock: function() {
                this.locked = false;
                var _this = this;
                this.game.cache.audio.entries.each(function(key, tags) {
                  for (var i = 0; i < tags.length; i++) {
                    if (tags[i].dataset.locked === "true") {
                      _this.locked = true;
                      return false;
                    }
                  }
                  return true;
                });
                if (!this.locked) {
                  return;
                }
                var moved = false;
                var detectMove = function() {
                  moved = true;
                };
                var unlock = function() {
                  if (moved) {
                    moved = false;
                    return;
                  }
                  document.body.removeEventListener("touchmove", detectMove);
                  document.body.removeEventListener("touchend", unlock);
                  var lockedTags = [];
                  _this.game.cache.audio.entries.each(function(key, tags) {
                    for (var i = 0; i < tags.length; i++) {
                      var tag = tags[i];
                      if (tag.dataset.locked === "true") {
                        lockedTags.push(tag);
                      }
                    }
                    return true;
                  });
                  if (lockedTags.length === 0) {
                    return;
                  }
                  var lastTag = lockedTags[lockedTags.length - 1];
                  lastTag.oncanplaythrough = function() {
                    lastTag.oncanplaythrough = null;
                    lockedTags.forEach(function(tag) {
                      tag.dataset.locked = "false";
                    });
                    _this.unlocked = true;
                  };
                  lockedTags.forEach(function(tag) {
                    tag.load();
                  });
                };
                this.once(Events.UNLOCKED, function() {
                  this.forEachActiveSound(function(sound) {
                    if (sound.currentMarker === null && sound.duration === 0) {
                      sound.duration = sound.tags[0].duration;
                    }
                    sound.totalDuration = sound.tags[0].duration;
                  });
                  while (this.lockedActionsQueue.length) {
                    var lockedAction = this.lockedActionsQueue.shift();
                    if (lockedAction.sound[lockedAction.prop].apply) {
                      lockedAction.sound[lockedAction.prop].apply(lockedAction.sound, lockedAction.value || []);
                    } else {
                      lockedAction.sound[lockedAction.prop] = lockedAction.value;
                    }
                  }
                }, this);
                document.body.addEventListener("touchmove", detectMove, false);
                document.body.addEventListener("touchend", unlock, false);
              },
              onBlur: function() {
                this.forEachActiveSound(function(sound) {
                  if (sound.isPlaying) {
                    this.onBlurPausedSounds.push(sound);
                    sound.onBlur();
                  }
                });
              },
              onFocus: function() {
                this.onBlurPausedSounds.forEach(function(sound) {
                  sound.onFocus();
                });
                this.onBlurPausedSounds.length = 0;
              },
              destroy: function() {
                BaseSoundManager.prototype.destroy.call(this);
                this.onBlurPausedSounds.length = 0;
                this.onBlurPausedSounds = null;
              },
              isLocked: function(sound, prop, value) {
                if (sound.tags[0].dataset.locked === "true") {
                  this.lockedActionsQueue.push({
                    sound,
                    prop,
                    value
                  });
                  return true;
                }
                return false;
              },
              setMute: function(value) {
                this.mute = value;
                return this;
              },
              mute: {
                get: function() {
                  return this._mute;
                },
                set: function(value) {
                  this._mute = value;
                  this.forEachActiveSound(function(sound) {
                    sound.updateMute();
                  });
                  this.emit(Events.GLOBAL_MUTE, this, value);
                }
              },
              setVolume: function(value) {
                this.volume = value;
                return this;
              },
              volume: {
                get: function() {
                  return this._volume;
                },
                set: function(value) {
                  this._volume = value;
                  this.forEachActiveSound(function(sound) {
                    sound.updateVolume();
                  });
                  this.emit(Events.GLOBAL_VOLUME, this, value);
                }
              }
            });
            module2.exports = HTML5AudioSoundManager;
          },
          56751: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              SoundManagerCreator: __webpack_require__2(84191),
              Events: __webpack_require__2(76038),
              BaseSound: __webpack_require__2(25798),
              BaseSoundManager: __webpack_require__2(12486),
              WebAudioSound: __webpack_require__2(96008),
              WebAudioSoundManager: __webpack_require__2(55491),
              HTML5AudioSound: __webpack_require__2(34350),
              HTML5AudioSoundManager: __webpack_require__2(27622),
              NoAudioSound: __webpack_require__2(38662),
              NoAudioSoundManager: __webpack_require__2(17546)
            };
          },
          38662: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseSound = __webpack_require__2(25798);
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Extend = __webpack_require__2(98611);
            var NOOP = __webpack_require__2(72283);
            var returnFalse = function() {
              return false;
            };
            var returnNull = function() {
              return null;
            };
            var returnThis = function() {
              return this;
            };
            var NoAudioSound = new Class({
              Extends: EventEmitter,
              initialize: function NoAudioSound2(manager, key, config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                EventEmitter.call(this);
                this.manager = manager;
                this.key = key;
                this.isPlaying = false;
                this.isPaused = false;
                this.totalRate = 1;
                this.duration = 0;
                this.totalDuration = 0;
                this.config = Extend({
                  mute: false,
                  volume: 1,
                  rate: 1,
                  detune: 0,
                  seek: 0,
                  loop: false,
                  delay: 0,
                  pan: 0
                }, config2);
                this.currentConfig = this.config;
                this.mute = false;
                this.volume = 1;
                this.rate = 1;
                this.detune = 0;
                this.seek = 0;
                this.loop = false;
                this.pan = 0;
                this.markers = {};
                this.currentMarker = null;
                this.pendingRemove = false;
              },
              addMarker: returnFalse,
              updateMarker: returnFalse,
              removeMarker: returnNull,
              play: returnFalse,
              pause: returnFalse,
              resume: returnFalse,
              stop: returnFalse,
              setMute: returnThis,
              setVolume: returnThis,
              setRate: returnThis,
              setDetune: returnThis,
              setSeek: returnThis,
              setLoop: returnThis,
              setPan: returnThis,
              applyConfig: returnNull,
              resetConfig: returnNull,
              update: NOOP,
              calculateRate: returnNull,
              destroy: function() {
                BaseSound.prototype.destroy.call(this);
              }
            });
            module2.exports = NoAudioSound;
          },
          17546: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseSoundManager = __webpack_require__2(12486);
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var NoAudioSound = __webpack_require__2(38662);
            var NOOP = __webpack_require__2(72283);
            var NoAudioSoundManager = new Class({
              Extends: EventEmitter,
              initialize: function NoAudioSoundManager2(game) {
                EventEmitter.call(this);
                this.game = game;
                this.sounds = [];
                this.mute = false;
                this.volume = 1;
                this.rate = 1;
                this.detune = 0;
                this.pauseOnBlur = true;
                this.locked = false;
              },
              add: function(key, config2) {
                var sound = new NoAudioSound(this, key, config2);
                this.sounds.push(sound);
                return sound;
              },
              addAudioSprite: function(key, config2) {
                var sound = this.add(key, config2);
                sound.spritemap = {};
                return sound;
              },
              get: function(key) {
                return BaseSoundManager.prototype.get.call(this, key);
              },
              getAll: function(key) {
                return BaseSoundManager.prototype.getAll.call(this, key);
              },
              play: function(key, extra) {
                return false;
              },
              playAudioSprite: function(key, spriteName, config2) {
                return false;
              },
              remove: function(sound) {
                return BaseSoundManager.prototype.remove.call(this, sound);
              },
              removeAll: function() {
                return BaseSoundManager.prototype.removeAll.call(this);
              },
              removeByKey: function(key) {
                return BaseSoundManager.prototype.removeByKey.call(this, key);
              },
              stopByKey: function(key) {
                return BaseSoundManager.prototype.stopByKey.call(this, key);
              },
              onBlur: NOOP,
              onFocus: NOOP,
              onGameBlur: NOOP,
              onGameFocus: NOOP,
              pauseAll: NOOP,
              resumeAll: NOOP,
              stopAll: NOOP,
              update: NOOP,
              setRate: NOOP,
              setDetune: NOOP,
              setMute: NOOP,
              setVolume: NOOP,
              unlock: NOOP,
              forEachActiveSound: function(callbackfn, scope) {
                BaseSoundManager.prototype.forEachActiveSound.call(this, callbackfn, scope);
              },
              destroy: function() {
                BaseSoundManager.prototype.destroy.call(this);
              }
            });
            module2.exports = NoAudioSoundManager;
          },
          96008: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseSound = __webpack_require__2(25798);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(76038);
            var GetFastValue = __webpack_require__2(72632);
            var WebAudioSound = new Class({
              Extends: BaseSound,
              initialize: function WebAudioSound2(manager, key, config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                this.audioBuffer = manager.game.cache.audio.get(key);
                if (!this.audioBuffer) {
                  throw new Error('Audio key "' + key + '" missing from cache');
                }
                this.source = null;
                this.loopSource = null;
                this.muteNode = manager.context.createGain();
                this.volumeNode = manager.context.createGain();
                this.pannerNode = null;
                this.spatialNode = null;
                this.spatialSource = null;
                this.playTime = 0;
                this.startTime = 0;
                this.loopTime = 0;
                this.rateUpdates = [];
                this.hasEnded = false;
                this.hasLooped = false;
                this.muteNode.connect(this.volumeNode);
                if (manager.context.createPanner) {
                  this.spatialNode = manager.context.createPanner();
                  this.volumeNode.connect(this.spatialNode);
                }
                if (manager.context.createStereoPanner) {
                  this.pannerNode = manager.context.createStereoPanner();
                  if (manager.context.createPanner) {
                    this.spatialNode.connect(this.pannerNode);
                  } else {
                    this.volumeNode.connect(this.pannerNode);
                  }
                  this.pannerNode.connect(manager.destination);
                } else if (manager.context.createPanner) {
                  this.spatialNode.connect(manager.destination);
                } else {
                  this.volumeNode.connect(manager.destination);
                }
                this.duration = this.audioBuffer.duration;
                this.totalDuration = this.audioBuffer.duration;
                BaseSound.call(this, manager, key, config2);
              },
              play: function(markerName, config2) {
                if (!BaseSound.prototype.play.call(this, markerName, config2)) {
                  return false;
                }
                this.stopAndRemoveBufferSource();
                this.createAndStartBufferSource();
                this.emit(Events.PLAY, this);
                return true;
              },
              pause: function() {
                if (this.manager.context.currentTime < this.startTime) {
                  return false;
                }
                if (!BaseSound.prototype.pause.call(this)) {
                  return false;
                }
                this.currentConfig.seek = this.getCurrentTime();
                this.stopAndRemoveBufferSource();
                this.emit(Events.PAUSE, this);
                return true;
              },
              resume: function() {
                if (this.manager.context.currentTime < this.startTime) {
                  return false;
                }
                if (!BaseSound.prototype.resume.call(this)) {
                  return false;
                }
                this.createAndStartBufferSource();
                this.emit(Events.RESUME, this);
                return true;
              },
              stop: function() {
                if (!BaseSound.prototype.stop.call(this)) {
                  return false;
                }
                this.stopAndRemoveBufferSource();
                this.emit(Events.STOP, this);
                return true;
              },
              createAndStartBufferSource: function() {
                var seek = this.currentConfig.seek;
                var delay = this.currentConfig.delay;
                var when = this.manager.context.currentTime + delay;
                var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
                var duration = this.duration - seek;
                this.playTime = when - seek;
                this.startTime = when;
                this.source = this.createBufferSource();
                this.applyConfig();
                this.source.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
                this.resetConfig();
              },
              createAndStartLoopBufferSource: function() {
                var when = this.getLoopTime();
                var offset = this.currentMarker ? this.currentMarker.start : 0;
                var duration = this.duration;
                this.loopTime = when;
                this.loopSource = this.createBufferSource();
                this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0);
                this.loopSource.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
              },
              createBufferSource: function() {
                var _this = this;
                var source = this.manager.context.createBufferSource();
                source.buffer = this.audioBuffer;
                source.connect(this.muteNode);
                source.onended = function(ev) {
                  if (ev.target === _this.source) {
                    if (_this.currentConfig.loop) {
                      _this.hasLooped = true;
                    } else {
                      _this.hasEnded = true;
                    }
                  }
                };
                return source;
              },
              stopAndRemoveBufferSource: function() {
                if (this.source) {
                  this.source.stop();
                  this.source.disconnect();
                  this.source = null;
                }
                this.playTime = 0;
                this.startTime = 0;
                this.stopAndRemoveLoopBufferSource();
              },
              stopAndRemoveLoopBufferSource: function() {
                if (this.loopSource) {
                  this.loopSource.stop();
                  this.loopSource.disconnect();
                  this.loopSource = null;
                }
                this.loopTime = 0;
              },
              applyConfig: function() {
                this.rateUpdates.length = 0;
                this.rateUpdates.push({
                  time: 0,
                  rate: 1
                });
                var source = this.currentConfig.source;
                if (source && this.manager.context.createPanner) {
                  var node = this.spatialNode;
                  node.panningModel = GetFastValue(source, "panningModel", "equalpower");
                  node.distanceModel = GetFastValue(source, "distanceModel", "inverse");
                  node.orientationX.value = GetFastValue(source, "orientationX", 0);
                  node.orientationY.value = GetFastValue(source, "orientationY", 0);
                  node.orientationZ.value = GetFastValue(source, "orientationZ", -1);
                  node.refDistance = GetFastValue(source, "refDistance", 1);
                  node.maxDistance = GetFastValue(source, "maxDistance", 1e4);
                  node.rolloffFactor = GetFastValue(source, "rolloffFactor", 1);
                  node.coneInnerAngle = GetFastValue(source, "coneInnerAngle", 360);
                  node.coneOuterAngle = GetFastValue(source, "coneOuterAngle", 0);
                  node.coneOuterGain = GetFastValue(source, "coneOuterGain", 0);
                  this.spatialSource = GetFastValue(source, "follow", null);
                  if (!this.spatialSource) {
                    node.positionX.value = GetFastValue(source, "x", 0);
                    node.positionY.value = GetFastValue(source, "y", 0);
                    node.positionZ.value = GetFastValue(source, "z", 0);
                  }
                }
                BaseSound.prototype.applyConfig.call(this);
              },
              x: {
                get: function() {
                  if (this.spatialNode) {
                    return this.spatialNode.positionX;
                  } else {
                    return 0;
                  }
                },
                set: function(value) {
                  if (this.spatialNode) {
                    this.spatialNode.positionX.value = value;
                  }
                }
              },
              y: {
                get: function() {
                  if (this.spatialNode) {
                    return this.spatialNode.positionY;
                  } else {
                    return 0;
                  }
                },
                set: function(value) {
                  if (this.spatialNode) {
                    this.spatialNode.positionY.value = value;
                  }
                }
              },
              update: function() {
                if (this.isPlaying && this.spatialSource) {
                  var x = GetFastValue(this.spatialSource, "x", null);
                  var y = GetFastValue(this.spatialSource, "y", null);
                  if (x && x !== this._spatialx) {
                    this._spatialx = this.spatialNode.positionX.value = x;
                  }
                  if (y && y !== this._spatialy) {
                    this._spatialy = this.spatialNode.positionY.value = y;
                  }
                }
                if (this.hasEnded) {
                  this.hasEnded = false;
                  BaseSound.prototype.stop.call(this);
                  this.stopAndRemoveBufferSource();
                  this.emit(Events.COMPLETE, this);
                } else if (this.hasLooped) {
                  this.hasLooped = false;
                  this.source = this.loopSource;
                  this.loopSource = null;
                  this.playTime = this.startTime = this.loopTime;
                  this.rateUpdates.length = 0;
                  this.rateUpdates.push({
                    time: 0,
                    rate: this.totalRate
                  });
                  this.createAndStartLoopBufferSource();
                  this.emit(Events.LOOPED, this);
                }
              },
              destroy: function() {
                if (this.pendingRemove) {
                  return;
                }
                BaseSound.prototype.destroy.call(this);
                this.audioBuffer = null;
                this.stopAndRemoveBufferSource();
                this.muteNode.disconnect();
                this.muteNode = null;
                this.volumeNode.disconnect();
                this.volumeNode = null;
                if (this.pannerNode) {
                  this.pannerNode.disconnect();
                  this.pannerNode = null;
                }
                if (this.spatialNode) {
                  this.spatialNode.disconnect();
                  this.spatialNode = null;
                  this.spatialSource = null;
                }
                this.rateUpdates.length = 0;
                this.rateUpdates = null;
              },
              calculateRate: function() {
                BaseSound.prototype.calculateRate.call(this);
                var now = this.manager.context.currentTime;
                if (this.source && typeof this.totalRate === "number") {
                  this.source.playbackRate.setValueAtTime(this.totalRate, now);
                }
                if (this.isPlaying) {
                  this.rateUpdates.push({
                    time: Math.max(this.startTime, now) - this.playTime,
                    rate: this.totalRate
                  });
                  if (this.loopSource) {
                    this.stopAndRemoveLoopBufferSource();
                    this.createAndStartLoopBufferSource();
                  }
                }
              },
              getCurrentTime: function() {
                var currentTime = 0;
                for (var i = 0; i < this.rateUpdates.length; i++) {
                  var nextTime = 0;
                  if (i < this.rateUpdates.length - 1) {
                    nextTime = this.rateUpdates[i + 1].time;
                  } else {
                    nextTime = this.manager.context.currentTime - this.playTime;
                  }
                  currentTime += (nextTime - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
                }
                return currentTime;
              },
              getLoopTime: function() {
                var lastRateUpdateCurrentTime = 0;
                for (var i = 0; i < this.rateUpdates.length - 1; i++) {
                  lastRateUpdateCurrentTime += (this.rateUpdates[i + 1].time - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
                }
                var lastRateUpdate = this.rateUpdates[this.rateUpdates.length - 1];
                return this.playTime + lastRateUpdate.time + (this.duration - lastRateUpdateCurrentTime) / lastRateUpdate.rate;
              },
              rate: {
                get: function() {
                  return this.currentConfig.rate;
                },
                set: function(value) {
                  this.currentConfig.rate = value;
                  this.calculateRate();
                  this.emit(Events.RATE, this, value);
                }
              },
              setRate: function(value) {
                this.rate = value;
                return this;
              },
              detune: {
                get: function() {
                  return this.currentConfig.detune;
                },
                set: function(value) {
                  this.currentConfig.detune = value;
                  this.calculateRate();
                  this.emit(Events.DETUNE, this, value);
                }
              },
              setDetune: function(value) {
                this.detune = value;
                return this;
              },
              mute: {
                get: function() {
                  return this.muteNode.gain.value === 0;
                },
                set: function(value) {
                  this.currentConfig.mute = value;
                  this.muteNode.gain.setValueAtTime(value ? 0 : 1, 0);
                  this.emit(Events.MUTE, this, value);
                }
              },
              setMute: function(value) {
                this.mute = value;
                return this;
              },
              volume: {
                get: function() {
                  return this.volumeNode.gain.value;
                },
                set: function(value) {
                  this.currentConfig.volume = value;
                  this.volumeNode.gain.setValueAtTime(value, 0);
                  this.emit(Events.VOLUME, this, value);
                }
              },
              setVolume: function(value) {
                this.volume = value;
                return this;
              },
              seek: {
                get: function() {
                  if (this.isPlaying) {
                    if (this.manager.context.currentTime < this.startTime) {
                      return this.startTime - this.playTime;
                    }
                    return this.getCurrentTime();
                  } else if (this.isPaused) {
                    return this.currentConfig.seek;
                  } else {
                    return 0;
                  }
                },
                set: function(value) {
                  if (this.manager.context.currentTime < this.startTime) {
                    return;
                  }
                  if (this.isPlaying || this.isPaused) {
                    value = Math.min(Math.max(0, value), this.duration);
                    this.currentConfig.seek = value;
                    if (this.isPlaying) {
                      this.stopAndRemoveBufferSource();
                      this.createAndStartBufferSource();
                    }
                    this.emit(Events.SEEK, this, value);
                  }
                }
              },
              setSeek: function(value) {
                this.seek = value;
                return this;
              },
              loop: {
                get: function() {
                  return this.currentConfig.loop;
                },
                set: function(value) {
                  this.currentConfig.loop = value;
                  if (this.isPlaying) {
                    this.stopAndRemoveLoopBufferSource();
                    if (value) {
                      this.createAndStartLoopBufferSource();
                    }
                  }
                  this.emit(Events.LOOP, this, value);
                }
              },
              setLoop: function(value) {
                this.loop = value;
                return this;
              },
              pan: {
                get: function() {
                  if (this.pannerNode) {
                    return this.pannerNode.pan.value;
                  } else {
                    return 0;
                  }
                },
                set: function(value) {
                  this.currentConfig.pan = value;
                  if (this.pannerNode) {
                    this.pannerNode.pan.setValueAtTime(value, this.manager.context.currentTime);
                  }
                  this.emit(Events.PAN, this, value);
                }
              },
              setPan: function(value) {
                this.pan = value;
                return this;
              }
            });
            module2.exports = WebAudioSound;
          },
          55491: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Base64ToArrayBuffer = __webpack_require__2(82329);
            var BaseSoundManager = __webpack_require__2(12486);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(76038);
            var GameEvents = __webpack_require__2(97081);
            var WebAudioSound = __webpack_require__2(96008);
            var GetFastValue = __webpack_require__2(72632);
            var WebAudioSoundManager = new Class({
              Extends: BaseSoundManager,
              initialize: function WebAudioSoundManager2(game) {
                this.context = this.createAudioContext(game);
                this.masterMuteNode = this.context.createGain();
                this.masterVolumeNode = this.context.createGain();
                this.masterMuteNode.connect(this.masterVolumeNode);
                this.masterVolumeNode.connect(this.context.destination);
                this.destination = this.masterMuteNode;
                this.locked = this.context.state === "suspended" && ("ontouchstart" in window || "onclick" in window);
                BaseSoundManager.call(this, game);
                if (this.locked && game.isBooted) {
                  this.unlock();
                } else {
                  game.events.once(GameEvents.BOOT, this.unlock, this);
                }
              },
              createAudioContext: function(game) {
                var audioConfig = game.config.audio;
                if (audioConfig.context) {
                  audioConfig.context.resume();
                  return audioConfig.context;
                }
                if (window.hasOwnProperty("AudioContext")) {
                  return new AudioContext();
                } else if (window.hasOwnProperty("webkitAudioContext")) {
                  return new window.webkitAudioContext();
                }
              },
              setAudioContext: function(context) {
                if (this.context) {
                  this.context.close();
                }
                if (this.masterMuteNode) {
                  this.masterMuteNode.disconnect();
                }
                if (this.masterVolumeNode) {
                  this.masterVolumeNode.disconnect();
                }
                this.context = context;
                this.masterMuteNode = context.createGain();
                this.masterVolumeNode = context.createGain();
                this.masterMuteNode.connect(this.masterVolumeNode);
                this.masterVolumeNode.connect(context.destination);
                this.destination = this.masterMuteNode;
                return this;
              },
              add: function(key, config2) {
                var sound = new WebAudioSound(this, key, config2);
                this.sounds.push(sound);
                return sound;
              },
              decodeAudio: function(audioKey, audioData) {
                var audioFiles;
                if (!Array.isArray(audioKey)) {
                  audioFiles = [{key: audioKey, data: audioData}];
                } else {
                  audioFiles = audioKey;
                }
                var cache = this.game.cache.audio;
                var remaining = audioFiles.length;
                for (var i = 0; i < audioFiles.length; i++) {
                  var entry = audioFiles[i];
                  var key = entry.key;
                  var data = entry.data;
                  if (typeof data === "string") {
                    data = Base64ToArrayBuffer(data);
                  }
                  var success = function(key2, audioBuffer) {
                    cache.add(key2, audioBuffer);
                    this.emit(Events.DECODED, key2);
                    remaining--;
                    if (remaining === 0) {
                      this.emit(Events.DECODED_ALL);
                    }
                  }.bind(this, key);
                  var failure = function(key2, error) {
                    console.error("Error decoding audio: " + key2 + " - ", error ? error.message : "");
                    remaining--;
                    if (remaining === 0) {
                      this.emit(Events.DECODED_ALL);
                    }
                  }.bind(this, key);
                  this.context.decodeAudioData(data, success, failure);
                }
              },
              setListenerPosition: function(x, y) {
                if (x === void 0) {
                  x = this.game.scale.width / 2;
                }
                if (y === void 0) {
                  y = this.game.scale.height / 2;
                }
                this.listenerPosition.set(x, y);
                return this;
              },
              unlock: function() {
                var _this = this;
                var body = document.body;
                var unlockHandler = function unlockHandler2() {
                  if (_this.context && body) {
                    var bodyRemove = body.removeEventListener.bind(body);
                    _this.context.resume().then(function() {
                      bodyRemove("touchstart", unlockHandler2);
                      bodyRemove("touchend", unlockHandler2);
                      bodyRemove("click", unlockHandler2);
                      bodyRemove("keydown", unlockHandler2);
                      _this.unlocked = true;
                    }, function() {
                      bodyRemove("touchstart", unlockHandler2);
                      bodyRemove("touchend", unlockHandler2);
                      bodyRemove("click", unlockHandler2);
                      bodyRemove("keydown", unlockHandler2);
                    });
                  }
                };
                if (body) {
                  body.addEventListener("touchstart", unlockHandler, false);
                  body.addEventListener("touchend", unlockHandler, false);
                  body.addEventListener("click", unlockHandler, false);
                  body.addEventListener("keydown", unlockHandler, false);
                }
              },
              onBlur: function() {
                if (!this.locked) {
                  this.context.suspend();
                }
              },
              onFocus: function() {
                var context = this.context;
                if (context && !this.locked && (context.state === "suspended" || context.state === "interrupted")) {
                  context.resume();
                }
              },
              update: function(time, delta) {
                var listener = this.context.listener;
                if (listener && listener.positionX !== void 0) {
                  var x = GetFastValue(this.listenerPosition, "x", null);
                  var y = GetFastValue(this.listenerPosition, "y", null);
                  if (x && x !== this._spatialx) {
                    this._spatialx = listener.positionX.value = x;
                  }
                  if (y && y !== this._spatialy) {
                    this._spatialy = listener.positionY.value = y;
                  }
                }
                BaseSoundManager.prototype.update.call(this, time, delta);
                if (!this.gameLostFocus) {
                  this.onFocus();
                }
              },
              destroy: function() {
                this.destination = null;
                this.masterVolumeNode.disconnect();
                this.masterVolumeNode = null;
                this.masterMuteNode.disconnect();
                this.masterMuteNode = null;
                if (this.game.config.audio.context) {
                  this.context.suspend();
                } else {
                  var _this = this;
                  this.context.close().then(function() {
                    _this.context = null;
                  });
                }
                BaseSoundManager.prototype.destroy.call(this);
              },
              setMute: function(value) {
                this.mute = value;
                return this;
              },
              mute: {
                get: function() {
                  return this.masterMuteNode.gain.value === 0;
                },
                set: function(value) {
                  this.masterMuteNode.gain.setValueAtTime(value ? 0 : 1, 0);
                  this.emit(Events.GLOBAL_MUTE, this, value);
                }
              },
              setVolume: function(value) {
                this.volume = value;
                return this;
              },
              volume: {
                get: function() {
                  return this.masterVolumeNode.gain.value;
                },
                set: function(value) {
                  this.masterVolumeNode.gain.setValueAtTime(value, 0);
                  this.emit(Events.GLOBAL_VOLUME, this, value);
                }
              }
            });
            module2.exports = WebAudioSoundManager;
          },
          71207: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArrayUtils = __webpack_require__2(59959);
            var Class = __webpack_require__2(56694);
            var NOOP = __webpack_require__2(72283);
            var StableSort = __webpack_require__2(17922);
            var List = new Class({
              initialize: function List2(parent) {
                this.parent = parent;
                this.list = [];
                this.position = 0;
                this.addCallback = NOOP;
                this.removeCallback = NOOP;
                this._sortKey = "";
              },
              add: function(child, skipCallback) {
                if (skipCallback) {
                  return ArrayUtils.Add(this.list, child);
                } else {
                  return ArrayUtils.Add(this.list, child, 0, this.addCallback, this);
                }
              },
              addAt: function(child, index, skipCallback) {
                if (skipCallback) {
                  return ArrayUtils.AddAt(this.list, child, index);
                } else {
                  return ArrayUtils.AddAt(this.list, child, index, 0, this.addCallback, this);
                }
              },
              getAt: function(index) {
                return this.list[index];
              },
              getIndex: function(child) {
                return this.list.indexOf(child);
              },
              sort: function(property, handler) {
                if (!property) {
                  return this;
                }
                if (handler === void 0) {
                  handler = function(childA, childB) {
                    return childA[property] - childB[property];
                  };
                }
                StableSort(this.list, handler);
                return this;
              },
              getByName: function(name) {
                return ArrayUtils.GetFirst(this.list, "name", name);
              },
              getRandom: function(startIndex, length) {
                return ArrayUtils.GetRandom(this.list, startIndex, length);
              },
              getFirst: function(property, value, startIndex, endIndex) {
                return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
              },
              getAll: function(property, value, startIndex, endIndex) {
                return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
              },
              count: function(property, value) {
                return ArrayUtils.CountAllMatching(this.list, property, value);
              },
              swap: function(child1, child2) {
                ArrayUtils.Swap(this.list, child1, child2);
              },
              moveTo: function(child, index) {
                return ArrayUtils.MoveTo(this.list, child, index);
              },
              moveAbove: function(child1, child2) {
                return ArrayUtils.MoveAbove(this.list, child1, child2);
              },
              moveBelow: function(child1, child2) {
                return ArrayUtils.MoveBelow(this.list, child1, child2);
              },
              remove: function(child, skipCallback) {
                if (skipCallback) {
                  return ArrayUtils.Remove(this.list, child);
                } else {
                  return ArrayUtils.Remove(this.list, child, this.removeCallback, this);
                }
              },
              removeAt: function(index, skipCallback) {
                if (skipCallback) {
                  return ArrayUtils.RemoveAt(this.list, index);
                } else {
                  return ArrayUtils.RemoveAt(this.list, index, this.removeCallback, this);
                }
              },
              removeBetween: function(startIndex, endIndex, skipCallback) {
                if (skipCallback) {
                  return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex);
                } else {
                  return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);
                }
              },
              removeAll: function(skipCallback) {
                var i = this.list.length;
                while (i--) {
                  this.remove(this.list[i], skipCallback);
                }
                return this;
              },
              bringToTop: function(child) {
                return ArrayUtils.BringToTop(this.list, child);
              },
              sendToBack: function(child) {
                return ArrayUtils.SendToBack(this.list, child);
              },
              moveUp: function(child) {
                ArrayUtils.MoveUp(this.list, child);
                return child;
              },
              moveDown: function(child) {
                ArrayUtils.MoveDown(this.list, child);
                return child;
              },
              reverse: function() {
                this.list.reverse();
                return this;
              },
              shuffle: function() {
                ArrayUtils.Shuffle(this.list);
                return this;
              },
              replace: function(oldChild, newChild) {
                return ArrayUtils.Replace(this.list, oldChild, newChild);
              },
              exists: function(child) {
                return this.list.indexOf(child) > -1;
              },
              setAll: function(property, value, startIndex, endIndex) {
                ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
                return this;
              },
              each: function(callback, context) {
                var args = [null];
                for (var i = 2; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                for (i = 0; i < this.list.length; i++) {
                  args[0] = this.list[i];
                  callback.apply(context, args);
                }
              },
              shutdown: function() {
                this.removeAll();
                this.list = [];
              },
              destroy: function() {
                this.removeAll();
                this.parent = null;
                this.addCallback = null;
                this.removeCallback = null;
              },
              length: {
                get: function() {
                  return this.list.length;
                }
              },
              first: {
                get: function() {
                  this.position = 0;
                  if (this.list.length > 0) {
                    return this.list[0];
                  } else {
                    return null;
                  }
                }
              },
              last: {
                get: function() {
                  if (this.list.length > 0) {
                    this.position = this.list.length - 1;
                    return this.list[this.position];
                  } else {
                    return null;
                  }
                }
              },
              next: {
                get: function() {
                  if (this.position < this.list.length) {
                    this.position++;
                    return this.list[this.position];
                  } else {
                    return null;
                  }
                }
              },
              previous: {
                get: function() {
                  if (this.position > 0) {
                    this.position--;
                    return this.list[this.position];
                  } else {
                    return null;
                  }
                }
              }
            });
            module2.exports = List;
          },
          33885: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Map = new Class({
              initialize: function Map2(elements) {
                this.entries = {};
                this.size = 0;
                this.setAll(elements);
              },
              setAll: function(elements) {
                if (Array.isArray(elements)) {
                  for (var i = 0; i < elements.length; i++) {
                    this.set(elements[i][0], elements[i][1]);
                  }
                }
                return this;
              },
              set: function(key, value) {
                if (!this.has(key)) {
                  this.size++;
                }
                this.entries[key] = value;
                return this;
              },
              get: function(key) {
                if (this.has(key)) {
                  return this.entries[key];
                }
              },
              getArray: function() {
                var output = [];
                var entries = this.entries;
                for (var key in entries) {
                  output.push(entries[key]);
                }
                return output;
              },
              has: function(key) {
                return this.entries.hasOwnProperty(key);
              },
              delete: function(key) {
                if (this.has(key)) {
                  delete this.entries[key];
                  this.size--;
                }
                return this;
              },
              clear: function() {
                Object.keys(this.entries).forEach(function(prop) {
                  delete this.entries[prop];
                }, this);
                this.size = 0;
                return this;
              },
              keys: function() {
                return Object.keys(this.entries);
              },
              values: function() {
                var output = [];
                var entries = this.entries;
                for (var key in entries) {
                  output.push(entries[key]);
                }
                return output;
              },
              dump: function() {
                var entries = this.entries;
                console.group("Map");
                for (var key in entries) {
                  console.log(key, entries[key]);
                }
                console.groupEnd();
              },
              each: function(callback) {
                var entries = this.entries;
                for (var key in entries) {
                  if (callback(key, entries[key]) === false) {
                    break;
                  }
                }
                return this;
              },
              contains: function(value) {
                var entries = this.entries;
                for (var key in entries) {
                  if (entries[key] === value) {
                    return true;
                  }
                }
                return false;
              },
              merge: function(map, override) {
                if (override === void 0) {
                  override = false;
                }
                var local = this.entries;
                var source = map.entries;
                for (var key in source) {
                  if (local.hasOwnProperty(key) && override) {
                    local[key] = source[key];
                  } else {
                    this.set(key, source[key]);
                  }
                }
                return this;
              }
            });
            module2.exports = Map;
          },
          74623: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(36716);
            var ProcessQueue = new Class({
              Extends: EventEmitter,
              initialize: function ProcessQueue2() {
                EventEmitter.call(this);
                this._pending = [];
                this._active = [];
                this._destroy = [];
                this._toProcess = 0;
                this.checkQueue = false;
              },
              isActive: function(item) {
                return this._active.indexOf(item) > -1;
              },
              isPending: function(item) {
                return this._toProcess > 0 && this._pending.indexOf(item) > -1;
              },
              isDestroying: function(item) {
                return this._destroy.indexOf(item) > -1;
              },
              add: function(item) {
                if (this.checkQueue && (this.isActive(item) && !this.isDestroying(item)) || this.isPending(item)) {
                  return item;
                }
                this._pending.push(item);
                this._toProcess++;
                return item;
              },
              remove: function(item) {
                if (this.isPending(item)) {
                  var pending = this._pending;
                  var idx = pending.indexOf(item);
                  if (idx !== -1) {
                    pending.splice(idx, 1);
                  }
                } else if (this.isActive(item)) {
                  this._destroy.push(item);
                  this._toProcess++;
                }
                return item;
              },
              removeAll: function() {
                var list = this._active;
                var destroy = this._destroy;
                var i = list.length;
                while (i--) {
                  destroy.push(list[i]);
                  this._toProcess++;
                }
                return this;
              },
              update: function() {
                if (this._toProcess === 0) {
                  return this._active;
                }
                var list = this._destroy;
                var active = this._active;
                var i;
                var item;
                for (i = 0; i < list.length; i++) {
                  item = list[i];
                  var idx = active.indexOf(item);
                  if (idx !== -1) {
                    active.splice(idx, 1);
                    this.emit(Events.PROCESS_QUEUE_REMOVE, item);
                  }
                }
                list.length = 0;
                list = this._pending;
                for (i = 0; i < list.length; i++) {
                  item = list[i];
                  if (!this.checkQueue || this.checkQueue && active.indexOf(item) === -1) {
                    active.push(item);
                    this.emit(Events.PROCESS_QUEUE_ADD, item);
                  }
                }
                list.length = 0;
                this._toProcess = 0;
                return active;
              },
              getActive: function() {
                return this._active;
              },
              length: {
                get: function() {
                  return this._active.length;
                }
              },
              destroy: function() {
                this._toProcess = 0;
                this._pending = [];
                this._active = [];
                this._destroy = [];
              }
            });
            module2.exports = ProcessQueue;
          },
          68687: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Vladimir Agafonkin
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var quickselect = __webpack_require__2(53466);
            function rbush(maxEntries) {
              var format = [".left", ".top", ".right", ".bottom"];
              if (!(this instanceof rbush))
                return new rbush(maxEntries, format);
              this._maxEntries = Math.max(4, maxEntries || 9);
              this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
              this.clear();
            }
            rbush.prototype = {
              all: function() {
                return this._all(this.data, []);
              },
              search: function(bbox) {
                var node = this.data, result = [], toBBox = this.toBBox;
                if (!intersects(bbox, node))
                  return result;
                var nodesToSearch = [], i, len, child, childBBox;
                while (node) {
                  for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;
                    if (intersects(bbox, childBBox)) {
                      if (node.leaf)
                        result.push(child);
                      else if (contains(bbox, childBBox))
                        this._all(child, result);
                      else
                        nodesToSearch.push(child);
                    }
                  }
                  node = nodesToSearch.pop();
                }
                return result;
              },
              collides: function(bbox) {
                var node = this.data, toBBox = this.toBBox;
                if (!intersects(bbox, node))
                  return false;
                var nodesToSearch = [], i, len, child, childBBox;
                while (node) {
                  for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;
                    if (intersects(bbox, childBBox)) {
                      if (node.leaf || contains(bbox, childBBox))
                        return true;
                      nodesToSearch.push(child);
                    }
                  }
                  node = nodesToSearch.pop();
                }
                return false;
              },
              load: function(data) {
                if (!(data && data.length))
                  return this;
                if (data.length < this._minEntries) {
                  for (var i = 0, len = data.length; i < len; i++) {
                    this.insert(data[i]);
                  }
                  return this;
                }
                var node = this._build(data.slice(), 0, data.length - 1, 0);
                if (!this.data.children.length) {
                  this.data = node;
                } else if (this.data.height === node.height) {
                  this._splitRoot(this.data, node);
                } else {
                  if (this.data.height < node.height) {
                    var tmpNode = this.data;
                    this.data = node;
                    node = tmpNode;
                  }
                  this._insert(node, this.data.height - node.height - 1, true);
                }
                return this;
              },
              insert: function(item) {
                if (item)
                  this._insert(item, this.data.height - 1);
                return this;
              },
              clear: function() {
                this.data = createNode([]);
                return this;
              },
              remove: function(item, equalsFn) {
                if (!item)
                  return this;
                var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
                while (node || path.length) {
                  if (!node) {
                    node = path.pop();
                    parent = path[path.length - 1];
                    i = indexes.pop();
                    goingUp = true;
                  }
                  if (node.leaf) {
                    index = findItem(item, node.children, equalsFn);
                    if (index !== -1) {
                      node.children.splice(index, 1);
                      path.push(node);
                      this._condense(path);
                      return this;
                    }
                  }
                  if (!goingUp && !node.leaf && contains(node, bbox)) {
                    path.push(node);
                    indexes.push(i);
                    i = 0;
                    parent = node;
                    node = node.children[0];
                  } else if (parent) {
                    i++;
                    node = parent.children[i];
                    goingUp = false;
                  } else
                    node = null;
                }
                return this;
              },
              toBBox: function(item) {
                return item;
              },
              compareMinX: compareNodeMinX,
              compareMinY: compareNodeMinY,
              toJSON: function() {
                return this.data;
              },
              fromJSON: function(data) {
                this.data = data;
                return this;
              },
              _all: function(node, result) {
                var nodesToSearch = [];
                while (node) {
                  if (node.leaf)
                    result.push.apply(result, node.children);
                  else
                    nodesToSearch.push.apply(nodesToSearch, node.children);
                  node = nodesToSearch.pop();
                }
                return result;
              },
              _build: function(items, left, right, height) {
                var N = right - left + 1, M = this._maxEntries, node;
                if (N <= M) {
                  node = createNode(items.slice(left, right + 1));
                  calcBBox(node, this.toBBox);
                  return node;
                }
                if (!height) {
                  height = Math.ceil(Math.log(N) / Math.log(M));
                  M = Math.ceil(N / Math.pow(M, height - 1));
                }
                node = createNode([]);
                node.leaf = false;
                node.height = height;
                var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
                multiSelect(items, left, right, N1, this.compareMinX);
                for (i = left; i <= right; i += N1) {
                  right2 = Math.min(i + N1 - 1, right);
                  multiSelect(items, i, right2, N2, this.compareMinY);
                  for (j = i; j <= right2; j += N2) {
                    right3 = Math.min(j + N2 - 1, right2);
                    node.children.push(this._build(items, j, right3, height - 1));
                  }
                }
                calcBBox(node, this.toBBox);
                return node;
              },
              _chooseSubtree: function(bbox, node, level, path) {
                var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
                while (true) {
                  path.push(node);
                  if (node.leaf || path.length - 1 === level)
                    break;
                  minArea = minEnlargement = Infinity;
                  for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    area = bboxArea(child);
                    enlargement = enlargedArea(bbox, child) - area;
                    if (enlargement < minEnlargement) {
                      minEnlargement = enlargement;
                      minArea = area < minArea ? area : minArea;
                      targetNode = child;
                    } else if (enlargement === minEnlargement) {
                      if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                      }
                    }
                  }
                  node = targetNode || node.children[0];
                }
                return node;
              },
              _insert: function(item, level, isNode) {
                var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
                var node = this._chooseSubtree(bbox, this.data, level, insertPath);
                node.children.push(item);
                extend(node, bbox);
                while (level >= 0) {
                  if (insertPath[level].children.length > this._maxEntries) {
                    this._split(insertPath, level);
                    level--;
                  } else
                    break;
                }
                this._adjustParentBBoxes(bbox, insertPath, level);
              },
              _split: function(insertPath, level) {
                var node = insertPath[level], M = node.children.length, m = this._minEntries;
                this._chooseSplitAxis(node, m, M);
                var splitIndex = this._chooseSplitIndex(node, m, M);
                var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
                newNode.height = node.height;
                newNode.leaf = node.leaf;
                calcBBox(node, this.toBBox);
                calcBBox(newNode, this.toBBox);
                if (level)
                  insertPath[level - 1].children.push(newNode);
                else
                  this._splitRoot(node, newNode);
              },
              _splitRoot: function(node, newNode) {
                this.data = createNode([node, newNode]);
                this.data.height = node.height + 1;
                this.data.leaf = false;
                calcBBox(this.data, this.toBBox);
              },
              _chooseSplitIndex: function(node, m, M) {
                var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
                minOverlap = minArea = Infinity;
                for (i = m; i <= M - m; i++) {
                  bbox1 = distBBox(node, 0, i, this.toBBox);
                  bbox2 = distBBox(node, i, M, this.toBBox);
                  overlap = intersectionArea(bbox1, bbox2);
                  area = bboxArea(bbox1) + bboxArea(bbox2);
                  if (overlap < minOverlap) {
                    minOverlap = overlap;
                    index = i;
                    minArea = area < minArea ? area : minArea;
                  } else if (overlap === minOverlap) {
                    if (area < minArea) {
                      minArea = area;
                      index = i;
                    }
                  }
                }
                return index;
              },
              _chooseSplitAxis: function(node, m, M) {
                var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
                if (xMargin < yMargin)
                  node.children.sort(compareMinX);
              },
              _allDistMargin: function(node, m, M, compare) {
                node.children.sort(compare);
                var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
                for (i = m; i < M - m; i++) {
                  child = node.children[i];
                  extend(leftBBox, node.leaf ? toBBox(child) : child);
                  margin += bboxMargin(leftBBox);
                }
                for (i = M - m - 1; i >= m; i--) {
                  child = node.children[i];
                  extend(rightBBox, node.leaf ? toBBox(child) : child);
                  margin += bboxMargin(rightBBox);
                }
                return margin;
              },
              _adjustParentBBoxes: function(bbox, path, level) {
                for (var i = level; i >= 0; i--) {
                  extend(path[i], bbox);
                }
              },
              _condense: function(path) {
                for (var i = path.length - 1, siblings; i >= 0; i--) {
                  if (path[i].children.length === 0) {
                    if (i > 0) {
                      siblings = path[i - 1].children;
                      siblings.splice(siblings.indexOf(path[i]), 1);
                    } else
                      this.clear();
                  } else
                    calcBBox(path[i], this.toBBox);
                }
              },
              compareMinX: function(a, b) {
                return a.left - b.left;
              },
              compareMinY: function(a, b) {
                return a.top - b.top;
              },
              toBBox: function(a) {
                return {
                  minX: a.left,
                  minY: a.top,
                  maxX: a.right,
                  maxY: a.bottom
                };
              }
            };
            function findItem(item, items, equalsFn) {
              if (!equalsFn)
                return items.indexOf(item);
              for (var i = 0; i < items.length; i++) {
                if (equalsFn(item, items[i]))
                  return i;
              }
              return -1;
            }
            function calcBBox(node, toBBox) {
              distBBox(node, 0, node.children.length, toBBox, node);
            }
            function distBBox(node, k, p, toBBox, destNode) {
              if (!destNode)
                destNode = createNode(null);
              destNode.minX = Infinity;
              destNode.minY = Infinity;
              destNode.maxX = -Infinity;
              destNode.maxY = -Infinity;
              for (var i = k, child; i < p; i++) {
                child = node.children[i];
                extend(destNode, node.leaf ? toBBox(child) : child);
              }
              return destNode;
            }
            function extend(a, b) {
              a.minX = Math.min(a.minX, b.minX);
              a.minY = Math.min(a.minY, b.minY);
              a.maxX = Math.max(a.maxX, b.maxX);
              a.maxY = Math.max(a.maxY, b.maxY);
              return a;
            }
            function compareNodeMinX(a, b) {
              return a.minX - b.minX;
            }
            function compareNodeMinY(a, b) {
              return a.minY - b.minY;
            }
            function bboxArea(a) {
              return (a.maxX - a.minX) * (a.maxY - a.minY);
            }
            function bboxMargin(a) {
              return a.maxX - a.minX + (a.maxY - a.minY);
            }
            function enlargedArea(a, b) {
              return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
            }
            function intersectionArea(a, b) {
              var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
              return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
            }
            function contains(a, b) {
              return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
            }
            function intersects(a, b) {
              return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
            }
            function createNode(children) {
              return {
                children,
                height: 1,
                leaf: true,
                minX: Infinity,
                minY: Infinity,
                maxX: -Infinity,
                maxY: -Infinity
              };
            }
            function multiSelect(arr, left, right, n, compare) {
              var stack = [left, right], mid;
              while (stack.length) {
                right = stack.pop();
                left = stack.pop();
                if (right - left <= n)
                  continue;
                mid = left + Math.ceil((right - left) / n / 2) * n;
                quickselect(arr, mid, left, right, compare);
                stack.push(left, mid, mid, right);
              }
            }
            module2.exports = rbush;
          },
          58403: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Set = new Class({
              initialize: function Set2(elements) {
                this.entries = [];
                if (Array.isArray(elements)) {
                  for (var i = 0; i < elements.length; i++) {
                    this.set(elements[i]);
                  }
                }
              },
              set: function(value) {
                if (this.entries.indexOf(value) === -1) {
                  this.entries.push(value);
                }
                return this;
              },
              get: function(property, value) {
                for (var i = 0; i < this.entries.length; i++) {
                  var entry = this.entries[i];
                  if (entry[property] === value) {
                    return entry;
                  }
                }
              },
              getArray: function() {
                return this.entries.slice(0);
              },
              delete: function(value) {
                var index = this.entries.indexOf(value);
                if (index > -1) {
                  this.entries.splice(index, 1);
                }
                return this;
              },
              dump: function() {
                console.group("Set");
                for (var i = 0; i < this.entries.length; i++) {
                  var entry = this.entries[i];
                  console.log(entry);
                }
                console.groupEnd();
              },
              each: function(callback, callbackScope) {
                var i;
                var temp = this.entries.slice();
                var len = temp.length;
                if (callbackScope) {
                  for (i = 0; i < len; i++) {
                    if (callback.call(callbackScope, temp[i], i) === false) {
                      break;
                    }
                  }
                } else {
                  for (i = 0; i < len; i++) {
                    if (callback(temp[i], i) === false) {
                      break;
                    }
                  }
                }
                return this;
              },
              iterate: function(callback, callbackScope) {
                var i;
                var len = this.entries.length;
                if (callbackScope) {
                  for (i = 0; i < len; i++) {
                    if (callback.call(callbackScope, this.entries[i], i) === false) {
                      break;
                    }
                  }
                } else {
                  for (i = 0; i < len; i++) {
                    if (callback(this.entries[i], i) === false) {
                      break;
                    }
                  }
                }
                return this;
              },
              iterateLocal: function(callbackKey) {
                var i;
                var args = [];
                for (i = 1; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                var len = this.entries.length;
                for (i = 0; i < len; i++) {
                  var entry = this.entries[i];
                  entry[callbackKey].apply(entry, args);
                }
                return this;
              },
              clear: function() {
                this.entries.length = 0;
                return this;
              },
              contains: function(value) {
                return this.entries.indexOf(value) > -1;
              },
              union: function(set) {
                var newSet = new Set();
                set.entries.forEach(function(value) {
                  newSet.set(value);
                });
                this.entries.forEach(function(value) {
                  newSet.set(value);
                });
                return newSet;
              },
              intersect: function(set) {
                var newSet = new Set();
                this.entries.forEach(function(value) {
                  if (set.contains(value)) {
                    newSet.set(value);
                  }
                });
                return newSet;
              },
              difference: function(set) {
                var newSet = new Set();
                this.entries.forEach(function(value) {
                  if (!set.contains(value)) {
                    newSet.set(value);
                  }
                });
                return newSet;
              },
              size: {
                get: function() {
                  return this.entries.length;
                },
                set: function(value) {
                  if (value < this.entries.length) {
                    return this.entries.length = value;
                  } else {
                    return this.entries.length;
                  }
                }
              }
            });
            module2.exports = Set;
          },
          90881: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var SnapFloor = __webpack_require__2(84314);
            var Vector2 = __webpack_require__2(93736);
            var Size = new Class({
              initialize: function Size2(width, height, aspectMode, parent) {
                if (width === void 0) {
                  width = 0;
                }
                if (height === void 0) {
                  height = width;
                }
                if (aspectMode === void 0) {
                  aspectMode = 0;
                }
                if (parent === void 0) {
                  parent = null;
                }
                this._width = width;
                this._height = height;
                this._parent = parent;
                this.aspectMode = aspectMode;
                this.aspectRatio = height === 0 ? 1 : width / height;
                this.minWidth = 0;
                this.minHeight = 0;
                this.maxWidth = Number.MAX_VALUE;
                this.maxHeight = Number.MAX_VALUE;
                this.snapTo = new Vector2();
              },
              setAspectMode: function(value) {
                if (value === void 0) {
                  value = 0;
                }
                this.aspectMode = value;
                return this.setSize(this._width, this._height);
              },
              setSnap: function(snapWidth, snapHeight) {
                if (snapWidth === void 0) {
                  snapWidth = 0;
                }
                if (snapHeight === void 0) {
                  snapHeight = snapWidth;
                }
                this.snapTo.set(snapWidth, snapHeight);
                return this.setSize(this._width, this._height);
              },
              setParent: function(parent) {
                this._parent = parent;
                return this.setSize(this._width, this._height);
              },
              setMin: function(width, height) {
                if (width === void 0) {
                  width = 0;
                }
                if (height === void 0) {
                  height = width;
                }
                this.minWidth = Clamp(width, 0, this.maxWidth);
                this.minHeight = Clamp(height, 0, this.maxHeight);
                return this.setSize(this._width, this._height);
              },
              setMax: function(width, height) {
                if (width === void 0) {
                  width = Number.MAX_VALUE;
                }
                if (height === void 0) {
                  height = width;
                }
                this.maxWidth = Clamp(width, this.minWidth, Number.MAX_VALUE);
                this.maxHeight = Clamp(height, this.minHeight, Number.MAX_VALUE);
                return this.setSize(this._width, this._height);
              },
              setSize: function(width, height) {
                if (width === void 0) {
                  width = 0;
                }
                if (height === void 0) {
                  height = width;
                }
                switch (this.aspectMode) {
                  case Size.NONE:
                    this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                    this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                    this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
                    break;
                  case Size.WIDTH_CONTROLS_HEIGHT:
                    this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                    this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), false);
                    break;
                  case Size.HEIGHT_CONTROLS_WIDTH:
                    this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                    this._width = this.getNewWidth(this._height * this.aspectRatio, false);
                    break;
                  case Size.FIT:
                    this.constrain(width, height, true);
                    break;
                  case Size.ENVELOP:
                    this.constrain(width, height, false);
                    break;
                }
                return this;
              },
              setAspectRatio: function(ratio) {
                this.aspectRatio = ratio;
                return this.setSize(this._width, this._height);
              },
              resize: function(width, height) {
                this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
                return this;
              },
              getNewWidth: function(value, checkParent) {
                if (checkParent === void 0) {
                  checkParent = true;
                }
                value = Clamp(value, this.minWidth, this.maxWidth);
                if (checkParent && this._parent && value > this._parent.width) {
                  value = Math.max(this.minWidth, this._parent.width);
                }
                return value;
              },
              getNewHeight: function(value, checkParent) {
                if (checkParent === void 0) {
                  checkParent = true;
                }
                value = Clamp(value, this.minHeight, this.maxHeight);
                if (checkParent && this._parent && value > this._parent.height) {
                  value = Math.max(this.minHeight, this._parent.height);
                }
                return value;
              },
              constrain: function(width, height, fit) {
                if (width === void 0) {
                  width = 0;
                }
                if (height === void 0) {
                  height = width;
                }
                if (fit === void 0) {
                  fit = true;
                }
                width = this.getNewWidth(width);
                height = this.getNewHeight(height);
                var snap = this.snapTo;
                var newRatio = height === 0 ? 1 : width / height;
                if (fit && this.aspectRatio > newRatio || !fit && this.aspectRatio < newRatio) {
                  width = SnapFloor(width, snap.x);
                  height = width / this.aspectRatio;
                  if (snap.y > 0) {
                    height = SnapFloor(height, snap.y);
                    width = height * this.aspectRatio;
                  }
                } else if (fit && this.aspectRatio < newRatio || !fit && this.aspectRatio > newRatio) {
                  height = SnapFloor(height, snap.y);
                  width = height * this.aspectRatio;
                  if (snap.x > 0) {
                    width = SnapFloor(width, snap.x);
                    height = width * (1 / this.aspectRatio);
                  }
                }
                this._width = width;
                this._height = height;
                return this;
              },
              fitTo: function(width, height) {
                return this.constrain(width, height, true);
              },
              envelop: function(width, height) {
                return this.constrain(width, height, false);
              },
              setWidth: function(value) {
                return this.setSize(value, this._height);
              },
              setHeight: function(value) {
                return this.setSize(this._width, value);
              },
              toString: function() {
                return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
              },
              setCSS: function(element) {
                if (element && element.style) {
                  element.style.width = this._width + "px";
                  element.style.height = this._height + "px";
                }
              },
              copy: function(destination) {
                destination.setAspectMode(this.aspectMode);
                destination.aspectRatio = this.aspectRatio;
                return destination.setSize(this.width, this.height);
              },
              destroy: function() {
                this._parent = null;
                this.snapTo = null;
              },
              width: {
                get: function() {
                  return this._width;
                },
                set: function(value) {
                  this.setSize(value, this._height);
                }
              },
              height: {
                get: function() {
                  return this._height;
                },
                set: function(value) {
                  this.setSize(this._width, value);
                }
              }
            });
            Size.NONE = 0;
            Size.WIDTH_CONTROLS_HEIGHT = 1;
            Size.HEIGHT_CONTROLS_WIDTH = 2;
            Size.FIT = 3;
            Size.ENVELOP = 4;
            module2.exports = Size;
          },
          94160: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "add";
          },
          95393: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "remove";
          },
          36716: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              PROCESS_QUEUE_ADD: __webpack_require__2(94160),
              PROCESS_QUEUE_REMOVE: __webpack_require__2(95393)
            };
          },
          20010: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Events: __webpack_require__2(36716),
              List: __webpack_require__2(71207),
              Map: __webpack_require__2(33885),
              ProcessQueue: __webpack_require__2(74623),
              RTree: __webpack_require__2(68687),
              Set: __webpack_require__2(58403),
              Size: __webpack_require__2(90881)
            };
          },
          17487: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Clamp = __webpack_require__2(82897);
            var Color = __webpack_require__2(27119);
            var CONST = __webpack_require__2(86459);
            var IsSizePowerOfTwo = __webpack_require__2(28621);
            var Texture = __webpack_require__2(31673);
            var CanvasTexture = new Class({
              Extends: Texture,
              initialize: function CanvasTexture2(manager, key, source, width, height) {
                Texture.call(this, manager, key, source, width, height);
                this.add("__BASE", 0, 0, 0, width, height);
                this._source = this.frames["__BASE"].source;
                this.canvas = this._source.image;
                this.context = this.canvas.getContext("2d", {willReadFrequently: true});
                this.width = width;
                this.height = height;
                this.imageData = this.context.getImageData(0, 0, width, height);
                this.data = null;
                if (this.imageData) {
                  this.data = this.imageData.data;
                }
                this.pixels = null;
                this.buffer;
                if (this.data) {
                  if (this.imageData.data.buffer) {
                    this.buffer = this.imageData.data.buffer;
                    this.pixels = new Uint32Array(this.buffer);
                  } else if (window.ArrayBuffer) {
                    this.buffer = new ArrayBuffer(this.imageData.data.length);
                    this.pixels = new Uint32Array(this.buffer);
                  } else {
                    this.pixels = this.imageData.data;
                  }
                }
              },
              update: function() {
                this.imageData = this.context.getImageData(0, 0, this.width, this.height);
                this.data = this.imageData.data;
                if (this.imageData.data.buffer) {
                  this.buffer = this.imageData.data.buffer;
                  this.pixels = new Uint32Array(this.buffer);
                } else if (window.ArrayBuffer) {
                  this.buffer = new ArrayBuffer(this.imageData.data.length);
                  this.pixels = new Uint32Array(this.buffer);
                } else {
                  this.pixels = this.imageData.data;
                }
                if (this.manager.game.config.renderType === CONST.WEBGL) {
                  this.refresh();
                }
                return this;
              },
              draw: function(x, y, source, update) {
                if (update === void 0) {
                  update = true;
                }
                this.context.drawImage(source, x, y);
                if (update) {
                  this.update();
                }
                return this;
              },
              drawFrame: function(key, frame, x, y, update) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (update === void 0) {
                  update = true;
                }
                var textureFrame = this.manager.getFrame(key, frame);
                if (textureFrame) {
                  var cd = textureFrame.canvasData;
                  var width = textureFrame.cutWidth;
                  var height = textureFrame.cutHeight;
                  var res = textureFrame.source.resolution;
                  this.context.drawImage(textureFrame.source.image, cd.x, cd.y, width, height, x, y, width / res, height / res);
                  if (update) {
                    this.update();
                  }
                }
                return this;
              },
              setPixel: function(x, y, red, green, blue, alpha) {
                if (alpha === void 0) {
                  alpha = 255;
                }
                x = Math.abs(Math.floor(x));
                y = Math.abs(Math.floor(y));
                var index = this.getIndex(x, y);
                if (index > -1) {
                  var imageData = this.context.getImageData(x, y, 1, 1);
                  imageData.data[0] = red;
                  imageData.data[1] = green;
                  imageData.data[2] = blue;
                  imageData.data[3] = alpha;
                  this.context.putImageData(imageData, x, y);
                }
                return this;
              },
              putData: function(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
                if (dirtyX === void 0) {
                  dirtyX = 0;
                }
                if (dirtyY === void 0) {
                  dirtyY = 0;
                }
                if (dirtyWidth === void 0) {
                  dirtyWidth = imageData.width;
                }
                if (dirtyHeight === void 0) {
                  dirtyHeight = imageData.height;
                }
                this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
                return this;
              },
              getData: function(x, y, width, height) {
                x = Clamp(Math.floor(x), 0, this.width - 1);
                y = Clamp(Math.floor(y), 0, this.height - 1);
                width = Clamp(width, 1, this.width - x);
                height = Clamp(height, 1, this.height - y);
                var imageData = this.context.getImageData(x, y, width, height);
                return imageData;
              },
              getPixel: function(x, y, out) {
                if (!out) {
                  out = new Color();
                }
                var index = this.getIndex(x, y);
                if (index > -1) {
                  var data = this.data;
                  var r = data[index + 0];
                  var g = data[index + 1];
                  var b = data[index + 2];
                  var a = data[index + 3];
                  out.setTo(r, g, b, a);
                }
                return out;
              },
              getPixels: function(x, y, width, height) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = this.width;
                }
                if (height === void 0) {
                  height = width;
                }
                x = Math.abs(Math.round(x));
                y = Math.abs(Math.round(y));
                var left = Clamp(x, 0, this.width);
                var right = Clamp(x + width, 0, this.width);
                var top = Clamp(y, 0, this.height);
                var bottom = Clamp(y + height, 0, this.height);
                var pixel = new Color();
                var out = [];
                for (var py = top; py < bottom; py++) {
                  var row = [];
                  for (var px = left; px < right; px++) {
                    pixel = this.getPixel(px, py, pixel);
                    row.push({x: px, y: py, color: pixel.color, alpha: pixel.alphaGL});
                  }
                  out.push(row);
                }
                return out;
              },
              getIndex: function(x, y) {
                x = Math.abs(Math.round(x));
                y = Math.abs(Math.round(y));
                if (x < this.width && y < this.height) {
                  return (x + y * this.width) * 4;
                } else {
                  return -1;
                }
              },
              refresh: function() {
                this._source.update();
                return this;
              },
              getCanvas: function() {
                return this.canvas;
              },
              getContext: function() {
                return this.context;
              },
              clear: function(x, y, width, height, update) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = this.width;
                }
                if (height === void 0) {
                  height = this.height;
                }
                if (update === void 0) {
                  update = true;
                }
                this.context.clearRect(x, y, width, height);
                if (update) {
                  this.update();
                }
                return this;
              },
              setSize: function(width, height) {
                if (height === void 0) {
                  height = width;
                }
                if (width !== this.width || height !== this.height) {
                  this.canvas.width = width;
                  this.canvas.height = height;
                  this._source.width = width;
                  this._source.height = height;
                  this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);
                  this.frames["__BASE"].setSize(width, height, 0, 0);
                  this.width = width;
                  this.height = height;
                  this.refresh();
                }
                return this;
              },
              destroy: function() {
                Texture.prototype.destroy.call(this);
                this._source = null;
                this.canvas = null;
                this.context = null;
                this.imageData = null;
                this.data = null;
                this.pixels = null;
                this.buffer = null;
              }
            });
            module2.exports = CanvasTexture;
          },
          845: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BlendModes = __webpack_require__2(95723);
            var Camera = __webpack_require__2(51052);
            var CanvasPool = __webpack_require__2(61068);
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(86459);
            var Frame = __webpack_require__2(82047);
            var GetFastValue = __webpack_require__2(72632);
            var PIPELINES = __webpack_require__2(65641);
            var RenderTarget = __webpack_require__2(37410);
            var Texture = __webpack_require__2(31673);
            var Utils = __webpack_require__2(75512);
            var DynamicTexture = new Class({
              Extends: Texture,
              initialize: function DynamicTexture2(manager, key, width, height) {
                if (width === void 0) {
                  width = 256;
                }
                if (height === void 0) {
                  height = 256;
                }
                this.type = "DynamicTexture";
                var renderer = manager.game.renderer;
                var isCanvas = renderer && renderer.type === CONST.CANVAS;
                var source = isCanvas ? CanvasPool.create2D(this, width, height) : [this];
                Texture.call(this, manager, key, source, width, height);
                this.add("__BASE", 0, 0, 0, width, height);
                this.renderer = renderer;
                this.width = -1;
                this.height = -1;
                this.isDrawing = false;
                this.canvas = isCanvas ? source : null;
                this.context = isCanvas ? source.getContext("2d", {willReadFrequently: true}) : null;
                this.dirty = false;
                this.isSpriteTexture = true;
                this._eraseMode = false;
                this.camera = new Camera(0, 0, width, height).setScene(manager.game.scene.systemScene, false);
                this.renderTarget = !isCanvas ? new RenderTarget(renderer, width, height, 1, 0, false, true, true, false) : null;
                this.pipeline = !isCanvas ? renderer.pipelines.get(PIPELINES.SINGLE_PIPELINE) : null;
                if (!isCanvas) {
                  this.setSize(width, height);
                }
              },
              setSize: function(width, height) {
                if (height === void 0) {
                  height = width;
                }
                var frame = this.get();
                var source = frame.source;
                if (width !== this.width || height !== this.height) {
                  if (this.canvas) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                  }
                  var renderTarget = this.renderTarget;
                  if (renderTarget) {
                    if (renderTarget.willResize(width, height)) {
                      renderTarget.resize(width, height);
                      this.renderer.deleteTexture(source.glTexture);
                    }
                    this.setFromRenderTarget();
                  }
                  this.camera.setSize(width, height);
                  source.width = width;
                  source.height = height;
                  frame.setSize(width, height);
                  this.width = width;
                  this.height = height;
                } else {
                  var baseFrame = this.getSourceImage();
                  if (frame.cutX + width > baseFrame.width) {
                    width = baseFrame.width - frame.cutX;
                  }
                  if (frame.cutY + height > baseFrame.height) {
                    height = baseFrame.height - frame.cutY;
                  }
                  frame.setSize(width, height, frame.cutX, frame.cutY);
                }
                return this;
              },
              setFromRenderTarget: function() {
                var frame = this.get();
                var source = frame.source;
                var renderTarget = this.renderTarget;
                frame.glTexture = renderTarget.texture;
                source.isRenderTexture = true;
                source.isGLTexture = true;
                source.glTexture = renderTarget.texture;
                source.glTexture.flipY = true;
                return this;
              },
              setIsSpriteTexture: function(value) {
                this.isSpriteTexture = value;
                return this;
              },
              fill: function(rgb, alpha, x, y, width, height) {
                var camera = this.camera;
                var renderer = this.renderer;
                if (alpha === void 0) {
                  alpha = 1;
                }
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = this.width;
                }
                if (height === void 0) {
                  height = this.height;
                }
                var r = rgb >> 16 & 255;
                var g = rgb >> 8 & 255;
                var b = rgb & 255;
                var renderTarget = this.renderTarget;
                camera.preRender();
                if (renderTarget) {
                  renderTarget.bind(true);
                  var pipeline = this.pipeline.manager.set(this.pipeline);
                  var sx = renderer.width / renderTarget.width;
                  var sy = renderer.height / renderTarget.height;
                  var ty = renderTarget.height - (y + height);
                  pipeline.drawFillRect(x * sx, ty * sy, width * sx, height * sy, Utils.getTintFromFloats(b / 255, g / 255, r / 255, 1), alpha);
                  renderTarget.unbind(true);
                } else {
                  var ctx = this.context;
                  renderer.setContext(ctx);
                  ctx.globalCompositeOperation = "source-over";
                  ctx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
                  ctx.fillRect(x, y, width, height);
                  renderer.setContext();
                }
                this.dirty = true;
                return this;
              },
              clear: function() {
                if (this.dirty) {
                  var ctx = this.context;
                  var renderTarget = this.renderTarget;
                  if (renderTarget) {
                    renderTarget.clear();
                  } else if (ctx) {
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, this.width, this.height);
                    ctx.restore();
                  }
                  this.dirty = false;
                }
                return this;
              },
              stamp: function(key, frame, x, y, config2) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                var alpha = GetFastValue(config2, "alpha", 1);
                var tint = GetFastValue(config2, "tint", 16777215);
                var angle = GetFastValue(config2, "angle", 0);
                var rotation = GetFastValue(config2, "rotation", 0);
                var scale = GetFastValue(config2, "scale", 1);
                var scaleX = GetFastValue(config2, "scaleX", scale);
                var scaleY = GetFastValue(config2, "scaleY", scale);
                var originX = GetFastValue(config2, "originX", 0.5);
                var originY = GetFastValue(config2, "originY", 0.5);
                var blendMode = GetFastValue(config2, "blendMode", 0);
                var erase = GetFastValue(config2, "erase", false);
                var skipBatch = GetFastValue(config2, "skipBatch", false);
                var stamp = this.manager.resetStamp(alpha, tint);
                stamp.setAngle(0);
                if (angle !== 0) {
                  stamp.setAngle(angle);
                } else if (rotation !== 0) {
                  stamp.setRotation(rotation);
                }
                stamp.setScale(scaleX, scaleY);
                stamp.setTexture(key, frame);
                stamp.setOrigin(originX, originY);
                stamp.setBlendMode(blendMode);
                if (erase) {
                  this._eraseMode = true;
                }
                if (!skipBatch) {
                  this.draw(stamp, x, y);
                } else {
                  this.batchGameObject(stamp, x, y);
                }
                if (erase) {
                  this._eraseMode = false;
                }
                return this;
              },
              erase: function(entries, x, y) {
                this._eraseMode = true;
                this.draw(entries, x, y);
                this._eraseMode = false;
                return this;
              },
              draw: function(entries, x, y, alpha, tint) {
                this.beginDraw();
                this.batchDraw(entries, x, y, alpha, tint);
                this.endDraw();
                return this;
              },
              drawFrame: function(key, frame, x, y, alpha, tint) {
                this.beginDraw();
                this.batchDrawFrame(key, frame, x, y, alpha, tint);
                this.endDraw();
                return this;
              },
              repeat: function(key, frame, x, y, width, height, alpha, tint, skipBatch) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = this.width;
                }
                if (height === void 0) {
                  height = this.height;
                }
                if (alpha === void 0) {
                  alpha = 1;
                }
                if (tint === void 0) {
                  tint = 16777215;
                }
                if (skipBatch === void 0) {
                  skipBatch = false;
                }
                if (key instanceof Frame) {
                  frame = key;
                } else {
                  frame = this.manager.getFrame(key, frame);
                }
                if (!frame) {
                  return this;
                }
                var stamp = this.manager.resetStamp(alpha, tint);
                stamp.setFrame(frame);
                stamp.setOrigin(0);
                var frameWidth = frame.width;
                var frameHeight = frame.height;
                width = Math.floor(width);
                height = Math.floor(height);
                var hmax = Math.ceil(width / frameWidth);
                var vmax = Math.ceil(height / frameHeight);
                var hdiff = hmax * frameWidth - width;
                var vdiff = vmax * frameHeight - height;
                if (hdiff > 0) {
                  hdiff = frameWidth - hdiff;
                }
                if (vdiff > 0) {
                  vdiff = frameHeight - vdiff;
                }
                if (x < 0) {
                  hmax += Math.ceil(Math.abs(x) / frameWidth);
                }
                if (y < 0) {
                  vmax += Math.ceil(Math.abs(y) / frameHeight);
                }
                var dx = x;
                var dy = y;
                var useCrop = false;
                var cropRect = this.manager.stampCrop.setTo(0, 0, frameWidth, frameHeight);
                if (!skipBatch) {
                  this.beginDraw();
                }
                for (var ty = 0; ty < vmax; ty++) {
                  if (dy + frameHeight < 0) {
                    dy += frameHeight;
                    continue;
                  }
                  for (var tx = 0; tx < hmax; tx++) {
                    useCrop = false;
                    if (dx + frameWidth < 0) {
                      dx += frameWidth;
                      continue;
                    } else if (dx < 0) {
                      useCrop = true;
                      cropRect.width = frameWidth + dx;
                      cropRect.x = frameWidth - cropRect.width;
                    }
                    if (dy < 0) {
                      useCrop = true;
                      cropRect.height = frameHeight + dy;
                      cropRect.y = frameHeight - cropRect.height;
                    }
                    if (hdiff > 0 && tx === hmax - 1) {
                      useCrop = true;
                      cropRect.width = hdiff;
                    }
                    if (vdiff > 0 && ty === vmax - 1) {
                      useCrop = true;
                      cropRect.height = vdiff;
                    }
                    if (useCrop) {
                      stamp.setCrop(cropRect);
                    }
                    this.batchGameObject(stamp, dx, dy);
                    stamp.isCropped = false;
                    cropRect.setTo(0, 0, frameWidth, frameHeight);
                    dx += frameWidth;
                  }
                  dx = x;
                  dy += frameHeight;
                }
                if (!skipBatch) {
                  this.endDraw();
                }
                return this;
              },
              beginDraw: function() {
                if (!this.isDrawing) {
                  var camera = this.camera;
                  var renderer = this.renderer;
                  var renderTarget = this.renderTarget;
                  camera.preRender();
                  if (renderTarget) {
                    renderer.beginCapture(renderTarget.width, renderTarget.height);
                  } else {
                    renderer.setContext(this.context);
                  }
                  this.isDrawing = true;
                }
                return this;
              },
              batchDraw: function(entries, x, y, alpha, tint) {
                if (!Array.isArray(entries)) {
                  entries = [entries];
                }
                this.batchList(entries, x, y, alpha, tint);
                return this;
              },
              batchDrawFrame: function(key, frame, x, y, alpha, tint) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (alpha === void 0) {
                  alpha = 1;
                }
                if (tint === void 0) {
                  tint = 16777215;
                }
                var textureFrame = this.manager.getFrame(key, frame);
                if (textureFrame) {
                  if (this.renderTarget) {
                    this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
                  } else {
                    this.batchTextureFrame(textureFrame, x, y, alpha, tint);
                  }
                }
                return this;
              },
              endDraw: function(erase) {
                if (erase === void 0) {
                  erase = this._eraseMode;
                }
                if (this.isDrawing) {
                  var renderer = this.renderer;
                  var renderTarget = this.renderTarget;
                  if (renderTarget) {
                    var canvasTarget = renderer.endCapture();
                    var util = renderer.pipelines.setUtility();
                    util.blitFrame(canvasTarget, renderTarget, 1, false, false, erase, this.isSpriteTexture);
                    renderer.resetScissor();
                    renderer.resetViewport();
                  } else {
                    renderer.setContext();
                  }
                  this.dirty = true;
                  this.isDrawing = false;
                }
                return this;
              },
              batchList: function(children, x, y, alpha, tint) {
                var len = children.length;
                if (len === 0) {
                  return;
                }
                for (var i = 0; i < len; i++) {
                  var entry = children[i];
                  if (!entry || entry === this) {
                    continue;
                  }
                  if (entry.renderWebGL || entry.renderCanvas) {
                    this.batchGameObject(entry, x, y);
                  } else if (entry.isParent || entry.list) {
                    this.batchGroup(entry.getChildren(), x, y);
                  } else if (typeof entry === "string") {
                    this.batchTextureFrameKey(entry, null, x, y, alpha, tint);
                  } else if (entry instanceof Frame) {
                    this.batchTextureFrame(entry, x, y, alpha, tint);
                  } else if (Array.isArray(entry)) {
                    this.batchList(entry, x, y, alpha, tint);
                  }
                }
              },
              batchGroup: function(children, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                for (var i = 0; i < children.length; i++) {
                  var entry = children[i];
                  if (entry.willRender(this.camera)) {
                    this.batchGameObject(entry, entry.x + x, entry.y + y);
                  }
                }
              },
              batchGameObject: function(gameObject, x, y) {
                if (x === void 0) {
                  x = gameObject.x;
                }
                if (y === void 0) {
                  y = gameObject.y;
                }
                var prevX = gameObject.x;
                var prevY = gameObject.y;
                var camera = this.camera;
                var renderer = this.renderer;
                var eraseMode = this._eraseMode;
                var mask = gameObject.mask;
                gameObject.setPosition(x, y);
                if (this.canvas) {
                  if (eraseMode) {
                    var blendMode = gameObject.blendMode;
                    gameObject.blendMode = BlendModes.ERASE;
                  }
                  if (mask) {
                    mask.preRenderCanvas(renderer, gameObject, camera);
                  }
                  gameObject.renderCanvas(renderer, gameObject, camera, null);
                  if (mask) {
                    mask.postRenderCanvas(renderer, gameObject, camera);
                  }
                  if (eraseMode) {
                    gameObject.blendMode = blendMode;
                  }
                } else if (renderer) {
                  if (mask) {
                    mask.preRenderWebGL(renderer, gameObject, camera);
                  }
                  if (!eraseMode) {
                    renderer.setBlendMode(gameObject.blendMode);
                  }
                  gameObject.renderWebGL(renderer, gameObject, camera);
                  if (mask) {
                    mask.postRenderWebGL(renderer, camera, this.renderTarget);
                  }
                }
                gameObject.setPosition(prevX, prevY);
              },
              batchTextureFrameKey: function(key, frame, x, y, alpha, tint) {
                var textureFrame = this.manager.getFrame(key, frame);
                if (textureFrame) {
                  this.batchTextureFrame(textureFrame, x, y, alpha, tint);
                }
              },
              batchTextureFrame: function(textureFrame, x, y, alpha, tint) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (alpha === void 0) {
                  alpha = 1;
                }
                if (tint === void 0) {
                  tint = 16777215;
                }
                var matrix = this.camera.matrix;
                var renderTarget = this.renderTarget;
                if (renderTarget) {
                  this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, matrix, null);
                } else {
                  var ctx = this.context;
                  var cd = textureFrame.canvasData;
                  var source = textureFrame.source.image;
                  ctx.save();
                  ctx.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over";
                  ctx.globalAlpha = alpha;
                  matrix.setToContext(ctx);
                  if (cd.width > 0 && cd.height > 0) {
                    ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
                  }
                  ctx.restore();
                }
              },
              snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
                if (this.renderTarget) {
                  this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);
                } else {
                  this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);
                }
                return this;
              },
              snapshot: function(callback, type, encoderOptions) {
                return this.snapshotArea(0, 0, this.width, this.height, callback, type, encoderOptions);
              },
              snapshotPixel: function(x, y, callback) {
                return this.snapshotArea(x, y, 1, 1, callback, "pixel");
              },
              getWebGLTexture: function() {
                if (this.renderTarget) {
                  return this.renderTarget.texture;
                }
              },
              renderWebGL: function(renderer, src, camera, parentMatrix) {
                var stamp = this.manager.resetStamp();
                stamp.setTexture(this);
                stamp.setOrigin(0);
                stamp.renderWebGL(renderer, stamp, camera, parentMatrix);
              },
              renderCanvas: function() {
              },
              destroy: function() {
                var stamp = this.manager.stamp;
                if (stamp && stamp.texture === this) {
                  this.manager.resetStamp();
                }
                Texture.prototype.destroy.call(this);
                CanvasPool.remove(this.canvas);
                if (this.renderTarget) {
                  this.renderTarget.destroy();
                }
                this.camera.destroy();
                this.canvas = null;
                this.context = null;
                this.renderer = null;
              }
            });
            module2.exports = DynamicTexture;
          },
          82047: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Clamp = __webpack_require__2(82897);
            var Extend = __webpack_require__2(98611);
            var Frame = new Class({
              initialize: function Frame2(texture, name, sourceIndex, x, y, width, height) {
                this.texture = texture;
                this.name = name;
                this.source = texture.source[sourceIndex];
                this.sourceIndex = sourceIndex;
                this.glTexture = this.source.glTexture;
                this.cutX;
                this.cutY;
                this.cutWidth;
                this.cutHeight;
                this.x = 0;
                this.y = 0;
                this.width;
                this.height;
                this.halfWidth;
                this.halfHeight;
                this.centerX;
                this.centerY;
                this.pivotX = 0;
                this.pivotY = 0;
                this.customPivot = false;
                this.rotated = false;
                this.autoRound = -1;
                this.customData = {};
                this.u0 = 0;
                this.v0 = 0;
                this.u1 = 0;
                this.v1 = 0;
                this.data = {
                  cut: {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0,
                    r: 0,
                    b: 0
                  },
                  trim: false,
                  sourceSize: {
                    w: 0,
                    h: 0
                  },
                  spriteSourceSize: {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0,
                    r: 0,
                    b: 0
                  },
                  radius: 0,
                  drawImage: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  },
                  is3Slice: false,
                  scale9: false,
                  scale9Borders: {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0
                  }
                };
                this.setSize(width, height, x, y);
              },
              setSize: function(width, height, x, y) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                this.cutX = x;
                this.cutY = y;
                this.cutWidth = width;
                this.cutHeight = height;
                this.width = width;
                this.height = height;
                this.halfWidth = Math.floor(width * 0.5);
                this.halfHeight = Math.floor(height * 0.5);
                this.centerX = Math.floor(width / 2);
                this.centerY = Math.floor(height / 2);
                var data = this.data;
                var cut = data.cut;
                cut.x = x;
                cut.y = y;
                cut.w = width;
                cut.h = height;
                cut.r = x + width;
                cut.b = y + height;
                data.sourceSize.w = width;
                data.sourceSize.h = height;
                data.spriteSourceSize.w = width;
                data.spriteSourceSize.h = height;
                data.radius = 0.5 * Math.sqrt(width * width + height * height);
                var drawImage = data.drawImage;
                drawImage.x = x;
                drawImage.y = y;
                drawImage.width = width;
                drawImage.height = height;
                return this.updateUVs();
              },
              setTrim: function(actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
                var data = this.data;
                var ss = data.spriteSourceSize;
                data.trim = true;
                data.sourceSize.w = actualWidth;
                data.sourceSize.h = actualHeight;
                ss.x = destX;
                ss.y = destY;
                ss.w = destWidth;
                ss.h = destHeight;
                ss.r = destX + destWidth;
                ss.b = destY + destHeight;
                this.x = destX;
                this.y = destY;
                this.width = destWidth;
                this.height = destHeight;
                this.halfWidth = destWidth * 0.5;
                this.halfHeight = destHeight * 0.5;
                this.centerX = Math.floor(destWidth / 2);
                this.centerY = Math.floor(destHeight / 2);
                return this.updateUVs();
              },
              setScale9: function(x, y, width, height) {
                var data = this.data;
                data.scale9 = true;
                data.is3Slice = y === 0 && height === this.height;
                data.scale9Borders.x = x;
                data.scale9Borders.y = y;
                data.scale9Borders.w = width;
                data.scale9Borders.h = height;
                return this;
              },
              setCropUVs: function(crop, x, y, width, height, flipX, flipY) {
                var cx = this.cutX;
                var cy = this.cutY;
                var cw = this.cutWidth;
                var ch = this.cutHeight;
                var rw = this.realWidth;
                var rh = this.realHeight;
                x = Clamp(x, 0, rw);
                y = Clamp(y, 0, rh);
                width = Clamp(width, 0, rw - x);
                height = Clamp(height, 0, rh - y);
                var ox = cx + x;
                var oy = cy + y;
                var ow = width;
                var oh = height;
                var data = this.data;
                if (data.trim) {
                  var ss = data.spriteSourceSize;
                  width = Clamp(width, 0, cw - x);
                  height = Clamp(height, 0, ch - y);
                  var cropRight = x + width;
                  var cropBottom = y + height;
                  var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);
                  if (intersects) {
                    var ix = Math.max(ss.x, x);
                    var iy = Math.max(ss.y, y);
                    var iw = Math.min(ss.r, cropRight) - ix;
                    var ih = Math.min(ss.b, cropBottom) - iy;
                    ow = iw;
                    oh = ih;
                    if (flipX) {
                      ox = cx + (cw - (ix - ss.x) - iw);
                    } else {
                      ox = cx + (ix - ss.x);
                    }
                    if (flipY) {
                      oy = cy + (ch - (iy - ss.y) - ih);
                    } else {
                      oy = cy + (iy - ss.y);
                    }
                    x = ix;
                    y = iy;
                    width = iw;
                    height = ih;
                  } else {
                    ox = 0;
                    oy = 0;
                    ow = 0;
                    oh = 0;
                  }
                } else {
                  if (flipX) {
                    ox = cx + (cw - x - width);
                  }
                  if (flipY) {
                    oy = cy + (ch - y - height);
                  }
                }
                var tw = this.source.width;
                var th = this.source.height;
                crop.u0 = Math.max(0, ox / tw);
                crop.v0 = Math.max(0, oy / th);
                crop.u1 = Math.min(1, (ox + ow) / tw);
                crop.v1 = Math.min(1, (oy + oh) / th);
                crop.x = x;
                crop.y = y;
                crop.cx = ox;
                crop.cy = oy;
                crop.cw = ow;
                crop.ch = oh;
                crop.width = width;
                crop.height = height;
                crop.flipX = flipX;
                crop.flipY = flipY;
                return crop;
              },
              updateCropUVs: function(crop, flipX, flipY) {
                return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);
              },
              setUVs: function(width, height, u0, v0, u1, v1) {
                var cd = this.data.drawImage;
                cd.width = width;
                cd.height = height;
                this.u0 = u0;
                this.v0 = v0;
                this.u1 = u1;
                this.v1 = v1;
                return this;
              },
              updateUVs: function() {
                var cx = this.cutX;
                var cy = this.cutY;
                var cw = this.cutWidth;
                var ch = this.cutHeight;
                var cd = this.data.drawImage;
                cd.width = cw;
                cd.height = ch;
                var tw = this.source.width;
                var th = this.source.height;
                this.u0 = cx / tw;
                this.v0 = cy / th;
                this.u1 = (cx + cw) / tw;
                this.v1 = (cy + ch) / th;
                return this;
              },
              updateUVsInverted: function() {
                var tw = this.source.width;
                var th = this.source.height;
                this.u0 = (this.cutX + this.cutHeight) / tw;
                this.v0 = this.cutY / th;
                this.u1 = this.cutX / tw;
                this.v1 = (this.cutY + this.cutWidth) / th;
                return this;
              },
              clone: function() {
                var clone = new Frame(this.texture, this.name, this.sourceIndex);
                clone.cutX = this.cutX;
                clone.cutY = this.cutY;
                clone.cutWidth = this.cutWidth;
                clone.cutHeight = this.cutHeight;
                clone.x = this.x;
                clone.y = this.y;
                clone.width = this.width;
                clone.height = this.height;
                clone.halfWidth = this.halfWidth;
                clone.halfHeight = this.halfHeight;
                clone.centerX = this.centerX;
                clone.centerY = this.centerY;
                clone.rotated = this.rotated;
                clone.data = Extend(true, clone.data, this.data);
                clone.updateUVs();
                return clone;
              },
              destroy: function() {
                this.texture = null;
                this.source = null;
                this.glTexture = null;
                this.customData = null;
                this.data = null;
              },
              realWidth: {
                get: function() {
                  return this.data.sourceSize.w;
                }
              },
              realHeight: {
                get: function() {
                  return this.data.sourceSize.h;
                }
              },
              radius: {
                get: function() {
                  return this.data.radius;
                }
              },
              trimmed: {
                get: function() {
                  return this.data.trim;
                }
              },
              scale9: {
                get: function() {
                  return this.data.scale9;
                }
              },
              is3Slice: {
                get: function() {
                  return this.data.is3Slice;
                }
              },
              canvasData: {
                get: function() {
                  return this.data.drawImage;
                }
              }
            });
            module2.exports = Frame;
          },
          31673: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Frame = __webpack_require__2(82047);
            var TextureSource = __webpack_require__2(32547);
            var TEXTURE_MISSING_ERROR = 'Texture "%s" has no frame "%s"';
            var Texture = new Class({
              initialize: function Texture2(manager, key, source, width, height) {
                if (!Array.isArray(source)) {
                  source = [source];
                }
                this.manager = manager;
                this.key = key;
                this.source = [];
                this.dataSource = [];
                this.frames = {};
                this.customData = {};
                this.firstFrame = "__BASE";
                this.frameTotal = 0;
                for (var i = 0; i < source.length; i++) {
                  this.source.push(new TextureSource(this, source[i], width, height));
                }
              },
              add: function(name, sourceIndex, x, y, width, height) {
                if (this.has(name)) {
                  return null;
                }
                var frame = new Frame(this, name, sourceIndex, x, y, width, height);
                this.frames[name] = frame;
                if (this.firstFrame === "__BASE") {
                  this.firstFrame = name;
                }
                this.frameTotal++;
                return frame;
              },
              remove: function(name) {
                if (this.has(name)) {
                  var frame = this.get(name);
                  frame.destroy();
                  delete this.frames[name];
                  return true;
                }
                return false;
              },
              has: function(name) {
                return this.frames.hasOwnProperty(name);
              },
              get: function(name) {
                if (!name) {
                  name = this.firstFrame;
                }
                var frame = this.frames[name];
                if (!frame) {
                  console.warn(TEXTURE_MISSING_ERROR, this.key, name);
                  frame = this.frames[this.firstFrame];
                }
                return frame;
              },
              getTextureSourceIndex: function(source) {
                for (var i = 0; i < this.source.length; i++) {
                  if (this.source[i] === source) {
                    return i;
                  }
                }
                return -1;
              },
              getFramesFromTextureSource: function(sourceIndex, includeBase) {
                if (includeBase === void 0) {
                  includeBase = false;
                }
                var out = [];
                for (var frameName in this.frames) {
                  if (frameName === "__BASE" && !includeBase) {
                    continue;
                  }
                  var frame = this.frames[frameName];
                  if (frame.sourceIndex === sourceIndex) {
                    out.push(frame);
                  }
                }
                return out;
              },
              getFrameNames: function(includeBase) {
                if (includeBase === void 0) {
                  includeBase = false;
                }
                var out = Object.keys(this.frames);
                if (!includeBase) {
                  var idx = out.indexOf("__BASE");
                  if (idx !== -1) {
                    out.splice(idx, 1);
                  }
                }
                return out;
              },
              getSourceImage: function(name) {
                if (name === void 0 || name === null || this.frameTotal === 1) {
                  name = "__BASE";
                }
                var frame = this.frames[name];
                if (frame) {
                  return frame.source.image;
                } else {
                  console.warn(TEXTURE_MISSING_ERROR, this.key, name);
                  return this.frames["__BASE"].source.image;
                }
              },
              getDataSourceImage: function(name) {
                if (name === void 0 || name === null || this.frameTotal === 1) {
                  name = "__BASE";
                }
                var frame = this.frames[name];
                var idx;
                if (!frame) {
                  console.warn(TEXTURE_MISSING_ERROR, this.key, name);
                  idx = this.frames["__BASE"].sourceIndex;
                } else {
                  idx = frame.sourceIndex;
                }
                return this.dataSource[idx].image;
              },
              setDataSource: function(data) {
                if (!Array.isArray(data)) {
                  data = [data];
                }
                for (var i = 0; i < data.length; i++) {
                  var source = this.source[i];
                  this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));
                }
              },
              setFilter: function(filterMode) {
                var i;
                for (i = 0; i < this.source.length; i++) {
                  this.source[i].setFilter(filterMode);
                }
                for (i = 0; i < this.dataSource.length; i++) {
                  this.dataSource[i].setFilter(filterMode);
                }
              },
              destroy: function() {
                var i;
                var source = this.source;
                var dataSource = this.dataSource;
                for (i = 0; i < source.length; i++) {
                  if (source[i]) {
                    source[i].destroy();
                  }
                }
                for (i = 0; i < dataSource.length; i++) {
                  if (dataSource[i]) {
                    dataSource[i].destroy();
                  }
                }
                for (var frameName in this.frames) {
                  var frame = this.frames[frameName];
                  if (frame) {
                    frame.destroy();
                  }
                }
                this.source = [];
                this.dataSource = [];
                this.frames = {};
                this.manager.removeKey(this.key);
                this.manager = null;
              }
            });
            module2.exports = Texture;
          },
          6237: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasPool = __webpack_require__2(61068);
            var CanvasTexture = __webpack_require__2(17487);
            var Class = __webpack_require__2(56694);
            var Color = __webpack_require__2(27119);
            var CONST = __webpack_require__2(86459);
            var DynamicTexture = __webpack_require__2(845);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(38203);
            var Frame = __webpack_require__2(82047);
            var GameEvents = __webpack_require__2(97081);
            var GenerateTexture = __webpack_require__2(52780);
            var GetValue = __webpack_require__2(10850);
            var ImageGameObject = __webpack_require__2(1539);
            var IsPlainObject = __webpack_require__2(42911);
            var Parser = __webpack_require__2(69150);
            var Rectangle = __webpack_require__2(74118);
            var Texture = __webpack_require__2(31673);
            var TextureManager = new Class({
              Extends: EventEmitter,
              initialize: function TextureManager2(game) {
                EventEmitter.call(this);
                this.game = game;
                this.name = "TextureManager";
                this.list = {};
                this._tempCanvas = CanvasPool.create2D(this);
                this._tempContext = this._tempCanvas.getContext("2d", {willReadFrequently: true});
                this._pending = 0;
                this.stamp;
                this.stampCrop = new Rectangle();
                this.silentWarnings = false;
                game.events.once(GameEvents.BOOT, this.boot, this);
              },
              boot: function() {
                this._pending = 3;
                this.on(Events.LOAD, this.updatePending, this);
                this.on(Events.ERROR, this.updatePending, this);
                var config2 = this.game.config;
                this.addBase64("__DEFAULT", config2.defaultImage);
                this.addBase64("__MISSING", config2.missingImage);
                this.addBase64("__WHITE", config2.whiteImage);
                this.game.events.once(GameEvents.DESTROY, this.destroy, this);
                this.game.events.once(GameEvents.SYSTEM_READY, function(scene) {
                  this.stamp = new ImageGameObject(scene).setOrigin(0);
                }, this);
              },
              updatePending: function() {
                this._pending--;
                if (this._pending === 0) {
                  this.off(Events.LOAD);
                  this.off(Events.ERROR);
                  this.emit(Events.READY);
                }
              },
              checkKey: function(key) {
                if (this.exists(key)) {
                  if (!this.silentWarnings) {
                    console.error("Texture key already in use: " + key);
                  }
                  return false;
                }
                return true;
              },
              remove: function(key) {
                if (typeof key === "string") {
                  if (this.exists(key)) {
                    key = this.get(key);
                  } else {
                    if (!this.silentWarnings) {
                      console.warn("No texture found matching key: " + key);
                    }
                    return this;
                  }
                }
                var textureKey = key.key;
                if (this.list.hasOwnProperty(textureKey)) {
                  key.destroy();
                  this.emit(Events.REMOVE, textureKey);
                  this.emit(Events.REMOVE_KEY + textureKey);
                }
                return this;
              },
              removeKey: function(key) {
                if (this.list.hasOwnProperty(key)) {
                  delete this.list[key];
                }
                return this;
              },
              addBase64: function(key, data) {
                if (this.checkKey(key)) {
                  var _this = this;
                  var image = new Image();
                  image.onerror = function() {
                    _this.emit(Events.ERROR, key);
                  };
                  image.onload = function() {
                    var texture = _this.create(key, image);
                    Parser.Image(texture, 0);
                    _this.emit(Events.ADD, key, texture);
                    _this.emit(Events.ADD_KEY + key, texture);
                    _this.emit(Events.LOAD, key, texture);
                  };
                  image.src = data;
                }
                return this;
              },
              getBase64: function(key, frame, type, encoderOptions) {
                if (type === void 0) {
                  type = "image/png";
                }
                if (encoderOptions === void 0) {
                  encoderOptions = 0.92;
                }
                var data = "";
                var textureFrame = this.getFrame(key, frame);
                if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture)) {
                  if (!this.silentWarnings) {
                    console.warn("Cannot getBase64 from WebGL Texture");
                  }
                } else if (textureFrame) {
                  var cd = textureFrame.canvasData;
                  var canvas = CanvasPool.create2D(this, cd.width, cd.height);
                  var ctx = canvas.getContext("2d", {willReadFrequently: true});
                  if (cd.width > 0 && cd.height > 0) {
                    ctx.drawImage(textureFrame.source.image, cd.x, cd.y, cd.width, cd.height, 0, 0, cd.width, cd.height);
                  }
                  data = canvas.toDataURL(type, encoderOptions);
                  CanvasPool.remove(canvas);
                }
                return data;
              },
              addImage: function(key, source, dataSource) {
                var texture = null;
                if (this.checkKey(key)) {
                  texture = this.create(key, source);
                  Parser.Image(texture, 0);
                  if (dataSource) {
                    texture.setDataSource(dataSource);
                  }
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addGLTexture: function(key, glTexture, width, height) {
                var texture = null;
                if (this.checkKey(key)) {
                  if (width === void 0) {
                    width = glTexture.width;
                  }
                  if (height === void 0) {
                    height = glTexture.height;
                  }
                  texture = this.create(key, glTexture, width, height);
                  texture.add("__BASE", 0, 0, 0, width, height);
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addCompressedTexture: function(key, textureData, atlasData) {
                var texture = null;
                if (this.checkKey(key)) {
                  texture = this.create(key, textureData);
                  texture.add("__BASE", 0, 0, 0, textureData.width, textureData.height);
                  if (atlasData) {
                    if (Array.isArray(atlasData)) {
                      for (var i = 0; i < atlasData.length; i++) {
                        Parser.JSONHash(texture, i, atlasData[i]);
                      }
                    } else {
                      Parser.JSONHash(texture, 0, atlasData);
                    }
                  }
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addRenderTexture: function(key, renderTexture) {
                var texture = null;
                if (this.checkKey(key)) {
                  texture = this.create(key, renderTexture);
                  texture.add("__BASE", 0, 0, 0, renderTexture.width, renderTexture.height);
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              generate: function(key, config2) {
                if (this.checkKey(key)) {
                  var canvas = CanvasPool.create(this, 1, 1);
                  config2.canvas = canvas;
                  GenerateTexture(config2);
                  return this.addCanvas(key, canvas);
                } else {
                  return null;
                }
              },
              createCanvas: function(key, width, height) {
                if (width === void 0) {
                  width = 256;
                }
                if (height === void 0) {
                  height = 256;
                }
                if (this.checkKey(key)) {
                  var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);
                  return this.addCanvas(key, canvas);
                }
                return null;
              },
              addCanvas: function(key, source, skipCache) {
                if (skipCache === void 0) {
                  skipCache = false;
                }
                var texture = null;
                if (skipCache) {
                  texture = new CanvasTexture(this, key, source, source.width, source.height);
                } else if (this.checkKey(key)) {
                  texture = new CanvasTexture(this, key, source, source.width, source.height);
                  this.list[key] = texture;
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addDynamicTexture: function(key, width, height) {
                var texture = null;
                if (typeof key === "string" && !this.exists(key)) {
                  texture = new DynamicTexture(this, key, width, height);
                } else {
                  texture = key;
                  key = texture.key;
                }
                if (this.checkKey(key)) {
                  this.list[key] = texture;
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                } else {
                  texture = null;
                }
                return texture;
              },
              addAtlas: function(key, source, data, dataSource) {
                if (Array.isArray(data.textures) || Array.isArray(data.frames)) {
                  return this.addAtlasJSONArray(key, source, data, dataSource);
                } else {
                  return this.addAtlasJSONHash(key, source, data, dataSource);
                }
              },
              addAtlasJSONArray: function(key, source, data, dataSource) {
                var texture = null;
                if (source instanceof Texture) {
                  key = source.key;
                  texture = source;
                } else if (this.checkKey(key)) {
                  texture = this.create(key, source);
                }
                if (texture) {
                  if (Array.isArray(data)) {
                    var singleAtlasFile = data.length === 1;
                    for (var i = 0; i < texture.source.length; i++) {
                      var atlasData = singleAtlasFile ? data[0] : data[i];
                      Parser.JSONArray(texture, i, atlasData);
                    }
                  } else {
                    Parser.JSONArray(texture, 0, data);
                  }
                  if (dataSource) {
                    texture.setDataSource(dataSource);
                  }
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addAtlasJSONHash: function(key, source, data, dataSource) {
                var texture = null;
                if (source instanceof Texture) {
                  key = source.key;
                  texture = source;
                } else if (this.checkKey(key)) {
                  texture = this.create(key, source);
                }
                if (texture) {
                  if (Array.isArray(data)) {
                    for (var i = 0; i < data.length; i++) {
                      Parser.JSONHash(texture, i, data[i]);
                    }
                  } else {
                    Parser.JSONHash(texture, 0, data);
                  }
                  if (dataSource) {
                    texture.setDataSource(dataSource);
                  }
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addAtlasXML: function(key, source, data, dataSource) {
                var texture = null;
                if (source instanceof Texture) {
                  key = source.key;
                  texture = source;
                } else if (this.checkKey(key)) {
                  texture = this.create(key, source);
                }
                if (texture) {
                  Parser.AtlasXML(texture, 0, data);
                  if (dataSource) {
                    texture.setDataSource(dataSource);
                  }
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addUnityAtlas: function(key, source, data, dataSource) {
                var texture = null;
                if (source instanceof Texture) {
                  key = source.key;
                  texture = source;
                } else if (this.checkKey(key)) {
                  texture = this.create(key, source);
                }
                if (texture) {
                  Parser.UnityYAML(texture, 0, data);
                  if (dataSource) {
                    texture.setDataSource(dataSource);
                  }
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addSpriteSheet: function(key, source, config2, dataSource) {
                var texture = null;
                if (source instanceof Texture) {
                  key = source.key;
                  texture = source;
                } else if (this.checkKey(key)) {
                  texture = this.create(key, source);
                }
                if (texture) {
                  var width = texture.source[0].width;
                  var height = texture.source[0].height;
                  Parser.SpriteSheet(texture, 0, 0, 0, width, height, config2);
                  if (dataSource) {
                    texture.setDataSource(dataSource);
                  }
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                }
                return texture;
              },
              addSpriteSheetFromAtlas: function(key, config2) {
                if (!this.checkKey(key)) {
                  return null;
                }
                var atlasKey = GetValue(config2, "atlas", null);
                var atlasFrame = GetValue(config2, "frame", null);
                if (!atlasKey || !atlasFrame) {
                  return;
                }
                var atlas = this.get(atlasKey);
                var sheet = atlas.get(atlasFrame);
                if (sheet) {
                  var texture = this.create(key, sheet.source.image);
                  if (sheet.trimmed) {
                    Parser.SpriteSheetFromAtlas(texture, sheet, config2);
                  } else {
                    Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config2);
                  }
                  this.emit(Events.ADD, key, texture);
                  this.emit(Events.ADD_KEY + key, texture);
                  return texture;
                }
              },
              create: function(key, source, width, height) {
                var texture = null;
                if (this.checkKey(key)) {
                  texture = new Texture(this, key, source, width, height);
                  this.list[key] = texture;
                }
                return texture;
              },
              exists: function(key) {
                return this.list.hasOwnProperty(key);
              },
              get: function(key) {
                if (key === void 0) {
                  key = "__DEFAULT";
                }
                if (this.list[key]) {
                  return this.list[key];
                } else if (key instanceof Texture) {
                  return key;
                } else if (key instanceof Frame) {
                  return key.texture;
                } else {
                  return this.list["__MISSING"];
                }
              },
              cloneFrame: function(key, frame) {
                if (this.list[key]) {
                  return this.list[key].get(frame).clone();
                }
              },
              getFrame: function(key, frame) {
                if (this.list[key]) {
                  return this.list[key].get(frame);
                }
              },
              parseFrame: function(key) {
                if (!key) {
                  return void 0;
                } else if (typeof key === "string") {
                  return this.getFrame(key);
                } else if (Array.isArray(key) && key.length === 2) {
                  return this.getFrame(key[0], key[1]);
                } else if (IsPlainObject(key)) {
                  return this.getFrame(key.key, key.frame);
                } else if (key instanceof Texture) {
                  return key.get();
                } else if (key instanceof Frame) {
                  return key;
                }
              },
              getTextureKeys: function() {
                var output = [];
                for (var key in this.list) {
                  if (key !== "__DEFAULT" && key !== "__MISSING" && key !== "__WHITE") {
                    output.push(key);
                  }
                }
                return output;
              },
              getPixel: function(x, y, key, frame) {
                var textureFrame = this.getFrame(key, frame);
                if (textureFrame) {
                  x -= textureFrame.x;
                  y -= textureFrame.y;
                  var data = textureFrame.data.cut;
                  x += data.x;
                  y += data.y;
                  if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
                    var ctx = this._tempContext;
                    ctx.clearRect(0, 0, 1, 1);
                    ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
                    var rgb = ctx.getImageData(0, 0, 1, 1);
                    return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
                  }
                }
                return null;
              },
              getPixelAlpha: function(x, y, key, frame) {
                var textureFrame = this.getFrame(key, frame);
                if (textureFrame) {
                  x -= textureFrame.x;
                  y -= textureFrame.y;
                  var data = textureFrame.data.cut;
                  x += data.x;
                  y += data.y;
                  if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
                    var ctx = this._tempContext;
                    ctx.clearRect(0, 0, 1, 1);
                    ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
                    var rgb = ctx.getImageData(0, 0, 1, 1);
                    return rgb.data[3];
                  }
                }
                return null;
              },
              setTexture: function(gameObject, key, frame) {
                if (this.list[key]) {
                  gameObject.texture = this.list[key];
                  gameObject.frame = gameObject.texture.get(frame);
                }
                return gameObject;
              },
              renameTexture: function(currentKey, newKey) {
                var texture = this.get(currentKey);
                if (texture && currentKey !== newKey) {
                  texture.key = newKey;
                  this.list[newKey] = texture;
                  delete this.list[currentKey];
                  return true;
                }
                return false;
              },
              each: function(callback, scope) {
                var args = [null];
                for (var i = 1; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                for (var texture in this.list) {
                  args[0] = this.list[texture];
                  callback.apply(scope, args);
                }
              },
              resetStamp: function(alpha, tint) {
                if (alpha === void 0) {
                  alpha = 1;
                }
                if (tint === void 0) {
                  tint = 16777215;
                }
                var stamp = this.stamp;
                stamp.setCrop();
                stamp.setPosition(0);
                stamp.setAngle(0);
                stamp.setScale(1);
                stamp.setAlpha(alpha);
                stamp.setTint(tint);
                stamp.setTexture("__WHITE");
                return stamp;
              },
              destroy: function() {
                for (var texture in this.list) {
                  this.list[texture].destroy();
                }
                this.list = {};
                this.stamp.destroy();
                this.game = null;
                this.stamp = null;
                CanvasPool.remove(this._tempCanvas);
              }
            });
            module2.exports = TextureManager;
          },
          32547: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CanvasPool = __webpack_require__2(61068);
            var Class = __webpack_require__2(56694);
            var IsSizePowerOfTwo = __webpack_require__2(28621);
            var ScaleModes = __webpack_require__2(27394);
            var TextureSource = new Class({
              initialize: function TextureSource2(texture, source, width, height, flipY) {
                if (flipY === void 0) {
                  flipY = false;
                }
                var game = texture.manager.game;
                this.renderer = game.renderer;
                this.texture = texture;
                this.source = source;
                this.image = source.compressed ? null : source;
                this.compressionAlgorithm = source.compressed ? source.format : null;
                this.resolution = 1;
                this.width = width || source.naturalWidth || source.videoWidth || source.width || 0;
                this.height = height || source.naturalHeight || source.videoHeight || source.height || 0;
                this.scaleMode = ScaleModes.DEFAULT;
                this.isCanvas = source instanceof HTMLCanvasElement;
                this.isVideo = window.hasOwnProperty("HTMLVideoElement") && source instanceof HTMLVideoElement;
                this.isRenderTexture = source.type === "RenderTexture" || source.type === "DynamicTexture";
                this.isGLTexture = window.hasOwnProperty("WebGLTexture") && source instanceof WebGLTexture;
                this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);
                this.glTexture = null;
                this.flipY = flipY;
                this.init(game);
              },
              init: function(game) {
                var renderer = this.renderer;
                if (renderer) {
                  var source = this.source;
                  if (renderer.gl) {
                    var image = this.image;
                    var flipY = this.flipY;
                    var width = this.width;
                    var height = this.height;
                    var scaleMode = this.scaleMode;
                    if (this.isCanvas) {
                      this.glTexture = renderer.createCanvasTexture(image, false, flipY);
                    } else if (this.isVideo) {
                      this.glTexture = renderer.createVideoTexture(image, false, flipY);
                    } else if (this.isRenderTexture) {
                      this.glTexture = renderer.createTextureFromSource(null, width, height, scaleMode);
                    } else if (this.isGLTexture) {
                      this.glTexture = source;
                    } else if (this.compressionAlgorithm) {
                      this.glTexture = renderer.createTextureFromSource(source);
                    } else {
                      this.glTexture = renderer.createTextureFromSource(image, width, height, scaleMode);
                    }
                    if (false) {
                    }
                  } else if (this.isRenderTexture) {
                    this.image = source.canvas;
                  }
                }
                if (!game.config.antialias) {
                  this.setFilter(1);
                }
              },
              setFilter: function(filterMode) {
                if (this.renderer && this.renderer.gl) {
                  this.renderer.setTextureFilter(this.glTexture, filterMode);
                }
                this.scaleMode = filterMode;
              },
              setFlipY: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.flipY = value;
                return this;
              },
              update: function() {
                var renderer = this.renderer;
                var image = this.image;
                var flipY = this.flipY;
                var gl = renderer.gl;
                if (gl && this.isCanvas) {
                  this.glTexture = renderer.updateCanvasTexture(image, this.glTexture, flipY);
                } else if (gl && this.isVideo) {
                  this.glTexture = renderer.updateVideoTexture(image, this.glTexture, flipY);
                }
              },
              destroy: function() {
                if (this.glTexture) {
                  this.renderer.deleteTexture(this.glTexture);
                }
                if (this.isCanvas) {
                  CanvasPool.remove(this.image);
                }
                this.renderer = null;
                this.texture = null;
                this.source = null;
                this.image = null;
                this.glTexture = null;
              }
            });
            module2.exports = TextureSource;
          },
          65154: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = {
              LINEAR: 0,
              NEAREST: 1
            };
            module2.exports = CONST;
          },
          49644: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "addtexture";
          },
          29569: (module2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "addtexture-";
          },
          60079: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "onerror";
          },
          72665: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "onload";
          },
          93006: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "ready";
          },
          69018: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "removetexture";
          },
          85549: (module2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "removetexture-";
          },
          38203: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ADD: __webpack_require__2(49644),
              ADD_KEY: __webpack_require__2(29569),
              ERROR: __webpack_require__2(60079),
              LOAD: __webpack_require__2(72665),
              READY: __webpack_require__2(93006),
              REMOVE: __webpack_require__2(69018),
              REMOVE_KEY: __webpack_require__2(85549)
            };
          },
          87499: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Extend = __webpack_require__2(98611);
            var FilterMode = __webpack_require__2(65154);
            var Textures = {
              CanvasTexture: __webpack_require__2(17487),
              DynamicTexture: __webpack_require__2(845),
              Events: __webpack_require__2(38203),
              FilterMode,
              Frame: __webpack_require__2(82047),
              Parsers: __webpack_require__2(69150),
              Texture: __webpack_require__2(31673),
              TextureManager: __webpack_require__2(6237),
              TextureSource: __webpack_require__2(32547)
            };
            Textures = Extend(false, Textures, FilterMode);
            module2.exports = Textures;
          },
          35082: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AtlasXML = function(texture, sourceIndex, xml) {
              if (!xml.getElementsByTagName("TextureAtlas")) {
                console.warn("Invalid Texture Atlas XML given");
                return;
              }
              var source = texture.source[sourceIndex];
              texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
              var frames = xml.getElementsByTagName("SubTexture");
              var newFrame;
              for (var i = 0; i < frames.length; i++) {
                var frame = frames[i].attributes;
                var name = frame.name.value;
                var x = parseInt(frame.x.value, 10);
                var y = parseInt(frame.y.value, 10);
                var width = parseInt(frame.width.value, 10);
                var height = parseInt(frame.height.value, 10);
                newFrame = texture.add(name, sourceIndex, x, y, width, height);
                if (frame.frameX) {
                  var frameX = Math.abs(parseInt(frame.frameX.value, 10));
                  var frameY = Math.abs(parseInt(frame.frameY.value, 10));
                  var frameWidth = parseInt(frame.frameWidth.value, 10);
                  var frameHeight = parseInt(frame.frameHeight.value, 10);
                  newFrame.setTrim(width, height, frameX, frameY, frameWidth, frameHeight);
                }
              }
              return texture;
            };
            module2.exports = AtlasXML;
          },
          83332: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Canvas = function(texture, sourceIndex) {
              var source = texture.source[sourceIndex];
              texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
              return texture;
            };
            module2.exports = Canvas;
          },
          21560: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Image2 = function(texture, sourceIndex) {
              var source = texture.source[sourceIndex];
              texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
              return texture;
            };
            module2.exports = Image2;
          },
          64423: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clone = __webpack_require__2(32742);
            var JSONArray = function(texture, sourceIndex, json) {
              if (!json["frames"] && !json["textures"]) {
                console.warn("Invalid Texture Atlas JSON Array");
                return;
              }
              var source = texture.source[sourceIndex];
              texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
              var frames = Array.isArray(json.textures) ? json.textures[sourceIndex].frames : json.frames;
              var newFrame;
              for (var i = 0; i < frames.length; i++) {
                var src = frames[i];
                newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
                if (!newFrame) {
                  console.warn("Invalid atlas json, frame already exists: " + src.filename);
                  continue;
                }
                if (src.trimmed) {
                  newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
                }
                if (src.rotated) {
                  newFrame.rotated = true;
                  newFrame.updateUVsInverted();
                }
                var pivot = src.anchor || src.pivot;
                if (pivot) {
                  newFrame.customPivot = true;
                  newFrame.pivotX = pivot.x;
                  newFrame.pivotY = pivot.y;
                }
                if (src.scale9Borders) {
                  newFrame.setScale9(src.scale9Borders.x, src.scale9Borders.y, src.scale9Borders.w, src.scale9Borders.h);
                }
                newFrame.customData = Clone(src);
              }
              for (var dataKey in json) {
                if (dataKey === "frames") {
                  continue;
                }
                if (Array.isArray(json[dataKey])) {
                  texture.customData[dataKey] = json[dataKey].slice(0);
                } else {
                  texture.customData[dataKey] = json[dataKey];
                }
              }
              return texture;
            };
            module2.exports = JSONArray;
          },
          17264: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clone = __webpack_require__2(32742);
            var JSONHash = function(texture, sourceIndex, json) {
              if (!json["frames"]) {
                console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
                return;
              }
              var source = texture.source[sourceIndex];
              texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
              var frames = json.frames;
              var newFrame;
              for (var key in frames) {
                if (!frames.hasOwnProperty(key)) {
                  continue;
                }
                var src = frames[key];
                newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
                if (!newFrame) {
                  console.warn("Invalid atlas json, frame already exists: " + key);
                  continue;
                }
                if (src.trimmed) {
                  newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
                }
                if (src.rotated) {
                  newFrame.rotated = true;
                  newFrame.updateUVsInverted();
                }
                var pivot = src.anchor || src.pivot;
                if (pivot) {
                  newFrame.customPivot = true;
                  newFrame.pivotX = pivot.x;
                  newFrame.pivotY = pivot.y;
                }
                if (src.scale9Borders) {
                  newFrame.setScale9(src.scale9Borders.x, src.scale9Borders.y, src.scale9Borders.w, src.scale9Borders.h);
                }
                newFrame.customData = Clone(src);
              }
              for (var dataKey in json) {
                if (dataKey === "frames") {
                  continue;
                }
                if (Array.isArray(json[dataKey])) {
                  texture.customData[dataKey] = json[dataKey].slice(0);
                } else {
                  texture.customData[dataKey] = json[dataKey];
                }
              }
              return texture;
            };
            module2.exports = JSONHash;
          },
          67409: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2021 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var KTXParser = function(data) {
              var idCheck = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
              var i;
              var id = new Uint8Array(data, 0, 12);
              for (i = 0; i < id.length; i++) {
                if (id[i] !== idCheck[i]) {
                  console.warn("KTXParser - Invalid file format");
                  return;
                }
              }
              var size = Uint32Array.BYTES_PER_ELEMENT;
              var head = new DataView(data, 12, 13 * size);
              var littleEndian = head.getUint32(0, true) === 67305985;
              var glType = head.getUint32(1 * size, littleEndian);
              if (glType !== 0) {
                console.warn("KTXParser - Only compressed formats supported");
                return;
              }
              var internalFormat = head.getUint32(4 * size, littleEndian);
              var width = head.getUint32(6 * size, littleEndian);
              var height = head.getUint32(7 * size, littleEndian);
              var mipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));
              var bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);
              var mipmaps = new Array(mipmapLevels);
              var offset = 12 + 13 * 4 + bytesOfKeyValueData;
              var levelWidth = width;
              var levelHeight = height;
              for (i = 0; i < mipmapLevels; i++) {
                var levelSize = new Int32Array(data, offset, 1)[0];
                offset += 4;
                mipmaps[i] = {
                  data: new Uint8Array(data, offset, levelSize),
                  width: levelWidth,
                  height: levelHeight
                };
                levelWidth = Math.max(1, levelWidth >> 1);
                levelHeight = Math.max(1, levelHeight >> 1);
                offset += levelSize;
              }
              return {
                mipmaps,
                width,
                height,
                internalFormat,
                compressed: true,
                generateMipmap: false
              };
            };
            module2.exports = KTXParser;
          },
          24904: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2021 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            function GetSize(width, height, x, y, dx, dy, mult) {
              if (mult === void 0) {
                mult = 16;
              }
              return Math.floor((width + x) / dx) * Math.floor((height + y) / dy) * mult;
            }
            function PVRTC2bppSize(width, height) {
              width = Math.max(width, 16);
              height = Math.max(height, 8);
              return width * height / 4;
            }
            function PVRTC4bppSize(width, height) {
              width = Math.max(width, 8);
              height = Math.max(height, 8);
              return width * height / 2;
            }
            function DXTEtcSmallSize(width, height) {
              return GetSize(width, height, 3, 3, 4, 4, 8);
            }
            function DXTEtcAstcBigSize(width, height) {
              return GetSize(width, height, 3, 3, 4, 4);
            }
            function ATC5x4Size(width, height) {
              return GetSize(width, height, 4, 3, 5, 4);
            }
            function ATC5x5Size(width, height) {
              return GetSize(width, height, 4, 4, 5, 5);
            }
            function ATC6x5Size(width, height) {
              return GetSize(width, height, 5, 4, 6, 5);
            }
            function ATC6x6Size(width, height) {
              return GetSize(width, height, 5, 5, 6, 6);
            }
            function ATC8x5Size(width, height) {
              return GetSize(width, height, 7, 4, 8, 5);
            }
            function ATC8x6Size(width, height) {
              return GetSize(width, height, 7, 5, 8, 6);
            }
            function ATC8x8Size(width, height) {
              return GetSize(width, height, 7, 7, 8, 8);
            }
            function ATC10x5Size(width, height) {
              return GetSize(width, height, 9, 4, 10, 5);
            }
            function ATC10x6Size(width, height) {
              return GetSize(width, height, 9, 5, 10, 6);
            }
            function ATC10x8Size(width, height) {
              return GetSize(width, height, 9, 7, 10, 8);
            }
            function ATC10x10Size(width, height) {
              return GetSize(width, height, 9, 9, 10, 10);
            }
            function ATC12x10Size(width, height) {
              return GetSize(width, height, 11, 9, 12, 10);
            }
            function ATC12x12Size(width, height) {
              return GetSize(width, height, 11, 11, 12, 12);
            }
            var FORMATS = {
              0: {sizeFunc: PVRTC2bppSize, glFormat: 35841},
              1: {sizeFunc: PVRTC2bppSize, glFormat: 35843},
              2: {sizeFunc: PVRTC4bppSize, glFormat: 35840},
              3: {sizeFunc: PVRTC4bppSize, glFormat: 35842},
              6: {sizeFunc: DXTEtcSmallSize, glFormat: 36196},
              7: {sizeFunc: DXTEtcSmallSize, glFormat: 33776},
              8: {sizeFunc: DXTEtcAstcBigSize, glFormat: 33777},
              9: {sizeFunc: DXTEtcAstcBigSize, glFormat: 33778},
              11: {sizeFunc: DXTEtcAstcBigSize, glFormat: 33779},
              22: {sizeFunc: DXTEtcSmallSize, glFormat: 37492},
              23: {sizeFunc: DXTEtcAstcBigSize, glFormat: 37496},
              24: {sizeFunc: DXTEtcSmallSize, glFormat: 37494},
              25: {sizeFunc: DXTEtcSmallSize, glFormat: 37488},
              26: {sizeFunc: DXTEtcAstcBigSize, glFormat: 37490},
              27: {sizeFunc: DXTEtcAstcBigSize, glFormat: 37808},
              28: {sizeFunc: ATC5x4Size, glFormat: 37809},
              29: {sizeFunc: ATC5x5Size, glFormat: 37810},
              30: {sizeFunc: ATC6x5Size, glFormat: 37811},
              31: {sizeFunc: ATC6x6Size, glFormat: 37812},
              32: {sizeFunc: ATC8x5Size, glFormat: 37813},
              33: {sizeFunc: ATC8x6Size, glFormat: 37814},
              34: {sizeFunc: ATC8x8Size, glFormat: 37815},
              35: {sizeFunc: ATC10x5Size, glFormat: 37816},
              36: {sizeFunc: ATC10x6Size, glFormat: 37817},
              37: {sizeFunc: ATC10x8Size, glFormat: 37818},
              38: {sizeFunc: ATC10x10Size, glFormat: 37819},
              39: {sizeFunc: ATC12x10Size, glFormat: 37820},
              40: {sizeFunc: ATC12x12Size, glFormat: 37821}
            };
            var PVRParser = function(data) {
              var header = new Uint32Array(data, 0, 13);
              var pvrFormat = header[2];
              var internalFormat = FORMATS[pvrFormat].glFormat;
              var sizeFunction = FORMATS[pvrFormat].sizeFunc;
              var mipmapLevels = header[11];
              var width = header[7];
              var height = header[6];
              var dataOffset = 52 + header[12];
              var image = new Uint8Array(data, dataOffset);
              var mipmaps = new Array(mipmapLevels);
              var offset = 0;
              var levelWidth = width;
              var levelHeight = height;
              for (var i = 0; i < mipmapLevels; i++) {
                var levelSize = sizeFunction(levelWidth, levelHeight);
                mipmaps[i] = {
                  data: new Uint8Array(image.buffer, image.byteOffset + offset, levelSize),
                  width: levelWidth,
                  height: levelHeight
                };
                levelWidth = Math.max(1, levelWidth >> 1);
                levelHeight = Math.max(1, levelHeight >> 1);
                offset += levelSize;
              }
              return {
                mipmaps,
                width,
                height,
                internalFormat,
                compressed: true,
                generateMipmap: false
              };
            };
            module2.exports = PVRParser;
          },
          6143: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var SpriteSheet = function(texture, sourceIndex, x, y, width, height, config2) {
              var frameWidth = GetFastValue(config2, "frameWidth", null);
              var frameHeight = GetFastValue(config2, "frameHeight", frameWidth);
              if (frameWidth === null) {
                throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
              }
              var source = texture.source[sourceIndex];
              texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
              var startFrame = GetFastValue(config2, "startFrame", 0);
              var endFrame = GetFastValue(config2, "endFrame", -1);
              var margin = GetFastValue(config2, "margin", 0);
              var spacing = GetFastValue(config2, "spacing", 0);
              var row = Math.floor((width - margin + spacing) / (frameWidth + spacing));
              var column = Math.floor((height - margin + spacing) / (frameHeight + spacing));
              var total = row * column;
              if (total === 0) {
                console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", texture.key);
              }
              if (startFrame > total || startFrame < -total) {
                startFrame = 0;
              }
              if (startFrame < 0) {
                startFrame = total + startFrame;
              }
              if (endFrame === -1 || endFrame > total || endFrame < startFrame) {
                endFrame = total;
              }
              var fx = margin;
              var fy = margin;
              var ax = 0;
              var ay = 0;
              var c = 0;
              for (var i = 0; i < total; i++) {
                ax = 0;
                ay = 0;
                var w = fx + frameWidth;
                var h = fy + frameHeight;
                if (w > width) {
                  ax = w - width;
                }
                if (h > height) {
                  ay = h - height;
                }
                if (i >= startFrame && i <= endFrame) {
                  texture.add(c, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);
                  c++;
                }
                fx += frameWidth + spacing;
                if (fx + frameWidth > width) {
                  fx = margin;
                  fy += frameHeight + spacing;
                }
              }
              return texture;
            };
            module2.exports = SpriteSheet;
          },
          20030: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var SpriteSheetFromAtlas = function(texture, frame, config2) {
              var frameWidth = GetFastValue(config2, "frameWidth", null);
              var frameHeight = GetFastValue(config2, "frameHeight", frameWidth);
              if (!frameWidth) {
                throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
              }
              var source = texture.source[0];
              texture.add("__BASE", 0, 0, 0, source.width, source.height);
              var startFrame = GetFastValue(config2, "startFrame", 0);
              var endFrame = GetFastValue(config2, "endFrame", -1);
              var margin = GetFastValue(config2, "margin", 0);
              var spacing = GetFastValue(config2, "spacing", 0);
              var x = frame.cutX;
              var y = frame.cutY;
              var cutWidth = frame.cutWidth;
              var cutHeight = frame.cutHeight;
              var sheetWidth = frame.realWidth;
              var sheetHeight = frame.realHeight;
              var row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing));
              var column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing));
              var total = row * column;
              var leftPad = frame.x;
              var leftWidth = frameWidth - leftPad;
              var rightWidth = frameWidth - (sheetWidth - cutWidth - leftPad);
              var topPad = frame.y;
              var topHeight = frameHeight - topPad;
              var bottomHeight = frameHeight - (sheetHeight - cutHeight - topPad);
              if (startFrame > total || startFrame < -total) {
                startFrame = 0;
              }
              if (startFrame < 0) {
                startFrame = total + startFrame;
              }
              if (endFrame !== -1) {
                total = startFrame + (endFrame + 1);
              }
              var sheetFrame;
              var frameX = margin;
              var frameY = margin;
              var frameIndex = 0;
              var sourceIndex = 0;
              for (var sheetY = 0; sheetY < column; sheetY++) {
                var topRow = sheetY === 0;
                var bottomRow = sheetY === column - 1;
                for (var sheetX = 0; sheetX < row; sheetX++) {
                  var leftRow = sheetX === 0;
                  var rightRow = sheetX === row - 1;
                  sheetFrame = texture.add(frameIndex, sourceIndex, x + frameX, y + frameY, frameWidth, frameHeight);
                  if (leftRow || topRow || rightRow || bottomRow) {
                    var destX = leftRow ? leftPad : 0;
                    var destY = topRow ? topPad : 0;
                    var trimWidth = 0;
                    var trimHeight = 0;
                    if (leftRow) {
                      trimWidth += frameWidth - leftWidth;
                    }
                    if (rightRow) {
                      trimWidth += frameWidth - rightWidth;
                    }
                    if (topRow) {
                      trimHeight += frameHeight - topHeight;
                    }
                    if (bottomRow) {
                      trimHeight += frameHeight - bottomHeight;
                    }
                    var destWidth = frameWidth - trimWidth;
                    var destHeight = frameHeight - trimHeight;
                    sheetFrame.cutWidth = destWidth;
                    sheetFrame.cutHeight = destHeight;
                    sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight);
                  }
                  frameX += spacing;
                  if (leftRow) {
                    frameX += leftWidth;
                  } else if (rightRow) {
                    frameX += rightWidth;
                  } else {
                    frameX += frameWidth;
                  }
                  frameIndex++;
                }
                frameX = margin;
                frameY += spacing;
                if (topRow) {
                  frameY += topHeight;
                } else if (bottomRow) {
                  frameY += bottomHeight;
                } else {
                  frameY += frameHeight;
                }
              }
              return texture;
            };
            module2.exports = SpriteSheetFromAtlas;
          },
          89187: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var imageHeight = 0;
            var addFrame = function(texture, sourceIndex, name, frame) {
              var y = imageHeight - frame.y - frame.height;
              texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);
            };
            var UnityYAML = function(texture, sourceIndex, yaml) {
              var source = texture.source[sourceIndex];
              texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
              imageHeight = source.height;
              var data = yaml.split("\n");
              var lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/;
              var prevSprite = "";
              var currentSprite = "";
              var rect = {x: 0, y: 0, width: 0, height: 0};
              for (var i = 0; i < data.length; i++) {
                var results = data[i].match(lineRegExp);
                if (!results) {
                  continue;
                }
                var isList = results[1] === "- ";
                var key = results[2];
                var value = results[3];
                if (isList) {
                  if (currentSprite !== prevSprite) {
                    addFrame(texture, sourceIndex, currentSprite, rect);
                    prevSprite = currentSprite;
                  }
                  rect = {x: 0, y: 0, width: 0, height: 0};
                }
                if (key === "name") {
                  currentSprite = value;
                  continue;
                }
                switch (key) {
                  case "x":
                  case "y":
                  case "width":
                  case "height":
                    rect[key] = parseInt(value, 10);
                    break;
                }
              }
              if (currentSprite !== prevSprite) {
                addFrame(texture, sourceIndex, currentSprite, rect);
              }
              return texture;
            };
            module2.exports = UnityYAML;
          },
          69150: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              AtlasXML: __webpack_require__2(35082),
              Canvas: __webpack_require__2(83332),
              Image: __webpack_require__2(21560),
              JSONArray: __webpack_require__2(64423),
              JSONHash: __webpack_require__2(17264),
              KTXParser: __webpack_require__2(67409),
              PVRParser: __webpack_require__2(24904),
              SpriteSheet: __webpack_require__2(6143),
              SpriteSheetFromAtlas: __webpack_require__2(20030),
              UnityYAML: __webpack_require__2(89187)
            };
          },
          93560: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              CSV: 0,
              TILED_JSON: 1,
              ARRAY_2D: 2,
              WELTMEISTER: 3
            };
          },
          97042: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ImageCollection = new Class({
              initialize: function ImageCollection2(name, firstgid, width, height, margin, spacing, properties) {
                if (width === void 0 || width <= 0) {
                  width = 32;
                }
                if (height === void 0 || height <= 0) {
                  height = 32;
                }
                if (margin === void 0) {
                  margin = 0;
                }
                if (spacing === void 0) {
                  spacing = 0;
                }
                this.name = name;
                this.firstgid = firstgid | 0;
                this.imageWidth = width | 0;
                this.imageHeight = height | 0;
                this.imageMargin = margin | 0;
                this.imageSpacing = spacing | 0;
                this.properties = properties || {};
                this.images = [];
                this.total = 0;
              },
              containsImageIndex: function(imageIndex) {
                return imageIndex >= this.firstgid && imageIndex < this.firstgid + this.total;
              },
              addImage: function(gid, image) {
                this.images.push({gid, image});
                this.total++;
                return this;
              }
            });
            module2.exports = ImageCollection;
          },
          46422: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2021 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var ObjectHelper = new Class({
              initialize: function ObjectHelper2(tilesets) {
                this.gids = [];
                if (tilesets !== void 0) {
                  for (var t = 0; t < tilesets.length; ++t) {
                    var tileset = tilesets[t];
                    for (var i = 0; i < tileset.total; ++i) {
                      this.gids[tileset.firstgid + i] = tileset;
                    }
                  }
                }
                this._gids = this.gids;
              },
              enabled: {
                get: function() {
                  return !!this.gids;
                },
                set: function(v) {
                  this.gids = v ? this._gids : void 0;
                }
              },
              getTypeIncludingTile: function(obj) {
                if (obj.type !== void 0 && obj.type !== "") {
                  return obj.type;
                }
                if (!this.gids || obj.gid === void 0) {
                  return void 0;
                }
                var tileset = this.gids[obj.gid];
                if (!tileset) {
                  return void 0;
                }
                var tileData = tileset.getTileData(obj.gid);
                if (!tileData) {
                  return void 0;
                }
                return tileData.type;
              },
              setTextureAndFrame: function(sprite, key, frame, obj) {
                if (key === null && this.gids && obj.gid !== void 0) {
                  var tileset = this.gids[obj.gid];
                  if (tileset) {
                    if (key === null && tileset.image !== void 0) {
                      key = tileset.image.key;
                    }
                    if (frame === null) {
                      frame = obj.gid - tileset.firstgid;
                    }
                    if (!sprite.scene.textures.getFrame(key, frame)) {
                      key = null;
                      frame = null;
                    }
                  }
                }
                sprite.setTexture(key, frame);
              },
              setPropertiesFromTiledObject: function(sprite, obj) {
                if (this.gids !== void 0 && obj.gid !== void 0) {
                  var tileset = this.gids[obj.gid];
                  if (tileset !== void 0) {
                    this.setFromJSON(sprite, tileset.getTileProperties(obj.gid));
                  }
                }
                this.setFromJSON(sprite, obj.properties);
              },
              setFromJSON: function(sprite, properties) {
                if (!properties) {
                  return;
                }
                if (Array.isArray(properties)) {
                  for (var i = 0; i < properties.length; i++) {
                    var prop = properties[i];
                    if (sprite[prop.name] !== void 0) {
                      sprite[prop.name] = prop.value;
                    } else {
                      sprite.setData(prop.name, prop.value);
                    }
                  }
                  return;
                }
                for (var key in properties) {
                  if (sprite[key] !== void 0) {
                    sprite[key] = properties[key];
                  } else {
                    sprite.setData(key, properties[key]);
                  }
                }
              }
            });
            module2.exports = ObjectHelper;
          },
          15043: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Formats = __webpack_require__2(93560);
            var MapData = __webpack_require__2(16586);
            var Parse = __webpack_require__2(90715);
            var Tilemap = __webpack_require__2(89797);
            var ParseToTilemap = function(scene, key, tileWidth, tileHeight, width, height, data, insertNull) {
              if (tileWidth === void 0) {
                tileWidth = 32;
              }
              if (tileHeight === void 0) {
                tileHeight = 32;
              }
              if (width === void 0) {
                width = 10;
              }
              if (height === void 0) {
                height = 10;
              }
              if (insertNull === void 0) {
                insertNull = false;
              }
              var mapData = null;
              if (Array.isArray(data)) {
                var name = key !== void 0 ? key : "map";
                mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);
              } else if (key !== void 0) {
                var tilemapData = scene.cache.tilemap.get(key);
                if (!tilemapData) {
                  console.warn("No map data found for key " + key);
                } else {
                  mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);
                }
              }
              if (mapData === null) {
                mapData = new MapData({
                  tileWidth,
                  tileHeight,
                  width,
                  height
                });
              }
              return new Tilemap(scene, mapData);
            };
            module2.exports = ParseToTilemap;
          },
          29633: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Components = __webpack_require__2(64937);
            var CONST = __webpack_require__2(12920);
            var DeepCopy = __webpack_require__2(28699);
            var Rectangle = __webpack_require__2(66658);
            var Tile = new Class({
              Mixins: [
                Components.AlphaSingle,
                Components.Flip,
                Components.Visible
              ],
              initialize: function Tile2(layer, index, x, y, width, height, baseWidth, baseHeight) {
                this.layer = layer;
                this.index = index;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.right;
                this.bottom;
                this.baseWidth = baseWidth !== void 0 ? baseWidth : width;
                this.baseHeight = baseHeight !== void 0 ? baseHeight : height;
                this.pixelX = 0;
                this.pixelY = 0;
                this.updatePixelXY();
                this.properties = {};
                this.rotation = 0;
                this.collideLeft = false;
                this.collideRight = false;
                this.collideUp = false;
                this.collideDown = false;
                this.faceLeft = false;
                this.faceRight = false;
                this.faceTop = false;
                this.faceBottom = false;
                this.collisionCallback = void 0;
                this.collisionCallbackContext = this;
                this.tint = 16777215;
                this.tintFill = false;
                this.physics = {};
              },
              containsPoint: function(x, y) {
                return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);
              },
              copy: function(tile) {
                this.index = tile.index;
                this.alpha = tile.alpha;
                this.properties = DeepCopy(tile.properties);
                this.visible = tile.visible;
                this.setFlip(tile.flipX, tile.flipY);
                this.tint = tile.tint;
                this.rotation = tile.rotation;
                this.collideUp = tile.collideUp;
                this.collideDown = tile.collideDown;
                this.collideLeft = tile.collideLeft;
                this.collideRight = tile.collideRight;
                this.collisionCallback = tile.collisionCallback;
                this.collisionCallbackContext = tile.collisionCallbackContext;
                return this;
              },
              getCollisionGroup: function() {
                return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;
              },
              getTileData: function() {
                return this.tileset ? this.tileset.getTileData(this.index) : null;
              },
              getLeft: function(camera) {
                var tilemapLayer = this.tilemapLayer;
                if (tilemapLayer) {
                  var point = tilemapLayer.tileToWorldXY(this.x, this.y, void 0, camera);
                  return point.x;
                }
                return this.x * this.baseWidth;
              },
              getRight: function(camera) {
                var tilemapLayer = this.tilemapLayer;
                return tilemapLayer ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;
              },
              getTop: function(camera) {
                var tilemapLayer = this.tilemapLayer;
                if (tilemapLayer) {
                  var point = tilemapLayer.tileToWorldXY(this.x, this.y, void 0, camera);
                  return point.y;
                }
                return this.y * this.baseWidth - (this.height - this.baseHeight);
              },
              getBottom: function(camera) {
                var tilemapLayer = this.tilemapLayer;
                return tilemapLayer ? this.getTop(camera) + this.height * tilemapLayer.scaleY : this.getTop(camera) + this.height;
              },
              getBounds: function(camera, output) {
                if (output === void 0) {
                  output = new Rectangle();
                }
                output.x = this.getLeft(camera);
                output.y = this.getTop(camera);
                output.width = this.getRight(camera) - output.x;
                output.height = this.getBottom(camera) - output.y;
                return output;
              },
              getCenterX: function(camera) {
                return (this.getLeft(camera) + this.getRight(camera)) / 2;
              },
              getCenterY: function(camera) {
                return (this.getTop(camera) + this.getBottom(camera)) / 2;
              },
              intersects: function(x, y, right, bottom) {
                return !(right <= this.pixelX || bottom <= this.pixelY || x >= this.right || y >= this.bottom);
              },
              isInteresting: function(collides, faces) {
                if (collides && faces) {
                  return this.canCollide || this.hasInterestingFace;
                } else if (collides) {
                  return this.collides;
                } else if (faces) {
                  return this.hasInterestingFace;
                }
                return false;
              },
              resetCollision: function(recalculateFaces) {
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                this.collideLeft = false;
                this.collideRight = false;
                this.collideUp = false;
                this.collideDown = false;
                this.faceTop = false;
                this.faceBottom = false;
                this.faceLeft = false;
                this.faceRight = false;
                if (recalculateFaces) {
                  var tilemapLayer = this.tilemapLayer;
                  if (tilemapLayer) {
                    this.tilemapLayer.calculateFacesAt(this.x, this.y);
                  }
                }
                return this;
              },
              resetFaces: function() {
                this.faceTop = false;
                this.faceBottom = false;
                this.faceLeft = false;
                this.faceRight = false;
                return this;
              },
              setCollision: function(left, right, up, down, recalculateFaces) {
                if (right === void 0) {
                  right = left;
                }
                if (up === void 0) {
                  up = left;
                }
                if (down === void 0) {
                  down = left;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                this.collideLeft = left;
                this.collideRight = right;
                this.collideUp = up;
                this.collideDown = down;
                this.faceLeft = left;
                this.faceRight = right;
                this.faceTop = up;
                this.faceBottom = down;
                if (recalculateFaces) {
                  var tilemapLayer = this.tilemapLayer;
                  if (tilemapLayer) {
                    this.tilemapLayer.calculateFacesAt(this.x, this.y);
                  }
                }
                return this;
              },
              setCollisionCallback: function(callback, context) {
                if (callback === null) {
                  this.collisionCallback = void 0;
                  this.collisionCallbackContext = void 0;
                } else {
                  this.collisionCallback = callback;
                  this.collisionCallbackContext = context;
                }
                return this;
              },
              setSize: function(tileWidth, tileHeight, baseWidth, baseHeight) {
                if (tileWidth !== void 0) {
                  this.width = tileWidth;
                }
                if (tileHeight !== void 0) {
                  this.height = tileHeight;
                }
                if (baseWidth !== void 0) {
                  this.baseWidth = baseWidth;
                }
                if (baseHeight !== void 0) {
                  this.baseHeight = baseHeight;
                }
                this.updatePixelXY();
                return this;
              },
              updatePixelXY: function() {
                var orientation = this.layer.orientation;
                if (orientation === CONST.ORTHOGONAL) {
                  this.pixelX = this.x * this.baseWidth;
                  this.pixelY = this.y * this.baseHeight;
                } else if (orientation === CONST.ISOMETRIC) {
                  this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;
                  this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;
                } else if (orientation === CONST.STAGGERED) {
                  this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
                  this.pixelY = this.y * (this.baseHeight / 2);
                } else if (orientation === CONST.HEXAGONAL) {
                  var staggerAxis = this.layer.staggerAxis;
                  var staggerIndex = this.layer.staggerIndex;
                  var len = this.layer.hexSideLength;
                  var rowWidth;
                  var rowHeight;
                  if (staggerAxis === "y") {
                    rowHeight = (this.baseHeight - len) / 2 + len;
                    if (staggerIndex === "odd") {
                      this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
                    } else {
                      this.pixelX = this.x * this.baseWidth - this.y % 2 * (this.baseWidth / 2);
                    }
                    this.pixelY = this.y * rowHeight;
                  } else if (staggerAxis === "x") {
                    rowWidth = (this.baseWidth - len) / 2 + len;
                    this.pixelX = this.x * rowWidth;
                    if (staggerIndex === "odd") {
                      this.pixelY = this.y * this.baseHeight + this.x % 2 * (this.baseHeight / 2);
                    } else {
                      this.pixelY = this.y * this.baseHeight - this.x % 2 * (this.baseHeight / 2);
                    }
                  }
                }
                this.right = this.pixelX + this.baseWidth;
                this.bottom = this.pixelY + this.baseHeight;
                return this;
              },
              destroy: function() {
                this.collisionCallback = void 0;
                this.collisionCallbackContext = void 0;
                this.properties = void 0;
              },
              canCollide: {
                get: function() {
                  return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback !== void 0;
                }
              },
              collides: {
                get: function() {
                  return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
                }
              },
              hasInterestingFace: {
                get: function() {
                  return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
                }
              },
              tileset: {
                get: function() {
                  var tilemapLayer = this.layer.tilemapLayer;
                  if (tilemapLayer) {
                    var tileset = tilemapLayer.gidMap[this.index];
                    if (tileset) {
                      return tileset;
                    }
                  }
                  return null;
                }
              },
              tilemapLayer: {
                get: function() {
                  return this.layer.tilemapLayer;
                }
              },
              tilemap: {
                get: function() {
                  var tilemapLayer = this.tilemapLayer;
                  return tilemapLayer ? tilemapLayer.tilemap : null;
                }
              }
            });
            module2.exports = Tile;
          },
          89797: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BuildTilesetIndex = __webpack_require__2(14556);
            var Class = __webpack_require__2(56694);
            var DegToRad = __webpack_require__2(75606);
            var Formats = __webpack_require__2(93560);
            var GetFastValue = __webpack_require__2(72632);
            var LayerData = __webpack_require__2(94990);
            var ObjectHelper = __webpack_require__2(46422);
            var ORIENTATION = __webpack_require__2(12920);
            var Rotate = __webpack_require__2(52257);
            var SpliceOne = __webpack_require__2(72677);
            var Sprite = __webpack_require__2(13747);
            var Tile = __webpack_require__2(29633);
            var TilemapComponents = __webpack_require__2(5047);
            var TilemapLayer = __webpack_require__2(87177);
            var Tileset = __webpack_require__2(47975);
            var Tilemap = new Class({
              initialize: function Tilemap2(scene, mapData) {
                this.scene = scene;
                this.tileWidth = mapData.tileWidth;
                this.tileHeight = mapData.tileHeight;
                this.width = mapData.width;
                this.height = mapData.height;
                this.orientation = mapData.orientation;
                this.renderOrder = mapData.renderOrder;
                this.format = mapData.format;
                this.version = mapData.version;
                this.properties = mapData.properties;
                this.widthInPixels = mapData.widthInPixels;
                this.heightInPixels = mapData.heightInPixels;
                this.imageCollections = mapData.imageCollections;
                this.images = mapData.images;
                this.layers = mapData.layers;
                this.tiles = mapData.tiles;
                this.tilesets = mapData.tilesets;
                this.objects = mapData.objects;
                this.currentLayerIndex = 0;
                this.hexSideLength = mapData.hexSideLength;
                var orientation = this.orientation;
                this._convert = {
                  WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),
                  WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),
                  WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),
                  TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),
                  TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),
                  TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation),
                  GetTileCorners: TilemapComponents.GetTileCornersFunction(orientation)
                };
              },
              setRenderOrder: function(renderOrder) {
                var orders = ["right-down", "left-down", "right-up", "left-up"];
                if (typeof renderOrder === "number") {
                  renderOrder = orders[renderOrder];
                }
                if (orders.indexOf(renderOrder) > -1) {
                  this.renderOrder = renderOrder;
                }
                return this;
              },
              addTilesetImage: function(tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid, tileOffset) {
                if (tilesetName === void 0) {
                  return null;
                }
                if (key === void 0 || key === null) {
                  key = tilesetName;
                }
                if (!this.scene.sys.textures.exists(key)) {
                  console.warn("Invalid Tileset Image: " + key);
                  return null;
                }
                var texture = this.scene.sys.textures.get(key);
                var index = this.getTilesetIndex(tilesetName);
                if (index === null && this.format === Formats.TILED_JSON) {
                  console.warn("No data found for Tileset: " + tilesetName);
                  return null;
                }
                var tileset = this.tilesets[index];
                if (tileset) {
                  tileset.setTileSize(tileWidth, tileHeight);
                  tileset.setSpacing(tileMargin, tileSpacing);
                  tileset.setImage(texture);
                  return tileset;
                }
                if (tileWidth === void 0) {
                  tileWidth = this.tileWidth;
                }
                if (tileHeight === void 0) {
                  tileHeight = this.tileHeight;
                }
                if (tileMargin === void 0) {
                  tileMargin = 0;
                }
                if (tileSpacing === void 0) {
                  tileSpacing = 0;
                }
                if (gid === void 0) {
                  gid = 0;
                }
                if (tileOffset === void 0) {
                  tileOffset = {x: 0, y: 0};
                }
                tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing, void 0, void 0, tileOffset);
                tileset.setImage(texture);
                this.tilesets.push(tileset);
                this.tiles = BuildTilesetIndex(this);
                return tileset;
              },
              copy: function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
                layer = this.getLayer(layer);
                if (layer !== null) {
                  TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer);
                  return this;
                } else {
                  return null;
                }
              },
              createBlankLayer: function(name, tileset, x, y, width, height, tileWidth, tileHeight) {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (width === void 0) {
                  width = this.width;
                }
                if (height === void 0) {
                  height = this.height;
                }
                if (tileWidth === void 0) {
                  tileWidth = this.tileWidth;
                }
                if (tileHeight === void 0) {
                  tileHeight = this.tileHeight;
                }
                var index = this.getLayerIndex(name);
                if (index !== null) {
                  console.warn("Invalid Tilemap Layer ID: " + name);
                  return null;
                }
                var layerData = new LayerData({
                  name,
                  tileWidth,
                  tileHeight,
                  width,
                  height,
                  orientation: this.orientation
                });
                var row;
                for (var tileY = 0; tileY < height; tileY++) {
                  row = [];
                  for (var tileX = 0; tileX < width; tileX++) {
                    row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));
                  }
                  layerData.data.push(row);
                }
                this.layers.push(layerData);
                this.currentLayerIndex = this.layers.length - 1;
                var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);
                layer.setRenderOrder(this.renderOrder);
                this.scene.sys.displayList.add(layer);
                return layer;
              },
              createLayer: function(layerID, tileset, x, y) {
                var index = this.getLayerIndex(layerID);
                if (index === null) {
                  console.warn("Invalid Tilemap Layer ID: " + layerID);
                  if (typeof layerID === "string") {
                    console.warn("Valid tilelayer names: %o", this.getTileLayerNames());
                  }
                  return null;
                }
                var layerData = this.layers[index];
                if (layerData.tilemapLayer) {
                  console.warn("Tilemap Layer ID already exists:" + layerID);
                  return null;
                }
                this.currentLayerIndex = index;
                if (x === void 0) {
                  x = layerData.x;
                }
                if (y === void 0) {
                  y = layerData.y;
                }
                var layer = new TilemapLayer(this.scene, this, index, tileset, x, y);
                layer.setRenderOrder(this.renderOrder);
                this.scene.sys.displayList.add(layer);
                return layer;
              },
              createFromObjects: function(objectLayerName, config2, useTileset) {
                if (useTileset === void 0) {
                  useTileset = true;
                }
                var results = [];
                var objectLayer = this.getObjectLayer(objectLayerName);
                if (!objectLayer) {
                  console.warn("createFromObjects: Invalid objectLayerName given: " + objectLayerName);
                  return results;
                }
                var objectHelper = new ObjectHelper(useTileset ? this.tilesets : void 0);
                if (!Array.isArray(config2)) {
                  config2 = [config2];
                }
                var objects = objectLayer.objects;
                for (var c = 0; c < config2.length; c++) {
                  var singleConfig = config2[c];
                  var id = GetFastValue(singleConfig, "id", null);
                  var gid = GetFastValue(singleConfig, "gid", null);
                  var name = GetFastValue(singleConfig, "name", null);
                  var type = GetFastValue(singleConfig, "type", null);
                  objectHelper.enabled = !GetFastValue(singleConfig, "ignoreTileset", null);
                  var obj;
                  var toConvert = [];
                  for (var s = 0; s < objects.length; s++) {
                    obj = objects[s];
                    if (id === null && gid === null && name === null && type === null || id !== null && obj.id === id || gid !== null && obj.gid === gid || name !== null && obj.name === name || type !== null && objectHelper.getTypeIncludingTile(obj) === type) {
                      toConvert.push(obj);
                    }
                  }
                  var classType = GetFastValue(singleConfig, "classType", Sprite);
                  var scene = GetFastValue(singleConfig, "scene", this.scene);
                  var container = GetFastValue(singleConfig, "container", null);
                  var texture = GetFastValue(singleConfig, "key", null);
                  var frame = GetFastValue(singleConfig, "frame", null);
                  for (var i = 0; i < toConvert.length; i++) {
                    obj = toConvert[i];
                    var sprite = new classType(scene);
                    sprite.setName(obj.name);
                    sprite.setPosition(obj.x, obj.y);
                    objectHelper.setTextureAndFrame(sprite, texture, frame, obj);
                    if (obj.width) {
                      sprite.displayWidth = obj.width;
                    }
                    if (obj.height) {
                      sprite.displayHeight = obj.height;
                    }
                    if (this.orientation === ORIENTATION.ISOMETRIC) {
                      var isometricRatio = this.tileWidth / this.tileHeight;
                      var isometricPosition = {
                        x: sprite.x - sprite.y,
                        y: (sprite.x + sprite.y) / isometricRatio
                      };
                      sprite.x = isometricPosition.x;
                      sprite.y = isometricPosition.y;
                    }
                    var offset = {
                      x: sprite.originX * obj.width,
                      y: (sprite.originY - (obj.gid ? 1 : 0)) * obj.height
                    };
                    if (obj.rotation) {
                      var angle = DegToRad(obj.rotation);
                      Rotate(offset, angle);
                      sprite.rotation = angle;
                    }
                    sprite.x += offset.x;
                    sprite.y += offset.y;
                    if (obj.flippedHorizontal !== void 0 || obj.flippedVertical !== void 0) {
                      sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);
                    }
                    if (!obj.visible) {
                      sprite.visible = false;
                    }
                    objectHelper.setPropertiesFromTiledObject(sprite, obj);
                    if (container) {
                      container.add(sprite);
                    } else {
                      scene.add.existing(sprite);
                    }
                    results.push(sprite);
                  }
                }
                return results;
              },
              createFromTiles: function(indexes, replacements, spriteConfig, scene, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);
              },
              fill: function(index, tileX, tileY, width, height, recalculateFaces, layer) {
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);
                return this;
              },
              filterObjects: function(objectLayer, callback, context) {
                if (typeof objectLayer === "string") {
                  var name = objectLayer;
                  objectLayer = this.getObjectLayer(objectLayer);
                  if (!objectLayer) {
                    console.warn("No object layer found with the name: " + name);
                    return null;
                  }
                }
                return objectLayer.objects.filter(callback, context);
              },
              filterTiles: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);
              },
              findByIndex: function(findIndex, skip, reverse, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);
              },
              findObject: function(objectLayer, callback, context) {
                if (typeof objectLayer === "string") {
                  var name = objectLayer;
                  objectLayer = this.getObjectLayer(objectLayer);
                  if (!objectLayer) {
                    console.warn("No object layer found with the name: " + name);
                    return null;
                  }
                }
                return objectLayer.objects.find(callback, context) || null;
              },
              findTile: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
              },
              forEachTile: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
                return this;
              },
              getImageIndex: function(name) {
                return this.getIndex(this.images, name);
              },
              getImageLayerNames: function() {
                if (!this.images || !Array.isArray(this.images)) {
                  return [];
                }
                return this.images.map(function(image) {
                  return image.name;
                });
              },
              getIndex: function(location, name) {
                for (var i = 0; i < location.length; i++) {
                  if (location[i].name === name) {
                    return i;
                  }
                }
                return null;
              },
              getLayer: function(layer) {
                var index = this.getLayerIndex(layer);
                return index !== null ? this.layers[index] : null;
              },
              getObjectLayer: function(name) {
                var index = this.getIndex(this.objects, name);
                return index !== null ? this.objects[index] : null;
              },
              getObjectLayerNames: function() {
                if (!this.objects || !Array.isArray(this.objects)) {
                  return [];
                }
                return this.objects.map(function(object) {
                  return object.name;
                });
              },
              getLayerIndex: function(layer) {
                if (layer === void 0) {
                  return this.currentLayerIndex;
                } else if (typeof layer === "string") {
                  return this.getLayerIndexByName(layer);
                } else if (typeof layer === "number" && layer < this.layers.length) {
                  return layer;
                } else if (layer instanceof TilemapLayer && layer.tilemap === this) {
                  return layer.layerIndex;
                } else {
                  return null;
                }
              },
              getLayerIndexByName: function(name) {
                return this.getIndex(this.layers, name);
              },
              getTileAt: function(tileX, tileY, nonNull, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);
              },
              getTileAtWorldXY: function(worldX, worldY, nonNull, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);
              },
              getTileLayerNames: function() {
                if (!this.layers || !Array.isArray(this.layers)) {
                  return [];
                }
                return this.layers.map(function(layer) {
                  return layer.name;
                });
              },
              getTilesWithin: function(tileX, tileY, width, height, filteringOptions, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
              },
              getTilesWithinShape: function(shape, filteringOptions, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);
              },
              getTilesWithinWorldXY: function(worldX, worldY, width, height, filteringOptions, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);
              },
              getTileset: function(name) {
                var index = this.getIndex(this.tilesets, name);
                return index !== null ? this.tilesets[index] : null;
              },
              getTilesetIndex: function(name) {
                return this.getIndex(this.tilesets, name);
              },
              hasTileAt: function(tileX, tileY, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.HasTileAt(tileX, tileY, layer);
              },
              hasTileAtWorldXY: function(worldX, worldY, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);
              },
              layer: {
                get: function() {
                  return this.layers[this.currentLayerIndex];
                },
                set: function(layer) {
                  this.setLayer(layer);
                }
              },
              putTileAt: function(tile, tileX, tileY, recalculateFaces, layer) {
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);
              },
              putTileAtWorldXY: function(tile, worldX, worldY, recalculateFaces, camera, layer) {
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);
              },
              putTilesAt: function(tilesArray, tileX, tileY, recalculateFaces, layer) {
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);
                return this;
              },
              randomize: function(tileX, tileY, width, height, indexes, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);
                return this;
              },
              calculateFacesAt: function(tileX, tileY, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.CalculateFacesAt(tileX, tileY, layer);
                return this;
              },
              calculateFacesWithin: function(tileX, tileY, width, height, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);
                return this;
              },
              removeLayer: function(layer) {
                var index = this.getLayerIndex(layer);
                if (index !== null) {
                  SpliceOne(this.layers, index);
                  for (var i = index; i < this.layers.length; i++) {
                    if (this.layers[i].tilemapLayer) {
                      this.layers[i].tilemapLayer.layerIndex--;
                    }
                  }
                  if (this.currentLayerIndex === index) {
                    this.currentLayerIndex = 0;
                  }
                  return this;
                } else {
                  return null;
                }
              },
              destroyLayer: function(layer) {
                var index = this.getLayerIndex(layer);
                if (index !== null) {
                  layer = this.layers[index];
                  layer.tilemapLayer.destroy();
                  SpliceOne(this.layers, index);
                  if (this.currentLayerIndex === index) {
                    this.currentLayerIndex = 0;
                  }
                  return this;
                } else {
                  return null;
                }
              },
              removeAllLayers: function() {
                var layers = this.layers;
                for (var i = 0; i < layers.length; i++) {
                  if (layers[i].tilemapLayer) {
                    layers[i].tilemapLayer.destroy(false);
                  }
                }
                layers.length = 0;
                this.currentLayerIndex = 0;
                return this;
              },
              removeTile: function(tiles, replaceIndex, recalculateFaces) {
                if (replaceIndex === void 0) {
                  replaceIndex = -1;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                var removed = [];
                if (!Array.isArray(tiles)) {
                  tiles = [tiles];
                }
                for (var i = 0; i < tiles.length; i++) {
                  var tile = tiles[i];
                  removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));
                  if (replaceIndex > -1) {
                    this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);
                  }
                }
                return removed;
              },
              removeTileAt: function(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
                if (replaceWithNull === void 0) {
                  replaceWithNull = true;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);
              },
              removeTileAtWorldXY: function(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
                if (replaceWithNull === void 0) {
                  replaceWithNull = true;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);
              },
              renderDebug: function(graphics, styleConfig, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                if (this.orientation === ORIENTATION.ORTHOGONAL) {
                  TilemapComponents.RenderDebug(graphics, styleConfig, layer);
                }
                return this;
              },
              renderDebugFull: function(graphics, styleConfig) {
                var layers = this.layers;
                for (var i = 0; i < layers.length; i++) {
                  TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);
                }
                return this;
              },
              replaceByIndex: function(findIndex, newIndex, tileX, tileY, width, height, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);
                return this;
              },
              setCollision: function(indexes, collides, recalculateFaces, layer, updateLayer) {
                if (collides === void 0) {
                  collides = true;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                if (updateLayer === void 0) {
                  updateLayer = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);
                return this;
              },
              setCollisionBetween: function(start, stop, collides, recalculateFaces, layer) {
                if (collides === void 0) {
                  collides = true;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);
                return this;
              },
              setCollisionByProperty: function(properties, collides, recalculateFaces, layer) {
                if (collides === void 0) {
                  collides = true;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);
                return this;
              },
              setCollisionByExclusion: function(indexes, collides, recalculateFaces, layer) {
                if (collides === void 0) {
                  collides = true;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);
                return this;
              },
              setCollisionFromCollisionGroup: function(collides, recalculateFaces, layer) {
                if (collides === void 0) {
                  collides = true;
                }
                if (recalculateFaces === void 0) {
                  recalculateFaces = true;
                }
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);
                return this;
              },
              setTileIndexCallback: function(indexes, callback, callbackContext, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);
                return this;
              },
              setTileLocationCallback: function(tileX, tileY, width, height, callback, callbackContext, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);
                return this;
              },
              setLayer: function(layer) {
                var index = this.getLayerIndex(layer);
                if (index !== null) {
                  this.currentLayerIndex = index;
                }
                return this;
              },
              setBaseTileSize: function(tileWidth, tileHeight) {
                this.tileWidth = tileWidth;
                this.tileHeight = tileHeight;
                this.widthInPixels = this.width * tileWidth;
                this.heightInPixels = this.height * tileHeight;
                for (var i = 0; i < this.layers.length; i++) {
                  this.layers[i].baseTileWidth = tileWidth;
                  this.layers[i].baseTileHeight = tileHeight;
                  var mapData = this.layers[i].data;
                  var mapWidth = this.layers[i].width;
                  var mapHeight = this.layers[i].height;
                  for (var row = 0; row < mapHeight; row++) {
                    for (var col = 0; col < mapWidth; col++) {
                      var tile = mapData[row][col];
                      if (tile !== null) {
                        tile.setSize(void 0, void 0, tileWidth, tileHeight);
                      }
                    }
                  }
                }
                return this;
              },
              setLayerTileSize: function(tileWidth, tileHeight, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return this;
                }
                layer.tileWidth = tileWidth;
                layer.tileHeight = tileHeight;
                var mapData = layer.data;
                var mapWidth = layer.width;
                var mapHeight = layer.height;
                for (var row = 0; row < mapHeight; row++) {
                  for (var col = 0; col < mapWidth; col++) {
                    var tile = mapData[row][col];
                    if (tile !== null) {
                      tile.setSize(tileWidth, tileHeight);
                    }
                  }
                }
                return this;
              },
              shuffle: function(tileX, tileY, width, height, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.Shuffle(tileX, tileY, width, height, layer);
                return this;
              },
              swapByIndex: function(indexA, indexB, tileX, tileY, width, height, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);
                return this;
              },
              tileToWorldX: function(tileX, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return this._convert.TileToWorldX(tileX, camera, layer);
              },
              tileToWorldY: function(tileY, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return this._convert.TileToWorldY(tileY, camera, layer);
              },
              tileToWorldXY: function(tileX, tileY, vec2, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);
              },
              getTileCorners: function(tileX, tileY, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return this._convert.GetTileCorners(tileX, tileY, camera, layer);
              },
              weightedRandomize: function(weightedIndexes, tileX, tileY, width, height, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);
                return this;
              },
              worldToTileX: function(worldX, snapToFloor, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);
              },
              worldToTileY: function(worldY, snapToFloor, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);
              },
              worldToTileXY: function(worldX, worldY, snapToFloor, vec2, camera, layer) {
                layer = this.getLayer(layer);
                if (layer === null) {
                  return null;
                }
                return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);
              },
              destroy: function() {
                this.removeAllLayers();
                this.tiles.length = 0;
                this.tilesets.length = 0;
                this.objects.length = 0;
                this.scene = null;
              }
            });
            module2.exports = Tilemap;
          },
          4843: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectCreator = __webpack_require__2(99325);
            var ParseToTilemap = __webpack_require__2(15043);
            GameObjectCreator.register("tilemap", function(config2) {
              var c = config2 !== void 0 ? config2 : {};
              return ParseToTilemap(this.scene, c.key, c.tileWidth, c.tileHeight, c.width, c.height, c.data, c.insertNull);
            });
          },
          37940: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GameObjectFactory = __webpack_require__2(61286);
            var ParseToTilemap = __webpack_require__2(15043);
            GameObjectFactory.register("tilemap", function(key, tileWidth, tileHeight, width, height, data, insertNull) {
              if (key === null) {
                key = void 0;
              }
              if (tileWidth === null) {
                tileWidth = void 0;
              }
              if (tileHeight === null) {
                tileHeight = void 0;
              }
              if (width === null) {
                width = void 0;
              }
              if (height === null) {
                height = void 0;
              }
              return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);
            });
          },
          87177: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CollisionComponent = __webpack_require__2(95239);
            var Components = __webpack_require__2(64937);
            var GameObject = __webpack_require__2(89980);
            var TilemapComponents = __webpack_require__2(5047);
            var TilemapLayerRender = __webpack_require__2(96193);
            var Vector2 = __webpack_require__2(93736);
            var TilemapLayer = new Class({
              Extends: GameObject,
              Mixins: [
                Components.Alpha,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.PostPipeline,
                Components.Transform,
                Components.Visible,
                Components.ScrollFactor,
                CollisionComponent,
                TilemapLayerRender
              ],
              initialize: function TilemapLayer2(scene, tilemap, layerIndex, tileset, x, y) {
                GameObject.call(this, scene, "TilemapLayer");
                this.isTilemap = true;
                this.tilemap = tilemap;
                this.layerIndex = layerIndex;
                this.layer = tilemap.layers[layerIndex];
                this.layer.tilemapLayer = this;
                this.tileset = [];
                this.tilesDrawn = 0;
                this.tilesTotal = this.layer.width * this.layer.height;
                this.culledTiles = [];
                this.skipCull = false;
                this.cullPaddingX = 1;
                this.cullPaddingY = 1;
                this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);
                this._renderOrder = 0;
                this.gidMap = [];
                this.tempVec = new Vector2();
                this.collisionCategory = 1;
                this.collisionMask = 1;
                this.setTilesets(tileset);
                this.setAlpha(this.layer.alpha);
                this.setPosition(x, y);
                this.setOrigin(0, 0);
                this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);
                this.initPipeline();
                this.initPostPipeline(false);
              },
              setTilesets: function(tilesets) {
                var gidMap = [];
                var setList = [];
                var map = this.tilemap;
                if (!Array.isArray(tilesets)) {
                  tilesets = [tilesets];
                }
                for (var i = 0; i < tilesets.length; i++) {
                  var tileset = tilesets[i];
                  if (typeof tileset === "string") {
                    tileset = map.getTileset(tileset);
                  }
                  if (tileset) {
                    setList.push(tileset);
                    var s = tileset.firstgid;
                    for (var t = 0; t < tileset.total; t++) {
                      gidMap[s + t] = tileset;
                    }
                  }
                }
                this.gidMap = gidMap;
                this.tileset = setList;
              },
              setRenderOrder: function(renderOrder) {
                var orders = ["right-down", "left-down", "right-up", "left-up"];
                if (typeof renderOrder === "string") {
                  renderOrder = orders.indexOf(renderOrder);
                }
                if (renderOrder >= 0 && renderOrder < 4) {
                  this._renderOrder = renderOrder;
                }
                return this;
              },
              calculateFacesAt: function(tileX, tileY) {
                TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);
                return this;
              },
              calculateFacesWithin: function(tileX, tileY, width, height) {
                TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);
                return this;
              },
              createFromTiles: function(indexes, replacements, spriteConfig, scene, camera) {
                return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);
              },
              cull: function(camera) {
                return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);
              },
              copy: function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces) {
                TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);
                return this;
              },
              fill: function(index, tileX, tileY, width, height, recalculateFaces) {
                TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer);
                return this;
              },
              filterTiles: function(callback, context, tileX, tileY, width, height, filteringOptions) {
                return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
              },
              findByIndex: function(findIndex, skip, reverse) {
                return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);
              },
              findTile: function(callback, context, tileX, tileY, width, height, filteringOptions) {
                return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
              },
              forEachTile: function(callback, context, tileX, tileY, width, height, filteringOptions) {
                TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
                return this;
              },
              setTint: function(tint, tileX, tileY, width, height, filteringOptions) {
                if (tint === void 0) {
                  tint = 16777215;
                }
                var tintTile = function(tile) {
                  tile.tint = tint;
                  tile.tintFill = false;
                };
                return this.forEachTile(tintTile, this, tileX, tileY, width, height, filteringOptions);
              },
              setTintFill: function(tint, tileX, tileY, width, height, filteringOptions) {
                if (tint === void 0) {
                  tint = 16777215;
                }
                var tintTile = function(tile) {
                  tile.tint = tint;
                  tile.tintFill = true;
                };
                return this.forEachTile(tintTile, this, tileX, tileY, width, height, filteringOptions);
              },
              getTileAt: function(tileX, tileY, nonNull) {
                return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);
              },
              getTileAtWorldXY: function(worldX, worldY, nonNull, camera) {
                return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);
              },
              getIsoTileAtWorldXY: function(worldX, worldY, originTop, nonNull, camera) {
                if (originTop === void 0) {
                  originTop = true;
                }
                var point = this.tempVec;
                TilemapComponents.IsometricWorldToTileXY(worldX, worldY, true, point, camera, this.layer, originTop);
                return this.getTileAt(point.x, point.y, nonNull);
              },
              getTilesWithin: function(tileX, tileY, width, height, filteringOptions) {
                return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);
              },
              getTilesWithinShape: function(shape, filteringOptions, camera) {
                return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);
              },
              getTilesWithinWorldXY: function(worldX, worldY, width, height, filteringOptions, camera) {
                return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);
              },
              hasTileAt: function(tileX, tileY) {
                return TilemapComponents.HasTileAt(tileX, tileY, this.layer);
              },
              hasTileAtWorldXY: function(worldX, worldY, camera) {
                return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);
              },
              putTileAt: function(tile, tileX, tileY, recalculateFaces) {
                return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);
              },
              putTileAtWorldXY: function(tile, worldX, worldY, recalculateFaces, camera) {
                return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);
              },
              putTilesAt: function(tilesArray, tileX, tileY, recalculateFaces) {
                TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);
                return this;
              },
              randomize: function(tileX, tileY, width, height, indexes) {
                TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);
                return this;
              },
              removeTileAt: function(tileX, tileY, replaceWithNull, recalculateFaces) {
                return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);
              },
              removeTileAtWorldXY: function(worldX, worldY, replaceWithNull, recalculateFaces, camera) {
                return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);
              },
              renderDebug: function(graphics, styleConfig) {
                TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);
                return this;
              },
              replaceByIndex: function(findIndex, newIndex, tileX, tileY, width, height) {
                TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);
                return this;
              },
              setSkipCull: function(value) {
                if (value === void 0) {
                  value = true;
                }
                this.skipCull = value;
                return this;
              },
              setCullPadding: function(paddingX, paddingY) {
                if (paddingX === void 0) {
                  paddingX = 1;
                }
                if (paddingY === void 0) {
                  paddingY = 1;
                }
                this.cullPaddingX = paddingX;
                this.cullPaddingY = paddingY;
                return this;
              },
              setCollision: function(indexes, collides, recalculateFaces, updateLayer) {
                TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);
                return this;
              },
              setCollisionBetween: function(start, stop, collides, recalculateFaces) {
                TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);
                return this;
              },
              setCollisionByProperty: function(properties, collides, recalculateFaces) {
                TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);
                return this;
              },
              setCollisionByExclusion: function(indexes, collides, recalculateFaces) {
                TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);
                return this;
              },
              setCollisionFromCollisionGroup: function(collides, recalculateFaces) {
                TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);
                return this;
              },
              setTileIndexCallback: function(indexes, callback, callbackContext) {
                TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);
                return this;
              },
              setTileLocationCallback: function(tileX, tileY, width, height, callback, callbackContext) {
                TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);
                return this;
              },
              shuffle: function(tileX, tileY, width, height) {
                TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);
                return this;
              },
              swapByIndex: function(indexA, indexB, tileX, tileY, width, height) {
                TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);
                return this;
              },
              tileToWorldX: function(tileX, camera) {
                return this.tilemap.tileToWorldX(tileX, camera, this);
              },
              tileToWorldY: function(tileY, camera) {
                return this.tilemap.tileToWorldY(tileY, camera, this);
              },
              tileToWorldXY: function(tileX, tileY, point, camera) {
                return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);
              },
              getTileCorners: function(tileX, tileY, camera) {
                return this.tilemap.getTileCorners(tileX, tileY, camera, this);
              },
              weightedRandomize: function(weightedIndexes, tileX, tileY, width, height) {
                TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);
                return this;
              },
              worldToTileX: function(worldX, snapToFloor, camera) {
                return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);
              },
              worldToTileY: function(worldY, snapToFloor, camera) {
                return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);
              },
              worldToTileXY: function(worldX, worldY, snapToFloor, point, camera) {
                return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);
              },
              destroy: function(removeFromTilemap) {
                if (removeFromTilemap === void 0) {
                  removeFromTilemap = true;
                }
                if (!this.tilemap) {
                  return;
                }
                if (this.layer.tilemapLayer === this) {
                  this.layer.tilemapLayer = void 0;
                }
                if (removeFromTilemap) {
                  this.tilemap.removeLayer(this);
                }
                this.tilemap = void 0;
                this.layer = void 0;
                this.culledTiles.length = 0;
                this.cullCallback = null;
                this.gidMap = [];
                this.tileset = [];
                GameObject.prototype.destroy.call(this);
              }
            });
            module2.exports = TilemapLayer;
          },
          17394: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TransformMatrix = __webpack_require__2(69360);
            var tempMatrix1 = new TransformMatrix();
            var tempMatrix2 = new TransformMatrix();
            var tempMatrix3 = new TransformMatrix();
            var TilemapLayerCanvasRenderer = function(renderer, src, camera, parentMatrix) {
              var renderTiles = src.cull(camera);
              var tileCount = renderTiles.length;
              var alpha = camera.alpha * src.alpha;
              if (tileCount === 0 || alpha <= 0) {
                return;
              }
              var camMatrix = tempMatrix1;
              var layerMatrix = tempMatrix2;
              var calcMatrix = tempMatrix3;
              layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
              camMatrix.copyFrom(camera.matrix);
              var ctx = renderer.currentContext;
              var gidMap = src.gidMap;
              ctx.save();
              if (parentMatrix) {
                camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
                layerMatrix.e = src.x;
                layerMatrix.f = src.y;
                camMatrix.multiply(layerMatrix, calcMatrix);
                calcMatrix.copyToContext(ctx);
              } else {
                layerMatrix.e -= camera.scrollX * src.scrollFactorX;
                layerMatrix.f -= camera.scrollY * src.scrollFactorY;
                layerMatrix.copyToContext(ctx);
              }
              if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1) {
                ctx.imageSmoothingEnabled = false;
              }
              for (var i = 0; i < tileCount; i++) {
                var tile = renderTiles[i];
                var tileset = gidMap[tile.index];
                if (!tileset) {
                  continue;
                }
                var image = tileset.image.getSourceImage();
                var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
                var tileWidth = tileset.tileWidth;
                var tileHeight = tileset.tileHeight;
                if (tileTexCoords === null || tileWidth === 0 || tileHeight === 0) {
                  continue;
                }
                var halfWidth = tileWidth * 0.5;
                var halfHeight = tileHeight * 0.5;
                tileTexCoords.x += tileset.tileOffset.x;
                tileTexCoords.y += tileset.tileOffset.y;
                ctx.save();
                ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);
                if (tile.rotation !== 0) {
                  ctx.rotate(tile.rotation);
                }
                if (tile.flipX || tile.flipY) {
                  ctx.scale(tile.flipX ? -1 : 1, tile.flipY ? -1 : 1);
                }
                ctx.globalAlpha = alpha * tile.alpha;
                ctx.drawImage(image, tileTexCoords.x, tileTexCoords.y, tileWidth, tileHeight, -halfWidth, -halfHeight, tileWidth, tileHeight);
                ctx.restore();
              }
              ctx.restore();
            };
            module2.exports = TilemapLayerCanvasRenderer;
          },
          96193: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = __webpack_require__2(72283);
            var renderWebGL = NOOP;
            var renderCanvas = NOOP;
            if (true) {
              renderWebGL = __webpack_require__2(51395);
            }
            if (true) {
              renderCanvas = __webpack_require__2(17394);
            }
            module2.exports = {
              renderWebGL,
              renderCanvas
            };
          },
          51395: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Utils = __webpack_require__2(75512);
            var TilemapLayerWebGLRenderer = function(renderer, src, camera) {
              var renderTiles = src.cull(camera);
              var tileCount = renderTiles.length;
              var alpha = camera.alpha * src.alpha;
              if (tileCount === 0 || alpha <= 0) {
                return;
              }
              var gidMap = src.gidMap;
              var pipeline = renderer.pipelines.set(src.pipeline, src);
              var getTint = Utils.getTintAppendFloatAlpha;
              var scrollFactorX = src.scrollFactorX;
              var scrollFactorY = src.scrollFactorY;
              var x = src.x;
              var y = src.y;
              var sx = src.scaleX;
              var sy = src.scaleY;
              renderer.pipelines.preBatch(src);
              for (var i = 0; i < tileCount; i++) {
                var tile = renderTiles[i];
                var tileset = gidMap[tile.index];
                if (!tileset) {
                  continue;
                }
                var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
                if (tileTexCoords === null) {
                  continue;
                }
                var texture = tileset.glTexture;
                var textureUnit = pipeline.setTexture2D(texture, src);
                var frameWidth = tileset.tileWidth;
                var frameHeight = tileset.tileHeight;
                var frameX = tileTexCoords.x;
                var frameY = tileTexCoords.y;
                var tw = tileset.tileWidth * 0.5;
                var th = tileset.tileHeight * 0.5;
                var tOffsetX = tileset.tileOffset.x;
                var tOffsetY = tileset.tileOffset.y;
                var tint = getTint(tile.tint, alpha * tile.alpha);
                pipeline.batchTexture(src, texture, texture.width, texture.height, x + tile.pixelX * sx + (tw * sx - tOffsetX), y + tile.pixelY * sy + (th * sy - tOffsetY), tile.width, tile.height, sx, sy, tile.rotation, tile.flipX, tile.flipY, scrollFactorX, scrollFactorY, tw, th, frameX, frameY, frameWidth, frameHeight, tint, tint, tint, tint, tile.tintFill, 0, 0, camera, null, true, textureUnit, true);
              }
              renderer.pipelines.postBatch(src);
            };
            module2.exports = TilemapLayerWebGLRenderer;
          },
          47975: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Vector2 = __webpack_require__2(93736);
            var Tileset = new Class({
              initialize: function Tileset2(name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData, tileOffset) {
                if (tileWidth === void 0 || tileWidth <= 0) {
                  tileWidth = 32;
                }
                if (tileHeight === void 0 || tileHeight <= 0) {
                  tileHeight = 32;
                }
                if (tileMargin === void 0) {
                  tileMargin = 0;
                }
                if (tileSpacing === void 0) {
                  tileSpacing = 0;
                }
                if (tileProperties === void 0) {
                  tileProperties = {};
                }
                if (tileData === void 0) {
                  tileData = {};
                }
                this.name = name;
                this.firstgid = firstgid;
                this.tileWidth = tileWidth;
                this.tileHeight = tileHeight;
                this.tileMargin = tileMargin;
                this.tileSpacing = tileSpacing;
                this.tileProperties = tileProperties;
                this.tileData = tileData;
                this.tileOffset = new Vector2();
                if (tileOffset !== void 0) {
                  this.tileOffset.set(tileOffset.x, tileOffset.y);
                }
                this.image = null;
                this.glTexture = null;
                this.rows = 0;
                this.columns = 0;
                this.total = 0;
                this.texCoordinates = [];
              },
              getTileProperties: function(tileIndex) {
                if (!this.containsTileIndex(tileIndex)) {
                  return null;
                }
                return this.tileProperties[tileIndex - this.firstgid];
              },
              getTileData: function(tileIndex) {
                if (!this.containsTileIndex(tileIndex)) {
                  return null;
                }
                return this.tileData[tileIndex - this.firstgid];
              },
              getTileCollisionGroup: function(tileIndex) {
                var data = this.getTileData(tileIndex);
                return data && data.objectgroup ? data.objectgroup : null;
              },
              containsTileIndex: function(tileIndex) {
                return tileIndex >= this.firstgid && tileIndex < this.firstgid + this.total;
              },
              getTileTextureCoordinates: function(tileIndex) {
                if (!this.containsTileIndex(tileIndex)) {
                  return null;
                }
                return this.texCoordinates[tileIndex - this.firstgid];
              },
              setImage: function(texture) {
                this.image = texture;
                this.glTexture = texture.get().source.glTexture;
                this.updateTileData(this.image.source[0].width, this.image.source[0].height);
                return this;
              },
              setTileSize: function(tileWidth, tileHeight) {
                if (tileWidth !== void 0) {
                  this.tileWidth = tileWidth;
                }
                if (tileHeight !== void 0) {
                  this.tileHeight = tileHeight;
                }
                if (this.image) {
                  this.updateTileData(this.image.source[0].width, this.image.source[0].height);
                }
                return this;
              },
              setSpacing: function(margin, spacing) {
                if (margin !== void 0) {
                  this.tileMargin = margin;
                }
                if (spacing !== void 0) {
                  this.tileSpacing = spacing;
                }
                if (this.image) {
                  this.updateTileData(this.image.source[0].width, this.image.source[0].height);
                }
                return this;
              },
              updateTileData: function(imageWidth, imageHeight) {
                var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);
                var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                if (rowCount % 1 !== 0 || colCount % 1 !== 0) {
                  console.warn("Image tile area not tile size multiple in: " + this.name);
                }
                rowCount = Math.floor(rowCount);
                colCount = Math.floor(colCount);
                this.rows = rowCount;
                this.columns = colCount;
                this.total = rowCount * colCount;
                this.texCoordinates.length = 0;
                var tx = this.tileMargin;
                var ty = this.tileMargin;
                for (var y = 0; y < this.rows; y++) {
                  for (var x = 0; x < this.columns; x++) {
                    this.texCoordinates.push({x: tx, y: ty});
                    tx += this.tileWidth + this.tileSpacing;
                  }
                  tx = this.tileMargin;
                  ty += this.tileHeight + this.tileSpacing;
                }
                return this;
              }
            });
            module2.exports = Tileset;
          },
          92839: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTileAt = __webpack_require__2(15494);
            var CalculateFacesAt = function(tileX, tileY, layer) {
              var tile = GetTileAt(tileX, tileY, true, layer);
              var above = GetTileAt(tileX, tileY - 1, true, layer);
              var below = GetTileAt(tileX, tileY + 1, true, layer);
              var left = GetTileAt(tileX - 1, tileY, true, layer);
              var right = GetTileAt(tileX + 1, tileY, true, layer);
              var tileCollides = tile && tile.collides;
              if (tileCollides) {
                tile.faceTop = true;
                tile.faceBottom = true;
                tile.faceLeft = true;
                tile.faceRight = true;
              }
              if (above && above.collides) {
                if (tileCollides) {
                  tile.faceTop = false;
                }
                above.faceBottom = !tileCollides;
              }
              if (below && below.collides) {
                if (tileCollides) {
                  tile.faceBottom = false;
                }
                below.faceTop = !tileCollides;
              }
              if (left && left.collides) {
                if (tileCollides) {
                  tile.faceLeft = false;
                }
                left.faceRight = !tileCollides;
              }
              if (right && right.collides) {
                if (tileCollides) {
                  tile.faceRight = false;
                }
                right.faceLeft = !tileCollides;
              }
              if (tile && !tile.collides) {
                tile.resetFaces();
              }
              return tile;
            };
            module2.exports = CalculateFacesAt;
          },
          60386: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTileAt = __webpack_require__2(15494);
            var GetTilesWithin = __webpack_require__2(50811);
            var CalculateFacesWithin = function(tileX, tileY, width, height, layer) {
              var above = null;
              var below = null;
              var left = null;
              var right = null;
              var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
              for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                if (tile) {
                  if (tile.collides) {
                    above = GetTileAt(tile.x, tile.y - 1, true, layer);
                    below = GetTileAt(tile.x, tile.y + 1, true, layer);
                    left = GetTileAt(tile.x - 1, tile.y, true, layer);
                    right = GetTileAt(tile.x + 1, tile.y, true, layer);
                    tile.faceTop = above && above.collides ? false : true;
                    tile.faceBottom = below && below.collides ? false : true;
                    tile.faceLeft = left && left.collides ? false : true;
                    tile.faceRight = right && right.collides ? false : true;
                  } else {
                    tile.resetFaces();
                  }
                }
              }
            };
            module2.exports = CalculateFacesWithin;
          },
          13125: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var point = new Vector2();
            var CheckIsoBounds = function(tileX, tileY, layer, camera) {
              var tilemapLayer = layer.tilemapLayer;
              var cullPaddingX = tilemapLayer.cullPaddingX;
              var cullPaddingY = tilemapLayer.cullPaddingY;
              var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);
              return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5) && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5) && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1) && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);
            };
            module2.exports = CheckIsoBounds;
          },
          17347: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CalculateFacesWithin = __webpack_require__2(60386);
            var GetTilesWithin = __webpack_require__2(50811);
            var IsInLayerBounds = __webpack_require__2(62839);
            var Tile = __webpack_require__2(29633);
            var Copy = function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);
              var copyTiles = [];
              srcTiles.forEach(function(tile) {
                var newTile = new Tile(tile.layer, tile.index, tile.x, tile.y, tile.width, tile.height, tile.baseWidth, tile.baseHeight);
                newTile.copy(tile);
                copyTiles.push(newTile);
              });
              var offsetX = destTileX - srcTileX;
              var offsetY = destTileY - srcTileY;
              for (var i = 0; i < copyTiles.length; i++) {
                var copy = copyTiles[i];
                var tileX = copy.x + offsetX;
                var tileY = copy.y + offsetY;
                if (IsInLayerBounds(tileX, tileY, layer)) {
                  if (layer.data[tileY][tileX]) {
                    copy.x = tileX;
                    copy.y = tileY;
                    copy.updatePixelXY();
                    layer.data[tileY][tileX] = copy;
                  }
                }
              }
              if (recalculateFaces) {
                CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);
              }
              srcTiles.length = 0;
              copyTiles.length = 0;
            };
            module2.exports = Copy;
          },
          93604: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var ReplaceByIndex = __webpack_require__2(51202);
            var CreateFromTiles = function(indexes, replacements, spriteConfig, scene, camera, layer) {
              if (!spriteConfig) {
                spriteConfig = {};
              }
              if (!Array.isArray(indexes)) {
                indexes = [indexes];
              }
              var tilemapLayer = layer.tilemapLayer;
              if (!scene) {
                scene = tilemapLayer.scene;
              }
              if (!camera) {
                camera = scene.cameras.main;
              }
              var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
              var sprites = [];
              var i;
              for (i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                if (indexes.indexOf(tile.index) !== -1) {
                  var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, void 0, camera, layer);
                  spriteConfig.x = point.x;
                  spriteConfig.y = point.y;
                  sprites.push(scene.make.sprite(spriteConfig));
                }
              }
              if (typeof replacements === "number") {
                for (i = 0; i < indexes.length; i++) {
                  ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);
                }
              } else if (Array.isArray(replacements)) {
                for (i = 0; i < indexes.length; i++) {
                  ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);
                }
              }
              return sprites;
            };
            module2.exports = CreateFromTiles;
          },
          71586: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Rectangle = __webpack_require__2(74118);
            var SnapCeil = __webpack_require__2(82127);
            var SnapFloor = __webpack_require__2(84314);
            var bounds = new Rectangle();
            var CullBounds = function(layer, camera) {
              var tilemap = layer.tilemapLayer.tilemap;
              var tilemapLayer = layer.tilemapLayer;
              var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
              var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
              var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
              var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
              var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;
              var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;
              return bounds.setTo(boundsLeft, boundsTop, boundsRight - boundsLeft, boundsBottom - boundsTop);
            };
            module2.exports = CullBounds;
          },
          381: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CullBounds = __webpack_require__2(71586);
            var RunCull = __webpack_require__2(6987);
            var CullTiles = function(layer, camera, outputArray, renderOrder) {
              if (outputArray === void 0) {
                outputArray = [];
              }
              if (renderOrder === void 0) {
                renderOrder = 0;
              }
              outputArray.length = 0;
              var tilemapLayer = layer.tilemapLayer;
              var bounds = CullBounds(layer, camera);
              if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1) {
                bounds.left = 0;
                bounds.right = layer.width;
                bounds.top = 0;
                bounds.bottom = layer.height;
              }
              RunCull(layer, bounds, renderOrder, outputArray);
              return outputArray;
            };
            module2.exports = CullTiles;
          },
          97734: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var CalculateFacesWithin = __webpack_require__2(60386);
            var SetTileCollision = __webpack_require__2(68234);
            var Fill = function(index, tileX, tileY, width, height, recalculateFaces, layer) {
              var doesIndexCollide = layer.collideIndexes.indexOf(index) !== -1;
              var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
              for (var i = 0; i < tiles.length; i++) {
                tiles[i].index = index;
                SetTileCollision(tiles[i], doesIndexCollide);
              }
              if (recalculateFaces) {
                CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
              }
            };
            module2.exports = Fill;
          },
          63555: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var FilterTiles = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
              return tiles.filter(callback, context);
            };
            module2.exports = FilterTiles;
          },
          37982: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FindByIndex = function(findIndex, skip, reverse, layer) {
              if (skip === void 0) {
                skip = 0;
              }
              if (reverse === void 0) {
                reverse = false;
              }
              var count = 0;
              var tx;
              var ty;
              var tile;
              if (reverse) {
                for (ty = layer.height - 1; ty >= 0; ty--) {
                  for (tx = layer.width - 1; tx >= 0; tx--) {
                    tile = layer.data[ty][tx];
                    if (tile && tile.index === findIndex) {
                      if (count === skip) {
                        return tile;
                      } else {
                        count += 1;
                      }
                    }
                  }
                }
              } else {
                for (ty = 0; ty < layer.height; ty++) {
                  for (tx = 0; tx < layer.width; tx++) {
                    tile = layer.data[ty][tx];
                    if (tile && tile.index === findIndex) {
                      if (count === skip) {
                        return tile;
                      } else {
                        count += 1;
                      }
                    }
                  }
                }
              }
              return null;
            };
            module2.exports = FindByIndex;
          },
          48297: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var FindTile = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
              return tiles.find(callback, context) || null;
            };
            module2.exports = FindTile;
          },
          80916: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var ForEachTile = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
              tiles.forEach(callback, context);
            };
            module2.exports = ForEachTile;
          },
          31493: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var CullTiles = __webpack_require__2(381);
            var HexagonalCullTiles = __webpack_require__2(37524);
            var IsometricCullTiles = __webpack_require__2(20887);
            var NOOP = __webpack_require__2(72283);
            var StaggeredCullTiles = __webpack_require__2(19242);
            var GetCullTilesFunction = function(orientation) {
              if (orientation === CONST.ORTHOGONAL) {
                return CullTiles;
              } else if (orientation === CONST.HEXAGONAL) {
                return HexagonalCullTiles;
              } else if (orientation === CONST.STAGGERED) {
                return StaggeredCullTiles;
              } else if (orientation === CONST.ISOMETRIC) {
                return IsometricCullTiles;
              } else {
                return NOOP;
              }
            };
            module2.exports = GetCullTilesFunction;
          },
          15494: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsInLayerBounds = __webpack_require__2(62839);
            var GetTileAt = function(tileX, tileY, nonNull, layer) {
              if (nonNull === void 0) {
                nonNull = false;
              }
              if (IsInLayerBounds(tileX, tileY, layer)) {
                var tile = layer.data[tileY][tileX] || null;
                if (!tile) {
                  return null;
                } else if (tile.index === -1) {
                  return nonNull ? tile : null;
                } else {
                  return tile;
                }
              } else {
                return null;
              }
            };
            module2.exports = GetTileAt;
          },
          24640: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTileAt = __webpack_require__2(15494);
            var Vector2 = __webpack_require__2(93736);
            var point = new Vector2();
            var GetTileAtWorldXY = function(worldX, worldY, nonNull, camera, layer) {
              layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
              return GetTileAt(point.x, point.y, nonNull, layer);
            };
            module2.exports = GetTileAtWorldXY;
          },
          48495: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var GetTileCorners = function(tileX, tileY, camera, layer) {
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              var worldX = 0;
              var worldY = 0;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                worldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
                worldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
                tileWidth *= tilemapLayer.scaleX;
                tileHeight *= tilemapLayer.scaleY;
              }
              var x = worldX + tileX * tileWidth;
              var y = worldY + tileY * tileHeight;
              return [
                new Vector2(x, y),
                new Vector2(x + tileWidth, y),
                new Vector2(x + tileWidth, y + tileHeight),
                new Vector2(x, y + tileHeight)
              ];
            };
            module2.exports = GetTileCorners;
          },
          7160: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var HexagonalGetTileCorners = __webpack_require__2(63634);
            var NOOP = __webpack_require__2(72283);
            var GetTileCorners = __webpack_require__2(48495);
            var GetTileCornersFunction = function(orientation) {
              if (orientation === CONST.ORTHOGONAL) {
                return GetTileCorners;
              } else if (orientation === CONST.ISOMETRIC) {
                return NOOP;
              } else if (orientation === CONST.HEXAGONAL) {
                return HexagonalGetTileCorners;
              } else if (orientation === CONST.STAGGERED) {
                return NOOP;
              } else {
                return NOOP;
              }
            };
            module2.exports = GetTileCornersFunction;
          },
          16884: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var NOOP = __webpack_require__2(72283);
            var TileToWorldX = __webpack_require__2(44150);
            var GetTileToWorldXFunction = function(orientation) {
              if (orientation === CONST.ORTHOGONAL) {
                return TileToWorldX;
              } else {
                return NOOP;
              }
            };
            module2.exports = GetTileToWorldXFunction;
          },
          68182: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var HexagonalTileToWorldXY = __webpack_require__2(21715);
            var IsometricTileToWorldXY = __webpack_require__2(21808);
            var NOOP = __webpack_require__2(72283);
            var StaggeredTileToWorldXY = __webpack_require__2(33388);
            var TileToWorldXY = __webpack_require__2(46836);
            var GetTileToWorldXYFunction = function(orientation) {
              if (orientation === CONST.ORTHOGONAL) {
                return TileToWorldXY;
              } else if (orientation === CONST.ISOMETRIC) {
                return IsometricTileToWorldXY;
              } else if (orientation === CONST.HEXAGONAL) {
                return HexagonalTileToWorldXY;
              } else if (orientation === CONST.STAGGERED) {
                return StaggeredTileToWorldXY;
              } else {
                return NOOP;
              }
            };
            module2.exports = GetTileToWorldXYFunction;
          },
          3752: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var NOOP = __webpack_require__2(72283);
            var StaggeredTileToWorldY = __webpack_require__2(84132);
            var TileToWorldY = __webpack_require__2(42477);
            var GetTileToWorldYFunction = function(orientation) {
              if (orientation === CONST.ORTHOGONAL) {
                return TileToWorldY;
              } else if (orientation === CONST.STAGGERED) {
                return StaggeredTileToWorldY;
              } else {
                return NOOP;
              }
            };
            module2.exports = GetTileToWorldYFunction;
          },
          50811: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var GetTilesWithin = function(tileX, tileY, width, height, filteringOptions, layer) {
              if (tileX === void 0) {
                tileX = 0;
              }
              if (tileY === void 0) {
                tileY = 0;
              }
              if (width === void 0) {
                width = layer.width;
              }
              if (height === void 0) {
                height = layer.height;
              }
              if (!filteringOptions) {
                filteringOptions = {};
              }
              var isNotEmpty = GetFastValue(filteringOptions, "isNotEmpty", false);
              var isColliding = GetFastValue(filteringOptions, "isColliding", false);
              var hasInterestingFace = GetFastValue(filteringOptions, "hasInterestingFace", false);
              if (tileX < 0) {
                width += tileX;
                tileX = 0;
              }
              if (tileY < 0) {
                height += tileY;
                tileY = 0;
              }
              if (tileX + width > layer.width) {
                width = Math.max(layer.width - tileX, 0);
              }
              if (tileY + height > layer.height) {
                height = Math.max(layer.height - tileY, 0);
              }
              var results = [];
              for (var ty = tileY; ty < tileY + height; ty++) {
                for (var tx = tileX; tx < tileX + width; tx++) {
                  var tile = layer.data[ty][tx];
                  if (tile !== null) {
                    if (isNotEmpty && tile.index === -1) {
                      continue;
                    }
                    if (isColliding && !tile.collides) {
                      continue;
                    }
                    if (hasInterestingFace && !tile.hasInterestingFace) {
                      continue;
                    }
                    results.push(tile);
                  }
                }
              }
              return results;
            };
            module2.exports = GetTilesWithin;
          },
          31674: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Geom = __webpack_require__2(84068);
            var GetTilesWithin = __webpack_require__2(50811);
            var Intersects = __webpack_require__2(7563);
            var NOOP = __webpack_require__2(72283);
            var Vector2 = __webpack_require__2(93736);
            var TriangleToRectangle = function(triangle, rect) {
              return Intersects.RectangleToTriangle(rect, triangle);
            };
            var point = new Vector2();
            var pointStart = new Vector2();
            var pointEnd = new Vector2();
            var GetTilesWithinShape = function(shape, filteringOptions, camera, layer) {
              if (shape === void 0) {
                return [];
              }
              var intersectTest = NOOP;
              if (shape instanceof Geom.Circle) {
                intersectTest = Intersects.CircleToRectangle;
              } else if (shape instanceof Geom.Rectangle) {
                intersectTest = Intersects.RectangleToRectangle;
              } else if (shape instanceof Geom.Triangle) {
                intersectTest = TriangleToRectangle;
              } else if (shape instanceof Geom.Line) {
                intersectTest = Intersects.LineToRectangle;
              }
              layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);
              var xStart = pointStart.x;
              var yStart = pointStart.y;
              layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, false, pointEnd, camera);
              var xEnd = Math.ceil(pointEnd.x);
              var yEnd = Math.ceil(pointEnd.y);
              var width = Math.max(xEnd - xStart, 1);
              var height = Math.max(yEnd - yStart, 1);
              var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);
              var tileWidth = layer.tileWidth;
              var tileHeight = layer.tileHeight;
              if (layer.tilemapLayer) {
                tileWidth *= layer.tilemapLayer.scaleX;
                tileHeight *= layer.tilemapLayer.scaleY;
              }
              var results = [];
              var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);
              for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);
                tileRect.x = point.x;
                tileRect.y = point.y;
                if (intersectTest(shape, tileRect)) {
                  results.push(tile);
                }
              }
              return results;
            };
            module2.exports = GetTilesWithinShape;
          },
          44662: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var Vector2 = __webpack_require__2(93736);
            var pointStart = new Vector2();
            var pointEnd = new Vector2();
            var GetTilesWithinWorldXY = function(worldX, worldY, width, height, filteringOptions, camera, layer) {
              var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;
              worldToTileXY(worldX, worldY, true, pointStart, camera, layer);
              var xStart = pointStart.x;
              var yStart = pointStart.y;
              worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);
              var xEnd = Math.ceil(pointEnd.x);
              var yEnd = Math.ceil(pointEnd.y);
              return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);
            };
            module2.exports = GetTilesWithinWorldXY;
          },
          29296: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var NULL = __webpack_require__2(10618);
            var WorldToTileX = __webpack_require__2(806);
            var GetWorldToTileXFunction = function(orientation) {
              if (orientation === CONST.ORTHOGONAL) {
                return WorldToTileX;
              } else {
                return NULL;
              }
            };
            module2.exports = GetWorldToTileXFunction;
          },
          32688: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var HexagonalWorldToTileXY = __webpack_require__2(11516);
            var IsometricWorldToTileXY = __webpack_require__2(18750);
            var NOOP = __webpack_require__2(72283);
            var StaggeredWorldToTileXY = __webpack_require__2(90562);
            var WorldToTileXY = __webpack_require__2(45676);
            var GetWorldToTileXYFunction = function(orientation) {
              if (orientation === CONST.ORTHOGONAL) {
                return WorldToTileXY;
              } else if (orientation === CONST.ISOMETRIC) {
                return IsometricWorldToTileXY;
              } else if (orientation === CONST.HEXAGONAL) {
                return HexagonalWorldToTileXY;
              } else if (orientation === CONST.STAGGERED) {
                return StaggeredWorldToTileXY;
              } else {
                return NOOP;
              }
            };
            module2.exports = GetWorldToTileXYFunction;
          },
          74326: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var NULL = __webpack_require__2(10618);
            var StaggeredWorldToTileY = __webpack_require__2(3689);
            var WorldToTileY = __webpack_require__2(70520);
            var GetWorldToTileYFunction = function(orientation) {
              if (orientation === CONST.ORTHOGONAL) {
                return WorldToTileY;
              } else if (orientation === CONST.STAGGERED) {
                return StaggeredWorldToTileY;
              } else {
                return NULL;
              }
            };
            module2.exports = GetWorldToTileYFunction;
          },
          46598: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsInLayerBounds = __webpack_require__2(62839);
            var HasTileAt = function(tileX, tileY, layer) {
              if (IsInLayerBounds(tileX, tileY, layer)) {
                var tile = layer.data[tileY][tileX];
                return tile !== null && tile.index > -1;
              } else {
                return false;
              }
            };
            module2.exports = HasTileAt;
          },
          28654: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HasTileAt = __webpack_require__2(46598);
            var Vector2 = __webpack_require__2(93736);
            var point = new Vector2();
            var HasTileAtWorldXY = function(worldX, worldY, camera, layer) {
              layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
              var tileX = point.x;
              var tileY = point.y;
              return HasTileAt(tileX, tileY, layer);
            };
            module2.exports = HasTileAtWorldXY;
          },
          6358: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SnapCeil = __webpack_require__2(82127);
            var SnapFloor = __webpack_require__2(84314);
            var HexagonalCullBounds = function(layer, camera) {
              var tilemap = layer.tilemapLayer.tilemap;
              var tilemapLayer = layer.tilemapLayer;
              var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
              var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
              var len = layer.hexSideLength;
              var boundsLeft;
              var boundsRight;
              var boundsTop;
              var boundsBottom;
              if (layer.staggerAxis === "y") {
                var rowH = (tileH - len) / 2 + len;
                boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
                boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
                boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;
                boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;
              } else {
                var rowW = (tileW - len) / 2 + len;
                boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, rowW, 0, true) - tilemapLayer.cullPaddingX;
                boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, rowW, 0, true) + tilemapLayer.cullPaddingX;
                boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;
                boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;
              }
              return {
                left: boundsLeft,
                right: boundsRight,
                top: boundsTop,
                bottom: boundsBottom
              };
            };
            module2.exports = HexagonalCullBounds;
          },
          37524: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CullBounds = __webpack_require__2(6358);
            var RunCull = __webpack_require__2(6987);
            var HexagonalCullTiles = function(layer, camera, outputArray, renderOrder) {
              if (outputArray === void 0) {
                outputArray = [];
              }
              if (renderOrder === void 0) {
                renderOrder = 0;
              }
              outputArray.length = 0;
              var tilemapLayer = layer.tilemapLayer;
              var bounds = CullBounds(layer, camera);
              if (tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
                bounds.left = 0;
                bounds.right = layer.width;
                bounds.top = 0;
                bounds.bottom = layer.height;
              }
              RunCull(layer, bounds, renderOrder, outputArray);
              return outputArray;
            };
            module2.exports = HexagonalCullTiles;
          },
          63634: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HexagonalTileToWorldXY = __webpack_require__2(21715);
            var Vector2 = __webpack_require__2(93736);
            var tempVec = new Vector2();
            var HexagonalGetTileCorners = function(tileX, tileY, camera, layer) {
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              if (tilemapLayer) {
                tileWidth *= tilemapLayer.scaleX;
                tileHeight *= tilemapLayer.scaleY;
              }
              var center = HexagonalTileToWorldXY(tileX, tileY, tempVec, camera, layer);
              var corners = [];
              var b0 = 0.5773502691896257;
              var hexWidth;
              var hexHeight;
              if (layer.staggerAxis === "y") {
                hexWidth = b0 * tileWidth;
                hexHeight = tileHeight / 2;
              } else {
                hexWidth = tileWidth / 2;
                hexHeight = b0 * tileHeight;
              }
              for (var i = 0; i < 6; i++) {
                var angle = 2 * Math.PI * (0.5 - i) / 6;
                corners.push(new Vector2(center.x + hexWidth * Math.cos(angle), center.y + hexHeight * Math.sin(angle)));
              }
              return corners;
            };
            module2.exports = HexagonalGetTileCorners;
          },
          21715: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var HexagonalTileToWorldXY = function(tileX, tileY, point, camera, layer) {
              if (!point) {
                point = new Vector2();
              }
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              var worldX = 0;
              var worldY = 0;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                worldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
                worldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
                tileWidth *= tilemapLayer.scaleX;
                tileHeight *= tilemapLayer.scaleY;
              }
              var tileWidthHalf = tileWidth / 2;
              var tileHeightHalf = tileHeight / 2;
              var x;
              var y;
              if (layer.staggerAxis === "y") {
                x = worldX + tileWidth * tileX + tileWidth;
                y = worldY + 1.5 * tileY * tileHeightHalf + tileHeightHalf;
                if (tileY % 2 === 0) {
                  if (this.staggerIndex === "odd") {
                    x -= tileWidthHalf;
                  } else {
                    x += tileWidthHalf;
                  }
                }
              } else if (this.staggerAxis === "x" && this.staggerIndex === "odd") {
                x = worldX + 1.5 * tileX * tileWidthHalf + tileWidthHalf;
                y = worldY + tileHeight * tileX + tileHeight;
                if (tileX % 2 === 0) {
                  if (this.staggerIndex === "odd") {
                    y -= tileHeightHalf;
                  } else {
                    y += tileHeightHalf;
                  }
                }
              }
              return point.set(x, y);
            };
            module2.exports = HexagonalTileToWorldXY;
          },
          11516: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var HexagonalWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
              if (!point) {
                point = new Vector2();
              }
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
                worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
                tileWidth *= tilemapLayer.scaleX;
                tileHeight *= tilemapLayer.scaleY;
              }
              var b0 = 0.5773502691896257;
              var b1 = -0.3333333333333333;
              var b2 = 0;
              var b3 = 0.6666666666666666;
              var tileWidthHalf = tileWidth / 2;
              var tileHeightHalf = tileHeight / 2;
              var px;
              var py;
              var q;
              var r;
              var s;
              if (layer.staggerAxis === "y") {
                px = (worldX - tileWidthHalf) / (b0 * tileWidth);
                py = (worldY - tileHeightHalf) / tileHeightHalf;
                q = b0 * px + b1 * py;
                r = b2 * px + b3 * py;
              } else {
                px = (worldX - tileWidthHalf) / tileWidthHalf;
                py = (worldY - tileHeightHalf) / (b0 * tileHeight);
                q = b1 * px + b0 * py;
                r = b3 * px + b2 * py;
              }
              s = -q - r;
              var qi = Math.round(q);
              var ri = Math.round(r);
              var si = Math.round(s);
              var qDiff = Math.abs(qi - q);
              var rDiff = Math.abs(ri - r);
              var sDiff = Math.abs(si - s);
              if (qDiff > rDiff && qDiff > sDiff) {
                qi = -ri - si;
              } else if (rDiff > sDiff) {
                ri = -qi - si;
              }
              var x;
              var y = ri;
              if (layer.staggerIndex === "odd") {
                x = y % 2 === 0 ? ri / 2 + qi : ri / 2 + qi - 0.5;
              } else {
                x = y % 2 === 0 ? ri / 2 + qi : ri / 2 + qi + 0.5;
              }
              return point.set(x, y);
            };
            module2.exports = HexagonalWorldToTileXY;
          },
          62839: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsInLayerBounds = function(tileX, tileY, layer) {
              return tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height;
            };
            module2.exports = IsInLayerBounds;
          },
          20887: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CheckIsoBounds = __webpack_require__2(13125);
            var IsometricCullTiles = function(layer, camera, outputArray, renderOrder) {
              if (outputArray === void 0) {
                outputArray = [];
              }
              if (renderOrder === void 0) {
                renderOrder = 0;
              }
              outputArray.length = 0;
              var tilemapLayer = layer.tilemapLayer;
              var mapData = layer.data;
              var mapWidth = layer.width;
              var mapHeight = layer.height;
              var skipCull = tilemapLayer.skipCull;
              var drawLeft = 0;
              var drawRight = mapWidth;
              var drawTop = 0;
              var drawBottom = mapHeight;
              var x;
              var y;
              var tile;
              if (renderOrder === 0) {
                for (y = drawTop; y < drawBottom; y++) {
                  for (x = drawLeft; x < drawRight; x++) {
                    if (skipCull || CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 1) {
                for (y = drawTop; y < drawBottom; y++) {
                  for (x = drawRight; x >= drawLeft; x--) {
                    if (skipCull || CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 2) {
                for (y = drawBottom; y >= drawTop; y--) {
                  for (x = drawLeft; x < drawRight; x++) {
                    if (skipCull || CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 3) {
                for (y = drawBottom; y >= drawTop; y--) {
                  for (x = drawRight; x >= drawLeft; x--) {
                    if (skipCull || CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              }
              tilemapLayer.tilesDrawn = outputArray.length;
              tilemapLayer.tilesTotal = mapWidth * mapHeight;
              return outputArray;
            };
            module2.exports = IsometricCullTiles;
          },
          21808: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var IsometricTileToWorldXY = function(tileX, tileY, point, camera, layer) {
              if (!point) {
                point = new Vector2();
              }
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              var layerWorldX = 0;
              var layerWorldY = 0;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
                tileWidth *= tilemapLayer.scaleX;
                layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
                tileHeight *= tilemapLayer.scaleY;
              }
              var x = layerWorldX + (tileX - tileY) * (tileWidth / 2);
              var y = layerWorldY + (tileX + tileY) * (tileHeight / 2);
              return point.set(x, y);
            };
            module2.exports = IsometricTileToWorldXY;
          },
          18750: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var IsometricWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer, originTop) {
              if (!point) {
                point = new Vector2();
              }
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
                tileHeight *= tilemapLayer.scaleY;
                worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
                tileWidth *= tilemapLayer.scaleX;
              }
              var tileWidthHalf = tileWidth / 2;
              var tileHeightHalf = tileHeight / 2;
              worldX = worldX - tileWidthHalf;
              if (!originTop) {
                worldY = worldY - tileHeight;
              }
              var x = 0.5 * (worldX / tileWidthHalf + worldY / tileHeightHalf);
              var y = 0.5 * (-worldX / tileWidthHalf + worldY / tileHeightHalf);
              if (snapToFloor) {
                x = Math.floor(x);
                y = Math.floor(y);
              }
              return point.set(x, y);
            };
            module2.exports = IsometricWorldToTileXY;
          },
          29003: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Tile = __webpack_require__2(29633);
            var IsInLayerBounds = __webpack_require__2(62839);
            var CalculateFacesAt = __webpack_require__2(92839);
            var SetTileCollision = __webpack_require__2(68234);
            var PutTileAt = function(tile, tileX, tileY, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              if (!IsInLayerBounds(tileX, tileY, layer)) {
                return null;
              }
              var index;
              var oldTile = layer.data[tileY][tileX];
              var oldTileCollides = oldTile && oldTile.collides;
              if (tile instanceof Tile) {
                if (layer.data[tileY][tileX] === null) {
                  layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);
                }
                layer.data[tileY][tileX].copy(tile);
              } else {
                index = tile;
                if (layer.data[tileY][tileX] === null) {
                  layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);
                } else {
                  layer.data[tileY][tileX].index = index;
                }
              }
              var newTile = layer.data[tileY][tileX];
              var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;
              index = tile instanceof Tile ? tile.index : tile;
              if (index === -1) {
                newTile.width = layer.tileWidth;
                newTile.height = layer.tileHeight;
              } else {
                var tilemap = layer.tilemapLayer.tilemap;
                var tiles = tilemap.tiles;
                var sid = tiles[index][2];
                var set = tilemap.tilesets[sid];
                newTile.width = set.tileWidth;
                newTile.height = set.tileHeight;
              }
              SetTileCollision(newTile, collides);
              if (recalculateFaces && oldTileCollides !== newTile.collides) {
                CalculateFacesAt(tileX, tileY, layer);
              }
              return newTile;
            };
            module2.exports = PutTileAt;
          },
          48565: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var PutTileAt = __webpack_require__2(29003);
            var Vector2 = __webpack_require__2(93736);
            var point = new Vector2();
            var PutTileAtWorldXY = function(tile, worldX, worldY, recalculateFaces, camera, layer) {
              layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
              return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);
            };
            module2.exports = PutTileAtWorldXY;
          },
          56547: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CalculateFacesWithin = __webpack_require__2(60386);
            var PutTileAt = __webpack_require__2(29003);
            var PutTilesAt = function(tilesArray, tileX, tileY, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              if (!Array.isArray(tilesArray)) {
                return null;
              }
              if (!Array.isArray(tilesArray[0])) {
                tilesArray = [tilesArray];
              }
              var height = tilesArray.length;
              var width = tilesArray[0].length;
              for (var ty = 0; ty < height; ty++) {
                for (var tx = 0; tx < width; tx++) {
                  var tile = tilesArray[ty][tx];
                  PutTileAt(tile, tileX + tx, tileY + ty, false, layer);
                }
              }
              if (recalculateFaces) {
                CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
              }
            };
            module2.exports = PutTilesAt;
          },
          91180: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var GetRandom = __webpack_require__2(72861);
            var Randomize = function(tileX, tileY, width, height, indexes, layer) {
              var i;
              var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);
              if (!indexes) {
                indexes = [];
                for (i = 0; i < tiles.length; i++) {
                  if (indexes.indexOf(tiles[i].index) === -1) {
                    indexes.push(tiles[i].index);
                  }
                }
              }
              for (i = 0; i < tiles.length; i++) {
                tiles[i].index = GetRandom(indexes);
              }
            };
            module2.exports = Randomize;
          },
          929: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Tile = __webpack_require__2(29633);
            var IsInLayerBounds = __webpack_require__2(62839);
            var CalculateFacesAt = __webpack_require__2(92839);
            var RemoveTileAt = function(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
              if (replaceWithNull === void 0) {
                replaceWithNull = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              if (!IsInLayerBounds(tileX, tileY, layer)) {
                return null;
              }
              var tile = layer.data[tileY][tileX];
              if (!tile) {
                return null;
              } else {
                layer.data[tileY][tileX] = replaceWithNull ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);
              }
              if (recalculateFaces && tile && tile.collides) {
                CalculateFacesAt(tileX, tileY, layer);
              }
              return tile;
            };
            module2.exports = RemoveTileAt;
          },
          17384: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RemoveTileAt = __webpack_require__2(929);
            var Vector2 = __webpack_require__2(93736);
            var point = new Vector2();
            var RemoveTileAtWorldXY = function(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
              layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
              return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);
            };
            module2.exports = RemoveTileAtWorldXY;
          },
          93763: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var Color = __webpack_require__2(95509);
            var defaultTileColor = new Color(105, 210, 231, 150);
            var defaultCollidingTileColor = new Color(243, 134, 48, 200);
            var defaultFaceColor = new Color(40, 39, 37, 150);
            var RenderDebug = function(graphics, styleConfig, layer) {
              if (styleConfig === void 0) {
                styleConfig = {};
              }
              var tileColor = styleConfig.tileColor !== void 0 ? styleConfig.tileColor : defaultTileColor;
              var collidingTileColor = styleConfig.collidingTileColor !== void 0 ? styleConfig.collidingTileColor : defaultCollidingTileColor;
              var faceColor = styleConfig.faceColor !== void 0 ? styleConfig.faceColor : defaultFaceColor;
              var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
              graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);
              graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);
              for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                var tw = tile.width;
                var th = tile.height;
                var x = tile.pixelX;
                var y = tile.pixelY;
                var color = tile.collides ? collidingTileColor : tileColor;
                if (color !== null) {
                  graphics.fillStyle(color.color, color.alpha / 255);
                  graphics.fillRect(x, y, tw, th);
                }
                x += 1;
                y += 1;
                tw -= 2;
                th -= 2;
                if (faceColor !== null) {
                  graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);
                  if (tile.faceTop) {
                    graphics.lineBetween(x, y, x + tw, y);
                  }
                  if (tile.faceRight) {
                    graphics.lineBetween(x + tw, y, x + tw, y + th);
                  }
                  if (tile.faceBottom) {
                    graphics.lineBetween(x, y + th, x + tw, y + th);
                  }
                  if (tile.faceLeft) {
                    graphics.lineBetween(x, y, x, y + th);
                  }
                }
              }
            };
            module2.exports = RenderDebug;
          },
          51202: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var ReplaceByIndex = function(findIndex, newIndex, tileX, tileY, width, height, layer) {
              var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
              for (var i = 0; i < tiles.length; i++) {
                if (tiles[i] && tiles[i].index === findIndex) {
                  tiles[i].index = newIndex;
                }
              }
            };
            module2.exports = ReplaceByIndex;
          },
          6987: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RunCull = function(layer, bounds, renderOrder, outputArray) {
              var mapData = layer.data;
              var mapWidth = layer.width;
              var mapHeight = layer.height;
              var tilemapLayer = layer.tilemapLayer;
              var drawLeft = Math.max(0, bounds.left);
              var drawRight = Math.min(mapWidth, bounds.right);
              var drawTop = Math.max(0, bounds.top);
              var drawBottom = Math.min(mapHeight, bounds.bottom);
              var x;
              var y;
              var tile;
              if (renderOrder === 0) {
                for (y = drawTop; y < drawBottom; y++) {
                  for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                    tile = mapData[y][x];
                    if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                      continue;
                    }
                    outputArray.push(tile);
                  }
                }
              } else if (renderOrder === 1) {
                for (y = drawTop; y < drawBottom; y++) {
                  for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                    tile = mapData[y][x];
                    if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                      continue;
                    }
                    outputArray.push(tile);
                  }
                }
              } else if (renderOrder === 2) {
                for (y = drawBottom; y >= drawTop; y--) {
                  for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                    tile = mapData[y][x];
                    if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                      continue;
                    }
                    outputArray.push(tile);
                  }
                }
              } else if (renderOrder === 3) {
                for (y = drawBottom; y >= drawTop; y--) {
                  for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                    tile = mapData[y][x];
                    if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                      continue;
                    }
                    outputArray.push(tile);
                  }
                }
              }
              tilemapLayer.tilesDrawn = outputArray.length;
              tilemapLayer.tilesTotal = mapWidth * mapHeight;
              return outputArray;
            };
            module2.exports = RunCull;
          },
          51710: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTileCollision = __webpack_require__2(68234);
            var CalculateFacesWithin = __webpack_require__2(60386);
            var SetLayerCollisionIndex = __webpack_require__2(91181);
            var SetCollision = function(indexes, collides, recalculateFaces, layer, updateLayer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              if (updateLayer === void 0) {
                updateLayer = true;
              }
              if (!Array.isArray(indexes)) {
                indexes = [indexes];
              }
              for (var i = 0; i < indexes.length; i++) {
                SetLayerCollisionIndex(indexes[i], collides, layer);
              }
              if (updateLayer) {
                for (var ty = 0; ty < layer.height; ty++) {
                  for (var tx = 0; tx < layer.width; tx++) {
                    var tile = layer.data[ty][tx];
                    if (tile && indexes.indexOf(tile.index) !== -1) {
                      SetTileCollision(tile, collides);
                    }
                  }
                }
              }
              if (recalculateFaces) {
                CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
              }
            };
            module2.exports = SetCollision;
          },
          15216: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTileCollision = __webpack_require__2(68234);
            var CalculateFacesWithin = __webpack_require__2(60386);
            var SetLayerCollisionIndex = __webpack_require__2(91181);
            var SetCollisionBetween = function(start, stop, collides, recalculateFaces, layer, updateLayer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              if (updateLayer === void 0) {
                updateLayer = true;
              }
              if (start > stop) {
                return;
              }
              for (var index = start; index <= stop; index++) {
                SetLayerCollisionIndex(index, collides, layer);
              }
              if (updateLayer) {
                for (var ty = 0; ty < layer.height; ty++) {
                  for (var tx = 0; tx < layer.width; tx++) {
                    var tile = layer.data[ty][tx];
                    if (tile) {
                      if (tile.index >= start && tile.index <= stop) {
                        SetTileCollision(tile, collides);
                      }
                    }
                  }
                }
              }
              if (recalculateFaces) {
                CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
              }
            };
            module2.exports = SetCollisionBetween;
          },
          33158: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTileCollision = __webpack_require__2(68234);
            var CalculateFacesWithin = __webpack_require__2(60386);
            var SetLayerCollisionIndex = __webpack_require__2(91181);
            var SetCollisionByExclusion = function(indexes, collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              if (!Array.isArray(indexes)) {
                indexes = [indexes];
              }
              for (var ty = 0; ty < layer.height; ty++) {
                for (var tx = 0; tx < layer.width; tx++) {
                  var tile = layer.data[ty][tx];
                  if (tile && indexes.indexOf(tile.index) === -1) {
                    SetTileCollision(tile, collides);
                    SetLayerCollisionIndex(tile.index, collides, layer);
                  }
                }
              }
              if (recalculateFaces) {
                CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
              }
            };
            module2.exports = SetCollisionByExclusion;
          },
          4180: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTileCollision = __webpack_require__2(68234);
            var CalculateFacesWithin = __webpack_require__2(60386);
            var HasValue = __webpack_require__2(19256);
            var SetCollisionByProperty = function(properties, collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              for (var ty = 0; ty < layer.height; ty++) {
                for (var tx = 0; tx < layer.width; tx++) {
                  var tile = layer.data[ty][tx];
                  if (!tile) {
                    continue;
                  }
                  for (var property in properties) {
                    if (!HasValue(tile.properties, property)) {
                      continue;
                    }
                    var values = properties[property];
                    if (!Array.isArray(values)) {
                      values = [values];
                    }
                    for (var i = 0; i < values.length; i++) {
                      if (tile.properties[property] === values[i]) {
                        SetTileCollision(tile, collides);
                      }
                    }
                  }
                }
              }
              if (recalculateFaces) {
                CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
              }
            };
            module2.exports = SetCollisionByProperty;
          },
          18625: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTileCollision = __webpack_require__2(68234);
            var CalculateFacesWithin = __webpack_require__2(60386);
            var SetCollisionFromCollisionGroup = function(collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              for (var ty = 0; ty < layer.height; ty++) {
                for (var tx = 0; tx < layer.width; tx++) {
                  var tile = layer.data[ty][tx];
                  if (!tile) {
                    continue;
                  }
                  var collisionGroup = tile.getCollisionGroup();
                  if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0) {
                    SetTileCollision(tile, collides);
                  }
                }
              }
              if (recalculateFaces) {
                CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
              }
            };
            module2.exports = SetCollisionFromCollisionGroup;
          },
          91181: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetLayerCollisionIndex = function(tileIndex, collides, layer) {
              var loc = layer.collideIndexes.indexOf(tileIndex);
              if (collides && loc === -1) {
                layer.collideIndexes.push(tileIndex);
              } else if (!collides && loc !== -1) {
                layer.collideIndexes.splice(loc, 1);
              }
            };
            module2.exports = SetLayerCollisionIndex;
          },
          68234: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTileCollision = function(tile, collides) {
              if (collides) {
                tile.setCollision(true, true, true, true, false);
              } else {
                tile.resetCollision(false);
              }
            };
            module2.exports = SetTileCollision;
          },
          11628: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetTileIndexCallback = function(indexes, callback, callbackContext, layer) {
              if (typeof indexes === "number") {
                layer.callbacks[indexes] = callback !== null ? {callback, callbackContext} : void 0;
              } else {
                for (var i = 0, len = indexes.length; i < len; i++) {
                  layer.callbacks[indexes[i]] = callback !== null ? {callback, callbackContext} : void 0;
                }
              }
            };
            module2.exports = SetTileIndexCallback;
          },
          72732: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var SetTileLocationCallback = function(tileX, tileY, width, height, callback, callbackContext, layer) {
              var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
              for (var i = 0; i < tiles.length; i++) {
                tiles[i].setCollisionCallback(callback, callbackContext);
              }
            };
            module2.exports = SetTileLocationCallback;
          },
          34397: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var ShuffleArray = __webpack_require__2(18592);
            var Shuffle = function(tileX, tileY, width, height, layer) {
              var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
              var indexes = tiles.map(function(tile) {
                return tile.index;
              });
              ShuffleArray(indexes);
              for (var i = 0; i < tiles.length; i++) {
                tiles[i].index = indexes[i];
              }
            };
            module2.exports = Shuffle;
          },
          53945: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SnapCeil = __webpack_require__2(82127);
            var SnapFloor = __webpack_require__2(84314);
            var StaggeredCullBounds = function(layer, camera) {
              var tilemap = layer.tilemapLayer.tilemap;
              var tilemapLayer = layer.tilemapLayer;
              var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
              var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
              var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
              var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
              var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;
              var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;
              return {
                left: boundsLeft,
                right: boundsRight,
                top: boundsTop,
                bottom: boundsBottom
              };
            };
            module2.exports = StaggeredCullBounds;
          },
          19242: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CullBounds = __webpack_require__2(53945);
            var RunCull = __webpack_require__2(6987);
            var StaggeredCullTiles = function(layer, camera, outputArray, renderOrder) {
              if (outputArray === void 0) {
                outputArray = [];
              }
              if (renderOrder === void 0) {
                renderOrder = 0;
              }
              outputArray.length = 0;
              var tilemapLayer = layer.tilemapLayer;
              var bounds = CullBounds(layer, camera);
              if (tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
                bounds.left = 0;
                bounds.right = layer.width;
                bounds.top = 0;
                bounds.bottom = layer.height;
              }
              RunCull(layer, bounds, renderOrder, outputArray);
              return outputArray;
            };
            module2.exports = StaggeredCullTiles;
          },
          33388: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var StaggeredTileToWorldXY = function(tileX, tileY, point, camera, layer) {
              if (!point) {
                point = new Vector2();
              }
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              var layerWorldX = 0;
              var layerWorldY = 0;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
                tileWidth *= tilemapLayer.scaleX;
                layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
                tileHeight *= tilemapLayer.scaleY;
              }
              var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
              var y = layerWorldY + tileY * (tileHeight / 2);
              return point.set(x, y);
            };
            module2.exports = StaggeredTileToWorldXY;
          },
          84132: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var StaggeredTileToWorldY = function(tileY, camera, layer) {
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              var layerWorldY = 0;
              if (tilemapLayer) {
                if (camera === void 0) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
                tileHeight *= tilemapLayer.scaleY;
              }
              return layerWorldY + tileY * (tileHeight / 2) + tileHeight;
            };
            module2.exports = StaggeredTileToWorldY;
          },
          90562: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var StaggeredWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
              if (!point) {
                point = new Vector2();
              }
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
                tileHeight *= tilemapLayer.scaleY;
                worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
                tileWidth *= tilemapLayer.scaleX;
              }
              var y = snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
              var x = snapToFloor ? Math.floor((worldX + y % 2 * 0.5 * tileWidth) / tileWidth) : (worldX + y % 2 * 0.5 * tileWidth) / tileWidth;
              return point.set(x, y);
            };
            module2.exports = StaggeredWorldToTileXY;
          },
          3689: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var StaggeredWorldToTileY = function(worldY, snapToFloor, camera, layer) {
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
                tileHeight *= tilemapLayer.scaleY;
              }
              return snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
            };
            module2.exports = StaggeredWorldToTileY;
          },
          55217: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var SwapByIndex = function(indexA, indexB, tileX, tileY, width, height, layer) {
              var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
              for (var i = 0; i < tiles.length; i++) {
                if (tiles[i]) {
                  if (tiles[i].index === indexA) {
                    tiles[i].index = indexB;
                  } else if (tiles[i].index === indexB) {
                    tiles[i].index = indexA;
                  }
                }
              }
            };
            module2.exports = SwapByIndex;
          },
          44150: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TileToWorldX = function(tileX, camera, layer) {
              var tileWidth = layer.baseTileWidth;
              var tilemapLayer = layer.tilemapLayer;
              var layerWorldX = 0;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
                tileWidth *= tilemapLayer.scaleX;
              }
              return layerWorldX + tileX * tileWidth;
            };
            module2.exports = TileToWorldX;
          },
          46836: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TileToWorldX = __webpack_require__2(44150);
            var TileToWorldY = __webpack_require__2(42477);
            var Vector2 = __webpack_require__2(93736);
            var TileToWorldXY = function(tileX, tileY, point, camera, layer) {
              if (!point) {
                point = new Vector2(0, 0);
              }
              point.x = TileToWorldX(tileX, camera, layer);
              point.y = TileToWorldY(tileY, camera, layer);
              return point;
            };
            module2.exports = TileToWorldXY;
          },
          42477: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TileToWorldY = function(tileY, camera, layer) {
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              var layerWorldY = 0;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
                tileHeight *= tilemapLayer.scaleY;
              }
              return layerWorldY + tileY * tileHeight;
            };
            module2.exports = TileToWorldY;
          },
          39677: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetTilesWithin = __webpack_require__2(50811);
            var WeightedRandomize = function(tileX, tileY, width, height, weightedIndexes, layer) {
              if (!weightedIndexes) {
                return;
              }
              var i;
              var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
              var weightTotal = 0;
              for (i = 0; i < weightedIndexes.length; i++) {
                weightTotal += weightedIndexes[i].weight;
              }
              if (weightTotal <= 0) {
                return;
              }
              for (i = 0; i < tiles.length; i++) {
                var rand = Math.random() * weightTotal;
                var sum = 0;
                var randomIndex = -1;
                for (var j = 0; j < weightedIndexes.length; j++) {
                  sum += weightedIndexes[j].weight;
                  if (rand <= sum) {
                    var chosen = weightedIndexes[j].index;
                    randomIndex = Array.isArray(chosen) ? chosen[Math.floor(Math.random() * chosen.length)] : chosen;
                    break;
                  }
                }
                tiles[i].index = randomIndex;
              }
            };
            module2.exports = WeightedRandomize;
          },
          806: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var WorldToTileXY = __webpack_require__2(45676);
            var Vector2 = __webpack_require__2(93736);
            var tempVec = new Vector2();
            var WorldToTileX = function(worldX, snapToFloor, camera, layer) {
              WorldToTileXY(worldX, 0, snapToFloor, tempVec, camera, layer);
              return tempVec.x;
            };
            module2.exports = WorldToTileX;
          },
          45676: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Vector2 = __webpack_require__2(93736);
            var WorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
              if (snapToFloor === void 0) {
                snapToFloor = true;
              }
              if (!point) {
                point = new Vector2();
              }
              var tileWidth = layer.baseTileWidth;
              var tileHeight = layer.baseTileHeight;
              var tilemapLayer = layer.tilemapLayer;
              if (tilemapLayer) {
                if (!camera) {
                  camera = tilemapLayer.scene.cameras.main;
                }
                worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
                worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
                tileWidth *= tilemapLayer.scaleX;
                tileHeight *= tilemapLayer.scaleY;
              }
              var x = worldX / tileWidth;
              var y = worldY / tileHeight;
              if (snapToFloor) {
                x = Math.floor(x);
                y = Math.floor(y);
              }
              return point.set(x, y);
            };
            module2.exports = WorldToTileXY;
          },
          70520: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var WorldToTileXY = __webpack_require__2(45676);
            var Vector2 = __webpack_require__2(93736);
            var tempVec = new Vector2();
            var WorldToTileY = function(worldY, snapToFloor, camera, layer) {
              WorldToTileXY(0, worldY, snapToFloor, tempVec, camera, layer);
              return tempVec.y;
            };
            module2.exports = WorldToTileY;
          },
          5047: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              CalculateFacesAt: __webpack_require__2(92839),
              CalculateFacesWithin: __webpack_require__2(60386),
              CheckIsoBounds: __webpack_require__2(13125),
              Copy: __webpack_require__2(17347),
              CreateFromTiles: __webpack_require__2(93604),
              CullBounds: __webpack_require__2(71586),
              CullTiles: __webpack_require__2(381),
              Fill: __webpack_require__2(97734),
              FilterTiles: __webpack_require__2(63555),
              FindByIndex: __webpack_require__2(37982),
              FindTile: __webpack_require__2(48297),
              ForEachTile: __webpack_require__2(80916),
              GetCullTilesFunction: __webpack_require__2(31493),
              GetTileAt: __webpack_require__2(15494),
              GetTileAtWorldXY: __webpack_require__2(24640),
              GetTileCorners: __webpack_require__2(48495),
              GetTileCornersFunction: __webpack_require__2(7160),
              GetTilesWithin: __webpack_require__2(50811),
              GetTilesWithinShape: __webpack_require__2(31674),
              GetTilesWithinWorldXY: __webpack_require__2(44662),
              GetTileToWorldXFunction: __webpack_require__2(16884),
              GetTileToWorldXYFunction: __webpack_require__2(68182),
              GetTileToWorldYFunction: __webpack_require__2(3752),
              GetWorldToTileXFunction: __webpack_require__2(29296),
              GetWorldToTileXYFunction: __webpack_require__2(32688),
              GetWorldToTileYFunction: __webpack_require__2(74326),
              HasTileAt: __webpack_require__2(46598),
              HasTileAtWorldXY: __webpack_require__2(28654),
              HexagonalCullBounds: __webpack_require__2(6358),
              HexagonalCullTiles: __webpack_require__2(37524),
              HexagonalGetTileCorners: __webpack_require__2(63634),
              HexagonalTileToWorldXY: __webpack_require__2(21715),
              HexagonalWorldToTileXY: __webpack_require__2(11516),
              IsInLayerBounds: __webpack_require__2(62839),
              IsometricCullTiles: __webpack_require__2(20887),
              IsometricTileToWorldXY: __webpack_require__2(21808),
              IsometricWorldToTileXY: __webpack_require__2(18750),
              PutTileAt: __webpack_require__2(29003),
              PutTileAtWorldXY: __webpack_require__2(48565),
              PutTilesAt: __webpack_require__2(56547),
              Randomize: __webpack_require__2(91180),
              RemoveTileAt: __webpack_require__2(929),
              RemoveTileAtWorldXY: __webpack_require__2(17384),
              RenderDebug: __webpack_require__2(93763),
              ReplaceByIndex: __webpack_require__2(51202),
              RunCull: __webpack_require__2(6987),
              SetCollision: __webpack_require__2(51710),
              SetCollisionBetween: __webpack_require__2(15216),
              SetCollisionByExclusion: __webpack_require__2(33158),
              SetCollisionByProperty: __webpack_require__2(4180),
              SetCollisionFromCollisionGroup: __webpack_require__2(18625),
              SetLayerCollisionIndex: __webpack_require__2(91181),
              SetTileCollision: __webpack_require__2(68234),
              SetTileIndexCallback: __webpack_require__2(11628),
              SetTileLocationCallback: __webpack_require__2(72732),
              Shuffle: __webpack_require__2(34397),
              StaggeredCullBounds: __webpack_require__2(53945),
              StaggeredCullTiles: __webpack_require__2(19242),
              StaggeredTileToWorldXY: __webpack_require__2(33388),
              StaggeredTileToWorldY: __webpack_require__2(84132),
              StaggeredWorldToTileXY: __webpack_require__2(90562),
              StaggeredWorldToTileY: __webpack_require__2(3689),
              SwapByIndex: __webpack_require__2(55217),
              TileToWorldX: __webpack_require__2(44150),
              TileToWorldXY: __webpack_require__2(46836),
              TileToWorldY: __webpack_require__2(42477),
              WeightedRandomize: __webpack_require__2(39677),
              WorldToTileX: __webpack_require__2(806),
              WorldToTileXY: __webpack_require__2(45676),
              WorldToTileY: __webpack_require__2(70520)
            };
          },
          12920: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ORTHOGONAL: 0,
              ISOMETRIC: 1,
              STAGGERED: 2,
              HEXAGONAL: 3
            };
          },
          84758: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = {
              ORIENTATION: __webpack_require__2(12920)
            };
            module2.exports = CONST;
          },
          52678: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Extend = __webpack_require__2(98611);
            var CONST = __webpack_require__2(84758);
            var Tilemaps = {
              Components: __webpack_require__2(5047),
              Parsers: __webpack_require__2(34124),
              Formats: __webpack_require__2(93560),
              ImageCollection: __webpack_require__2(97042),
              ParseToTilemap: __webpack_require__2(15043),
              Tile: __webpack_require__2(29633),
              Tilemap: __webpack_require__2(89797),
              TilemapCreator: __webpack_require__2(4843),
              TilemapFactory: __webpack_require__2(37940),
              Tileset: __webpack_require__2(47975),
              TilemapLayer: __webpack_require__2(87177),
              Orientation: __webpack_require__2(12920),
              LayerData: __webpack_require__2(94990),
              MapData: __webpack_require__2(16586),
              ObjectLayer: __webpack_require__2(15256)
            };
            Tilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);
            module2.exports = Tilemaps;
          },
          94990: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12920);
            var GetFastValue = __webpack_require__2(72632);
            var LayerData = new Class({
              initialize: function LayerData2(config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                this.name = GetFastValue(config2, "name", "layer");
                this.id = GetFastValue(config2, "id", 0);
                this.x = GetFastValue(config2, "x", 0);
                this.y = GetFastValue(config2, "y", 0);
                this.width = GetFastValue(config2, "width", 0);
                this.height = GetFastValue(config2, "height", 0);
                this.tileWidth = GetFastValue(config2, "tileWidth", 0);
                this.tileHeight = GetFastValue(config2, "tileHeight", 0);
                this.baseTileWidth = GetFastValue(config2, "baseTileWidth", this.tileWidth);
                this.baseTileHeight = GetFastValue(config2, "baseTileHeight", this.tileHeight);
                this.orientation = GetFastValue(config2, "orientation", CONST.ORTHOGONAL);
                this.widthInPixels = GetFastValue(config2, "widthInPixels", this.width * this.baseTileWidth);
                this.heightInPixels = GetFastValue(config2, "heightInPixels", this.height * this.baseTileHeight);
                this.alpha = GetFastValue(config2, "alpha", 1);
                this.visible = GetFastValue(config2, "visible", true);
                this.properties = GetFastValue(config2, "properties", []);
                this.indexes = GetFastValue(config2, "indexes", []);
                this.collideIndexes = GetFastValue(config2, "collideIndexes", []);
                this.callbacks = GetFastValue(config2, "callbacks", []);
                this.bodies = GetFastValue(config2, "bodies", []);
                this.data = GetFastValue(config2, "data", []);
                this.tilemapLayer = GetFastValue(config2, "tilemapLayer", null);
                this.hexSideLength = GetFastValue(config2, "hexSideLength", 0);
                this.staggerAxis = GetFastValue(config2, "staggerAxis", "y");
                this.staggerIndex = GetFastValue(config2, "staggerIndex", "odd");
              }
            });
            module2.exports = LayerData;
          },
          16586: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var CONST = __webpack_require__2(12920);
            var GetFastValue = __webpack_require__2(72632);
            var MapData = new Class({
              initialize: function MapData2(config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                this.name = GetFastValue(config2, "name", "map");
                this.width = GetFastValue(config2, "width", 0);
                this.height = GetFastValue(config2, "height", 0);
                this.infinite = GetFastValue(config2, "infinite", false);
                this.tileWidth = GetFastValue(config2, "tileWidth", 0);
                this.tileHeight = GetFastValue(config2, "tileHeight", 0);
                this.widthInPixels = GetFastValue(config2, "widthInPixels", this.width * this.tileWidth);
                this.heightInPixels = GetFastValue(config2, "heightInPixels", this.height * this.tileHeight);
                this.format = GetFastValue(config2, "format", null);
                this.orientation = GetFastValue(config2, "orientation", CONST.ORTHOGONAL);
                this.renderOrder = GetFastValue(config2, "renderOrder", "right-down");
                this.version = GetFastValue(config2, "version", "1");
                this.properties = GetFastValue(config2, "properties", {});
                this.layers = GetFastValue(config2, "layers", []);
                this.images = GetFastValue(config2, "images", []);
                this.objects = GetFastValue(config2, "objects", []);
                if (!Array.isArray(this.objects)) {
                  this.objects = [];
                }
                this.collision = GetFastValue(config2, "collision", {});
                this.tilesets = GetFastValue(config2, "tilesets", []);
                this.imageCollections = GetFastValue(config2, "imageCollections", []);
                this.tiles = GetFastValue(config2, "tiles", []);
                this.hexSideLength = GetFastValue(config2, "hexSideLength", 0);
                this.staggerAxis = GetFastValue(config2, "staggerAxis", "y");
                this.staggerIndex = GetFastValue(config2, "staggerIndex", "odd");
              }
            });
            module2.exports = MapData;
          },
          15256: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var ObjectLayer = new Class({
              initialize: function ObjectLayer2(config2) {
                if (config2 === void 0) {
                  config2 = {};
                }
                this.name = GetFastValue(config2, "name", "object layer");
                this.id = GetFastValue(config2, "id", 0);
                this.opacity = GetFastValue(config2, "opacity", 1);
                this.properties = GetFastValue(config2, "properties", {});
                this.propertyTypes = GetFastValue(config2, "propertytypes", {});
                this.type = GetFastValue(config2, "type", "objectgroup");
                this.visible = GetFastValue(config2, "visible", true);
                this.objects = GetFastValue(config2, "objects", []);
                if (!Array.isArray(this.objects)) {
                  this.objects = [];
                }
              }
            });
            module2.exports = ObjectLayer;
          },
          21394: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CONST = __webpack_require__2(12920);
            var FromOrientationString = function(orientation) {
              orientation = orientation.toLowerCase();
              if (orientation === "isometric") {
                return CONST.ISOMETRIC;
              } else if (orientation === "staggered") {
                return CONST.STAGGERED;
              } else if (orientation === "hexagonal") {
                return CONST.HEXAGONAL;
              } else {
                return CONST.ORTHOGONAL;
              }
            };
            module2.exports = FromOrientationString;
          },
          90715: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Formats = __webpack_require__2(93560);
            var Parse2DArray = __webpack_require__2(84346);
            var ParseCSV = __webpack_require__2(96097);
            var ParseJSONTiled = __webpack_require__2(2378);
            var ParseWeltmeister = __webpack_require__2(44909);
            var Parse = function(name, mapFormat, data, tileWidth, tileHeight, insertNull) {
              var newMap;
              switch (mapFormat) {
                case Formats.ARRAY_2D:
                  newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);
                  break;
                case Formats.CSV:
                  newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);
                  break;
                case Formats.TILED_JSON:
                  newMap = ParseJSONTiled(name, data, insertNull);
                  break;
                case Formats.WELTMEISTER:
                  newMap = ParseWeltmeister(name, data, insertNull);
                  break;
                default:
                  console.warn("Unrecognized tilemap data format: " + mapFormat);
                  newMap = null;
              }
              return newMap;
            };
            module2.exports = Parse;
          },
          84346: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Formats = __webpack_require__2(93560);
            var LayerData = __webpack_require__2(94990);
            var MapData = __webpack_require__2(16586);
            var Tile = __webpack_require__2(29633);
            var Parse2DArray = function(name, data, tileWidth, tileHeight, insertNull) {
              var layerData = new LayerData({
                tileWidth,
                tileHeight
              });
              var mapData = new MapData({
                name,
                tileWidth,
                tileHeight,
                format: Formats.ARRAY_2D,
                layers: [layerData]
              });
              var tiles = [];
              var height = data.length;
              var width = 0;
              for (var y = 0; y < data.length; y++) {
                tiles[y] = [];
                var row = data[y];
                for (var x = 0; x < row.length; x++) {
                  var tileIndex = parseInt(row[x], 10);
                  if (isNaN(tileIndex) || tileIndex === -1) {
                    tiles[y][x] = insertNull ? null : new Tile(layerData, -1, x, y, tileWidth, tileHeight);
                  } else {
                    tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);
                  }
                }
                if (width === 0) {
                  width = row.length;
                }
              }
              mapData.width = layerData.width = width;
              mapData.height = layerData.height = height;
              mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;
              mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;
              layerData.data = tiles;
              return mapData;
            };
            module2.exports = Parse2DArray;
          },
          96097: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Formats = __webpack_require__2(93560);
            var Parse2DArray = __webpack_require__2(84346);
            var ParseCSV = function(name, data, tileWidth, tileHeight, insertNull) {
              var array2D = data.trim().split("\n").map(function(row) {
                return row.split(",");
              });
              var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);
              map.format = Formats.CSV;
              return map;
            };
            module2.exports = ParseCSV;
          },
          30951: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var LayerData = __webpack_require__2(94990);
            var Tile = __webpack_require__2(29633);
            var ParseTileLayers = function(json, insertNull) {
              var tileLayers = [];
              for (var i = 0; i < json.layer.length; i++) {
                var layer = json.layer[i];
                var layerData = new LayerData({
                  name: layer.name,
                  width: layer.width,
                  height: layer.height,
                  tileWidth: layer.tilesize,
                  tileHeight: layer.tilesize,
                  visible: layer.visible === 1
                });
                var row = [];
                var tileGrid = [];
                for (var y = 0; y < layer.data.length; y++) {
                  for (var x = 0; x < layer.data[y].length; x++) {
                    var index = layer.data[y][x] - 1;
                    var tile;
                    if (index > -1) {
                      tile = new Tile(layerData, index, x, y, layer.tilesize, layer.tilesize);
                    } else {
                      tile = insertNull ? null : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);
                    }
                    row.push(tile);
                  }
                  tileGrid.push(row);
                  row = [];
                }
                layerData.data = tileGrid;
                tileLayers.push(layerData);
              }
              return tileLayers;
            };
            module2.exports = ParseTileLayers;
          },
          47488: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Tileset = __webpack_require__2(47975);
            var ParseTilesets = function(json) {
              var tilesets = [];
              var tilesetsNames = [];
              for (var i = 0; i < json.layer.length; i++) {
                var layer = json.layer[i];
                var tilesetName = layer.tilesetName;
                if (tilesetName !== "" && tilesetsNames.indexOf(tilesetName) === -1) {
                  tilesetsNames.push(tilesetName);
                  tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));
                }
              }
              return tilesets;
            };
            module2.exports = ParseTilesets;
          },
          44909: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Formats = __webpack_require__2(93560);
            var MapData = __webpack_require__2(16586);
            var ParseTileLayers = __webpack_require__2(30951);
            var ParseTilesets = __webpack_require__2(47488);
            var ParseWeltmeister = function(name, json, insertNull) {
              if (json.layer.length === 0) {
                console.warn("No layers found in the Weltmeister map: " + name);
                return null;
              }
              var width = 0;
              var height = 0;
              for (var i = 0; i < json.layer.length; i++) {
                if (json.layer[i].width > width) {
                  width = json.layer[i].width;
                }
                if (json.layer[i].height > height) {
                  height = json.layer[i].height;
                }
              }
              var mapData = new MapData({
                width,
                height,
                name,
                tileWidth: json.layer[0].tilesize,
                tileHeight: json.layer[0].tilesize,
                format: Formats.WELTMEISTER
              });
              mapData.layers = ParseTileLayers(json, insertNull);
              mapData.tilesets = ParseTilesets(json);
              return mapData;
            };
            module2.exports = ParseWeltmeister;
          },
          24507: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ParseTileLayers: __webpack_require__2(30951),
              ParseTilesets: __webpack_require__2(47488),
              ParseWeltmeister: __webpack_require__2(44909)
            };
          },
          34124: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              FromOrientationString: __webpack_require__2(21394),
              Parse: __webpack_require__2(90715),
              Parse2DArray: __webpack_require__2(84346),
              ParseCSV: __webpack_require__2(96097),
              Impact: __webpack_require__2(24507),
              Tiled: __webpack_require__2(50044)
            };
          },
          48646: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Extend = __webpack_require__2(98611);
            var AssignTileProperties = function(mapData) {
              var layerData;
              var tile;
              var sid;
              var set;
              var row;
              for (var i = 0; i < mapData.layers.length; i++) {
                layerData = mapData.layers[i];
                set = null;
                for (var j = 0; j < layerData.data.length; j++) {
                  row = layerData.data[j];
                  for (var k = 0; k < row.length; k++) {
                    tile = row[k];
                    if (tile === null || tile.index < 0) {
                      continue;
                    }
                    sid = mapData.tiles[tile.index][2];
                    set = mapData.tilesets[sid];
                    tile.width = set.tileWidth;
                    tile.height = set.tileHeight;
                    if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) {
                      tile.properties = Extend(tile.properties, set.tileProperties[tile.index - set.firstgid]);
                    }
                  }
                }
              }
            };
            module2.exports = AssignTileProperties;
          },
          43908: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Base64Decode = function(data) {
              var binaryString = window.atob(data);
              var len = binaryString.length;
              var bytes = new Array(len / 4);
              for (var i = 0; i < len; i += 4) {
                bytes[i / 4] = (binaryString.charCodeAt(i) | binaryString.charCodeAt(i + 1) << 8 | binaryString.charCodeAt(i + 2) << 16 | binaryString.charCodeAt(i + 3) << 24) >>> 0;
              }
              return bytes;
            };
            module2.exports = Base64Decode;
          },
          14556: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Tileset = __webpack_require__2(47975);
            var BuildTilesetIndex = function(mapData) {
              var i;
              var set;
              var tiles = [];
              for (i = 0; i < mapData.imageCollections.length; i++) {
                var collection = mapData.imageCollections[i];
                var images = collection.images;
                for (var j = 0; j < images.length; j++) {
                  var image = images[j];
                  set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0);
                  set.updateTileData(collection.imageWidth, collection.imageHeight);
                  mapData.tilesets.push(set);
                }
              }
              for (i = 0; i < mapData.tilesets.length; i++) {
                set = mapData.tilesets[i];
                var x = set.tileMargin;
                var y = set.tileMargin;
                var count = 0;
                var countX = 0;
                var countY = 0;
                for (var t = set.firstgid; t < set.firstgid + set.total; t++) {
                  tiles[t] = [x, y, i];
                  x += set.tileWidth + set.tileSpacing;
                  count++;
                  if (count === set.total) {
                    break;
                  }
                  countX++;
                  if (countX === set.columns) {
                    x = set.tileMargin;
                    y += set.tileHeight + set.tileSpacing;
                    countX = 0;
                    countY++;
                    if (countY === set.rows) {
                      break;
                    }
                  }
                }
              }
              return tiles;
            };
            module2.exports = BuildTilesetIndex;
          },
          92044: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Seth Berrier <berriers@uwstout.edu>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var CreateGroupLayer = function(json, group, parentState) {
              if (!group) {
                return {
                  i: 0,
                  layers: json.layers,
                  name: "",
                  opacity: 1,
                  visible: true,
                  x: 0,
                  y: 0
                };
              }
              var layerX = group.x + GetFastValue(group, "startx", 0) * json.tilewidth + GetFastValue(group, "offsetx", 0);
              var layerY = group.y + GetFastValue(group, "starty", 0) * json.tileheight + GetFastValue(group, "offsety", 0);
              return {
                i: 0,
                layers: group.layers,
                name: parentState.name + group.name + "/",
                opacity: parentState.opacity * group.opacity,
                visible: parentState.visible && group.visible,
                x: parentState.x + layerX,
                y: parentState.y + layerY
              };
            };
            module2.exports = CreateGroupLayer;
          },
          8847: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FLIPPED_HORIZONTAL = 2147483648;
            var FLIPPED_VERTICAL = 1073741824;
            var FLIPPED_ANTI_DIAGONAL = 536870912;
            var ParseGID = function(gid) {
              var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);
              var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);
              var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);
              gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);
              var rotation = 0;
              var flipped = false;
              if (flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
                rotation = Math.PI / 2;
                flipped = true;
              } else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
                rotation = Math.PI;
                flipped = false;
              } else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
                rotation = Math.PI / 2;
                flipped = false;
              } else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
                rotation = 0;
                flipped = true;
              } else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
                rotation = 3 * Math.PI / 2;
                flipped = false;
              } else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
                rotation = Math.PI;
                flipped = true;
              } else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
                rotation = 3 * Math.PI / 2;
                flipped = true;
              } else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
                rotation = 0;
                flipped = false;
              }
              return {
                gid,
                flippedHorizontal,
                flippedVertical,
                flippedAntiDiagonal,
                rotation,
                flipped
              };
            };
            module2.exports = ParseGID;
          },
          78339: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var CreateGroupLayer = __webpack_require__2(92044);
            var ParseImageLayers = function(json) {
              var images = [];
              var groupStack = [];
              var curGroupState = CreateGroupLayer(json);
              while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
                if (curGroupState.i >= curGroupState.layers.length) {
                  if (groupStack.length < 1) {
                    console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                    break;
                  }
                  curGroupState = groupStack.pop();
                  continue;
                }
                var curi = curGroupState.layers[curGroupState.i];
                curGroupState.i++;
                if (curi.type !== "imagelayer") {
                  if (curi.type === "group") {
                    var nextGroupState = CreateGroupLayer(json, curi, curGroupState);
                    groupStack.push(curGroupState);
                    curGroupState = nextGroupState;
                  }
                  continue;
                }
                var layerOffsetX = GetFastValue(curi, "offsetx", 0) + GetFastValue(curi, "startx", 0);
                var layerOffsetY = GetFastValue(curi, "offsety", 0) + GetFastValue(curi, "starty", 0);
                images.push({
                  name: curGroupState.name + curi.name,
                  image: curi.image,
                  x: curGroupState.x + layerOffsetX + curi.x,
                  y: curGroupState.y + layerOffsetY + curi.y,
                  alpha: curGroupState.opacity * curi.opacity,
                  visible: curGroupState.visible && curi.visible,
                  properties: GetFastValue(curi, "properties", {})
                });
              }
              return images;
            };
            module2.exports = ParseImageLayers;
          },
          2378: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AssignTileProperties = __webpack_require__2(48646);
            var BuildTilesetIndex = __webpack_require__2(14556);
            var CONST = __webpack_require__2(12920);
            var DeepCopy = __webpack_require__2(28699);
            var Formats = __webpack_require__2(93560);
            var FromOrientationString = __webpack_require__2(21394);
            var MapData = __webpack_require__2(16586);
            var ParseImageLayers = __webpack_require__2(78339);
            var ParseObjectLayers = __webpack_require__2(61136);
            var ParseTileLayers = __webpack_require__2(95925);
            var ParseTilesets = __webpack_require__2(93392);
            var ParseJSONTiled = function(name, source, insertNull) {
              var json = DeepCopy(source);
              var mapData = new MapData({
                width: json.width,
                height: json.height,
                name,
                tileWidth: json.tilewidth,
                tileHeight: json.tileheight,
                orientation: FromOrientationString(json.orientation),
                format: Formats.TILED_JSON,
                version: json.version,
                properties: json.properties,
                renderOrder: json.renderorder,
                infinite: json.infinite
              });
              if (mapData.orientation === CONST.HEXAGONAL) {
                mapData.hexSideLength = json.hexsidelength;
                mapData.staggerAxis = json.staggeraxis;
                mapData.staggerIndex = json.staggerindex;
              }
              mapData.layers = ParseTileLayers(json, insertNull);
              mapData.images = ParseImageLayers(json);
              var sets = ParseTilesets(json);
              mapData.tilesets = sets.tilesets;
              mapData.imageCollections = sets.imageCollections;
              mapData.objects = ParseObjectLayers(json);
              mapData.tiles = BuildTilesetIndex(mapData);
              AssignTileProperties(mapData);
              return mapData;
            };
            module2.exports = ParseJSONTiled;
          },
          4281: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Pick = __webpack_require__2(28820);
            var ParseGID = __webpack_require__2(8847);
            var copyPoints = function(p) {
              return {x: p.x, y: p.y};
            };
            var commonObjectProps = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"];
            var ParseObject = function(tiledObject, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              var parsedObject = Pick(tiledObject, commonObjectProps);
              parsedObject.x += offsetX;
              parsedObject.y += offsetY;
              if (tiledObject.gid) {
                var gidInfo = ParseGID(tiledObject.gid);
                parsedObject.gid = gidInfo.gid;
                parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;
                parsedObject.flippedVertical = gidInfo.flippedVertical;
                parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;
              } else if (tiledObject.polyline) {
                parsedObject.polyline = tiledObject.polyline.map(copyPoints);
              } else if (tiledObject.polygon) {
                parsedObject.polygon = tiledObject.polygon.map(copyPoints);
              } else if (tiledObject.ellipse) {
                parsedObject.ellipse = tiledObject.ellipse;
              } else if (tiledObject.text) {
                parsedObject.text = tiledObject.text;
              } else if (tiledObject.point) {
                parsedObject.point = true;
              } else {
                parsedObject.rectangle = true;
              }
              return parsedObject;
            };
            module2.exports = ParseObject;
          },
          61136: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = __webpack_require__2(72632);
            var ParseObject = __webpack_require__2(4281);
            var ObjectLayer = __webpack_require__2(15256);
            var CreateGroupLayer = __webpack_require__2(92044);
            var ParseObjectLayers = function(json) {
              var objectLayers = [];
              var groupStack = [];
              var curGroupState = CreateGroupLayer(json);
              while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
                if (curGroupState.i >= curGroupState.layers.length) {
                  if (groupStack.length < 1) {
                    console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                    break;
                  }
                  curGroupState = groupStack.pop();
                  continue;
                }
                var curo = curGroupState.layers[curGroupState.i];
                curGroupState.i++;
                curo.opacity *= curGroupState.opacity;
                curo.visible = curGroupState.visible && curo.visible;
                if (curo.type !== "objectgroup") {
                  if (curo.type === "group") {
                    var nextGroupState = CreateGroupLayer(json, curo, curGroupState);
                    groupStack.push(curGroupState);
                    curGroupState = nextGroupState;
                  }
                  continue;
                }
                curo.name = curGroupState.name + curo.name;
                var offsetX = curGroupState.x + GetFastValue(curo, "startx", 0) + GetFastValue(curo, "offsetx", 0);
                var offsetY = curGroupState.y + GetFastValue(curo, "starty", 0) + GetFastValue(curo, "offsety", 0);
                var objects = [];
                for (var j = 0; j < curo.objects.length; j++) {
                  var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);
                  objects.push(parsedObject);
                }
                var objectLayer = new ObjectLayer(curo);
                objectLayer.objects = objects;
                objectLayers.push(objectLayer);
              }
              return objectLayers;
            };
            module2.exports = ParseObjectLayers;
          },
          95925: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Base64Decode = __webpack_require__2(43908);
            var CONST = __webpack_require__2(12920);
            var CreateGroupLayer = __webpack_require__2(92044);
            var FromOrientationString = __webpack_require__2(21394);
            var GetFastValue = __webpack_require__2(72632);
            var LayerData = __webpack_require__2(94990);
            var ParseGID = __webpack_require__2(8847);
            var Tile = __webpack_require__2(29633);
            var ParseTileLayers = function(json, insertNull) {
              var infiniteMap = GetFastValue(json, "infinite", false);
              var tileLayers = [];
              var groupStack = [];
              var curGroupState = CreateGroupLayer(json);
              while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
                if (curGroupState.i >= curGroupState.layers.length) {
                  if (groupStack.length < 1) {
                    console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                    break;
                  }
                  curGroupState = groupStack.pop();
                  continue;
                }
                var curl = curGroupState.layers[curGroupState.i];
                curGroupState.i++;
                if (curl.type !== "tilelayer") {
                  if (curl.type === "group") {
                    var nextGroupState = CreateGroupLayer(json, curl, curGroupState);
                    groupStack.push(curGroupState);
                    curGroupState = nextGroupState;
                  }
                  continue;
                }
                if (curl.compression) {
                  console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + curl.name + "'");
                  continue;
                } else if (curl.encoding && curl.encoding === "base64") {
                  if (curl.chunks) {
                    for (var i = 0; i < curl.chunks.length; i++) {
                      curl.chunks[i].data = Base64Decode(curl.chunks[i].data);
                    }
                  }
                  if (curl.data) {
                    curl.data = Base64Decode(curl.data);
                  }
                  delete curl.encoding;
                }
                var layerData;
                var gidInfo;
                var tile;
                var blankTile;
                var output = [];
                var x = 0;
                if (infiniteMap) {
                  var layerOffsetX = GetFastValue(curl, "startx", 0) + curl.x;
                  var layerOffsetY = GetFastValue(curl, "starty", 0) + curl.y;
                  layerData = new LayerData({
                    name: curGroupState.name + curl.name,
                    id: curl.id,
                    x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + layerOffsetX * json.tilewidth,
                    y: curGroupState.y + GetFastValue(curl, "offsety", 0) + layerOffsetY * json.tileheight,
                    width: curl.width,
                    height: curl.height,
                    tileWidth: json.tilewidth,
                    tileHeight: json.tileheight,
                    alpha: curGroupState.opacity * curl.opacity,
                    visible: curGroupState.visible && curl.visible,
                    properties: GetFastValue(curl, "properties", []),
                    orientation: FromOrientationString(json.orientation)
                  });
                  if (layerData.orientation === CONST.HEXAGONAL) {
                    layerData.hexSideLength = json.hexsidelength;
                    layerData.staggerAxis = json.staggeraxis;
                    layerData.staggerIndex = json.staggerindex;
                  }
                  for (var c = 0; c < curl.height; c++) {
                    output[c] = [null];
                    for (var j = 0; j < curl.width; j++) {
                      output[c][j] = null;
                    }
                  }
                  for (c = 0, len = curl.chunks.length; c < len; c++) {
                    var chunk = curl.chunks[c];
                    var offsetX = chunk.x - layerOffsetX;
                    var offsetY = chunk.y - layerOffsetY;
                    var y = 0;
                    for (var t = 0, len2 = chunk.data.length; t < len2; t++) {
                      var newOffsetX = x + offsetX;
                      var newOffsetY = y + offsetY;
                      gidInfo = ParseGID(chunk.data[t]);
                      if (gidInfo.gid > 0) {
                        tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
                        tile.rotation = gidInfo.rotation;
                        tile.flipX = gidInfo.flipped;
                        output[newOffsetY][newOffsetX] = tile;
                      } else {
                        blankTile = insertNull ? null : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
                        output[newOffsetY][newOffsetX] = blankTile;
                      }
                      x++;
                      if (x === chunk.width) {
                        y++;
                        x = 0;
                      }
                    }
                  }
                } else {
                  layerData = new LayerData({
                    name: curGroupState.name + curl.name,
                    id: curl.id,
                    x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + curl.x,
                    y: curGroupState.y + GetFastValue(curl, "offsety", 0) + curl.y,
                    width: curl.width,
                    height: curl.height,
                    tileWidth: json.tilewidth,
                    tileHeight: json.tileheight,
                    alpha: curGroupState.opacity * curl.opacity,
                    visible: curGroupState.visible && curl.visible,
                    properties: GetFastValue(curl, "properties", []),
                    orientation: FromOrientationString(json.orientation)
                  });
                  if (layerData.orientation === CONST.HEXAGONAL) {
                    layerData.hexSideLength = json.hexsidelength;
                    layerData.staggerAxis = json.staggeraxis;
                    layerData.staggerIndex = json.staggerindex;
                  }
                  var row = [];
                  for (var k = 0, len = curl.data.length; k < len; k++) {
                    gidInfo = ParseGID(curl.data[k]);
                    if (gidInfo.gid > 0) {
                      tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight);
                      tile.rotation = gidInfo.rotation;
                      tile.flipX = gidInfo.flipped;
                      row.push(tile);
                    } else {
                      blankTile = insertNull ? null : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);
                      row.push(blankTile);
                    }
                    x++;
                    if (x === curl.width) {
                      output.push(row);
                      x = 0;
                      row = [];
                    }
                  }
                }
                layerData.data = output;
                tileLayers.push(layerData);
              }
              return tileLayers;
            };
            module2.exports = ParseTileLayers;
          },
          93392: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Tileset = __webpack_require__2(47975);
            var ImageCollection = __webpack_require__2(97042);
            var ParseObject = __webpack_require__2(4281);
            var ParseWangsets = __webpack_require__2(39642);
            var ParseTilesets = function(json) {
              var tilesets = [];
              var imageCollections = [];
              var lastSet = null;
              var stringID;
              for (var i = 0; i < json.tilesets.length; i++) {
                var set = json.tilesets[i];
                if (set.source) {
                  console.warn("External tilesets unsupported. Use Embed Tileset and re-export");
                } else if (set.image) {
                  var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, void 0, void 0, set.tileoffset);
                  if (json.version > 1) {
                    var datas = void 0;
                    var props = void 0;
                    if (Array.isArray(set.tiles)) {
                      datas = datas || {};
                      props = props || {};
                      for (var t = 0; t < set.tiles.length; t++) {
                        var tile = set.tiles[t];
                        if (tile.properties) {
                          var newPropData = {};
                          tile.properties.forEach(function(propData) {
                            newPropData[propData["name"]] = propData["value"];
                          });
                          props[tile.id] = newPropData;
                        }
                        if (tile.objectgroup) {
                          (datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup;
                          if (tile.objectgroup.objects) {
                            var parsedObjects2 = tile.objectgroup.objects.map(function(obj) {
                              return ParseObject(obj);
                            });
                            datas[tile.id].objectgroup.objects = parsedObjects2;
                          }
                        }
                        if (tile.animation) {
                          (datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation;
                        }
                        if (tile.type) {
                          (datas[tile.id] || (datas[tile.id] = {})).type = tile.type;
                        }
                      }
                    }
                    if (Array.isArray(set.wangsets)) {
                      datas = datas || {};
                      props = props || {};
                      ParseWangsets(set.wangsets, datas);
                    }
                    if (datas) {
                      newSet.tileData = datas;
                      newSet.tileProperties = props;
                    }
                  } else {
                    if (set.tileproperties) {
                      newSet.tileProperties = set.tileproperties;
                    }
                    if (set.tiles) {
                      newSet.tileData = set.tiles;
                      for (stringID in newSet.tileData) {
                        var objectGroup = newSet.tileData[stringID].objectgroup;
                        if (objectGroup && objectGroup.objects) {
                          var parsedObjects1 = objectGroup.objects.map(function(obj) {
                            return ParseObject(obj);
                          });
                          newSet.tileData[stringID].objectgroup.objects = parsedObjects1;
                        }
                      }
                    }
                  }
                  newSet.updateTileData(set.imagewidth, set.imageheight);
                  tilesets.push(newSet);
                } else {
                  var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
                  var maxId = 0;
                  for (t = 0; t < set.tiles.length; t++) {
                    tile = set.tiles[t];
                    var image = tile.image;
                    var tileId = parseInt(tile.id, 10);
                    var gid = set.firstgid + tileId;
                    newCollection.addImage(gid, image);
                    maxId = Math.max(tileId, maxId);
                  }
                  newCollection.maxId = maxId;
                  imageCollections.push(newCollection);
                }
                if (lastSet) {
                  lastSet.lastgid = set.firstgid - 1;
                }
                lastSet = set;
              }
              return {tilesets, imageCollections};
            };
            module2.exports = ParseTilesets;
          },
          39642: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ParseWangsets = function(wangsets, datas) {
              for (var w = 0; w < wangsets.length; w++) {
                var wangset = wangsets[w];
                var identifier = w;
                if (wangset.name && wangset.name !== "") {
                  identifier = wangset.name;
                }
                if (Array.isArray(wangset.wangtiles) && wangset.wangtiles.length > 0) {
                  var edgeColors = {};
                  var cornerColors = {};
                  var c;
                  var color;
                  var colorIndex;
                  if (Array.isArray(wangset.edgecolors)) {
                    for (c = 0; c < wangset.edgecolors.length; c++) {
                      colorIndex = 1 + c;
                      color = wangset.edgecolors[c];
                      if (color.name !== "") {
                        edgeColors[colorIndex] = color.name;
                      }
                    }
                  }
                  if (Array.isArray(wangset.cornercolors)) {
                    for (c = 0; c < wangset.cornercolors.length; c++) {
                      colorIndex = 1 + c;
                      color = wangset.cornercolors[c];
                      if (color.name !== "") {
                        cornerColors[colorIndex] = color.name;
                      }
                    }
                  }
                  if (Array.isArray(wangset.colors)) {
                    for (c = 0; c < wangset.colors.length; c++) {
                      color = wangset.colors[c];
                      colorIndex = 1 + c;
                      if (color.name !== "") {
                        edgeColors[colorIndex] = cornerColors[colorIndex] = color.name;
                      }
                    }
                  }
                  var idLayout = [
                    edgeColors,
                    cornerColors,
                    edgeColors,
                    cornerColors,
                    edgeColors,
                    cornerColors,
                    edgeColors,
                    cornerColors
                  ];
                  for (var t = 0; t < wangset.wangtiles.length; t++) {
                    var wangtile = wangset.wangtiles[t];
                    var obj = datas[wangtile.tileid] || (datas[wangtile.tileid] = {});
                    obj = obj.wangid || (obj.wangid = {});
                    var wangid = [];
                    for (var i = 0; i < Math.min(idLayout.length, wangtile.wangid.length); i++) {
                      color = wangtile.wangid[i];
                      if (color === 0) {
                        wangid.push(void 0);
                        continue;
                      }
                      var renamed = idLayout[i][color];
                      if (renamed !== void 0) {
                        wangid.push(renamed);
                        continue;
                      }
                      wangid.push(color);
                    }
                    obj[identifier] = wangid;
                  }
                }
              }
            };
            module2.exports = ParseWangsets;
          },
          50044: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              AssignTileProperties: __webpack_require__2(48646),
              Base64Decode: __webpack_require__2(43908),
              BuildTilesetIndex: __webpack_require__2(14556),
              CreateGroupLayer: __webpack_require__2(92044),
              ParseGID: __webpack_require__2(8847),
              ParseImageLayers: __webpack_require__2(78339),
              ParseJSONTiled: __webpack_require__2(2378),
              ParseObject: __webpack_require__2(4281),
              ParseObjectLayers: __webpack_require__2(61136),
              ParseTileLayers: __webpack_require__2(95925),
              ParseTilesets: __webpack_require__2(93392)
            };
          },
          73779: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var TimerEvent = __webpack_require__2(57911);
            var Remove = __webpack_require__2(66458);
            var Clock = new Class({
              initialize: function Clock2(scene) {
                this.scene = scene;
                this.systems = scene.sys;
                this.now = 0;
                this.startTime = 0;
                this.timeScale = 1;
                this.paused = false;
                this._active = [];
                this._pendingInsertion = [];
                this._pendingRemoval = [];
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
                scene.sys.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.now = this.systems.game.loop.time;
                this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                this.startTime = this.systems.game.loop.time;
                var eventEmitter = this.systems.events;
                eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
                eventEmitter.on(SceneEvents.UPDATE, this.update, this);
                eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              addEvent: function(config2) {
                var event;
                if (config2 instanceof TimerEvent) {
                  event = config2;
                  this.removeEvent(event);
                  event.elapsed = event.startAt;
                  event.hasDispatched = false;
                  event.repeatCount = event.repeat === -1 || event.loop ? 999999999999 : event.repeat;
                } else {
                  event = new TimerEvent(config2);
                }
                this._pendingInsertion.push(event);
                return event;
              },
              delayedCall: function(delay, callback, args, callbackScope) {
                return this.addEvent({delay, callback, args, callbackScope});
              },
              clearPendingEvents: function() {
                this._pendingInsertion = [];
                return this;
              },
              removeEvent: function(events) {
                if (!Array.isArray(events)) {
                  events = [events];
                }
                for (var i = 0; i < events.length; i++) {
                  var event = events[i];
                  Remove(this._pendingRemoval, event);
                  Remove(this._pendingInsertion, event);
                  Remove(this._active, event);
                }
                return this;
              },
              removeAllEvents: function() {
                this._pendingRemoval = this._pendingRemoval.concat(this._active);
                return this;
              },
              preUpdate: function() {
                var toRemove = this._pendingRemoval.length;
                var toInsert = this._pendingInsertion.length;
                if (toRemove === 0 && toInsert === 0) {
                  return;
                }
                var i;
                var event;
                for (i = 0; i < toRemove; i++) {
                  event = this._pendingRemoval[i];
                  var index = this._active.indexOf(event);
                  if (index > -1) {
                    this._active.splice(index, 1);
                  }
                  event.destroy();
                }
                for (i = 0; i < toInsert; i++) {
                  event = this._pendingInsertion[i];
                  this._active.push(event);
                }
                this._pendingRemoval.length = 0;
                this._pendingInsertion.length = 0;
              },
              update: function(time, delta) {
                this.now = time;
                if (this.paused) {
                  return;
                }
                delta *= this.timeScale;
                for (var i = 0; i < this._active.length; i++) {
                  var event = this._active[i];
                  if (event.paused) {
                    continue;
                  }
                  event.elapsed += delta * event.timeScale;
                  if (event.elapsed >= event.delay) {
                    var remainder = event.elapsed - event.delay;
                    event.elapsed = event.delay;
                    if (!event.hasDispatched && event.callback) {
                      event.hasDispatched = true;
                      event.callback.apply(event.callbackScope, event.args);
                    }
                    if (event.repeatCount > 0) {
                      event.repeatCount--;
                      if (remainder >= event.delay) {
                        while (remainder >= event.delay && event.repeatCount > 0) {
                          if (event.callback) {
                            event.callback.apply(event.callbackScope, event.args);
                          }
                          remainder -= event.delay;
                          event.repeatCount--;
                        }
                      }
                      event.elapsed = remainder;
                      event.hasDispatched = false;
                    } else if (event.hasDispatched) {
                      this._pendingRemoval.push(event);
                    }
                  }
                }
              },
              shutdown: function() {
                var i;
                for (i = 0; i < this._pendingInsertion.length; i++) {
                  this._pendingInsertion[i].destroy();
                }
                for (i = 0; i < this._active.length; i++) {
                  this._active[i].destroy();
                }
                for (i = 0; i < this._pendingRemoval.length; i++) {
                  this._pendingRemoval[i].destroy();
                }
                this._active.length = 0;
                this._pendingRemoval.length = 0;
                this._pendingInsertion.length = 0;
                var eventEmitter = this.systems.events;
                eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
                eventEmitter.off(SceneEvents.UPDATE, this.update, this);
                eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                this.shutdown();
                this.scene.sys.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.systems = null;
              }
            });
            PluginCache.register("Clock", Clock, "time");
            module2.exports = Clock;
          },
          20517: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var GameObjectFactory = __webpack_require__2(61286);
            var GetFastValue = __webpack_require__2(72632);
            var SceneEvents = __webpack_require__2(7599);
            var Events = __webpack_require__2(52944);
            var Timeline = new Class({
              Extends: EventEmitter,
              initialize: function Timeline2(scene, config2) {
                EventEmitter.call(this);
                this.scene = scene;
                this.systems = scene.sys;
                this.elapsed = 0;
                this.paused = true;
                this.complete = false;
                this.totalComplete = 0;
                this.events = [];
                var eventEmitter = this.systems.events;
                eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
                eventEmitter.on(SceneEvents.UPDATE, this.update, this);
                eventEmitter.once(SceneEvents.SHUTDOWN, this.destroy, this);
                if (config2) {
                  this.add(config2);
                }
              },
              preUpdate: function(time, delta) {
                if (this.paused) {
                  return;
                }
                this.elapsed += delta;
              },
              update: function() {
                if (this.paused || this.complete) {
                  return;
                }
                var i;
                var events = this.events;
                var removeSweep = false;
                var sys = this.systems;
                var target;
                for (i = 0; i < events.length; i++) {
                  var event = events[i];
                  if (!event.complete && event.time <= this.elapsed) {
                    event.complete = true;
                    this.totalComplete++;
                    target = event.target ? event.target : this;
                    if (event.if) {
                      if (!event.if.call(target, event)) {
                        continue;
                      }
                    }
                    if (event.once) {
                      removeSweep = true;
                    }
                    if (event.set && event.target) {
                      for (var key in event.set) {
                        event.target[key] = event.set[key];
                      }
                    }
                    if (event.tween) {
                      sys.tweens.add(event.tween);
                    }
                    if (event.sound) {
                      if (typeof event.sound === "string") {
                        sys.sound.play(event.sound);
                      } else {
                        sys.sound.play(event.sound.key, event.sound.config);
                      }
                    }
                    if (event.event) {
                      this.emit(event.event, target);
                    }
                    if (event.run) {
                      event.run.call(target);
                    }
                    if (event.stop) {
                      this.stop();
                    }
                  }
                }
                if (removeSweep) {
                  for (i = 0; i < events.length; i++) {
                    if (events[i].complete && events[i].once) {
                      events.splice(i, 1);
                      i--;
                    }
                  }
                }
                if (this.totalComplete >= events.length) {
                  this.complete = true;
                }
                if (this.complete) {
                  this.emit(Events.COMPLETE, this);
                }
              },
              play: function(fromStart) {
                if (fromStart === void 0) {
                  fromStart = true;
                }
                this.paused = false;
                this.complete = false;
                this.totalComplete = 0;
                if (fromStart) {
                  this.reset();
                }
                return this;
              },
              pause: function() {
                this.paused = true;
                return this;
              },
              resume: function() {
                this.paused = false;
                return this;
              },
              stop: function() {
                this.paused = true;
                this.complete = true;
                return this;
              },
              reset: function() {
                this.elapsed = 0;
                for (var i = 0; i < this.events.length; i++) {
                  this.events[i].complete = false;
                }
                return this.play(false);
              },
              add: function(config2) {
                if (!Array.isArray(config2)) {
                  config2 = [config2];
                }
                var events = this.events;
                var prevTime = 0;
                if (events.length > 0) {
                  prevTime = events[events.length - 1].time;
                }
                for (var i = 0; i < config2.length; i++) {
                  var entry = config2[i];
                  var startTime = GetFastValue(entry, "at", 0);
                  var offsetTime = GetFastValue(entry, "in", null);
                  if (offsetTime !== null) {
                    startTime = this.elapsed + offsetTime;
                  }
                  var fromTime = GetFastValue(entry, "from", null);
                  if (fromTime !== null) {
                    startTime = prevTime + fromTime;
                  }
                  events.push({
                    complete: false,
                    time: startTime,
                    if: GetFastValue(entry, "if", null),
                    run: GetFastValue(entry, "run", null),
                    event: GetFastValue(entry, "event", null),
                    target: GetFastValue(entry, "target", null),
                    set: GetFastValue(entry, "set", null),
                    tween: GetFastValue(entry, "tween", null),
                    sound: GetFastValue(entry, "sound", null),
                    once: GetFastValue(entry, "once", false),
                    stop: GetFastValue(entry, "stop", false)
                  });
                  prevTime = startTime;
                }
                this.complete = false;
                return this;
              },
              clear: function() {
                this.events = [];
                this.elapsed = 0;
                this.paused = true;
                return this;
              },
              isPlaying: function() {
                return !this.paused && !this.complete;
              },
              getProgress: function() {
                var total = Math.min(this.totalComplete, this.events.length);
                return total / this.events.length;
              },
              destroy: function() {
                var eventEmitter = this.systems.events;
                eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
                eventEmitter.off(SceneEvents.UPDATE, this.update, this);
                eventEmitter.off(SceneEvents.SHUTDOWN, this.destroy, this);
                this.scene = null;
                this.systems = null;
                this.events = [];
              }
            });
            GameObjectFactory.register("timeline", function(config2) {
              return new Timeline(this.scene, config2);
            });
            module2.exports = Timeline;
          },
          57911: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var GetFastValue = __webpack_require__2(72632);
            var TimerEvent = new Class({
              initialize: function TimerEvent2(config2) {
                this.delay = 0;
                this.repeat = 0;
                this.repeatCount = 0;
                this.loop = false;
                this.callback;
                this.callbackScope;
                this.args;
                this.timeScale = 1;
                this.startAt = 0;
                this.elapsed = 0;
                this.paused = false;
                this.hasDispatched = false;
                this.reset(config2);
              },
              reset: function(config2) {
                this.delay = GetFastValue(config2, "delay", 0);
                this.repeat = GetFastValue(config2, "repeat", 0);
                this.loop = GetFastValue(config2, "loop", false);
                this.callback = GetFastValue(config2, "callback", void 0);
                this.callbackScope = GetFastValue(config2, "callbackScope", this);
                this.args = GetFastValue(config2, "args", []);
                this.timeScale = GetFastValue(config2, "timeScale", 1);
                this.startAt = GetFastValue(config2, "startAt", 0);
                this.paused = GetFastValue(config2, "paused", false);
                this.elapsed = this.startAt;
                this.hasDispatched = false;
                this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat;
                if (this.delay === 0 && (this.repeat > 0 || this.loop)) {
                  throw new Error("TimerEvent infinite loop created via zero delay");
                }
                return this;
              },
              getProgress: function() {
                return this.elapsed / this.delay;
              },
              getOverallProgress: function() {
                if (this.repeat > 0) {
                  var totalDuration = this.delay + this.delay * this.repeat;
                  var totalElapsed = this.elapsed + this.delay * (this.repeat - this.repeatCount);
                  return totalElapsed / totalDuration;
                } else {
                  return this.getProgress();
                }
              },
              getRepeatCount: function() {
                return this.repeatCount;
              },
              getElapsed: function() {
                return this.elapsed;
              },
              getElapsedSeconds: function() {
                return this.elapsed * 1e-3;
              },
              getRemaining: function() {
                return this.delay - this.elapsed;
              },
              getRemainingSeconds: function() {
                return this.getRemaining() * 1e-3;
              },
              getOverallRemaining: function() {
                return this.delay * (1 + this.repeatCount) - this.elapsed;
              },
              getOverallRemainingSeconds: function() {
                return this.getOverallRemaining() * 1e-3;
              },
              remove: function(dispatchCallback) {
                if (dispatchCallback === void 0) {
                  dispatchCallback = false;
                }
                this.elapsed = this.delay;
                this.hasDispatched = !dispatchCallback;
                this.repeatCount = 0;
              },
              destroy: function() {
                this.callback = void 0;
                this.callbackScope = void 0;
                this.args = [];
              }
            });
            module2.exports = TimerEvent;
          },
          12144: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "complete";
          },
          52944: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              COMPLETE: __webpack_require__2(12144)
            };
          },
          97121: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Clock: __webpack_require__2(73779),
              Events: __webpack_require__2(52944),
              Timeline: __webpack_require__2(20517),
              TimerEvent: __webpack_require__2(57911)
            };
          },
          64532: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArrayRemove = __webpack_require__2(66458);
            var Class = __webpack_require__2(56694);
            var Flatten = __webpack_require__2(5454);
            var NumberTweenBuilder = __webpack_require__2(68710);
            var PluginCache = __webpack_require__2(91963);
            var SceneEvents = __webpack_require__2(7599);
            var StaggerBuilder = __webpack_require__2(91944);
            var Tween = __webpack_require__2(39366);
            var TweenBuilder = __webpack_require__2(68061);
            var TweenChain = __webpack_require__2(45641);
            var TweenChainBuilder = __webpack_require__2(56034);
            var TweenManager = new Class({
              initialize: function TweenManager2(scene) {
                this.scene = scene;
                this.events = scene.sys.events;
                this.timeScale = 1;
                this.paused = false;
                this.processing = false;
                this.tweens = [];
                this.time = 0;
                this.startTime = 0;
                this.nextTime = 0;
                this.prevTime = 0;
                this.maxLag = 500;
                this.lagSkip = 33;
                this.gap = 1e3 / 240;
                this.events.once(SceneEvents.BOOT, this.boot, this);
                this.events.on(SceneEvents.START, this.start, this);
              },
              boot: function() {
                this.events.once(SceneEvents.DESTROY, this.destroy, this);
              },
              start: function() {
                this.timeScale = 1;
                this.paused = false;
                this.startTime = Date.now();
                this.prevTime = this.startTime;
                this.nextTime = this.gap;
                this.events.on(SceneEvents.UPDATE, this.update, this);
                this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              create: function(config2) {
                if (!Array.isArray(config2)) {
                  config2 = [config2];
                }
                var result = [];
                for (var i = 0; i < config2.length; i++) {
                  var tween = config2[i];
                  if (tween instanceof Tween || tween instanceof TweenChain) {
                    result.push(tween);
                  } else if (Array.isArray(tween.tweens)) {
                    result.push(TweenChainBuilder(this, tween));
                  } else {
                    result.push(TweenBuilder(this, tween));
                  }
                }
                return result.length === 1 ? result[0] : result;
              },
              add: function(config2) {
                var tween = config2;
                var tweens = this.tweens;
                if (tween instanceof Tween || tween instanceof TweenChain) {
                  tweens.push(tween.reset());
                } else {
                  if (Array.isArray(tween.tweens)) {
                    tween = TweenChainBuilder(this, tween);
                  } else {
                    tween = TweenBuilder(this, tween);
                  }
                  tweens.push(tween.reset());
                }
                return tween;
              },
              addMultiple: function(configs) {
                var tween;
                var result = [];
                var tweens = this.tweens;
                for (var i = 0; i < configs.length; i++) {
                  tween = configs[i];
                  if (tween instanceof Tween || tween instanceof TweenChain) {
                    tweens.push(tween.reset());
                  } else {
                    if (Array.isArray(tween.tweens)) {
                      tween = TweenChainBuilder(this, tween);
                    } else {
                      tween = TweenBuilder(this, tween);
                    }
                    tweens.push(tween.reset());
                  }
                  result.push(tween);
                }
                return result;
              },
              chain: function(config2) {
                var chain = TweenChainBuilder(this, config2);
                this.tweens.push(chain.init());
                return chain;
              },
              getChainedTweens: function(tween) {
                return tween.getChainedTweens();
              },
              has: function(tween) {
                return this.tweens.indexOf(tween) > -1;
              },
              existing: function(tween) {
                if (!this.has(tween)) {
                  this.tweens.push(tween.reset());
                }
                return this;
              },
              addCounter: function(config2) {
                var tween = NumberTweenBuilder(this, config2);
                this.tweens.push(tween.reset());
                return tween;
              },
              stagger: function(value, options) {
                return StaggerBuilder(value, options);
              },
              setLagSmooth: function(limit, skip) {
                if (limit === void 0) {
                  limit = 1 / 1e-8;
                }
                if (skip === void 0) {
                  skip = 0;
                }
                this.maxLag = limit;
                this.lagSkip = Math.min(skip, this.maxLag);
                return this;
              },
              setFps: function(fps) {
                if (fps === void 0) {
                  fps = 240;
                }
                this.gap = 1e3 / fps;
                this.nextTime = this.time * 1e3 + this.gap;
                return this;
              },
              getDelta: function(tick) {
                var elapsed = Date.now() - this.prevTime;
                if (elapsed > this.maxLag) {
                  this.startTime += elapsed - this.lagSkip;
                }
                this.prevTime += elapsed;
                var time = this.prevTime - this.startTime;
                var overlap = time - this.nextTime;
                var delta = time - this.time * 1e3;
                if (overlap > 0 || tick) {
                  time /= 1e3;
                  this.time = time;
                  this.nextTime += overlap + (overlap >= this.gap ? 4 : this.gap - overlap);
                } else {
                  delta = 0;
                }
                return delta;
              },
              tick: function() {
                this.step(true);
                return this;
              },
              update: function() {
                if (!this.paused) {
                  this.step(false);
                }
              },
              step: function(tick) {
                if (tick === void 0) {
                  tick = false;
                }
                var delta = this.getDelta(tick);
                if (delta <= 0) {
                  return;
                }
                this.processing = true;
                var i;
                var tween;
                var toDestroy = [];
                var list = this.tweens;
                for (i = 0; i < list.length; i++) {
                  tween = list[i];
                  if (tween.update(delta)) {
                    toDestroy.push(tween);
                  }
                }
                var count = toDestroy.length;
                if (count && list.length > 0) {
                  for (i = 0; i < count; i++) {
                    tween = toDestroy[i];
                    var idx = list.indexOf(tween);
                    if (idx > -1 && (tween.isPendingRemove() || tween.isDestroyed())) {
                      list.splice(idx, 1);
                      tween.destroy();
                    }
                  }
                  toDestroy.length = 0;
                }
                this.processing = false;
              },
              remove: function(tween) {
                if (this.processing) {
                  tween.setPendingRemoveState();
                } else {
                  ArrayRemove(this.tweens, tween);
                  tween.setRemovedState();
                }
                return this;
              },
              reset: function(tween) {
                this.existing(tween);
                tween.seek();
                tween.setActiveState();
                return this;
              },
              makeActive: function(tween) {
                this.existing(tween);
                tween.setActiveState();
                return this;
              },
              each: function(callback, scope) {
                var i;
                var args = [null];
                for (i = 1; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                this.tweens.forEach(function(tween) {
                  args[0] = tween;
                  callback.apply(scope, args);
                });
                return this;
              },
              getTweens: function() {
                return this.tweens.slice();
              },
              getTweensOf: function(target) {
                var output = [];
                var list = this.tweens;
                if (!Array.isArray(target)) {
                  target = [target];
                } else {
                  target = Flatten(target);
                }
                var targetLen = target.length;
                for (var i = 0; i < list.length; i++) {
                  var tween = list[i];
                  for (var t = 0; t < targetLen; t++) {
                    if (!tween.isDestroyed() && tween.hasTarget(target[t])) {
                      output.push(tween);
                    }
                  }
                }
                return output;
              },
              getGlobalTimeScale: function() {
                return this.timeScale;
              },
              setGlobalTimeScale: function(value) {
                this.timeScale = value;
                return this;
              },
              isTweening: function(target) {
                var list = this.tweens;
                var tween;
                for (var i = 0; i < list.length; i++) {
                  tween = list[i];
                  if (tween.isPlaying() && tween.hasTarget(target)) {
                    return true;
                  }
                }
                return false;
              },
              killAll: function() {
                var tweens = this.processing ? this.getTweens() : this.tweens;
                for (var i = 0; i < tweens.length; i++) {
                  tweens[i].destroy();
                }
                if (!this.processing) {
                  tweens.length = 0;
                }
                return this;
              },
              killTweensOf: function(target) {
                var tweens = this.getTweensOf(target);
                for (var i = 0; i < tweens.length; i++) {
                  tweens[i].destroy();
                }
                return this;
              },
              pauseAll: function() {
                this.paused = true;
                return this;
              },
              resumeAll: function() {
                this.paused = false;
                return this;
              },
              shutdown: function() {
                this.killAll();
                this.tweens = [];
                this.events.off(SceneEvents.UPDATE, this.update, this);
                this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              },
              destroy: function() {
                this.shutdown();
                this.events.off(SceneEvents.START, this.start, this);
                this.scene = null;
                this.events = null;
              }
            });
            PluginCache.register("TweenManager", TweenManager, "tweens");
            module2.exports = TweenManager;
          },
          63130: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetBoolean = function(source, key, defaultValue) {
              if (!source) {
                return defaultValue;
              } else if (source.hasOwnProperty(key)) {
                return source[key];
              } else {
                return defaultValue;
              }
            };
            module2.exports = GetBoolean;
          },
          21902: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var EaseMap = __webpack_require__2(35060);
            var UppercaseFirst = __webpack_require__2(40587);
            var GetEaseFunction = function(ease, easeParams) {
              var easeFunction = EaseMap.Power0;
              if (typeof ease === "string") {
                if (EaseMap.hasOwnProperty(ease)) {
                  easeFunction = EaseMap[ease];
                } else {
                  var direction = "";
                  if (ease.indexOf(".")) {
                    direction = ease.substring(ease.indexOf(".") + 1);
                    var directionLower = direction.toLowerCase();
                    if (directionLower === "in") {
                      direction = "easeIn";
                    } else if (directionLower === "out") {
                      direction = "easeOut";
                    } else if (directionLower === "inout") {
                      direction = "easeInOut";
                    }
                  }
                  ease = UppercaseFirst(ease.substring(0, ease.indexOf(".") + 1) + direction);
                  if (EaseMap.hasOwnProperty(ease)) {
                    easeFunction = EaseMap[ease];
                  }
                }
              } else if (typeof ease === "function") {
                easeFunction = ease;
              }
              if (!easeParams) {
                return easeFunction;
              }
              var cloneParams = easeParams.slice(0);
              cloneParams.unshift(0);
              return function(v) {
                cloneParams[0] = v;
                return easeFunction.apply(this, cloneParams);
              };
            };
            module2.exports = GetEaseFunction;
          },
          4840: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Bezier = __webpack_require__2(63210);
            var CatmullRom = __webpack_require__2(88332);
            var Linear = __webpack_require__2(47614);
            var FuncMap = {
              bezier: Bezier,
              catmull: CatmullRom,
              catmullrom: CatmullRom,
              linear: Linear
            };
            var GetInterpolationFunction = function(interpolation) {
              if (interpolation === null) {
                return null;
              }
              var interpolationFunction = FuncMap.linear;
              if (typeof interpolation === "string") {
                if (FuncMap.hasOwnProperty(interpolation)) {
                  interpolationFunction = FuncMap[interpolation];
                }
              } else if (typeof interpolation === "function") {
                interpolationFunction = interpolation;
              }
              return interpolationFunction;
            };
            module2.exports = GetInterpolationFunction;
          },
          28348: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetNewValue = function(source, key, defaultValue) {
              var valueCallback;
              if (source.hasOwnProperty(key)) {
                var t = typeof source[key];
                if (t === "function") {
                  valueCallback = function(target, targetKey, value, targetIndex, totalTargets, tween) {
                    return source[key](target, targetKey, value, targetIndex, totalTargets, tween);
                  };
                } else {
                  valueCallback = function() {
                    return source[key];
                  };
                }
              } else if (typeof defaultValue === "function") {
                valueCallback = defaultValue;
              } else {
                valueCallback = function() {
                  return defaultValue;
                };
              }
              return valueCallback;
            };
            module2.exports = GetNewValue;
          },
          92407: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RESERVED = __webpack_require__2(53709);
            var GetProps = function(config2) {
              var key;
              var keys = [];
              if (config2.hasOwnProperty("props")) {
                for (key in config2.props) {
                  if (key.substring(0, 1) !== "_") {
                    keys.push({key, value: config2.props[key]});
                  }
                }
              } else {
                for (key in config2) {
                  if (RESERVED.indexOf(key) === -1 && key.substring(0, 1) !== "_") {
                    keys.push({key, value: config2[key]});
                  }
                }
              }
              return keys;
            };
            module2.exports = GetProps;
          },
          65868: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetValue = __webpack_require__2(10850);
            var GetTargets = function(config2) {
              var targets = GetValue(config2, "targets", null);
              if (targets === null) {
                return targets;
              }
              if (typeof targets === "function") {
                targets = targets.call();
              }
              if (!Array.isArray(targets)) {
                targets = [targets];
              }
              return targets;
            };
            module2.exports = GetTargets;
          },
          9744: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Between = __webpack_require__2(17489);
            var FloatBetween = __webpack_require__2(61616);
            function hasGetActive(def) {
              return !!def.getActive && typeof def.getActive === "function";
            }
            function hasGetStart(def) {
              return !!def.getStart && typeof def.getStart === "function";
            }
            function hasGetEnd(def) {
              return !!def.getEnd && typeof def.getEnd === "function";
            }
            function hasGetters(def) {
              return hasGetStart(def) || hasGetEnd(def) || hasGetActive(def);
            }
            var GetValueOp = function(key, propertyValue) {
              var callbacks;
              var getEnd = function(target, key2, value) {
                return value;
              };
              var getStart = function(target, key2, value) {
                return value;
              };
              var getActive = null;
              var t = typeof propertyValue;
              if (t === "number") {
                getEnd = function() {
                  return propertyValue;
                };
              } else if (Array.isArray(propertyValue)) {
                getStart = function() {
                  return propertyValue[0];
                };
                getEnd = function() {
                  return propertyValue[propertyValue.length - 1];
                };
              } else if (t === "string") {
                var op = propertyValue.toLowerCase();
                var isRandom = op.substring(0, 6) === "random";
                var isInt = op.substring(0, 3) === "int";
                if (isRandom || isInt) {
                  var brace1 = op.indexOf("(");
                  var brace2 = op.indexOf(")");
                  var comma = op.indexOf(",");
                  if (brace1 && brace2 && comma) {
                    var value1 = parseFloat(op.substring(brace1 + 1, comma));
                    var value2 = parseFloat(op.substring(comma + 1, brace2));
                    if (isRandom) {
                      getEnd = function() {
                        return FloatBetween(value1, value2);
                      };
                    } else {
                      getEnd = function() {
                        return Between(value1, value2);
                      };
                    }
                  } else {
                    throw new Error("invalid random() format");
                  }
                } else {
                  op = op[0];
                  var num = parseFloat(propertyValue.substr(2));
                  switch (op) {
                    case "+":
                      getEnd = function(target, key2, value) {
                        return value + num;
                      };
                      break;
                    case "-":
                      getEnd = function(target, key2, value) {
                        return value - num;
                      };
                      break;
                    case "*":
                      getEnd = function(target, key2, value) {
                        return value * num;
                      };
                      break;
                    case "/":
                      getEnd = function(target, key2, value) {
                        return value / num;
                      };
                      break;
                    default:
                      getEnd = function() {
                        return parseFloat(propertyValue);
                      };
                  }
                }
              } else if (t === "function") {
                getEnd = propertyValue;
              } else if (t === "object") {
                if (hasGetters(propertyValue)) {
                  if (hasGetActive(propertyValue)) {
                    getActive = propertyValue.getActive;
                  }
                  if (hasGetEnd(propertyValue)) {
                    getEnd = propertyValue.getEnd;
                  }
                  if (hasGetStart(propertyValue)) {
                    getStart = propertyValue.getStart;
                  }
                } else if (propertyValue.hasOwnProperty("value")) {
                  callbacks = GetValueOp(key, propertyValue.value);
                } else {
                  var hasTo = propertyValue.hasOwnProperty("to");
                  var hasFrom = propertyValue.hasOwnProperty("from");
                  var hasStart = propertyValue.hasOwnProperty("start");
                  if (hasTo && (hasFrom || hasStart)) {
                    callbacks = GetValueOp(key, propertyValue.to);
                    if (hasStart) {
                      var startCallbacks = GetValueOp(key, propertyValue.start);
                      callbacks.getActive = startCallbacks.getEnd;
                    }
                    if (hasFrom) {
                      var fromCallbacks = GetValueOp(key, propertyValue.from);
                      callbacks.getStart = fromCallbacks.getEnd;
                    }
                  }
                }
              }
              if (!callbacks) {
                callbacks = {
                  getActive,
                  getEnd,
                  getStart
                };
              }
              return callbacks;
            };
            module2.exports = GetValueOp;
          },
          68710: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseTween = __webpack_require__2(502);
            var Defaults = __webpack_require__2(99730);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetBoolean = __webpack_require__2(63130);
            var GetEaseFunction = __webpack_require__2(21902);
            var GetNewValue = __webpack_require__2(28348);
            var GetValue = __webpack_require__2(10850);
            var GetValueOp = __webpack_require__2(9744);
            var MergeRight = __webpack_require__2(72066);
            var Tween = __webpack_require__2(39366);
            var NumberTweenBuilder = function(parent, config2, defaults) {
              if (config2 instanceof Tween) {
                config2.parent = parent;
                return config2;
              }
              if (defaults === void 0) {
                defaults = Defaults;
              } else {
                defaults = MergeRight(Defaults, defaults);
              }
              var from = GetValue(config2, "from", 0);
              var to = GetValue(config2, "to", 1);
              var targets = [{value: from}];
              var delay = GetValue(config2, "delay", defaults.delay);
              var easeParams = GetValue(config2, "easeParams", defaults.easeParams);
              var ease = GetValue(config2, "ease", defaults.ease);
              var ops = GetValueOp("value", to);
              var tween = new Tween(parent, targets);
              var tweenData = tween.add(0, "value", ops.getEnd, ops.getStart, ops.getActive, GetEaseFunction(GetValue(config2, "ease", ease), GetValue(config2, "easeParams", easeParams)), GetNewValue(config2, "delay", delay), GetValue(config2, "duration", defaults.duration), GetBoolean(config2, "yoyo", defaults.yoyo), GetValue(config2, "hold", defaults.hold), GetValue(config2, "repeat", defaults.repeat), GetValue(config2, "repeatDelay", defaults.repeatDelay), false, false);
              tweenData.start = from;
              tweenData.current = from;
              tween.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
              tween.loop = Math.round(GetAdvancedValue(config2, "loop", 0));
              tween.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", 0));
              tween.paused = GetBoolean(config2, "paused", false);
              tween.persist = GetBoolean(config2, "persist", false);
              tween.callbackScope = GetValue(config2, "callbackScope", tween);
              var callbacks = BaseTween.TYPES;
              for (var i = 0; i < callbacks.length; i++) {
                var type = callbacks[i];
                var callback = GetValue(config2, type, false);
                if (callback) {
                  var callbackParams = GetValue(config2, type + "Params", []);
                  tween.setCallback(type, callback, callbackParams);
                }
              }
              return tween;
            };
            module2.exports = NumberTweenBuilder;
          },
          91944: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetEaseFunction = __webpack_require__2(21902);
            var GetValue = __webpack_require__2(10850);
            var MATH_CONST = __webpack_require__2(83392);
            var StaggerBuilder = function(value, options) {
              if (options === void 0) {
                options = {};
              }
              var result;
              var start = GetValue(options, "start", 0);
              var ease = GetValue(options, "ease", null);
              var grid = GetValue(options, "grid", null);
              var from = GetValue(options, "from", 0);
              var fromFirst = from === "first";
              var fromCenter = from === "center";
              var fromLast = from === "last";
              var fromValue = typeof from === "number";
              var isRange = Array.isArray(value);
              var value1 = isRange ? parseFloat(value[0]) : parseFloat(value);
              var value2 = isRange ? parseFloat(value[1]) : 0;
              var maxValue = Math.max(value1, value2);
              if (isRange) {
                start += value1;
              }
              if (grid) {
                var gridWidth = grid[0];
                var gridHeight = grid[1];
                var fromX = 0;
                var fromY = 0;
                var distanceX = 0;
                var distanceY = 0;
                var gridValues = [];
                if (fromLast) {
                  fromX = gridWidth - 1;
                  fromY = gridHeight - 1;
                } else if (fromValue) {
                  fromX = from % gridWidth;
                  fromY = Math.floor(from / gridWidth);
                } else if (fromCenter) {
                  fromX = (gridWidth - 1) / 2;
                  fromY = (gridHeight - 1) / 2;
                }
                var gridMax = MATH_CONST.MIN_SAFE_INTEGER;
                for (var toY = 0; toY < gridHeight; toY++) {
                  gridValues[toY] = [];
                  for (var toX = 0; toX < gridWidth; toX++) {
                    distanceX = fromX - toX;
                    distanceY = fromY - toY;
                    var dist = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                    if (dist > gridMax) {
                      gridMax = dist;
                    }
                    gridValues[toY][toX] = dist;
                  }
                }
              }
              var easeFunction = ease ? GetEaseFunction(ease) : null;
              if (grid) {
                result = function(target, key, value3, index) {
                  var gridSpace = 0;
                  var toX2 = index % gridWidth;
                  var toY2 = Math.floor(index / gridWidth);
                  if (toX2 >= 0 && toX2 < gridWidth && toY2 >= 0 && toY2 < gridHeight) {
                    gridSpace = gridValues[toY2][toX2];
                  }
                  var output;
                  if (isRange) {
                    var diff = value2 - value1;
                    if (easeFunction) {
                      output = gridSpace / gridMax * diff * easeFunction(gridSpace / gridMax);
                    } else {
                      output = gridSpace / gridMax * diff;
                    }
                  } else if (easeFunction) {
                    output = gridSpace * value1 * easeFunction(gridSpace / gridMax);
                  } else {
                    output = gridSpace * value1;
                  }
                  return output + start;
                };
              } else {
                result = function(target, key, value3, index, total) {
                  total--;
                  var fromIndex;
                  if (fromFirst) {
                    fromIndex = index;
                  } else if (fromCenter) {
                    fromIndex = Math.abs(total / 2 - index);
                  } else if (fromLast) {
                    fromIndex = total - index;
                  } else if (fromValue) {
                    fromIndex = Math.abs(from - index);
                  }
                  var output;
                  if (isRange) {
                    var spacing;
                    if (fromCenter) {
                      spacing = (value2 - value1) / total * (fromIndex * 2);
                    } else {
                      spacing = (value2 - value1) / total * fromIndex;
                    }
                    if (easeFunction) {
                      output = spacing * easeFunction(fromIndex / total);
                    } else {
                      output = spacing;
                    }
                  } else if (easeFunction) {
                    output = total * maxValue * easeFunction(fromIndex / total);
                  } else {
                    output = fromIndex * value1;
                  }
                  return output + start;
                };
              }
              return result;
            };
            module2.exports = StaggerBuilder;
          },
          68061: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseTween = __webpack_require__2(502);
            var Defaults = __webpack_require__2(99730);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetBoolean = __webpack_require__2(63130);
            var GetEaseFunction = __webpack_require__2(21902);
            var GetInterpolationFunction = __webpack_require__2(4840);
            var GetNewValue = __webpack_require__2(28348);
            var GetProps = __webpack_require__2(92407);
            var GetTargets = __webpack_require__2(65868);
            var GetValue = __webpack_require__2(10850);
            var GetValueOp = __webpack_require__2(9744);
            var MergeRight = __webpack_require__2(72066);
            var Tween = __webpack_require__2(39366);
            var TweenBuilder = function(parent, config2, defaults) {
              if (config2 instanceof Tween) {
                config2.parent = parent;
                return config2;
              }
              if (defaults === void 0) {
                defaults = Defaults;
              } else {
                defaults = MergeRight(Defaults, defaults);
              }
              var targets = GetTargets(config2);
              if (!targets && defaults.targets) {
                targets = defaults.targets;
              }
              var props = GetProps(config2);
              var delay = GetValue(config2, "delay", defaults.delay);
              var duration = GetValue(config2, "duration", defaults.duration);
              var easeParams = GetValue(config2, "easeParams", defaults.easeParams);
              var ease = GetValue(config2, "ease", defaults.ease);
              var hold = GetValue(config2, "hold", defaults.hold);
              var repeat = GetValue(config2, "repeat", defaults.repeat);
              var repeatDelay = GetValue(config2, "repeatDelay", defaults.repeatDelay);
              var yoyo = GetBoolean(config2, "yoyo", defaults.yoyo);
              var flipX = GetBoolean(config2, "flipX", defaults.flipX);
              var flipY = GetBoolean(config2, "flipY", defaults.flipY);
              var interpolation = GetValue(config2, "interpolation", defaults.interpolation);
              var addTarget = function(tween2, targetIndex2, key2, value2) {
                if (key2 === "texture") {
                  var texture = value2;
                  var frame = void 0;
                  if (Array.isArray(value2)) {
                    texture = value2[0];
                    frame = value2[1];
                  } else if (value2.hasOwnProperty("value")) {
                    texture = value2.value;
                    if (Array.isArray(value2.value)) {
                      texture = value2.value[0];
                      frame = value2.value[1];
                    } else if (typeof value2.value === "string") {
                      texture = value2.value;
                    }
                  } else if (typeof value2 === "string") {
                    texture = value2;
                  }
                  tween2.addFrame(targetIndex2, texture, frame, GetNewValue(value2, "delay", delay), GetValue(value2, "duration", duration), GetValue(value2, "hold", hold), GetValue(value2, "repeat", repeat), GetValue(value2, "repeatDelay", repeatDelay), GetBoolean(value2, "flipX", flipX), GetBoolean(value2, "flipY", flipY));
                } else {
                  var ops = GetValueOp(key2, value2);
                  var interpolationFunc = GetInterpolationFunction(GetValue(value2, "interpolation", interpolation));
                  tween2.add(targetIndex2, key2, ops.getEnd, ops.getStart, ops.getActive, GetEaseFunction(GetValue(value2, "ease", ease), GetValue(value2, "easeParams", easeParams)), GetNewValue(value2, "delay", delay), GetValue(value2, "duration", duration), GetBoolean(value2, "yoyo", yoyo), GetValue(value2, "hold", hold), GetValue(value2, "repeat", repeat), GetValue(value2, "repeatDelay", repeatDelay), GetBoolean(value2, "flipX", flipX), GetBoolean(value2, "flipY", flipY), interpolationFunc, interpolationFunc ? value2 : null);
                }
              };
              var tween = new Tween(parent, targets);
              for (var p = 0; p < props.length; p++) {
                var key = props[p].key;
                var value = props[p].value;
                for (var targetIndex = 0; targetIndex < targets.length; targetIndex++) {
                  if (key === "scale" && !targets[targetIndex].hasOwnProperty("scale")) {
                    addTarget(tween, targetIndex, "scaleX", value);
                    addTarget(tween, targetIndex, "scaleY", value);
                  } else {
                    addTarget(tween, targetIndex, key, value);
                  }
                }
              }
              tween.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
              tween.loop = Math.round(GetAdvancedValue(config2, "loop", 0));
              tween.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", 0));
              tween.paused = GetBoolean(config2, "paused", false);
              tween.persist = GetBoolean(config2, "persist", false);
              tween.callbackScope = GetValue(config2, "callbackScope", tween);
              var callbacks = BaseTween.TYPES;
              for (var i = 0; i < callbacks.length; i++) {
                var type = callbacks[i];
                var callback = GetValue(config2, type, false);
                if (callback) {
                  var callbackParams = GetValue(config2, type + "Params", []);
                  tween.setCallback(type, callback, callbackParams);
                }
              }
              return tween;
            };
            module2.exports = TweenBuilder;
          },
          56034: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseTween = __webpack_require__2(502);
            var GetAdvancedValue = __webpack_require__2(20494);
            var GetBoolean = __webpack_require__2(63130);
            var GetTargets = __webpack_require__2(65868);
            var GetValue = __webpack_require__2(10850);
            var TweenBuilder = __webpack_require__2(68061);
            var TweenChain = __webpack_require__2(45641);
            var TweenChainBuilder = function(parent, config2) {
              if (config2 instanceof TweenChain) {
                config2.parent = parent;
                return config2;
              }
              var chain = new TweenChain(parent);
              chain.startDelay = GetValue(config2, "delay", 0);
              chain.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
              chain.loop = Math.round(GetAdvancedValue(config2, "loop", GetValue(config2, "repeat", 0)));
              chain.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", GetValue(config2, "repeatDelay", 0)));
              chain.paused = GetBoolean(config2, "paused", false);
              chain.persist = GetBoolean(config2, "persist", true);
              chain.callbackScope = GetValue(config2, "callbackScope", chain);
              var i;
              var callbacks = BaseTween.TYPES;
              for (i = 0; i < callbacks.length; i++) {
                var type = callbacks[i];
                var callback = GetValue(config2, type, false);
                if (callback) {
                  var callbackParams = GetValue(config2, type + "Params", []);
                  chain.setCallback(type, callback, callbackParams);
                }
              }
              var tweens = GetValue(config2, "tweens", null);
              if (Array.isArray(tweens)) {
                var chainedTweens = [];
                var targets = GetTargets(config2);
                var defaults = void 0;
                if (targets) {
                  defaults = {targets};
                }
                for (i = 0; i < tweens.length; i++) {
                  chainedTweens.push(TweenBuilder(chain, tweens[i], defaults));
                }
                chain.add(chainedTweens);
              }
              return chain;
            };
            module2.exports = TweenChainBuilder;
          },
          79619: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              GetBoolean: __webpack_require__2(63130),
              GetEaseFunction: __webpack_require__2(21902),
              GetInterpolationFunction: __webpack_require__2(4840),
              GetNewValue: __webpack_require__2(28348),
              GetProps: __webpack_require__2(92407),
              GetTargets: __webpack_require__2(65868),
              GetValueOp: __webpack_require__2(9744),
              NumberTweenBuilder: __webpack_require__2(68710),
              StaggerBuilder: __webpack_require__2(91944),
              TweenBuilder: __webpack_require__2(68061)
            };
          },
          5570: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "active";
          },
          6383: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "complete";
          },
          72582: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "loop";
          },
          90281: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "pause";
          },
          80803: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "repeat";
          },
          13640: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "resume";
          },
          10472: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "start";
          },
          5379: (module2) => {
            /**
             * @author       samme
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "stop";
          },
          43449: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "update";
          },
          61541: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = "yoyo";
          },
          54272: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              TWEEN_ACTIVE: __webpack_require__2(5570),
              TWEEN_COMPLETE: __webpack_require__2(6383),
              TWEEN_LOOP: __webpack_require__2(72582),
              TWEEN_PAUSE: __webpack_require__2(90281),
              TWEEN_RESUME: __webpack_require__2(13640),
              TWEEN_REPEAT: __webpack_require__2(80803),
              TWEEN_START: __webpack_require__2(10472),
              TWEEN_STOP: __webpack_require__2(5379),
              TWEEN_UPDATE: __webpack_require__2(43449),
              TWEEN_YOYO: __webpack_require__2(61541)
            };
          },
          75193: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Tweens = {
              States: __webpack_require__2(55303),
              Builders: __webpack_require__2(79619),
              Events: __webpack_require__2(54272),
              TweenManager: __webpack_require__2(64532),
              Tween: __webpack_require__2(39366),
              TweenData: __webpack_require__2(15718),
              TweenFrameData: __webpack_require__2(96490),
              BaseTween: __webpack_require__2(502),
              TweenChain: __webpack_require__2(45641)
            };
            module2.exports = Tweens;
          },
          502: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var EventEmitter = __webpack_require__2(6659);
            var Events = __webpack_require__2(54272);
            var TWEEN_CONST = __webpack_require__2(55303);
            var BaseTween = new Class({
              Extends: EventEmitter,
              initialize: function BaseTween2(parent) {
                EventEmitter.call(this);
                this.parent = parent;
                this.data = [];
                this.totalData = 0;
                this.startDelay = 0;
                this.hasStarted = false;
                this.timeScale = 1;
                this.loop = 0;
                this.loopDelay = 0;
                this.loopCounter = 0;
                this.completeDelay = 0;
                this.countdown = 0;
                this.state = TWEEN_CONST.PENDING;
                this.paused = false;
                this.callbacks = {
                  onActive: null,
                  onComplete: null,
                  onLoop: null,
                  onPause: null,
                  onRepeat: null,
                  onResume: null,
                  onStart: null,
                  onStop: null,
                  onUpdate: null,
                  onYoyo: null
                };
                this.callbackScope;
                this.persist = false;
              },
              setTimeScale: function(value) {
                this.timeScale = value;
                return this;
              },
              getTimeScale: function() {
                return this.timeScale;
              },
              isPlaying: function() {
                return !this.paused && this.isActive();
              },
              isPaused: function() {
                return this.paused;
              },
              pause: function() {
                if (!this.paused) {
                  this.paused = true;
                  this.dispatchEvent(Events.TWEEN_PAUSE, "onPause");
                }
                return this;
              },
              resume: function() {
                if (this.paused) {
                  this.paused = false;
                  this.dispatchEvent(Events.TWEEN_RESUME, "onResume");
                }
                return this;
              },
              makeActive: function() {
                this.parent.makeActive(this);
                this.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
              },
              onCompleteHandler: function() {
                this.setPendingRemoveState();
                this.dispatchEvent(Events.TWEEN_COMPLETE, "onComplete");
              },
              complete: function(delay) {
                if (delay === void 0) {
                  delay = 0;
                }
                if (delay) {
                  this.setCompleteDelayState();
                  this.countdown = delay;
                } else {
                  this.onCompleteHandler();
                }
                return this;
              },
              completeAfterLoop: function(loops) {
                if (loops === void 0) {
                  loops = 0;
                }
                if (this.loopCounter > loops) {
                  this.loopCounter = loops;
                }
                return this;
              },
              remove: function() {
                if (this.parent) {
                  this.parent.remove(this);
                }
                return this;
              },
              stop: function() {
                if (this.parent && !this.isRemoved() && !this.isPendingRemove() && !this.isDestroyed()) {
                  this.dispatchEvent(Events.TWEEN_STOP, "onStop");
                  this.setPendingRemoveState();
                }
                return this;
              },
              updateLoopCountdown: function(delta) {
                this.countdown -= delta;
                if (this.countdown <= 0) {
                  this.setActiveState();
                  this.dispatchEvent(Events.TWEEN_LOOP, "onLoop");
                }
              },
              updateStartCountdown: function(delta) {
                this.countdown -= delta;
                if (this.countdown <= 0) {
                  this.hasStarted = true;
                  this.setActiveState();
                  this.dispatchEvent(Events.TWEEN_START, "onStart");
                  delta = 0;
                }
                return delta;
              },
              updateCompleteDelay: function(delta) {
                this.countdown -= delta;
                if (this.countdown <= 0) {
                  this.onCompleteHandler();
                }
              },
              setCallback: function(type, callback, params) {
                if (params === void 0) {
                  params = [];
                }
                if (this.callbacks.hasOwnProperty(type)) {
                  this.callbacks[type] = {func: callback, params};
                }
                return this;
              },
              setPendingState: function() {
                this.state = TWEEN_CONST.PENDING;
              },
              setActiveState: function() {
                this.state = TWEEN_CONST.ACTIVE;
              },
              setLoopDelayState: function() {
                this.state = TWEEN_CONST.LOOP_DELAY;
              },
              setCompleteDelayState: function() {
                this.state = TWEEN_CONST.COMPLETE_DELAY;
              },
              setStartDelayState: function() {
                this.state = TWEEN_CONST.START_DELAY;
                this.countdown = this.startDelay;
                this.hasStarted = false;
              },
              setPendingRemoveState: function() {
                this.state = TWEEN_CONST.PENDING_REMOVE;
              },
              setRemovedState: function() {
                this.state = TWEEN_CONST.REMOVED;
              },
              setFinishedState: function() {
                this.state = TWEEN_CONST.FINISHED;
              },
              setDestroyedState: function() {
                this.state = TWEEN_CONST.DESTROYED;
              },
              isPending: function() {
                return this.state === TWEEN_CONST.PENDING;
              },
              isActive: function() {
                return this.state === TWEEN_CONST.ACTIVE;
              },
              isLoopDelayed: function() {
                return this.state === TWEEN_CONST.LOOP_DELAY;
              },
              isCompleteDelayed: function() {
                return this.state === TWEEN_CONST.COMPLETE_DELAY;
              },
              isStartDelayed: function() {
                return this.state === TWEEN_CONST.START_DELAY;
              },
              isPendingRemove: function() {
                return this.state === TWEEN_CONST.PENDING_REMOVE;
              },
              isRemoved: function() {
                return this.state === TWEEN_CONST.REMOVED;
              },
              isFinished: function() {
                return this.state === TWEEN_CONST.FINISHED;
              },
              isDestroyed: function() {
                return this.state === TWEEN_CONST.DESTROYED;
              },
              destroy: function() {
                if (this.data) {
                  this.data.forEach(function(tweenData) {
                    tweenData.destroy();
                  });
                }
                this.removeAllListeners();
                this.callbacks = null;
                this.data = null;
                this.parent = null;
                this.setDestroyedState();
              }
            });
            BaseTween.TYPES = [
              "onActive",
              "onComplete",
              "onLoop",
              "onPause",
              "onRepeat",
              "onResume",
              "onStart",
              "onStop",
              "onUpdate",
              "onYoyo"
            ];
            module2.exports = BaseTween;
          },
          65521: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(54272);
            var TWEEN_CONST = __webpack_require__2(55303);
            var BaseTweenData = new Class({
              initialize: function BaseTweenData2(tween, targetIndex, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY) {
                this.tween = tween;
                this.targetIndex = targetIndex;
                this.duration = duration;
                this.totalDuration = 0;
                this.delay = 0;
                this.getDelay = delay;
                this.yoyo = yoyo;
                this.hold = hold;
                this.repeat = repeat;
                this.repeatDelay = repeatDelay;
                this.repeatCounter = 0;
                this.flipX = flipX;
                this.flipY = flipY;
                this.progress = 0;
                this.elapsed = 0;
                this.state = 0;
                this.isCountdown = false;
              },
              getTarget: function() {
                return this.tween.targets[this.targetIndex];
              },
              setTargetValue: function(value) {
                if (value === void 0) {
                  value = this.current;
                }
                this.tween.targets[this.targetIndex][this.key] = value;
              },
              setCreatedState: function() {
                this.state = TWEEN_CONST.CREATED;
                this.isCountdown = false;
              },
              setDelayState: function() {
                this.state = TWEEN_CONST.DELAY;
                this.isCountdown = true;
              },
              setPendingRenderState: function() {
                this.state = TWEEN_CONST.PENDING_RENDER;
                this.isCountdown = false;
              },
              setPlayingForwardState: function() {
                this.state = TWEEN_CONST.PLAYING_FORWARD;
                this.isCountdown = false;
              },
              setPlayingBackwardState: function() {
                this.state = TWEEN_CONST.PLAYING_BACKWARD;
                this.isCountdown = false;
              },
              setHoldState: function() {
                this.state = TWEEN_CONST.HOLD_DELAY;
                this.isCountdown = true;
              },
              setRepeatState: function() {
                this.state = TWEEN_CONST.REPEAT_DELAY;
                this.isCountdown = true;
              },
              setCompleteState: function() {
                this.state = TWEEN_CONST.COMPLETE;
                this.isCountdown = false;
              },
              isCreated: function() {
                return this.state === TWEEN_CONST.CREATED;
              },
              isDelayed: function() {
                return this.state === TWEEN_CONST.DELAY;
              },
              isPendingRender: function() {
                return this.state === TWEEN_CONST.PENDING_RENDER;
              },
              isPlayingForward: function() {
                return this.state === TWEEN_CONST.PLAYING_FORWARD;
              },
              isPlayingBackward: function() {
                return this.state === TWEEN_CONST.PLAYING_BACKWARD;
              },
              isHolding: function() {
                return this.state === TWEEN_CONST.HOLD_DELAY;
              },
              isRepeating: function() {
                return this.state === TWEEN_CONST.REPEAT_DELAY;
              },
              isComplete: function() {
                return this.state === TWEEN_CONST.COMPLETE;
              },
              setStateFromEnd: function(diff) {
                if (this.yoyo) {
                  this.onRepeat(diff, true, true);
                } else if (this.repeatCounter > 0) {
                  this.onRepeat(diff, true, false);
                } else {
                  this.setCompleteState();
                }
              },
              setStateFromStart: function(diff) {
                if (this.repeatCounter > 0) {
                  this.onRepeat(diff, false);
                } else {
                  this.setCompleteState();
                }
              },
              reset: function() {
                var tween = this.tween;
                var totalTargets = tween.totalTargets;
                var targetIndex = this.targetIndex;
                var target = tween.targets[targetIndex];
                var key = this.key;
                this.progress = 0;
                this.elapsed = 0;
                this.delay = this.getDelay(target, key, 0, targetIndex, totalTargets, tween);
                this.repeatCounter = this.repeat === -1 ? TWEEN_CONST.MAX : this.repeat;
                this.setPendingRenderState();
                var t1 = this.duration + this.hold;
                if (this.yoyo) {
                  t1 += this.duration;
                }
                var t2 = t1 + this.repeatDelay;
                this.totalDuration = this.delay + t1;
                if (this.repeat === -1) {
                  this.totalDuration += t2 * TWEEN_CONST.MAX;
                  tween.isInfinite = true;
                } else if (this.repeat > 0) {
                  this.totalDuration += t2 * this.repeat;
                }
                if (this.totalDuration > tween.duration) {
                  tween.duration = this.totalDuration;
                }
                if (this.delay < tween.startDelay) {
                  tween.startDelay = this.delay;
                }
                if (this.delay > 0) {
                  this.elapsed = this.delay;
                  this.setDelayState();
                }
              },
              onRepeat: function(diff, setStart, isYoyo) {
                var tween = this.tween;
                var totalTargets = tween.totalTargets;
                var targetIndex = this.targetIndex;
                var target = tween.targets[targetIndex];
                var key = this.key;
                var isTweenData = key !== "texture";
                this.elapsed = diff;
                this.progress = diff / this.duration;
                if (this.flipX) {
                  target.toggleFlipX();
                }
                if (this.flipY) {
                  target.toggleFlipY();
                }
                if (isTweenData && (setStart || isYoyo)) {
                  this.start = this.getStartValue(target, key, this.start, targetIndex, totalTargets, tween);
                }
                if (isYoyo) {
                  this.setPlayingBackwardState();
                  this.dispatchEvent(Events.TWEEN_YOYO, "onYoyo");
                  return;
                }
                this.repeatCounter--;
                if (isTweenData) {
                  this.end = this.getEndValue(target, key, this.start, targetIndex, totalTargets, tween);
                }
                if (this.repeatDelay > 0) {
                  this.elapsed = this.repeatDelay - diff;
                  if (isTweenData) {
                    this.current = this.start;
                    target[key] = this.current;
                  }
                  this.setRepeatState();
                } else {
                  this.setPlayingForwardState();
                  this.dispatchEvent(Events.TWEEN_REPEAT, "onRepeat");
                }
              },
              destroy: function() {
                this.tween = null;
                this.getDelay = null;
                this.setCompleteState();
              }
            });
            module2.exports = BaseTweenData;
          },
          99730: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TWEEN_DEFAULTS = {
              targets: null,
              delay: 0,
              duration: 1e3,
              ease: "Power0",
              easeParams: null,
              hold: 0,
              repeat: 0,
              repeatDelay: 0,
              yoyo: false,
              flipX: false,
              flipY: false,
              persist: false,
              interpolation: null
            };
            module2.exports = TWEEN_DEFAULTS;
          },
          53709: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = [
              "callbackScope",
              "completeDelay",
              "delay",
              "duration",
              "ease",
              "easeParams",
              "flipX",
              "flipY",
              "hold",
              "interpolation",
              "loop",
              "loopDelay",
              "onActive",
              "onActiveParams",
              "onComplete",
              "onCompleteParams",
              "onLoop",
              "onLoopParams",
              "onPause",
              "onPauseParams",
              "onRepeat",
              "onRepeatParams",
              "onResume",
              "onResumeParams",
              "onStart",
              "onStartParams",
              "onStop",
              "onStopParams",
              "onUpdate",
              "onUpdateParams",
              "onYoyo",
              "onYoyoParams",
              "paused",
              "persist",
              "props",
              "repeat",
              "repeatDelay",
              "targets",
              "yoyo"
            ];
          },
          39366: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseTween = __webpack_require__2(502);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(54272);
            var GameObjectCreator = __webpack_require__2(99325);
            var GameObjectFactory = __webpack_require__2(61286);
            var MATH_CONST = __webpack_require__2(83392);
            var TWEEN_CONST = __webpack_require__2(55303);
            var TweenData = __webpack_require__2(15718);
            var TweenFrameData = __webpack_require__2(96490);
            var Tween = new Class({
              Extends: BaseTween,
              initialize: function Tween2(parent, targets) {
                BaseTween.call(this, parent);
                this.targets = targets;
                this.totalTargets = targets.length;
                this.isSeeking = false;
                this.isInfinite = false;
                this.elapsed = 0;
                this.totalElapsed = 0;
                this.duration = 0;
                this.progress = 0;
                this.totalDuration = 0;
                this.totalProgress = 0;
              },
              add: function(targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData) {
                var tweenData = new TweenData(this, targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData);
                this.totalData = this.data.push(tweenData);
                return tweenData;
              },
              addFrame: function(targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY) {
                var tweenData = new TweenFrameData(this, targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY);
                this.totalData = this.data.push(tweenData);
                return tweenData;
              },
              getValue: function(index) {
                if (index === void 0) {
                  index = 0;
                }
                var value = null;
                if (this.data) {
                  value = this.data[index].current;
                }
                return value;
              },
              hasTarget: function(target) {
                return this.targets && this.targets.indexOf(target) !== -1;
              },
              updateTo: function(key, value, startToCurrent) {
                if (startToCurrent === void 0) {
                  startToCurrent = false;
                }
                if (key !== "texture") {
                  for (var i = 0; i < this.totalData; i++) {
                    var tweenData = this.data[i];
                    if (tweenData.key === key && (tweenData.isPlayingForward() || tweenData.isPlayingBackward())) {
                      tweenData.end = value;
                      if (startToCurrent) {
                        tweenData.start = tweenData.current;
                      }
                    }
                  }
                }
                return this;
              },
              restart: function() {
                switch (this.state) {
                  case TWEEN_CONST.REMOVED:
                  case TWEEN_CONST.FINISHED:
                    this.seek();
                    this.parent.makeActive(this);
                    break;
                  case TWEEN_CONST.PENDING:
                  case TWEEN_CONST.PENDING_REMOVE:
                    this.parent.reset(this);
                    break;
                  case TWEEN_CONST.DESTROYED:
                    console.warn("Cannot restart destroyed Tween", this);
                    break;
                  default:
                    this.seek();
                    break;
                }
                this.paused = false;
                this.hasStarted = false;
                return this;
              },
              nextState: function() {
                if (this.loopCounter > 0) {
                  this.elapsed = 0;
                  this.progress = 0;
                  this.loopCounter--;
                  this.initTweenData(true);
                  if (this.loopDelay > 0) {
                    this.countdown = this.loopDelay;
                    this.setLoopDelayState();
                  } else {
                    this.setActiveState();
                    this.dispatchEvent(Events.TWEEN_LOOP, "onLoop");
                  }
                } else if (this.completeDelay > 0) {
                  this.countdown = this.completeDelay;
                  this.setCompleteDelayState();
                } else {
                  this.onCompleteHandler();
                  return true;
                }
                return false;
              },
              onCompleteHandler: function() {
                this.progress = 1;
                this.totalProgress = 1;
                BaseTween.prototype.onCompleteHandler.call(this);
              },
              play: function() {
                if (this.isDestroyed()) {
                  console.warn("Cannot play destroyed Tween", this);
                  return this;
                }
                if (this.isPendingRemove() || this.isFinished()) {
                  this.seek();
                }
                this.paused = false;
                this.setActiveState();
                return this;
              },
              seek: function(amount, delta, emit) {
                if (amount === void 0) {
                  amount = 0;
                }
                if (delta === void 0) {
                  delta = 16.6;
                }
                if (emit === void 0) {
                  emit = false;
                }
                if (this.isDestroyed()) {
                  console.warn("Cannot seek destroyed Tween", this);
                  return this;
                }
                if (!emit) {
                  this.isSeeking = true;
                }
                this.reset(true);
                this.initTweenData(true);
                this.setActiveState();
                this.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
                var isPaused = this.paused;
                this.paused = false;
                if (amount > 0) {
                  var iterations = Math.floor(amount / delta);
                  var remainder = amount - iterations * delta;
                  for (var i = 0; i < iterations; i++) {
                    this.update(delta);
                  }
                  if (remainder > 0) {
                    this.update(remainder);
                  }
                }
                this.paused = isPaused;
                this.isSeeking = false;
                return this;
              },
              initTweenData: function(isSeeking) {
                if (isSeeking === void 0) {
                  isSeeking = false;
                }
                this.duration = 0;
                this.startDelay = MATH_CONST.MAX_SAFE_INTEGER;
                var data = this.data;
                for (var i = 0; i < this.totalData; i++) {
                  data[i].reset(isSeeking);
                }
                this.duration = Math.max(this.duration, 0.01);
                var duration = this.duration;
                var completeDelay = this.completeDelay;
                var loopCounter = this.loopCounter;
                var loopDelay = this.loopDelay;
                if (loopCounter > 0) {
                  this.totalDuration = duration + completeDelay + (duration + loopDelay) * loopCounter;
                } else {
                  this.totalDuration = duration + completeDelay;
                }
              },
              reset: function(skipInit) {
                if (skipInit === void 0) {
                  skipInit = false;
                }
                this.elapsed = 0;
                this.totalElapsed = 0;
                this.progress = 0;
                this.totalProgress = 0;
                this.loopCounter = this.loop;
                if (this.loop === -1) {
                  this.isInfinite = true;
                  this.loopCounter = TWEEN_CONST.MAX;
                }
                if (!skipInit) {
                  this.initTweenData();
                  this.setActiveState();
                  this.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
                }
                return this;
              },
              update: function(delta) {
                if (this.isPendingRemove() || this.isDestroyed()) {
                  return true;
                } else if (this.paused || this.isFinished()) {
                  return false;
                }
                delta *= this.timeScale * this.parent.timeScale;
                if (this.isLoopDelayed()) {
                  this.updateLoopCountdown(delta);
                  return false;
                } else if (this.isCompleteDelayed()) {
                  this.updateCompleteDelay(delta);
                  return false;
                } else if (!this.hasStarted) {
                  this.startDelay -= delta;
                  if (this.startDelay <= 0) {
                    this.hasStarted = true;
                    this.dispatchEvent(Events.TWEEN_START, "onStart");
                    delta = 0;
                  }
                }
                var stillRunning = false;
                if (this.isActive()) {
                  var data = this.data;
                  for (var i = 0; i < this.totalData; i++) {
                    if (data[i].update(delta)) {
                      stillRunning = true;
                    }
                  }
                }
                this.elapsed += delta;
                this.progress = Math.min(this.elapsed / this.duration, 1);
                this.totalElapsed += delta;
                this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
                if (!stillRunning) {
                  this.nextState();
                }
                var remove = this.isPendingRemove();
                if (remove && this.persist) {
                  this.setFinishedState();
                  remove = false;
                }
                return remove;
              },
              forward: function(ms) {
                this.update(ms);
                return this;
              },
              rewind: function(ms) {
                this.update(-ms);
                return this;
              },
              dispatchEvent: function(event, callback) {
                if (!this.isSeeking) {
                  this.emit(event, this, this.targets);
                  var handler = this.callbacks[callback];
                  if (handler) {
                    handler.func.apply(this.callbackScope, [this, this.targets].concat(handler.params));
                  }
                }
              },
              destroy: function() {
                BaseTween.prototype.destroy.call(this);
                this.targets = null;
              }
            });
            GameObjectFactory.register("tween", function(config2) {
              return this.scene.sys.tweens.add(config2);
            });
            GameObjectCreator.register("tween", function(config2) {
              return this.scene.sys.tweens.create(config2);
            });
            module2.exports = Tween;
          },
          45641: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ArrayRemove = __webpack_require__2(66458);
            var BaseTween = __webpack_require__2(502);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(54272);
            var GameObjectCreator = __webpack_require__2(99325);
            var GameObjectFactory = __webpack_require__2(61286);
            var TWEEN_CONST = __webpack_require__2(55303);
            var TweenChain = new Class({
              Extends: BaseTween,
              initialize: function TweenChain2(parent) {
                BaseTween.call(this, parent);
                this.currentTween = null;
                this.currentIndex = 0;
              },
              init: function() {
                this.loopCounter = this.loop === -1 ? TWEEN_CONST.MAX : this.loop;
                this.setCurrentTween(0);
                if (this.startDelay > 0 && !this.isStartDelayed()) {
                  this.setStartDelayState();
                } else {
                  this.setActiveState();
                }
                this.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
                return this;
              },
              add: function(tweens) {
                var newTweens = this.parent.create(tweens);
                if (!Array.isArray(newTweens)) {
                  newTweens = [newTweens];
                }
                var data = this.data;
                for (var i = 0; i < newTweens.length; i++) {
                  var tween = newTweens[i];
                  tween.parent = this;
                  data.push(tween.reset());
                }
                this.totalData = data.length;
                return this;
              },
              remove: function(tween) {
                ArrayRemove(this.data, tween);
                tween.setRemovedState();
                if (tween === this.currentTween) {
                  this.nextTween();
                }
                this.totalData = this.data.length;
                return this;
              },
              hasTarget: function(target) {
                var data = this.data;
                for (var i = 0; i < this.totalData; i++) {
                  if (data[i].hasTarget(target)) {
                    return true;
                  }
                }
                return false;
              },
              restart: function() {
                if (this.isDestroyed()) {
                  console.warn("Cannot restart destroyed TweenChain", this);
                  return this;
                }
                if (this.isRemoved()) {
                  this.parent.makeActive(this);
                }
                this.resetTweens();
                this.paused = false;
                return this.init();
              },
              reset: function(tween) {
                tween.seek();
                tween.setActiveState();
                return this;
              },
              makeActive: function(tween) {
                tween.reset();
                tween.setActiveState();
                return this;
              },
              nextState: function() {
                if (this.loopCounter > 0) {
                  this.loopCounter--;
                  this.resetTweens();
                  if (this.loopDelay > 0) {
                    this.countdown = this.loopDelay;
                    this.setLoopDelayState();
                  } else {
                    this.setActiveState();
                    this.dispatchEvent(Events.TWEEN_LOOP, "onLoop");
                  }
                } else if (this.completeDelay > 0) {
                  this.countdown = this.completeDelay;
                  this.setCompleteDelayState();
                } else {
                  this.onCompleteHandler();
                  return true;
                }
                return false;
              },
              play: function() {
                if (this.isDestroyed()) {
                  console.warn("Cannot play destroyed TweenChain", this);
                  return this;
                }
                if (this.isPendingRemove() || this.isPending()) {
                  this.resetTweens();
                }
                this.paused = false;
                if (this.startDelay > 0 && !this.isStartDelayed()) {
                  this.setStartDelayState();
                } else {
                  this.setActiveState();
                }
                return this;
              },
              resetTweens: function() {
                var data = this.data;
                var total = this.totalData;
                for (var i = 0; i < total; i++) {
                  data[i].reset(false);
                }
                this.currentIndex = 0;
                this.currentTween = data[0];
              },
              update: function(delta) {
                if (this.isPendingRemove() || this.isDestroyed()) {
                  return true;
                } else if (this.isFinished() || this.paused) {
                  return false;
                }
                delta *= this.parent.timeScale;
                if (this.isLoopDelayed()) {
                  this.updateLoopCountdown(delta);
                } else if (this.isCompleteDelayed()) {
                  this.updateCompleteDelay(delta);
                } else if (this.isStartDelayed()) {
                  delta = this.updateStartCountdown(delta);
                }
                var remove = false;
                if (this.isActive() && this.currentTween) {
                  if (this.currentTween.update(delta)) {
                    if (this.nextTween()) {
                      this.nextState();
                    }
                  }
                  remove = this.isPendingRemove();
                  if (remove && this.persist) {
                    this.setFinishedState();
                    remove = false;
                  }
                }
                return remove;
              },
              nextTween: function() {
                this.currentIndex++;
                if (this.currentIndex === this.totalData) {
                  return true;
                } else {
                  this.setCurrentTween(this.currentIndex);
                }
                return false;
              },
              setCurrentTween: function(index) {
                this.currentIndex = index;
                this.currentTween = this.data[index];
                this.currentTween.setActiveState();
                this.currentTween.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
              },
              dispatchEvent: function(event, callback) {
                this.emit(event, this);
                var handler = this.callbacks[callback];
                if (handler) {
                  handler.func.apply(this.callbackScope, [this].concat(handler.params));
                }
              },
              destroy: function() {
                BaseTween.prototype.destroy.call(this);
                this.currentTween = null;
              }
            });
            GameObjectFactory.register("tweenchain", function(config2) {
              return this.scene.sys.tweens.chain(config2);
            });
            GameObjectCreator.register("tweenchain", function(config2) {
              return this.scene.sys.tweens.create(config2);
            });
            module2.exports = TweenChain;
          },
          15718: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseTweenData = __webpack_require__2(65521);
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(54272);
            var TweenData = new Class({
              Extends: BaseTweenData,
              initialize: function TweenData2(tween, targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData) {
                BaseTweenData.call(this, tween, targetIndex, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY);
                this.key = key;
                this.getActiveValue = getActive;
                this.getEndValue = getEnd;
                this.getStartValue = getStart;
                this.ease = ease;
                this.start = 0;
                this.previous = 0;
                this.current = 0;
                this.end = 0;
                this.interpolation = interpolation;
                this.interpolationData = interpolationData;
              },
              reset: function(isSeeking) {
                BaseTweenData.prototype.reset.call(this);
                var target = this.tween.targets[this.targetIndex];
                var key = this.key;
                if (isSeeking) {
                  target[key] = this.start;
                }
                this.start = 0;
                this.previous = 0;
                this.current = 0;
                this.end = 0;
                if (this.getActiveValue) {
                  target[key] = this.getActiveValue(target, key, 0);
                }
              },
              update: function(delta) {
                var tween = this.tween;
                var totalTargets = tween.totalTargets;
                var targetIndex = this.targetIndex;
                var target = tween.targets[targetIndex];
                var key = this.key;
                if (!target) {
                  this.setCompleteState();
                  return false;
                }
                if (this.isCountdown) {
                  this.elapsed -= delta;
                  if (this.elapsed <= 0) {
                    this.elapsed = 0;
                    delta = 0;
                    if (this.isDelayed()) {
                      this.setPendingRenderState();
                    } else if (this.isRepeating()) {
                      this.setPlayingForwardState();
                      this.dispatchEvent(Events.TWEEN_REPEAT, "onRepeat");
                    } else if (this.isHolding()) {
                      this.setStateFromEnd(0);
                    }
                  }
                }
                if (this.isPendingRender()) {
                  this.start = this.getStartValue(target, key, target[key], targetIndex, totalTargets, tween);
                  this.end = this.getEndValue(target, key, this.start, targetIndex, totalTargets, tween);
                  this.current = this.start;
                  target[key] = this.start;
                  this.setPlayingForwardState();
                  return true;
                }
                var forward = this.isPlayingForward();
                var backward = this.isPlayingBackward();
                if (forward || backward) {
                  var elapsed = this.elapsed;
                  var duration = this.duration;
                  var diff = 0;
                  var complete = false;
                  elapsed += delta;
                  if (elapsed >= duration) {
                    diff = elapsed - duration;
                    elapsed = duration;
                    complete = true;
                  } else if (elapsed < 0) {
                    elapsed = 0;
                  }
                  var progress = Clamp(elapsed / duration, 0, 1);
                  this.elapsed = elapsed;
                  this.progress = progress;
                  this.previous = this.current;
                  if (complete) {
                    if (forward) {
                      this.current = this.end;
                      target[key] = this.end;
                      if (this.hold > 0) {
                        this.elapsed = this.hold;
                        this.setHoldState();
                      } else {
                        this.setStateFromEnd(diff);
                      }
                    } else {
                      this.current = this.start;
                      target[key] = this.start;
                      this.setStateFromStart(diff);
                    }
                  } else {
                    if (!forward) {
                      progress = 1 - progress;
                    }
                    var v = this.ease(progress);
                    if (this.interpolation) {
                      this.current = this.interpolation(this.interpolationData, v);
                    } else {
                      this.current = this.start + (this.end - this.start) * v;
                    }
                    target[key] = this.current;
                  }
                  this.dispatchEvent(Events.TWEEN_UPDATE, "onUpdate");
                }
                return !this.isComplete();
              },
              dispatchEvent: function(event, callback) {
                var tween = this.tween;
                if (!tween.isSeeking) {
                  var target = tween.targets[this.targetIndex];
                  var key = this.key;
                  var current = this.current;
                  var previous = this.previous;
                  tween.emit(event, tween, key, target, current, previous);
                  var handler = tween.callbacks[callback];
                  if (handler) {
                    handler.func.apply(tween.callbackScope, [tween, target, key, current, previous].concat(handler.params));
                  }
                }
              },
              destroy: function() {
                BaseTweenData.prototype.destroy.call(this);
                this.getActiveValue = null;
                this.getEndValue = null;
                this.getStartValue = null;
                this.ease = null;
              }
            });
            module2.exports = TweenData;
          },
          96490: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BaseTweenData = __webpack_require__2(65521);
            var Clamp = __webpack_require__2(82897);
            var Class = __webpack_require__2(56694);
            var Events = __webpack_require__2(54272);
            var TweenFrameData = new Class({
              Extends: BaseTweenData,
              initialize: function TweenFrameData2(tween, targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY) {
                BaseTweenData.call(this, tween, targetIndex, delay, duration, false, hold, repeat, repeatDelay, flipX, flipY);
                this.key = "texture";
                this.startTexture = null;
                this.endTexture = texture;
                this.startFrame = null;
                this.endFrame = frame;
                this.yoyo = repeat !== 0 ? true : false;
              },
              reset: function(isSeeking) {
                BaseTweenData.prototype.reset.call(this);
                var target = this.tween.targets[this.targetIndex];
                if (!this.startTexture) {
                  this.startTexture = target.texture.key;
                  this.startFrame = target.frame.name;
                }
                if (isSeeking) {
                  target.setTexture(this.startTexture, this.startFrame);
                }
              },
              update: function(delta) {
                var tween = this.tween;
                var targetIndex = this.targetIndex;
                var target = tween.targets[targetIndex];
                if (!target) {
                  this.setCompleteState();
                  return false;
                }
                if (this.isCountdown) {
                  this.elapsed -= delta;
                  if (this.elapsed <= 0) {
                    this.elapsed = 0;
                    delta = 0;
                    if (this.isDelayed()) {
                      this.setPendingRenderState();
                    } else if (this.isRepeating()) {
                      this.setPlayingForwardState();
                      this.dispatchEvent(Events.TWEEN_REPEAT, "onRepeat");
                    } else if (this.isHolding()) {
                      this.setStateFromEnd(0);
                    }
                  }
                }
                if (this.isPendingRender()) {
                  if (this.startTexture) {
                    target.setTexture(this.startTexture, this.startFrame);
                  }
                  this.setPlayingForwardState();
                  return true;
                }
                var forward = this.isPlayingForward();
                var backward = this.isPlayingBackward();
                if (forward || backward) {
                  var elapsed = this.elapsed;
                  var duration = this.duration;
                  var diff = 0;
                  var complete = false;
                  elapsed += delta;
                  if (elapsed >= duration) {
                    diff = elapsed - duration;
                    elapsed = duration;
                    complete = true;
                  } else if (elapsed < 0) {
                    elapsed = 0;
                  }
                  var progress = Clamp(elapsed / duration, 0, 1);
                  this.elapsed = elapsed;
                  this.progress = progress;
                  if (complete) {
                    if (forward) {
                      target.setTexture(this.endTexture, this.endFrame);
                      if (this.hold > 0) {
                        this.elapsed = this.hold;
                        this.setHoldState();
                      } else {
                        this.setStateFromEnd(diff);
                      }
                    } else {
                      target.setTexture(this.startTexture, this.startFrame);
                      this.setStateFromStart(diff);
                    }
                  }
                  this.dispatchEvent(Events.TWEEN_UPDATE, "onUpdate");
                }
                return !this.isComplete();
              },
              dispatchEvent: function(event, callback) {
                var tween = this.tween;
                if (!tween.isSeeking) {
                  var target = tween.targets[this.targetIndex];
                  var key = this.key;
                  tween.emit(event, tween, key, target);
                  var handler = tween.callbacks[callback];
                  if (handler) {
                    handler.func.apply(tween.callbackScope, [tween, target, key].concat(handler.params));
                  }
                }
              },
              destroy: function() {
                BaseTweenData.prototype.destroy.call(this);
                this.startTexture = null;
                this.endTexture = null;
                this.startFrame = null;
                this.endFrame = null;
              }
            });
            module2.exports = TweenFrameData;
          },
          55303: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TWEEN_CONST = {
              CREATED: 0,
              DELAY: 2,
              PENDING_RENDER: 4,
              PLAYING_FORWARD: 5,
              PLAYING_BACKWARD: 6,
              HOLD_DELAY: 7,
              REPEAT_DELAY: 8,
              COMPLETE: 9,
              PENDING: 20,
              ACTIVE: 21,
              LOOP_DELAY: 22,
              COMPLETE_DELAY: 23,
              START_DELAY: 24,
              PENDING_REMOVE: 25,
              REMOVED: 26,
              FINISHED: 27,
              DESTROYED: 28,
              MAX: 999999999999
            };
            module2.exports = TWEEN_CONST;
          },
          56694: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            function hasGetterOrSetter(def) {
              return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
            }
            function getProperty(definition, k, isClassDescriptor) {
              var def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);
              if (!isClassDescriptor && def.value && typeof def.value === "object") {
                def = def.value;
              }
              if (def && hasGetterOrSetter(def)) {
                if (typeof def.enumerable === "undefined") {
                  def.enumerable = true;
                }
                if (typeof def.configurable === "undefined") {
                  def.configurable = true;
                }
                return def;
              } else {
                return false;
              }
            }
            function hasNonConfigurable(obj, k) {
              var prop = Object.getOwnPropertyDescriptor(obj, k);
              if (!prop) {
                return false;
              }
              if (prop.value && typeof prop.value === "object") {
                prop = prop.value;
              }
              if (prop.configurable === false) {
                return true;
              }
              return false;
            }
            function extend(ctor, definition, isClassDescriptor, extend2) {
              for (var k in definition) {
                if (!definition.hasOwnProperty(k)) {
                  continue;
                }
                var def = getProperty(definition, k, isClassDescriptor);
                if (def !== false) {
                  var parent = extend2 || ctor;
                  if (hasNonConfigurable(parent.prototype, k)) {
                    if (Class.ignoreFinals) {
                      continue;
                    }
                    throw new Error("cannot override final property '" + k + "', set Class.ignoreFinals = true to skip");
                  }
                  Object.defineProperty(ctor.prototype, k, def);
                } else {
                  ctor.prototype[k] = definition[k];
                }
              }
            }
            function mixin(myClass, mixins) {
              if (!mixins) {
                return;
              }
              if (!Array.isArray(mixins)) {
                mixins = [mixins];
              }
              for (var i = 0; i < mixins.length; i++) {
                extend(myClass, mixins[i].prototype || mixins[i]);
              }
            }
            function Class(definition) {
              if (!definition) {
                definition = {};
              }
              var initialize;
              var Extends;
              if (definition.initialize) {
                if (typeof definition.initialize !== "function") {
                  throw new Error("initialize must be a function");
                }
                initialize = definition.initialize;
                delete definition.initialize;
              } else if (definition.Extends) {
                var base = definition.Extends;
                initialize = function() {
                  base.apply(this, arguments);
                };
              } else {
                initialize = function() {
                };
              }
              if (definition.Extends) {
                initialize.prototype = Object.create(definition.Extends.prototype);
                initialize.prototype.constructor = initialize;
                Extends = definition.Extends;
                delete definition.Extends;
              } else {
                initialize.prototype.constructor = initialize;
              }
              var mixins = null;
              if (definition.Mixins) {
                mixins = definition.Mixins;
                delete definition.Mixins;
              }
              mixin(initialize, mixins);
              extend(initialize, definition, true, Extends);
              return initialize;
            }
            Class.extend = extend;
            Class.mixin = mixin;
            Class.ignoreFinals = false;
            module2.exports = Class;
          },
          72283: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NOOP = function() {
            };
            module2.exports = NOOP;
          },
          10618: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NULL = function() {
              return null;
            };
            module2.exports = NULL;
          },
          78991: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Add = function(array, item, limit, callback, context) {
              if (context === void 0) {
                context = array;
              }
              if (limit > 0) {
                var remaining = limit - array.length;
                if (remaining <= 0) {
                  return null;
                }
              }
              if (!Array.isArray(item)) {
                if (array.indexOf(item) === -1) {
                  array.push(item);
                  if (callback) {
                    callback.call(context, item);
                  }
                  return item;
                } else {
                  return null;
                }
              }
              var itemLength = item.length - 1;
              while (itemLength >= 0) {
                if (array.indexOf(item[itemLength]) !== -1) {
                  item.splice(itemLength, 1);
                }
                itemLength--;
              }
              itemLength = item.length;
              if (itemLength === 0) {
                return null;
              }
              if (limit > 0 && itemLength > remaining) {
                item.splice(remaining);
                itemLength = remaining;
              }
              for (var i = 0; i < itemLength; i++) {
                var entry = item[i];
                array.push(entry);
                if (callback) {
                  callback.call(context, entry);
                }
              }
              return item;
            };
            module2.exports = Add;
          },
          48522: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var AddAt = function(array, item, index, limit, callback, context) {
              if (index === void 0) {
                index = 0;
              }
              if (context === void 0) {
                context = array;
              }
              if (limit > 0) {
                var remaining = limit - array.length;
                if (remaining <= 0) {
                  return null;
                }
              }
              if (!Array.isArray(item)) {
                if (array.indexOf(item) === -1) {
                  array.splice(index, 0, item);
                  if (callback) {
                    callback.call(context, item);
                  }
                  return item;
                } else {
                  return null;
                }
              }
              var itemLength = item.length - 1;
              while (itemLength >= 0) {
                if (array.indexOf(item[itemLength]) !== -1) {
                  item.pop();
                }
                itemLength--;
              }
              itemLength = item.length;
              if (itemLength === 0) {
                return null;
              }
              if (limit > 0 && itemLength > remaining) {
                item.splice(remaining);
                itemLength = remaining;
              }
              for (var i = itemLength - 1; i >= 0; i--) {
                var entry = item[i];
                array.splice(index, 0, entry);
                if (callback) {
                  callback.call(context, entry);
                }
              }
              return item;
            };
            module2.exports = AddAt;
          },
          58742: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var BringToTop = function(array, item) {
              var currentIndex = array.indexOf(item);
              if (currentIndex !== -1 && currentIndex < array.length) {
                array.splice(currentIndex, 1);
                array.push(item);
              }
              return item;
            };
            module2.exports = BringToTop;
          },
          30164: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SafeRange = __webpack_require__2(45838);
            var CountAllMatching = function(array, property, value, startIndex, endIndex) {
              if (startIndex === void 0) {
                startIndex = 0;
              }
              if (endIndex === void 0) {
                endIndex = array.length;
              }
              var total = 0;
              if (SafeRange(array, startIndex, endIndex)) {
                for (var i = startIndex; i < endIndex; i++) {
                  var child = array[i];
                  if (child[property] === value) {
                    total++;
                  }
                }
              }
              return total;
            };
            module2.exports = CountAllMatching;
          },
          36337: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Each = function(array, callback, context) {
              var i;
              var args = [null];
              for (i = 3; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = 0; i < array.length; i++) {
                args[0] = array[i];
                callback.apply(context, args);
              }
              return array;
            };
            module2.exports = Each;
          },
          46208: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SafeRange = __webpack_require__2(45838);
            var EachInRange = function(array, callback, context, startIndex, endIndex) {
              if (startIndex === void 0) {
                startIndex = 0;
              }
              if (endIndex === void 0) {
                endIndex = array.length;
              }
              if (SafeRange(array, startIndex, endIndex)) {
                var i;
                var args = [null];
                for (i = 5; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                for (i = startIndex; i < endIndex; i++) {
                  args[0] = array[i];
                  callback.apply(context, args);
                }
              }
              return array;
            };
            module2.exports = EachInRange;
          },
          2406: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var FindClosestInSorted = function(value, array, key) {
              if (!array.length) {
                return NaN;
              } else if (array.length === 1) {
                return array[0];
              }
              var i = 1;
              var low;
              var high;
              if (key) {
                if (value < array[0][key]) {
                  return array[0];
                }
                while (array[i][key] < value) {
                  i++;
                }
              } else {
                while (array[i] < value) {
                  i++;
                }
              }
              if (i > array.length) {
                i = array.length;
              }
              if (key) {
                low = array[i - 1][key];
                high = array[i][key];
                return high - value <= value - low ? array[i] : array[i - 1];
              } else {
                low = array[i - 1];
                high = array[i];
                return high - value <= value - low ? high : low;
              }
            };
            module2.exports = FindClosestInSorted;
          },
          5454: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Flatten = function(array, output) {
              if (output === void 0) {
                output = [];
              }
              for (var i = 0; i < array.length; i++) {
                if (Array.isArray(array[i])) {
                  Flatten(array[i], output);
                } else {
                  output.push(array[i]);
                }
              }
              return output;
            };
            module2.exports = Flatten;
          },
          71608: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SafeRange = __webpack_require__2(45838);
            var GetAll = function(array, property, value, startIndex, endIndex) {
              if (startIndex === void 0) {
                startIndex = 0;
              }
              if (endIndex === void 0) {
                endIndex = array.length;
              }
              var output = [];
              if (SafeRange(array, startIndex, endIndex)) {
                for (var i = startIndex; i < endIndex; i++) {
                  var child = array[i];
                  if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
                    output.push(child);
                  }
                }
              }
              return output;
            };
            module2.exports = GetAll;
          },
          51463: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SafeRange = __webpack_require__2(45838);
            var GetFirst = function(array, property, value, startIndex, endIndex) {
              if (startIndex === void 0) {
                startIndex = 0;
              }
              if (endIndex === void 0) {
                endIndex = array.length;
              }
              if (SafeRange(array, startIndex, endIndex)) {
                for (var i = startIndex; i < endIndex; i++) {
                  var child = array[i];
                  if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
                    return child;
                  }
                }
              }
              return null;
            };
            module2.exports = GetFirst;
          },
          72861: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetRandom = function(array, startIndex, length) {
              if (startIndex === void 0) {
                startIndex = 0;
              }
              if (length === void 0) {
                length = array.length;
              }
              var randomIndex = startIndex + Math.floor(Math.random() * length);
              return array[randomIndex] === void 0 ? null : array[randomIndex];
            };
            module2.exports = GetRandom;
          },
          24218: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MoveAbove = function(array, item1, item2) {
              if (item1 === item2) {
                return array;
              }
              var currentIndex = array.indexOf(item1);
              var baseIndex = array.indexOf(item2);
              if (currentIndex < 0 || baseIndex < 0) {
                throw new Error("Supplied items must be elements of the same array");
              }
              if (currentIndex > baseIndex) {
                return array;
              }
              array.splice(currentIndex, 1);
              if (baseIndex === array.length - 1) {
                array.push(item1);
              } else {
                array.splice(baseIndex, 0, item1);
              }
              return array;
            };
            module2.exports = MoveAbove;
          },
          58258: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MoveBelow = function(array, item1, item2) {
              if (item1 === item2) {
                return array;
              }
              var currentIndex = array.indexOf(item1);
              var baseIndex = array.indexOf(item2);
              if (currentIndex < 0 || baseIndex < 0) {
                throw new Error("Supplied items must be elements of the same array");
              }
              if (currentIndex < baseIndex) {
                return array;
              }
              array.splice(currentIndex, 1);
              if (baseIndex === 0) {
                array.unshift(item1);
              } else {
                array.splice(baseIndex, 0, item1);
              }
              return array;
            };
            module2.exports = MoveBelow;
          },
          51172: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MoveDown = function(array, item) {
              var currentIndex = array.indexOf(item);
              if (currentIndex > 0) {
                var item2 = array[currentIndex - 1];
                var index2 = array.indexOf(item2);
                array[currentIndex] = item2;
                array[index2] = item;
              }
              return array;
            };
            module2.exports = MoveDown;
          },
          68396: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MoveTo = function(array, item, index) {
              var currentIndex = array.indexOf(item);
              if (currentIndex === -1 || index < 0 || index >= array.length) {
                throw new Error("Supplied index out of bounds");
              }
              if (currentIndex !== index) {
                array.splice(currentIndex, 1);
                array.splice(index, 0, item);
              }
              return item;
            };
            module2.exports = MoveTo;
          },
          27555: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MoveUp = function(array, item) {
              var currentIndex = array.indexOf(item);
              if (currentIndex !== -1 && currentIndex < array.length - 1) {
                var item2 = array[currentIndex + 1];
                var index2 = array.indexOf(item2);
                array[currentIndex] = item2;
                array[index2] = item;
              }
              return array;
            };
            module2.exports = MoveUp;
          },
          13401: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var NumberArray = function(start, end, prefix, suffix) {
              var result = [];
              var i;
              var asString = false;
              if (prefix || suffix) {
                asString = true;
                if (!prefix) {
                  prefix = "";
                }
                if (!suffix) {
                  suffix = "";
                }
              }
              if (end < start) {
                for (i = start; i >= end; i--) {
                  if (asString) {
                    result.push(prefix + i.toString() + suffix);
                  } else {
                    result.push(i);
                  }
                }
              } else {
                for (i = start; i <= end; i++) {
                  if (asString) {
                    result.push(prefix + i.toString() + suffix);
                  } else {
                    result.push(i);
                  }
                }
              }
              return result;
            };
            module2.exports = NumberArray;
          },
          89955: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RoundAwayFromZero = __webpack_require__2(67233);
            var NumberArrayStep = function(start, end, step) {
              if (start === void 0) {
                start = 0;
              }
              if (end === void 0) {
                end = null;
              }
              if (step === void 0) {
                step = 1;
              }
              if (end === null) {
                end = start;
                start = 0;
              }
              var result = [];
              var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);
              for (var i = 0; i < total; i++) {
                result.push(start);
                start += step;
              }
              return result;
            };
            module2.exports = NumberArrayStep;
          },
          53466: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            function swap(arr, i, j) {
              var tmp = arr[i];
              arr[i] = arr[j];
              arr[j] = tmp;
            }
            function defaultCompare(a, b) {
              return a < b ? -1 : a > b ? 1 : 0;
            }
            var QuickSelect = function(arr, k, left, right, compare) {
              if (left === void 0) {
                left = 0;
              }
              if (right === void 0) {
                right = arr.length - 1;
              }
              if (compare === void 0) {
                compare = defaultCompare;
              }
              while (right > left) {
                if (right - left > 600) {
                  var n = right - left + 1;
                  var m = k - left + 1;
                  var z = Math.log(n);
                  var s = 0.5 * Math.exp(2 * z / 3);
                  var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                  var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                  var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                  QuickSelect(arr, k, newLeft, newRight, compare);
                }
                var t = arr[k];
                var i = left;
                var j = right;
                swap(arr, left, k);
                if (compare(arr[right], t) > 0) {
                  swap(arr, left, right);
                }
                while (i < j) {
                  swap(arr, i, j);
                  i++;
                  j--;
                  while (compare(arr[i], t) < 0) {
                    i++;
                  }
                  while (compare(arr[j], t) > 0) {
                    j--;
                  }
                }
                if (compare(arr[left], t) === 0) {
                  swap(arr, left, j);
                } else {
                  j++;
                  swap(arr, j, right);
                }
                if (j <= k) {
                  left = j + 1;
                }
                if (k <= j) {
                  right = j - 1;
                }
              }
            };
            module2.exports = QuickSelect;
          },
          75757: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetValue = __webpack_require__2(10850);
            var Shuffle = __webpack_require__2(18592);
            var BuildChunk = function(a, b, qty) {
              var out = [];
              for (var aIndex = 0; aIndex < a.length; aIndex++) {
                for (var bIndex = 0; bIndex < b.length; bIndex++) {
                  for (var i = 0; i < qty; i++) {
                    out.push({a: a[aIndex], b: b[bIndex]});
                  }
                }
              }
              return out;
            };
            var Range = function(a, b, options) {
              var max = GetValue(options, "max", 0);
              var qty = GetValue(options, "qty", 1);
              var random = GetValue(options, "random", false);
              var randomB = GetValue(options, "randomB", false);
              var repeat = GetValue(options, "repeat", 0);
              var yoyo = GetValue(options, "yoyo", false);
              var out = [];
              if (randomB) {
                Shuffle(b);
              }
              if (repeat === -1) {
                if (max === 0) {
                  repeat = 0;
                } else {
                  var total = a.length * b.length * qty;
                  if (yoyo) {
                    total *= 2;
                  }
                  repeat = Math.ceil(max / total);
                }
              }
              for (var i = 0; i <= repeat; i++) {
                var chunk = BuildChunk(a, b, qty);
                if (random) {
                  Shuffle(chunk);
                }
                out = out.concat(chunk);
                if (yoyo) {
                  chunk.reverse();
                  out = out.concat(chunk);
                }
              }
              if (max) {
                out.splice(max);
              }
              return out;
            };
            module2.exports = Range;
          },
          66458: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SpliceOne = __webpack_require__2(72677);
            var Remove = function(array, item, callback, context) {
              if (context === void 0) {
                context = array;
              }
              var index;
              if (!Array.isArray(item)) {
                index = array.indexOf(item);
                if (index !== -1) {
                  SpliceOne(array, index);
                  if (callback) {
                    callback.call(context, item);
                  }
                  return item;
                } else {
                  return null;
                }
              }
              var itemLength = item.length - 1;
              var removed = [];
              while (itemLength >= 0) {
                var entry = item[itemLength];
                index = array.indexOf(entry);
                if (index !== -1) {
                  SpliceOne(array, index);
                  removed.push(entry);
                  if (callback) {
                    callback.call(context, entry);
                  }
                }
                itemLength--;
              }
              return removed;
            };
            module2.exports = Remove;
          },
          8324: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SpliceOne = __webpack_require__2(72677);
            var RemoveAt = function(array, index, callback, context) {
              if (context === void 0) {
                context = array;
              }
              if (index < 0 || index > array.length - 1) {
                throw new Error("Index out of bounds");
              }
              var item = SpliceOne(array, index);
              if (callback) {
                callback.call(context, item);
              }
              return item;
            };
            module2.exports = RemoveAt;
          },
          47427: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SafeRange = __webpack_require__2(45838);
            var RemoveBetween = function(array, startIndex, endIndex, callback, context) {
              if (startIndex === void 0) {
                startIndex = 0;
              }
              if (endIndex === void 0) {
                endIndex = array.length;
              }
              if (context === void 0) {
                context = array;
              }
              if (SafeRange(array, startIndex, endIndex)) {
                var size = endIndex - startIndex;
                var removed = array.splice(startIndex, size);
                if (callback) {
                  for (var i = 0; i < removed.length; i++) {
                    var entry = removed[i];
                    callback.call(context, entry);
                  }
                }
                return removed;
              } else {
                return [];
              }
            };
            module2.exports = RemoveBetween;
          },
          50147: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SpliceOne = __webpack_require__2(72677);
            var RemoveRandomElement = function(array, start, length) {
              if (start === void 0) {
                start = 0;
              }
              if (length === void 0) {
                length = array.length;
              }
              var randomIndex = start + Math.floor(Math.random() * length);
              return SpliceOne(array, randomIndex);
            };
            module2.exports = RemoveRandomElement;
          },
          80402: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Replace = function(array, oldChild, newChild) {
              var index1 = array.indexOf(oldChild);
              var index2 = array.indexOf(newChild);
              if (index1 !== -1 && index2 === -1) {
                array[index1] = newChild;
                return true;
              } else {
                return false;
              }
            };
            module2.exports = Replace;
          },
          77640: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateLeft = function(array, total) {
              if (total === void 0) {
                total = 1;
              }
              var element = null;
              for (var i = 0; i < total; i++) {
                element = array.shift();
                array.push(element);
              }
              return element;
            };
            module2.exports = RotateLeft;
          },
          38487: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateRight = function(array, total) {
              if (total === void 0) {
                total = 1;
              }
              var element = null;
              for (var i = 0; i < total; i++) {
                element = array.pop();
                array.unshift(element);
              }
              return element;
            };
            module2.exports = RotateRight;
          },
          45838: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SafeRange = function(array, startIndex, endIndex, throwError) {
              var len = array.length;
              if (startIndex < 0 || startIndex > len || startIndex >= endIndex || endIndex > len) {
                if (throwError) {
                  throw new Error("Range Error: Values outside acceptable range");
                }
                return false;
              } else {
                return true;
              }
            };
            module2.exports = SafeRange;
          },
          27847: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SendToBack = function(array, item) {
              var currentIndex = array.indexOf(item);
              if (currentIndex !== -1 && currentIndex > 0) {
                array.splice(currentIndex, 1);
                array.unshift(item);
              }
              return item;
            };
            module2.exports = SendToBack;
          },
          6034: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SafeRange = __webpack_require__2(45838);
            var SetAll = function(array, property, value, startIndex, endIndex) {
              if (startIndex === void 0) {
                startIndex = 0;
              }
              if (endIndex === void 0) {
                endIndex = array.length;
              }
              if (SafeRange(array, startIndex, endIndex)) {
                for (var i = startIndex; i < endIndex; i++) {
                  var entry = array[i];
                  if (entry.hasOwnProperty(property)) {
                    entry[property] = value;
                  }
                }
              }
              return array;
            };
            module2.exports = SetAll;
          },
          18592: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Shuffle = function(array) {
              for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
              }
              return array;
            };
            module2.exports = Shuffle;
          },
          28834: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SortByDigits = function(array) {
              var re = /\D/g;
              array.sort(function(a, b) {
                return parseInt(a.replace(re, ""), 10) - parseInt(b.replace(re, ""), 10);
              });
              return array;
            };
            module2.exports = SortByDigits;
          },
          72677: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SpliceOne = function(array, index) {
              if (index >= array.length) {
                return;
              }
              var len = array.length - 1;
              var item = array[index];
              for (var i = index; i < len; i++) {
                array[i] = array[i + 1];
              }
              array.length = len;
              return item;
            };
            module2.exports = SpliceOne;
          },
          17922: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @author       Angry Bytes (and contributors)
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Device = __webpack_require__2(77290);
            function Compare(a, b) {
              return String(a).localeCompare(b);
            }
            function Process(array, compare) {
              var len = array.length;
              if (len <= 1) {
                return array;
              }
              var buffer = new Array(len);
              for (var chk = 1; chk < len; chk *= 2) {
                RunPass(array, compare, chk, buffer);
                var tmp = array;
                array = buffer;
                buffer = tmp;
              }
              return array;
            }
            function RunPass(arr, comp, chk, result) {
              var len = arr.length;
              var i = 0;
              var dbl = chk * 2;
              var l, r, e;
              var li, ri;
              for (l = 0; l < len; l += dbl) {
                r = l + chk;
                e = r + chk;
                if (r > len) {
                  r = len;
                }
                if (e > len) {
                  e = len;
                }
                li = l;
                ri = r;
                while (true) {
                  if (li < r && ri < e) {
                    if (comp(arr[li], arr[ri]) <= 0) {
                      result[i++] = arr[li++];
                    } else {
                      result[i++] = arr[ri++];
                    }
                  } else if (li < r) {
                    result[i++] = arr[li++];
                  } else if (ri < e) {
                    result[i++] = arr[ri++];
                  } else {
                    break;
                  }
                }
              }
            }
            var StableSort = function(array, compare) {
              if (compare === void 0) {
                compare = Compare;
              }
              if (!array || array.length < 2) {
                return array;
              }
              if (Device.features.stableSort) {
                return array.sort(compare);
              }
              var result = Process(array, compare);
              if (result !== array) {
                RunPass(result, null, array.length, array);
              }
              return array;
            };
            module2.exports = StableSort;
          },
          96928: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Swap = function(array, item1, item2) {
              if (item1 === item2) {
                return array;
              }
              var index1 = array.indexOf(item1);
              var index2 = array.indexOf(item2);
              if (index1 < 0 || index2 < 0) {
                throw new Error("Supplied items must be elements of the same array");
              }
              array[index1] = item2;
              array[index2] = item1;
              return array;
            };
            module2.exports = Swap;
          },
          59959: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Matrix: __webpack_require__2(13515),
              Add: __webpack_require__2(78991),
              AddAt: __webpack_require__2(48522),
              BringToTop: __webpack_require__2(58742),
              CountAllMatching: __webpack_require__2(30164),
              Each: __webpack_require__2(36337),
              EachInRange: __webpack_require__2(46208),
              FindClosestInSorted: __webpack_require__2(2406),
              Flatten: __webpack_require__2(5454),
              GetAll: __webpack_require__2(71608),
              GetFirst: __webpack_require__2(51463),
              GetRandom: __webpack_require__2(72861),
              MoveDown: __webpack_require__2(51172),
              MoveTo: __webpack_require__2(68396),
              MoveUp: __webpack_require__2(27555),
              MoveAbove: __webpack_require__2(24218),
              MoveBelow: __webpack_require__2(58258),
              NumberArray: __webpack_require__2(13401),
              NumberArrayStep: __webpack_require__2(89955),
              QuickSelect: __webpack_require__2(53466),
              Range: __webpack_require__2(75757),
              Remove: __webpack_require__2(66458),
              RemoveAt: __webpack_require__2(8324),
              RemoveBetween: __webpack_require__2(47427),
              RemoveRandomElement: __webpack_require__2(50147),
              Replace: __webpack_require__2(80402),
              RotateLeft: __webpack_require__2(77640),
              RotateRight: __webpack_require__2(38487),
              SafeRange: __webpack_require__2(45838),
              SendToBack: __webpack_require__2(27847),
              SetAll: __webpack_require__2(6034),
              Shuffle: __webpack_require__2(18592),
              SortByDigits: __webpack_require__2(28834),
              SpliceOne: __webpack_require__2(72677),
              StableSort: __webpack_require__2(17922),
              Swap: __webpack_require__2(96928)
            };
          },
          97494: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CheckMatrix = function(matrix) {
              if (!Array.isArray(matrix) || !Array.isArray(matrix[0])) {
                return false;
              }
              var size = matrix[0].length;
              for (var i = 1; i < matrix.length; i++) {
                if (matrix[i].length !== size) {
                  return false;
                }
              }
              return true;
            };
            module2.exports = CheckMatrix;
          },
          68428: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Pad = __webpack_require__2(76400);
            var CheckMatrix = __webpack_require__2(97494);
            var MatrixToString = function(matrix) {
              var str = "";
              if (!CheckMatrix(matrix)) {
                return str;
              }
              for (var r = 0; r < matrix.length; r++) {
                for (var c = 0; c < matrix[r].length; c++) {
                  var cell = matrix[r][c].toString();
                  if (cell !== "undefined") {
                    str += Pad(cell, 2);
                  } else {
                    str += "?";
                  }
                  if (c < matrix[r].length - 1) {
                    str += " |";
                  }
                }
                if (r < matrix.length - 1) {
                  str += "\n";
                  for (var i = 0; i < matrix[r].length; i++) {
                    str += "---";
                    if (i < matrix[r].length - 1) {
                      str += "+";
                    }
                  }
                  str += "\n";
                }
              }
              return str;
            };
            module2.exports = MatrixToString;
          },
          59521: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ReverseColumns = function(matrix) {
              return matrix.reverse();
            };
            module2.exports = ReverseColumns;
          },
          51995: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var ReverseRows = function(matrix) {
              for (var i = 0; i < matrix.length; i++) {
                matrix[i].reverse();
              }
              return matrix;
            };
            module2.exports = ReverseRows;
          },
          89011: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateMatrix = __webpack_require__2(63515);
            var Rotate180 = function(matrix) {
              return RotateMatrix(matrix, 180);
            };
            module2.exports = Rotate180;
          },
          42549: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateMatrix = __webpack_require__2(63515);
            var RotateLeft = function(matrix, amount) {
              if (amount === void 0) {
                amount = 1;
              }
              for (var i = 0; i < amount; i++) {
                matrix = RotateMatrix(matrix, 90);
              }
              return matrix;
            };
            module2.exports = RotateLeft;
          },
          63515: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var CheckMatrix = __webpack_require__2(97494);
            var TransposeMatrix = __webpack_require__2(78581);
            var RotateMatrix = function(matrix, direction) {
              if (direction === void 0) {
                direction = 90;
              }
              if (!CheckMatrix(matrix)) {
                return null;
              }
              if (typeof direction !== "string") {
                direction = (direction % 360 + 360) % 360;
              }
              if (direction === 90 || direction === -270 || direction === "rotateLeft") {
                matrix = TransposeMatrix(matrix);
                matrix.reverse();
              } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
                matrix.reverse();
                matrix = TransposeMatrix(matrix);
              } else if (Math.abs(direction) === 180 || direction === "rotate180") {
                for (var i = 0; i < matrix.length; i++) {
                  matrix[i].reverse();
                }
                matrix.reverse();
              }
              return matrix;
            };
            module2.exports = RotateMatrix;
          },
          14305: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateMatrix = __webpack_require__2(63515);
            var RotateRight = function(matrix, amount) {
              if (amount === void 0) {
                amount = 1;
              }
              for (var i = 0; i < amount; i++) {
                matrix = RotateMatrix(matrix, -90);
              }
              return matrix;
            };
            module2.exports = RotateRight;
          },
          27365: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RotateLeft = __webpack_require__2(77640);
            var RotateRight = __webpack_require__2(38487);
            var TranslateMatrix = function(matrix, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (y !== 0) {
                if (y < 0) {
                  RotateLeft(matrix, Math.abs(y));
                } else {
                  RotateRight(matrix, y);
                }
              }
              if (x !== 0) {
                for (var i = 0; i < matrix.length; i++) {
                  var row = matrix[i];
                  if (x < 0) {
                    RotateLeft(row, Math.abs(x));
                  } else {
                    RotateRight(row, x);
                  }
                }
              }
              return matrix;
            };
            module2.exports = TranslateMatrix;
          },
          78581: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var TransposeMatrix = function(array) {
              var sourceRowCount = array.length;
              var sourceColCount = array[0].length;
              var result = new Array(sourceColCount);
              for (var i = 0; i < sourceColCount; i++) {
                result[i] = new Array(sourceRowCount);
                for (var j = sourceRowCount - 1; j > -1; j--) {
                  result[i][j] = array[j][i];
                }
              }
              return result;
            };
            module2.exports = TransposeMatrix;
          },
          13515: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              CheckMatrix: __webpack_require__2(97494),
              MatrixToString: __webpack_require__2(68428),
              ReverseColumns: __webpack_require__2(59521),
              ReverseRows: __webpack_require__2(51995),
              Rotate180: __webpack_require__2(89011),
              RotateLeft: __webpack_require__2(42549),
              RotateMatrix: __webpack_require__2(63515),
              RotateRight: __webpack_require__2(14305),
              Translate: __webpack_require__2(27365),
              TransposeMatrix: __webpack_require__2(78581)
            };
          },
          40581: (module2) => {
            /**
             * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var ArrayBufferToBase64 = function(arrayBuffer, mediaType) {
              var bytes = new Uint8Array(arrayBuffer);
              var len = bytes.length;
              var base64 = mediaType ? "data:" + mediaType + ";base64," : "";
              for (var i = 0; i < len; i += 3) {
                base64 += chars[bytes[i] >> 2];
                base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
                base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
                base64 += chars[bytes[i + 2] & 63];
              }
              if (len % 3 === 2) {
                base64 = base64.substring(0, base64.length - 1) + "=";
              } else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + "==";
              }
              return base64;
            };
            module2.exports = ArrayBufferToBase64;
          },
          82329: (module2) => {
            /**
             * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var lookup = new Uint8Array(256);
            for (var i = 0; i < chars.length; i++) {
              lookup[chars.charCodeAt(i)] = i;
            }
            var Base64ToArrayBuffer = function(base64) {
              base64 = base64.substr(base64.indexOf(",") + 1);
              var len = base64.length;
              var bufferLength = len * 0.75;
              var p = 0;
              var encoded1;
              var encoded2;
              var encoded3;
              var encoded4;
              if (base64[len - 1] === "=") {
                bufferLength--;
                if (base64[len - 2] === "=") {
                  bufferLength--;
                }
              }
              var arrayBuffer = new ArrayBuffer(bufferLength);
              var bytes = new Uint8Array(arrayBuffer);
              for (var i2 = 0; i2 < len; i2 += 4) {
                encoded1 = lookup[base64.charCodeAt(i2)];
                encoded2 = lookup[base64.charCodeAt(i2 + 1)];
                encoded3 = lookup[base64.charCodeAt(i2 + 2)];
                encoded4 = lookup[base64.charCodeAt(i2 + 3)];
                bytes[p++] = encoded1 << 2 | encoded2 >> 4;
                bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
              }
              return arrayBuffer;
            };
            module2.exports = Base64ToArrayBuffer;
          },
          78417: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              ArrayBufferToBase64: __webpack_require__2(40581),
              Base64ToArrayBuffer: __webpack_require__2(82329)
            };
          },
          22178: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Array: __webpack_require__2(59959),
              Base64: __webpack_require__2(78417),
              Objects: __webpack_require__2(64615),
              String: __webpack_require__2(50379),
              NOOP: __webpack_require__2(72283),
              NULL: __webpack_require__2(10618)
            };
          },
          32742: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clone = function(obj) {
              var clone = {};
              for (var key in obj) {
                if (Array.isArray(obj[key])) {
                  clone[key] = obj[key].slice(0);
                } else {
                  clone[key] = obj[key];
                }
              }
              return clone;
            };
            module2.exports = Clone;
          },
          28699: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var DeepCopy = function(inObject) {
              var outObject;
              var value;
              var key;
              if (typeof inObject !== "object" || inObject === null) {
                return inObject;
              }
              outObject = Array.isArray(inObject) ? [] : {};
              for (key in inObject) {
                value = inObject[key];
                outObject[key] = DeepCopy(value);
              }
              return outObject;
            };
            module2.exports = DeepCopy;
          },
          98611: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsPlainObject = __webpack_require__2(42911);
            var Extend = function() {
              var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
              if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                i = 2;
              }
              if (length === i) {
                target = this;
                --i;
              }
              for (; i < length; i++) {
                if ((options = arguments[i]) != null) {
                  for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                      continue;
                    }
                    if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                      if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                      } else {
                        clone = src && IsPlainObject(src) ? src : {};
                      }
                      target[name] = Extend(deep, clone, copy);
                    } else if (copy !== void 0) {
                      target[name] = copy;
                    }
                  }
                }
              }
              return target;
            };
            module2.exports = Extend;
          },
          20494: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var MATH = __webpack_require__2(5923);
            var GetValue = __webpack_require__2(10850);
            var GetAdvancedValue = function(source, key, defaultValue) {
              var value = GetValue(source, key, null);
              if (value === null) {
                return defaultValue;
              } else if (Array.isArray(value)) {
                return MATH.RND.pick(value);
              } else if (typeof value === "object") {
                if (value.hasOwnProperty("randInt")) {
                  return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
                } else if (value.hasOwnProperty("randFloat")) {
                  return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
                }
              } else if (typeof value === "function") {
                return value(key);
              }
              return value;
            };
            module2.exports = GetAdvancedValue;
          },
          72632: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetFastValue = function(source, key, defaultValue) {
              var t = typeof source;
              if (!source || t === "number" || t === "string") {
                return defaultValue;
              } else if (source.hasOwnProperty(key) && source[key] !== void 0) {
                return source[key];
              } else {
                return defaultValue;
              }
            };
            module2.exports = GetFastValue;
          },
          94324: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetValue = __webpack_require__2(10850);
            var Clamp = __webpack_require__2(82897);
            var GetMinMaxValue = function(source, key, min, max, defaultValue) {
              if (defaultValue === void 0) {
                defaultValue = min;
              }
              var value = GetValue(source, key, defaultValue);
              return Clamp(value, min, max);
            };
            module2.exports = GetMinMaxValue;
          },
          10850: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var GetValue = function(source, key, defaultValue, altSource) {
              if (!source && !altSource || typeof source === "number") {
                return defaultValue;
              } else if (source && source.hasOwnProperty(key)) {
                return source[key];
              } else if (altSource && altSource.hasOwnProperty(key)) {
                return altSource[key];
              } else if (key.indexOf(".") !== -1) {
                var keys = key.split(".");
                var parentA = source;
                var parentB = altSource;
                var valueA = defaultValue;
                var valueB = defaultValue;
                var valueAFound = true;
                var valueBFound = true;
                for (var i = 0; i < keys.length; i++) {
                  if (parentA && parentA.hasOwnProperty(keys[i])) {
                    valueA = parentA[keys[i]];
                    parentA = parentA[keys[i]];
                  } else {
                    valueAFound = false;
                  }
                  if (parentB && parentB.hasOwnProperty(keys[i])) {
                    valueB = parentB[keys[i]];
                    parentB = parentB[keys[i]];
                  } else {
                    valueBFound = false;
                  }
                }
                if (valueAFound) {
                  return valueA;
                } else if (valueBFound) {
                  return valueB;
                } else {
                  return defaultValue;
                }
              } else {
                return defaultValue;
              }
            };
            module2.exports = GetValue;
          },
          87701: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HasAll = function(source, keys) {
              for (var i = 0; i < keys.length; i++) {
                if (!source.hasOwnProperty(keys[i])) {
                  return false;
                }
              }
              return true;
            };
            module2.exports = HasAll;
          },
          53523: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HasAny = function(source, keys) {
              for (var i = 0; i < keys.length; i++) {
                if (source.hasOwnProperty(keys[i])) {
                  return true;
                }
              }
              return false;
            };
            module2.exports = HasAny;
          },
          19256: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HasValue = function(source, key) {
              return source.hasOwnProperty(key);
            };
            module2.exports = HasValue;
          },
          42911: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var IsPlainObject = function(obj) {
              if (!obj || typeof obj !== "object" || obj.nodeType || obj === obj.window) {
                return false;
              }
              try {
                if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
                  return false;
                }
              } catch (e) {
                return false;
              }
              return true;
            };
            module2.exports = IsPlainObject;
          },
          30657: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clone = __webpack_require__2(32742);
            var Merge = function(obj1, obj2) {
              var clone = Clone(obj1);
              for (var key in obj2) {
                if (!clone.hasOwnProperty(key)) {
                  clone[key] = obj2[key];
                }
              }
              return clone;
            };
            module2.exports = Merge;
          },
          72066: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Clone = __webpack_require__2(32742);
            var MergeRight = function(obj1, obj2) {
              var clone = Clone(obj1);
              for (var key in obj2) {
                if (clone.hasOwnProperty(key)) {
                  clone[key] = obj2[key];
                }
              }
              return clone;
            };
            module2.exports = MergeRight;
          },
          28820: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var HasValue = __webpack_require__2(19256);
            var Pick = function(object, keys) {
              var obj = {};
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (HasValue(object, key)) {
                  obj[key] = object[key];
                }
              }
              return obj;
            };
            module2.exports = Pick;
          },
          22440: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var SetValue = function(source, key, value) {
              if (!source || typeof source === "number") {
                return false;
              } else if (source.hasOwnProperty(key)) {
                source[key] = value;
                return true;
              } else if (key.indexOf(".") !== -1) {
                var keys = key.split(".");
                var parent = source;
                var prev = source;
                for (var i = 0; i < keys.length; i++) {
                  if (parent.hasOwnProperty(keys[i])) {
                    prev = parent;
                    parent = parent[keys[i]];
                  } else {
                    return false;
                  }
                }
                prev[keys[keys.length - 1]] = value;
                return true;
              }
              return false;
            };
            module2.exports = SetValue;
          },
          64615: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Clone: __webpack_require__2(32742),
              DeepCopy: __webpack_require__2(28699),
              Extend: __webpack_require__2(98611),
              GetAdvancedValue: __webpack_require__2(20494),
              GetFastValue: __webpack_require__2(72632),
              GetMinMaxValue: __webpack_require__2(94324),
              GetValue: __webpack_require__2(10850),
              HasAll: __webpack_require__2(87701),
              HasAny: __webpack_require__2(53523),
              HasValue: __webpack_require__2(19256),
              IsPlainObject: __webpack_require__2(42911),
              Merge: __webpack_require__2(30657),
              MergeRight: __webpack_require__2(72066),
              Pick: __webpack_require__2(28820),
              SetValue: __webpack_require__2(22440)
            };
          },
          69429: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Format = function(string, values) {
              return string.replace(/%([0-9]+)/g, function(s, n) {
                return values[Number(n) - 1];
              });
            };
            module2.exports = Format;
          },
          76400: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Pad = function(str, len, pad, dir) {
              if (len === void 0) {
                len = 0;
              }
              if (pad === void 0) {
                pad = " ";
              }
              if (dir === void 0) {
                dir = 3;
              }
              str = str.toString();
              var padlen = 0;
              if (len + 1 >= str.length) {
                switch (dir) {
                  case 1:
                    str = new Array(len + 1 - str.length).join(pad) + str;
                    break;
                  case 3:
                    var right = Math.ceil((padlen = len - str.length) / 2);
                    var left = padlen - right;
                    str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                    break;
                  default:
                    str = str + new Array(len + 1 - str.length).join(pad);
                    break;
                }
              }
              return str;
            };
            module2.exports = Pad;
          },
          76872: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var RemoveAt = function(string, index) {
              if (index === 0) {
                return string.slice(1);
              } else {
                return string.slice(0, index - 1) + string.slice(index);
              }
            };
            module2.exports = RemoveAt;
          },
          8051: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var Reverse = function(string) {
              return string.split("").reverse().join("");
            };
            module2.exports = Reverse;
          },
          76583: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var UUID = function() {
              return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0;
                var v = c === "x" ? r : r & 3 | 8;
                return v.toString(16);
              });
            };
            module2.exports = UUID;
          },
          40587: (module2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            var UppercaseFirst = function(str) {
              return str && str[0].toUpperCase() + str.slice(1);
            };
            module2.exports = UppercaseFirst;
          },
          50379: (module2, __unused_webpack_exports, __webpack_require__2) => {
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2013-2023 Photon Storm Ltd.
             * @license      {@link https://opensource.org/licenses/MIT|MIT License}
             */
            module2.exports = {
              Format: __webpack_require__2(69429),
              Pad: __webpack_require__2(76400),
              RemoveAt: __webpack_require__2(76872),
              Reverse: __webpack_require__2(8051),
              UppercaseFirst: __webpack_require__2(40587),
              UUID: __webpack_require__2(76583)
            };
          }
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            exports: {}
          };
          __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        (() => {
          __webpack_require__.g = function() {
            if (typeof globalThis === "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e) {
              if (typeof window === "object")
                return window;
            }
          }();
        })();
        var __webpack_exports__ = __webpack_require__(92491);
        return __webpack_exports__;
      })();
    });
  });

  // src/scenes/Boot.js
  var import_phaser = __toModule(require_phaser());
  var Boot = class extends import_phaser.Scene {
    constructor() {
      super("Boot");
    }
    preload() {
      this.load.image("background", "assets/bg.png");
    }
    create() {
      this.scene.start("Preloader");
    }
  };

  // src/scenes/Game.js
  var import_phaser2 = __toModule(require_phaser());
  var Game = class extends import_phaser2.Scene {
    constructor() {
      super("Game");
    }
    create() {
      this.cameras.main.setBackgroundColor(65280);
      this.add.image(512, 384, "background").setAlpha(0.5);
      this.add.text(512, 384, "Make something fun!\nand share it with us:\nsupport@phaser.io", {
        fontFamily: "Arial Black",
        fontSize: 38,
        color: "#ffffff",
        stroke: "#000000",
        strokeThickness: 8,
        align: "center"
      }).setOrigin(0.5);
      this.input.once("pointerdown", () => {
        this.scene.start("GameOver");
      });
    }
  };

  // src/scenes/GameOver.js
  var import_phaser3 = __toModule(require_phaser());
  var GameOver = class extends import_phaser3.Scene {
    constructor() {
      super("GameOver");
    }
    create() {
      this.cameras.main.setBackgroundColor(16711680);
      this.add.image(512, 384, "background").setAlpha(0.5);
      this.add.text(512, 384, "Game Over", {
        fontFamily: "Arial Black",
        fontSize: 64,
        color: "#ffffff",
        stroke: "#000000",
        strokeThickness: 8,
        align: "center"
      }).setOrigin(0.5);
      this.input.once("pointerdown", () => {
        this.scene.start("MainMenu");
      });
    }
  };

  // src/scenes/MainMenu.js
  var import_phaser4 = __toModule(require_phaser());
  var MainMenu = class extends import_phaser4.Scene {
    constructor() {
      super("MainMenu");
    }
    create() {
      this.add.image(512, 384, "background");
      this.add.image(512, 300, "logo").setRotation(70);
      this.add.text(512, 460, "Main Menu", {
        fontFamily: "Arial Black",
        fontSize: 38,
        color: "#ffffff",
        stroke: "#000000",
        strokeThickness: 8,
        align: "center"
      }).setOrigin(0.5);
      this.input.once("pointerdown", () => {
        this.scene.start("Game");
      });
    }
  };

  // src/scenes/Preloader.js
  var import_phaser5 = __toModule(require_phaser());
  var Preloader = class extends import_phaser5.Scene {
    constructor() {
      super("Preloader");
    }
    init() {
      this.add.image(512, 384, "background");
      this.add.rectangle(512, 384, 468, 32).setStrokeStyle(1, 16777215);
      const bar = this.add.rectangle(512 - 230, 384, 4, 28, 16777215);
      this.load.on("progress", (progress) => {
        bar.width = 4 + 460 * progress;
      });
    }
    preload() {
      this.load.setPath("assets");
      this.load.image("logo", "logo.png");
    }
    create() {
      this.scene.start("MainMenu");
    }
  };

  // src/main.js
  var config = {
    type: Phaser.AUTO,
    width: 1024,
    height: 768,
    parent: "game-container",
    backgroundColor: "#028af8",
    scale: {
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH
    },
    scene: [
      Boot,
      Preloader,
      MainMenu,
      Game,
      GameOver
    ]
  };
  var main_default = new Phaser.Game(config);
})();
